WEBVTT
Kind: captions
Language: en

00:00:03.033 --> 00:00:08.167
Johnson: So this presentation
is called GWT Can Do What?!

00:00:08.167 --> 00:00:11.033
And I sort of chickened out.

00:00:11.033 --> 00:00:18.000
On the session agenda
it says, "GWT Can Do What?!?!"

00:00:18.000 --> 00:00:19.934
And I was feeling
really ambitious

00:00:19.934 --> 00:00:21.133
a couple of months ago

00:00:21.133 --> 00:00:23.167
when we had to submit the title
in Abstract.

00:00:23.167 --> 00:00:25.000
But over the last couple days,
you know,

00:00:25.000 --> 00:00:26.834
I didn't want to set
expectations too high,

00:00:26.834 --> 00:00:29.300
so I removed one
of the question mark-

00:00:29.300 --> 00:00:31.534
exclamation point pairs.

00:00:31.534 --> 00:00:35.000
So maybe if you lower
your expectations--

00:00:35.000 --> 00:00:36.467
if a demo screws up
or something,

00:00:36.467 --> 00:00:38.200
it will not be a big deal.

00:00:38.200 --> 00:00:40.167
My name is Bruce Johnson.

00:00:40.167 --> 00:00:44.267
I run the Google
engineering office in Atlanta.

00:00:44.267 --> 00:00:47.133
I'm the engineering manager
of Google Web Toolkit.

00:00:47.133 --> 00:00:50.067
And I was the guy
a few years ago

00:00:50.067 --> 00:00:52.701
who had the silly idea
that, you know,

00:00:52.701 --> 00:00:55.234
hey, what if you actually
just tried to compile Java

00:00:55.234 --> 00:00:57.968
into JavaScript?

00:00:57.968 --> 00:01:00.300
Well, it turns out that
that does work pretty well.

00:01:00.300 --> 00:01:04.901
And since then we've seen the
GWT engineering team grow a lot.

00:01:04.901 --> 00:01:08.667
And we've seen the scope
of what GWT does

00:01:08.667 --> 00:01:12.234
really, really increase
as adoption of GWT has spiked,

00:01:12.234 --> 00:01:15.200
both inside and outside
of Google.

00:01:15.200 --> 00:01:18.501
So a lot of you might know that
GWT is an open-source project.

00:01:18.501 --> 00:01:21.501
And if you want to get
some idea

00:01:21.501 --> 00:01:25.167
of the rate of progress
within GWT,

00:01:25.167 --> 00:01:28.367
I dare you to subscribe
to the Subversion

00:01:28.367 --> 00:01:29.834
and commit log emails.

00:01:29.834 --> 00:01:34.000
And let those go to your inbox
for a couple of days

00:01:34.000 --> 00:01:36.634
and see how long
you can take it.

00:01:36.634 --> 00:01:39.734
But anyway,
to emphasize the point,

00:01:39.734 --> 00:01:41.100
this is all open source
development.

00:01:41.100 --> 00:01:42.267
You can watch the code reviews,

00:01:42.267 --> 00:01:44.300
design discussions happen
yourself.

00:01:44.300 --> 00:01:46.667
Just go to the Google Web
Toolkit contributors group

00:01:46.667 --> 00:01:49.667
on Google,
and please join right in.

00:01:49.667 --> 00:01:52.534
I would guess that a lot of you
may already do that,

00:01:52.534 --> 00:01:56.033
and that's fantastic
that you're here.

00:01:56.033 --> 00:01:59.267
So as we start to think about
GWT 2.0,

00:01:59.267 --> 00:02:01.868
the thing that is
mainly on my mind is,

00:02:01.868 --> 00:02:03.901
oh, my gosh,
this is a lot of stuff.

00:02:03.901 --> 00:02:05.300
And there used to be a time

00:02:05.300 --> 00:02:06.734
when I could keep it all
in my head.

00:02:06.734 --> 00:02:09.200
And I definitely cannot
do that anymore.

00:02:09.200 --> 00:02:12.100
So really, the best
I can hope to do is excite you

00:02:12.100 --> 00:02:14.534
about what's coming in GWT,

00:02:14.534 --> 00:02:17.934
and persuade you to go
to these other talks,

00:02:17.934 --> 00:02:20.734
where you will learn about
the real details

00:02:20.734 --> 00:02:23.901
from the engineers
who are developing GWT

00:02:23.901 --> 00:02:25.367
and really big applications
built with it.

00:02:25.367 --> 00:02:28.400
So a quick survey of the talks
to come in the track.

00:02:28.400 --> 00:02:30.167
Measure in Milliseconds.

00:02:30.167 --> 00:02:32.033
If you know anything
about GWT,

00:02:32.033 --> 00:02:34.100
you know that we're sort of
performance fanatics.

00:02:34.100 --> 00:02:37.267
This talk by Kelly Norton
will explain why that matters

00:02:37.267 --> 00:02:38.934
from the end user's
perspective,

00:02:38.934 --> 00:02:42.701
and go through some of the
sort of usability implications

00:02:42.701 --> 00:02:46.667
of the technologies we include
in GWT to help you have

00:02:46.667 --> 00:02:48.634
higher performance
applications.

00:02:48.634 --> 00:02:52.767
Ray Ryan is gonna talk about
Architecture Best Practices.

00:02:52.767 --> 00:02:56.200
And using as an example
a from-scratch rewrite

00:02:56.200 --> 00:02:59.801
of Google's AdWords
campaign management interface.

00:02:59.801 --> 00:03:02.000
The interface that
advertisers use

00:03:02.000 --> 00:03:04.367
to control their ad campaigns
on Google.

00:03:04.367 --> 00:03:08.534
A fairly important application
for Google.

00:03:08.534 --> 00:03:11.234
And Ray was heavily involved
in the architecture of that

00:03:11.234 --> 00:03:14.067
in the rewrite in GWT.

00:03:14.067 --> 00:03:16.601
Then Lex Spoon and I are doing
a talk about

00:03:16.601 --> 00:03:19.234
some compiler details--
especially code splitting--

00:03:19.234 --> 00:03:22.801
so that you will understand
how to use code splitting well,

00:03:22.801 --> 00:03:24.934
and how to basically read
the tea leaves

00:03:24.934 --> 00:03:28.701
of the information that GWT
compiler can provide to you

00:03:28.701 --> 00:03:30.801
as you optimize.

00:03:30.801 --> 00:03:32.801
The guys from Lombardi,
Alex and Damon,

00:03:32.801 --> 00:03:35.834
are coming back to discuss
lessons that they've learned

00:03:35.834 --> 00:03:37.567
in building
a really phenomenal

00:03:37.567 --> 00:03:39.334
diagramming application
in GWT.

00:03:39.334 --> 00:03:40.834
I highly recommend that talk.

00:03:40.834 --> 00:03:42.868
Another one
from Ray Cromwell.

00:03:42.868 --> 00:03:45.300
Ray had a talk with Extreme
last year

00:03:45.300 --> 00:03:46.834
that was an absolute hit.

00:03:46.834 --> 00:03:49.501
And I think he's going to
pull that off again.

00:03:49.501 --> 00:03:52.267
This is about progressive
enhancement using GWT Query,

00:03:52.267 --> 00:03:55.434
which is a JQuery-like library
built with GWT.

00:03:55.434 --> 00:03:57.067
And he's gonna do another talk

00:03:57.067 --> 00:03:59.100
that promises lots
of cool demos--

00:03:59.100 --> 00:04:01.667
that combines a bunch of
different Google APIs together

00:04:01.667 --> 00:04:06.033
using GWT in ways that
you might never have imagined.

00:04:06.033 --> 00:04:08.234
And then most of
the GWT team,

00:04:08.234 --> 00:04:09.601
or maybe half of us
are here,

00:04:09.601 --> 00:04:11.834
and we'll be doing
a fireside chat later,

00:04:11.834 --> 00:04:14.033
so we can talk shop then.

00:04:14.033 --> 00:04:15.701
We're excited about that.

00:04:15.701 --> 00:04:20.133
I want to emphasize especially
this GWT Query talk

00:04:20.133 --> 00:04:24.033
because Ray has done
such a good job with GWT Query.

00:04:24.033 --> 00:04:26.067
And the programming model is
so powerful

00:04:26.067 --> 00:04:28.634
that we are going to roll
that functionality

00:04:28.634 --> 00:04:30.634
into GWT itself--

00:04:30.634 --> 00:04:32.601
into the proper source control

00:04:32.601 --> 00:04:34.834
and distribution
and everything.

00:04:34.834 --> 00:04:37.901
That may not be in 2.0,
but it will be soon after.

00:04:37.901 --> 00:04:39.734
So you definitely want
to come to that talk.

00:04:39.734 --> 00:04:42.067
It's sort of underselling
itself, based on the title.

00:04:42.067 --> 00:04:44.267
But he's gonna explain
this awesome new library,

00:04:44.267 --> 00:04:45.567
and the work he's done
to improve it.

00:04:45.567 --> 00:04:50.100
Okay, on to the overview:
what's coming in 2.0?

00:04:50.100 --> 00:04:52.167
So first of all, as you saw
if you went to the keynote--

00:04:52.167 --> 00:04:54.934
hopefully you did, you heard
about the whole phone thing...

00:04:54.934 --> 00:04:56.601
[laughter]

00:04:56.601 --> 00:04:58.267
Uh, okay, you did.

00:04:58.267 --> 00:05:01.467
You saw Andrew Bowers talk
about something called,

00:05:01.467 --> 00:05:03.501
well, in-browser hosted mode--

00:05:03.501 --> 00:05:04.601
an improved version
of hosted mode

00:05:04.601 --> 00:05:06.000
coming into a 2.0.

00:05:06.000 --> 00:05:08.234
If you've seen us talk about
O-O-P-H-M, or "OOPHM"--

00:05:08.234 --> 00:05:10.501
because we like pronouncing
awkward-sounding acronyms

00:05:10.501 --> 00:05:13.834
on the GWT team...

00:05:13.834 --> 00:05:15.367
But we're probably gonna have
to abandon that

00:05:15.367 --> 00:05:17.367
by the time
we actually ship it

00:05:17.367 --> 00:05:19.467
because nobody really likes
saying OOPHAM.

00:05:19.467 --> 00:05:22.834
Some additional compiler
enhancements.

00:05:22.834 --> 00:05:28.300
Code splitting, which was
also mentioned in the keynote.

00:05:28.300 --> 00:05:30.000
Um, ImageBundle on steroids--

00:05:30.000 --> 00:05:32.601
a new technology called
ClientBundle.

00:05:32.601 --> 00:05:35.067
Improved layout and panels,

00:05:35.067 --> 00:05:36.667
which is always a source
of angst.

00:05:36.667 --> 00:05:39.033
Even using GWT today,
we've got some

00:05:39.033 --> 00:05:41.868
really promising solutions
in that area.

00:05:41.868 --> 00:05:44.133
And then, a grab bag
of not-to-miss features.

00:05:44.133 --> 00:05:47.167
So let's get started
with hosted mode.

00:05:47.167 --> 00:05:50.400
All right.

00:05:50.400 --> 00:05:53.300
So first of all,
hosted mode is good.

00:05:53.300 --> 00:05:56.100
I would not use GWT at all.

00:05:56.100 --> 00:05:57.868
I would not be interested
in cross-compiling

00:05:57.868 --> 00:05:59.734
to JavaScript whatsoever

00:05:59.734 --> 00:06:01.434
if it weren't for
hosted mode.

00:06:01.434 --> 00:06:05.200
Hosted mode is the key to
productive development in GWT.

00:06:05.200 --> 00:06:06.734
And if you aren't using
hosted mode,

00:06:06.734 --> 00:06:08.367
you're not really using GWT

00:06:08.367 --> 00:06:10.434
the way that we intended
for it to work.

00:06:10.434 --> 00:06:13.200
It gives you the ability
to debug in Java.

00:06:13.200 --> 00:06:16.400
It gives you the ability to make
a change in your source code

00:06:16.400 --> 00:06:18.367
and hit refresh
in the hosted browser

00:06:18.367 --> 00:06:20.701
so that the changes
are picked up immediately.

00:06:20.701 --> 00:06:22.834
And it is important to mention
that this is not

00:06:22.834 --> 00:06:24.534
a simulation of a browser.

00:06:24.534 --> 00:06:25.634
It actually is a browser.

00:06:25.634 --> 00:06:28.300
We just had to carefully
wire it into the JBM

00:06:28.300 --> 00:06:30.400
and bytecode layers

00:06:30.400 --> 00:06:32.367
so that it can do
all the magic work.

00:06:32.367 --> 00:06:34.667
But you see
the screen shot here.

00:06:34.667 --> 00:06:36.300
It isn't your browser,
right?

00:06:36.300 --> 00:06:41.501
It's a special SWT window
that we had to construct.

00:06:41.501 --> 00:06:44.868
Which brings us to
a problem:

00:06:44.868 --> 00:06:47.234
it's actually too special.

00:06:47.234 --> 00:06:49.567
We were only able
to really make that happen

00:06:49.567 --> 00:06:52.033
for one browser
per operating system.

00:06:52.033 --> 00:06:53.667
GWT does allow you
to develop

00:06:53.667 --> 00:06:55.434
on MAC and Windows
and Linux.

00:06:55.434 --> 00:06:57.868
but on each of those
you can only use hosted mode

00:06:57.868 --> 00:07:01.167
for a particular browser
on that development OS.

00:07:01.167 --> 00:07:04.033
In other words, you get
Internet Explorer

00:07:04.033 --> 00:07:05.901
for hosted mode on Windows.

00:07:05.901 --> 00:07:07.300
You get Safari on Mac,

00:07:07.300 --> 00:07:08.968
and you get some
ancient version of Mozilla

00:07:08.968 --> 00:07:10.567
that we--
[chuckles]

00:07:10.567 --> 00:07:12.067
It's embarrassingly old.

00:07:12.067 --> 00:07:16.167
It's not at all like 3.5 era.

00:07:18.601 --> 00:07:20.968
It's also a particularly
painful thing

00:07:20.968 --> 00:07:22.868
because layout--

00:07:22.868 --> 00:07:25.734
The existing GWT panels
don't solve layout perfectly.

00:07:25.734 --> 00:07:27.834
You still have to know a lot
about CSS.

00:07:27.834 --> 00:07:30.100
And CSS is
a very powerful technology.

00:07:30.100 --> 00:07:32.968
But as you saw, and everybody,
I think, laughed about

00:07:32.968 --> 00:07:37.000
the CSS's awesome mug
in the keynote,

00:07:37.000 --> 00:07:42.234
you do spend a lot of time
debugging CSS, like it or not.

00:07:42.234 --> 00:07:44.734
And it's really hard
to do that in a hosted browser

00:07:44.734 --> 00:07:45.901
because we don't--

00:07:45.901 --> 00:07:47.901
It's our own browser chrome,
right?

00:07:47.901 --> 00:07:51.300
So we aren't able to allow
extensions like Firebug

00:07:51.300 --> 00:07:52.701
and all these great things.

00:07:52.701 --> 00:07:54.501
They just aren't available
at the same time

00:07:54.501 --> 00:07:57.300
as hosted mode debugging.

00:07:57.300 --> 00:08:00.968
So there's this other
kind of related phenomenon,

00:08:00.968 --> 00:08:03.033
which is that it's hard
to use browser plugins

00:08:03.033 --> 00:08:05.167
that expect to be running
in a certain context.

00:08:05.167 --> 00:08:07.634
So Flash and Applets
and even Gears

00:08:07.634 --> 00:08:09.667
don't always work well
in the hosted browser.

00:08:09.667 --> 00:08:14.901
So it can be hard to debug
interactions with plugins.

00:08:14.901 --> 00:08:19.434
So what you find is that
you compile a lot.

00:08:19.434 --> 00:08:21.434
And as soon as you start
doing that,

00:08:21.434 --> 00:08:26.667
you realize that the compiler
is not the fastest aspect

00:08:26.667 --> 00:08:28.501
of the GWT offerings.

00:08:28.501 --> 00:08:33.300
It's, some have said, slow.

00:08:33.300 --> 00:08:35.667
Just a random search for GWT
on Twitter

00:08:35.667 --> 00:08:39.701
the night before last
uncovered this little gem.

00:08:39.701 --> 00:08:42.100
That, you know,
"one pain point with GWT,

00:08:42.100 --> 00:08:43.334
it takes too long
to compile."

00:08:43.334 --> 00:08:44.801
It's not an issue
in hosted mode,

00:08:44.801 --> 00:08:46.934
which is good.

00:08:46.934 --> 00:08:50.000
But it slows you down
while fixing browser issues.

00:08:50.000 --> 00:08:52.734
Since hosted mode
really is a browser,

00:08:52.734 --> 00:08:55.567
what he means by
"fixing browser issues" means

00:08:55.567 --> 00:08:57.801
fixing CSS and other types
of issues

00:08:57.801 --> 00:08:59.567
that can't be accurately
reflected

00:08:59.567 --> 00:09:01.200
in the hosted browser today.

00:09:01.200 --> 00:09:04.634
But the compiler isn't meant
to be an alternative

00:09:04.634 --> 00:09:05.734
to hosted mode.

00:09:05.734 --> 00:09:06.868
You're supposed to use
hosted mode

00:09:06.868 --> 00:09:08.267
to get your app
like you like it,

00:09:08.267 --> 00:09:09.801
then compile it.

00:09:09.801 --> 00:09:12.834
So we had to make some
pretty significant changes

00:09:12.834 --> 00:09:14.300
to the hosted mode.

00:09:14.300 --> 00:09:17.734
The solution, it turns out,
is to create a browser plugin,

00:09:17.734 --> 00:09:20.834
and have your Java bytecode
drive the browser plugin.

00:09:20.834 --> 00:09:23.300
A native code,
plug it into the browser.

00:09:23.300 --> 00:09:26.200
Then create such a plugin
for every browser

00:09:26.200 --> 00:09:27.801
that we want to debug against,

00:09:27.801 --> 00:09:30.501
and make that work
across the network.

00:09:30.501 --> 00:09:36.033
And so I think it's best
just if I show you.

00:09:36.033 --> 00:09:39.200
So...

00:09:39.200 --> 00:09:42.267
now I'm gonna do a little

00:09:42.267 --> 00:09:46.267
cross-window dragging here.

00:09:46.267 --> 00:09:48.968
Always difficult
and dangerous.

00:09:48.968 --> 00:09:51.701
All right,
so this is Showcase,

00:09:51.701 --> 00:09:53.000
which is sort of the--

00:09:53.000 --> 00:09:54.667
wow, this is actually
gonna be really hard to--

00:09:54.667 --> 00:09:57.234
I can do it.
All right.

00:09:57.234 --> 00:10:00.334
Does that look okay?
Okay.

00:10:00.334 --> 00:10:05.501
So we're gonna do...

00:10:05.501 --> 00:10:06.834
Showcase.

00:10:06.834 --> 00:10:11.300
I still have the term OOPHAM
in there.

00:10:11.300 --> 00:10:15.200
The first thing you'll see
is...this.

00:10:15.200 --> 00:10:18.300
This is the highly
unattractive,

00:10:18.300 --> 00:10:20.567
and because it's unfinished,
UI.

00:10:20.567 --> 00:10:23.601
And it basically says that
we are running

00:10:23.601 --> 00:10:27.501
a hosted mode session
as a server.

00:10:27.501 --> 00:10:32.901
So hide that one down here.

00:10:32.901 --> 00:10:37.234
Now hosted mode is sitting there
waiting for us.

00:10:37.234 --> 00:10:42.000
And I can enter the URL
from--

00:10:42.000 --> 00:10:43.200
Oh, yeah,
you can't see this.

00:10:43.200 --> 00:10:44.467
Actually, hang on.
I gotta--

00:10:44.467 --> 00:10:50.234
This is driving me insane.

00:10:50.234 --> 00:10:54.834
So I hope this is not gonna,
like, totally demolish

00:10:54.834 --> 00:10:56.601
what we've got going here
with the video,

00:10:56.601 --> 00:10:59.734
but we've gotta do it.

00:10:59.734 --> 00:11:02.300
Yeah.
How's that?

00:11:02.300 --> 00:11:05.834
Okay, now--
Okay, sanity regained.

00:11:05.834 --> 00:11:11.868
All right, so now I navigate
from a regular Safari instance

00:11:11.868 --> 00:11:14.501
to the Showcase URL.

00:11:14.501 --> 00:11:16.300
It's what I would have
normally done

00:11:16.300 --> 00:11:17.334
in the hosted browser,

00:11:17.334 --> 00:11:20.467
except this is
regular old Safari.

00:11:20.467 --> 00:11:22.400
Which means I get
all the tools

00:11:22.400 --> 00:11:24.434
that I would expect to have
in Safari...

00:11:24.434 --> 00:11:28.200
and any other plugins
that run in Safari and so on.

00:11:31.234 --> 00:11:33.901
So now hosted mode is
no longer trapped

00:11:33.901 --> 00:11:36.033
inside the hosted mode
browser.

00:11:36.033 --> 00:11:43.400
So that's the--
That's not the excitingest part.

00:11:43.400 --> 00:11:45.367
This isn't
the excitingest part either,

00:11:45.367 --> 00:11:46.467
the next thing
I'm gonna show you.

00:11:46.467 --> 00:11:51.934
But it is excitinger.

00:11:51.934 --> 00:11:56.200
All right.

00:11:56.200 --> 00:11:59.701
So...

00:11:59.701 --> 00:12:03.701
we also have this
working in Firefox.

00:12:06.434 --> 00:12:09.000
So I'll visit the same URL.

00:12:09.000 --> 00:12:10.601
But there's a couple
of interesting things

00:12:10.601 --> 00:12:13.200
to point out here.

00:12:13.200 --> 00:12:15.334
You're seeing
both instances run

00:12:15.334 --> 00:12:16.934
against the same
hosted mode session.

00:12:16.934 --> 00:12:18.501
And that works fine.

00:12:18.501 --> 00:12:22.234
It's like a server
on top of your Java codebase.

00:12:22.234 --> 00:12:25.601
And so if we look back
at the debugger...

00:12:25.601 --> 00:12:27.267
here...

00:12:27.267 --> 00:12:32.067
we just see a thread here
and a thread here

00:12:32.067 --> 00:12:36.167
for each of the browsers
that are connected.

00:12:36.167 --> 00:12:39.000
Okay.
Now that's pretty cool.

00:12:39.000 --> 00:12:44.234
And then you want to
do things like debug CSS, right?

00:12:44.234 --> 00:12:47.400
So this is one of
the key use cases

00:12:47.400 --> 00:12:49.367
for out of process hosted mode

00:12:49.367 --> 00:12:51.100
for this new plugin-based
hosted mode...

00:12:51.100 --> 00:12:55.834
to be able to do things
like use Firebug...

00:12:55.834 --> 00:12:58.067
at the same time.

00:13:05.334 --> 00:13:07.133
So I'm able to make
real-time changes.

00:13:07.133 --> 00:13:10.234
And especially when
you're tweaking CSS,

00:13:10.234 --> 00:13:11.667
it really helps
to be able to have

00:13:11.667 --> 00:13:13.467
the full power of Firebug,

00:13:13.467 --> 00:13:14.801
even while you're debugging

00:13:14.801 --> 00:13:19.133
your Javacode at
the same time.

00:13:19.133 --> 00:13:21.601
So hopefully this is gonna
go a long way

00:13:21.601 --> 00:13:25.267
towards making people able
to use hosted mode

00:13:25.267 --> 00:13:27.000
for the trickiest situations.

00:13:27.000 --> 00:13:29.167
All right, now...

00:13:29.167 --> 00:13:32.634
That also, by the way,
was not the excitingest part.

00:13:32.634 --> 00:13:35.167
What to me is
the excitingest part

00:13:35.167 --> 00:13:39.834
is the fact that if you're
developing a cross-browser--

00:13:39.834 --> 00:13:41.901
You have to remember,
not every browser runs

00:13:41.901 --> 00:13:44.234
on ever operating system,
obviously.

00:13:44.234 --> 00:13:46.701
Internet Explorer,
not to name names,

00:13:46.701 --> 00:13:49.200
doesn't run on Mac,
for example.

00:13:49.200 --> 00:13:51.701
So--but it has a large
market share,

00:13:51.701 --> 00:13:53.501
so I need to support it,
obviously.

00:13:53.501 --> 00:13:56.133
I'd like to be able
to debug with hosted mode

00:13:56.133 --> 00:13:57.601
against Internet Explorer.

00:13:57.601 --> 00:14:03.000
But I want to run Eclipse
on my Mac, of course.

00:14:03.000 --> 00:14:07.133
So that works too.

00:14:07.133 --> 00:14:09.767
I have the VMWare session
here.

00:14:25.667 --> 00:14:28.968
And it's actually using
cross-process communication

00:14:28.968 --> 00:14:30.334
across the network

00:14:30.334 --> 00:14:35.300
to hit the server
that is running hosted mode.

00:14:35.300 --> 00:14:39.868
And now you can see
all three sessions are running,

00:14:39.868 --> 00:14:41.300
and they each have
their own log

00:14:41.300 --> 00:14:43.300
at the same time.

00:14:43.300 --> 00:14:45.167
[applause]

00:14:45.167 --> 00:14:48.267
Cool.

00:14:48.267 --> 00:14:50.634
But wait, there's more.
[laughter]

00:14:50.634 --> 00:14:53.000
That's what you're supposed
to say during the demos.

00:14:53.000 --> 00:14:56.033
You're supposed to say,
"But wait, there's more."

00:14:56.033 --> 00:14:57.834
Yeah, we'll do questions
at the end

00:14:57.834 --> 00:14:59.167
because there's a microphone.

00:14:59.167 --> 00:15:00.467
And for the video's purposes,

00:15:00.467 --> 00:15:01.734
we have to have people
do that.

00:15:01.734 --> 00:15:04.234
So it just wouldn't be
a hosted mode demo

00:15:04.234 --> 00:15:07.000
unless we showed
hitting a break point, right?

00:15:07.000 --> 00:15:10.067
So I clicked on the hyperlink
in Internet Explorer,

00:15:10.067 --> 00:15:11.801
in a VMware session.

00:15:11.801 --> 00:15:15.000
Triggered a break point
back on my Mac in Eclipse here.

00:15:15.000 --> 00:15:17.133
And I can step through,
a line at a time.

00:15:17.133 --> 00:15:18.868
I can do everything

00:15:18.868 --> 00:15:22.167
that I'm used to doing
in hosted mode,

00:15:22.167 --> 00:15:27.033
including things like getting
the inner HTML associated

00:15:27.033 --> 00:15:28.434
with widgets and so on.

00:15:28.434 --> 00:15:32.033
So this is actually going back
to Internet Explorer,

00:15:32.033 --> 00:15:33.667
and extracting
the DOM structure

00:15:33.667 --> 00:15:35.067
as an HTML
and sending it back

00:15:35.067 --> 00:15:37.000
so that we can stay
in our debugger

00:15:37.000 --> 00:15:38.634
and not have to constantly
flip back and forth

00:15:38.634 --> 00:15:42.200
when we don't want to.

00:15:42.200 --> 00:15:46.501
Also, we think,
pretty time-saving.

00:15:46.501 --> 00:15:49.834
And then, another thing
that it would not be--

00:15:49.834 --> 00:15:51.601
it would not be
a hosted mode demo

00:15:51.601 --> 00:15:56.234
without showing
is the ability to...

00:15:56.234 --> 00:16:00.300
quickly refresh.

00:16:00.300 --> 00:16:03.267
So...okay.

00:16:03.267 --> 00:16:05.834
I'm gonna change
this subtitle right here.

00:16:05.834 --> 00:16:08.234
"Showcase of Features."

00:16:12.767 --> 00:16:17.834
"Edited Line..."

00:16:17.834 --> 00:16:21.634
And then,
refreshing the browser.

00:16:27.801 --> 00:16:30.434
And you see the edit
took place.

00:16:30.434 --> 00:16:35.234
Okay, that is out of
process hosted mode.

00:16:44.501 --> 00:16:46.501
Where were we?

00:16:46.501 --> 00:16:54.501
Okay, so now we talk a little
more about the compiler.

00:16:54.501 --> 00:16:56.901
The best thing to do is
not compile,

00:16:56.901 --> 00:16:59.567
if I haven't made that clear,
okay?

00:16:59.567 --> 00:17:02.234
Caveats and mumble, mumble.

00:17:02.234 --> 00:17:05.133
So this is times
on my MacBook Pro,

00:17:05.133 --> 00:17:06.934
which is a two-core computer,

00:17:06.934 --> 00:17:09.901
um, compiling
a Showcase sample

00:17:09.901 --> 00:17:12.734
in one inversion 1.6 of GWT.

00:17:12.734 --> 00:17:15.934
It took 144 seconds.

00:17:15.934 --> 00:17:17.701
But we keep adding features
to the compiler--

00:17:17.701 --> 00:17:19.601
optimizations, code splitting,
and all that.

00:17:19.601 --> 00:17:20.801
That takes time.

00:17:20.801 --> 00:17:22.601
So as much as I'd like
to show you

00:17:22.601 --> 00:17:24.868
the next bar being smaller,

00:17:24.868 --> 00:17:27.767
um, it's actually larger
right now.

00:17:27.767 --> 00:17:29.167
There are still some tweaks.

00:17:29.167 --> 00:17:30.868
You know, we'll spend
a little time with JProfiler.

00:17:30.868 --> 00:17:33.200
And we can probably
get the compiler

00:17:33.200 --> 00:17:35.100
a bit faster still.

00:17:35.100 --> 00:17:36.834
But the reason
it takes so long is

00:17:36.834 --> 00:17:41.200
GWT does an optimized version
of the compiled script

00:17:41.200 --> 00:17:42.501
for different browsers
and different locales

00:17:42.501 --> 00:17:44.000
and different context.

00:17:44.000 --> 00:17:45.234
It's one of
the key strengths

00:17:45.234 --> 00:17:47.634
in why GWT does actually
produce

00:17:47.634 --> 00:17:49.367
really fast JavaScript code.

00:17:49.367 --> 00:17:52.033
So there's sort of
a limit to

00:17:52.033 --> 00:17:53.534
how fast the compiler can be
in theory.

00:17:53.534 --> 00:17:56.467
It's why we invest so heavily
in hosted mode.

00:17:56.467 --> 00:17:59.601
But there are still some things
we can do and have done.

00:17:59.601 --> 00:18:02.701
In GWT 1.6, which is available
as a download right now,

00:18:02.701 --> 00:18:06.167
there is a dash local workers
flag.

00:18:06.167 --> 00:18:10.000
And you can specify the number
of job processes you'd like--

00:18:10.000 --> 00:18:12.033
sub-processes
you'd like to start

00:18:12.033 --> 00:18:14.767
to run the compiler
to compile those permutations

00:18:14.767 --> 00:18:16.200
in Parallel.

00:18:16.200 --> 00:18:19.534
So if you find the sweet spot
relative to your amount of RAM,

00:18:19.534 --> 00:18:21.067
and relative to your number
of cores,

00:18:21.067 --> 00:18:22.634
you can actually
speed things up a lot.

00:18:22.634 --> 00:18:24.834
As you see here
with local worker SQL-2,

00:18:24.834 --> 00:18:28.234
I can compile 25 permutations
in about two minutes.

00:18:28.234 --> 00:18:31.167
That's still not great.

00:18:31.167 --> 00:18:34.767
So in 2.0 we're adding
a dash draft compile flag.

00:18:34.767 --> 00:18:35.868
What this says is,

00:18:35.868 --> 00:18:37.901
"Look, I just really want
to compile fast.

00:18:37.901 --> 00:18:40.801
I don't mind if the output
isn't as good."

00:18:40.801 --> 00:18:43.133
So that the compiler does
fewer optimizations,

00:18:43.133 --> 00:18:45.300
and the resulting script runs
the same,

00:18:45.300 --> 00:18:46.934
but isn't as optimized.

00:18:46.934 --> 00:18:48.367
And you wouldn't want
to ship it into production.

00:18:48.367 --> 00:18:50.968
But it does speed things up,
as you can see.

00:18:50.968 --> 00:18:55.200
So now we're about
1/3 of the time as we were

00:18:55.200 --> 00:18:57.801
without using these flags.

00:18:57.801 --> 00:18:59.400
There's a trick,
we've said from the beginning,

00:18:59.400 --> 00:19:01.901
that you should do if you're
doing a bunch of desk compiles,

00:19:01.901 --> 00:19:03.901
which is to restrict the number
of permutations

00:19:03.901 --> 00:19:05.400
in your GWT module.

00:19:05.400 --> 00:19:07.367
People call this
a single-perm compile,

00:19:07.367 --> 00:19:08.701
and things like that.

00:19:08.701 --> 00:19:10.834
You can--

00:19:10.834 --> 00:19:13.934
using an XML element
called setProperty,

00:19:13.934 --> 00:19:15.901
you can restrict
certain values.

00:19:15.901 --> 00:19:17.400
You could say only compile

00:19:17.400 --> 00:19:20.667
for user agent IE6,
for example.

00:19:20.667 --> 00:19:23.734
In GWT 1.6,
we added the ability

00:19:23.734 --> 00:19:26.868
to set that as a subset--
a multiple value.

00:19:26.868 --> 00:19:29.701
So it's not just exactly
one permutation.

00:19:29.701 --> 00:19:31.267
You can actually kind of

00:19:31.267 --> 00:19:32.667
craft your own number
of permutations.

00:19:32.667 --> 00:19:35.234
I could, say, compile
for Safari and IE6

00:19:35.234 --> 00:19:36.534
and English and French.

00:19:36.534 --> 00:19:38.701
Even if the total number
of permutations

00:19:38.701 --> 00:19:39.868
are really large,

00:19:39.868 --> 00:19:41.234
you can kind of pick and choose
the subset

00:19:41.234 --> 00:19:43.067
that you're actually
focusing on at the time.

00:19:43.067 --> 00:19:44.801
And if I do that,
you can see,

00:19:44.801 --> 00:19:47.100
you can save a lot of time.

00:19:47.100 --> 00:19:49.901
Now we're at about 1/9th.

00:19:49.901 --> 00:19:55.868
And did I mention that
hosted mode is a lot faster

00:19:55.868 --> 00:19:56.901
than a compiler?

00:19:56.901 --> 00:19:58.200
Plus, you can debug.

00:19:58.200 --> 00:19:59.634
There's a lot of good things
about hosted mode.

00:19:59.634 --> 00:20:03.767
But we also say refresh
rather than restart hosted mode.

00:20:03.767 --> 00:20:06.767
So you can leave
the hosted mode browser running.

00:20:06.767 --> 00:20:09.067
Occasionally you'll get
an error message

00:20:09.067 --> 00:20:11.234
from the JVM that says
something about not able

00:20:11.234 --> 00:20:13.033
to hot swap end code.

00:20:13.033 --> 00:20:14.367
You can completely
ignore that.

00:20:14.367 --> 00:20:17.300
You can say don't talk to me
about this anymore.

00:20:17.300 --> 00:20:20.067
Because the hosted mode
infrastructure

00:20:20.067 --> 00:20:22.467
automatically recompiles things
into RAM for you.

00:20:22.467 --> 00:20:24.767
So it will always work,
and you can safely ignore those.

00:20:24.767 --> 00:20:27.100
In other words,
do run hosted mode

00:20:27.100 --> 00:20:29.601
for long periods of time,
and do hit refresh,

00:20:29.601 --> 00:20:31.367
and you get this kind
of turnaround time.

00:20:31.367 --> 00:20:35.400
So basically, instead
of waiting 186 seconds,

00:20:35.400 --> 00:20:37.934
you can wait two seconds to see
the results of your change.

00:20:37.934 --> 00:20:39.767
And you can still do
all the things

00:20:39.767 --> 00:20:41.367
you would have needed
to compile for.

00:20:41.367 --> 00:20:44.300
You can now do that using
out of process hosted mode,

00:20:44.300 --> 00:20:47.467
the plugin-based
hosted mode.

00:20:47.467 --> 00:20:50.501
Just to underscore the point.
[laughter]

00:20:50.501 --> 00:20:53.734
Plus, I just discovered
Keynote Animations,

00:20:53.734 --> 00:20:57.267
so like, I'm definitely gonna be
over the top with that.

00:20:57.267 --> 00:21:00.400
All right, let's talk about
code splitting.

00:21:00.400 --> 00:21:04.601
What happens is your scripts
become really big.

00:21:04.601 --> 00:21:08.601
Especially
if you haven't done

00:21:08.601 --> 00:21:12.734
enough JavaScript development
beforehand

00:21:12.734 --> 00:21:16.434
to be incredibly afraid
of browsers.

00:21:16.434 --> 00:21:22.534
You might not approach
a GWT project--

00:21:22.534 --> 00:21:26.367
hey, I did turn that off.
I swear.

00:21:26.367 --> 00:21:28.767
You might not approach
a GWT project

00:21:28.767 --> 00:21:32.367
with sufficient trepidation.

00:21:32.367 --> 00:21:34.133
You might feel
a little too confident.

00:21:34.133 --> 00:21:35.400
You might say, hey, wow,
this is great.

00:21:35.400 --> 00:21:36.834
I can write Javacode,

00:21:36.834 --> 00:21:40.434
and it just magically turns into
super-optimized JavaScript.

00:21:40.434 --> 00:21:44.234
Well, we do optimize,
but it's still proportional

00:21:44.234 --> 00:21:46.067
to the amount of Javacode
that you write.

00:21:46.067 --> 00:21:48.834
So don't be complacent.

00:21:48.834 --> 00:21:51.067
You want to think about
the size of your script

00:21:51.067 --> 00:21:53.367
and performance
from the very beginning.

00:21:53.367 --> 00:21:56.234
For one reason,
you have to download that script

00:21:56.234 --> 00:21:57.501
when the user visits
the site.

00:21:57.501 --> 00:22:00.100
So if you get one megabyte
of JavaScript,

00:22:00.100 --> 00:22:01.534
that is just going
to take a while.

00:22:01.534 --> 00:22:04.767
Especially for users
with slower connections.

00:22:04.767 --> 00:22:07.767
It also can trigger
some pathological behavior

00:22:07.767 --> 00:22:11.434
in certain browsers,
who shall remain nameless.

00:22:11.434 --> 00:22:14.167
The parsers were written
at a time

00:22:14.167 --> 00:22:15.467
when nobody expected
to be parsing

00:22:15.467 --> 00:22:16.734
a megabyte of JavaScript.

00:22:16.734 --> 00:22:19.167
So some of the internal data
structures that they use

00:22:19.167 --> 00:22:22.267
have worse than linear time

00:22:22.267 --> 00:22:26.334
with respect to the number
of lines of JavaScript code.

00:22:26.334 --> 00:22:29.901
There is one thing we can do
and have done in GWT 2.0

00:22:29.901 --> 00:22:32.033
which is to break
really long script blocks

00:22:32.033 --> 00:22:33.901
into just multiple
script blocks.

00:22:33.901 --> 00:22:37.968
Believe it or not, just
inserting extra script tags

00:22:37.968 --> 00:22:40.200
does something to reset
the internal compiler--

00:22:40.200 --> 00:22:42.601
I mean, the JavaScript
parser state--

00:22:42.601 --> 00:22:45.100
so that it actually sort of does
avoid that script time--

00:22:45.100 --> 00:22:48.067
uh, the pathological behavior.

00:22:48.067 --> 00:22:49.501
So we help you out somewhat,

00:22:49.501 --> 00:22:51.968
but still, in general,
the UI is locked up,

00:22:51.968 --> 00:22:53.501
and that's not good.

00:22:53.501 --> 00:22:56.033
That's the last thing you want
to do is hang the browser.

00:22:56.033 --> 00:22:57.300
Remember from the keynote,

00:22:57.300 --> 00:22:59.367
"I will not hose the browser
with JavaScript."

00:22:59.367 --> 00:23:01.601
We help you write a lot
of JavaScript,

00:23:01.601 --> 00:23:04.400
but we still don't want you
to hose the browser.

00:23:04.400 --> 00:23:09.367
So...and then also remember
that you--

00:23:09.367 --> 00:23:11.400
A lot of times with GWT
you run code

00:23:11.400 --> 00:23:14.601
to produce DOM structures
that then render as the UI.

00:23:14.601 --> 00:23:16.801
If you have to parse
a lot of script at startup,

00:23:16.801 --> 00:23:19.934
that adds latency
to the beginning--

00:23:19.934 --> 00:23:23.334
before your code can
start running to build the UI,

00:23:23.334 --> 00:23:24.701
that then has to get rendered.

00:23:24.701 --> 00:23:28.000
Long story short,
you don't want to wait too long

00:23:28.000 --> 00:23:30.901
to parse a really large bit
of JavaScript.

00:23:30.901 --> 00:23:34.868
So it seems like a problem
for GWT to solve.

00:23:34.868 --> 00:23:38.767
Did I mention I discovered
the animations in Keynote?

00:23:38.767 --> 00:23:45.100
So we've got the ability
to drop split points.

00:23:45.100 --> 00:23:48.334
The API is called GWT.runAsync.

00:23:48.334 --> 00:23:52.334
And all you do is pass
a callback into runAsync.

00:23:52.334 --> 00:23:57.033
Okay, so that's an example
of the split point.

00:23:57.033 --> 00:24:01.767
If the code fragment
successfully downloads,

00:24:01.767 --> 00:24:07.334
the onSuccess callback
will be called...

00:24:07.334 --> 00:24:10.267
But it's possible that
the code fragment might fail

00:24:10.267 --> 00:24:12.667
to download if there was
a network pickup

00:24:12.667 --> 00:24:14.067
or a problem like that.

00:24:14.067 --> 00:24:18.400
In which case...
you have that.

00:24:18.400 --> 00:24:19.834
I promise there's no more

00:24:19.834 --> 00:24:21.801
annoying animations
after that.

00:24:21.801 --> 00:24:23.534
I pretty much milked
that joke.

00:24:23.534 --> 00:24:26.701
All right, so does that
kind of make sense?

00:24:26.701 --> 00:24:29.100
The idea is
the compiler can see

00:24:29.100 --> 00:24:33.267
what's within
the onSuccess method there.

00:24:33.267 --> 00:24:38.601
And it does something
that Lex deemed dead for now,

00:24:38.601 --> 00:24:40.968
code elimination.

00:24:40.968 --> 00:24:43.234
And so it starts with that
as the beginning

00:24:43.234 --> 00:24:45.033
of a set of dependencies.

00:24:45.033 --> 00:24:47.934
So this is sort of a--
it creates a split point

00:24:47.934 --> 00:24:51.067
in the dependency graph
that the compiler can analyze,

00:24:51.067 --> 00:24:54.267
and to make splitting
decisions.

00:24:54.267 --> 00:24:57.601
So let's see what happens
when we split Showcase up.

00:24:57.601 --> 00:25:00.601
The original Showcase,
the unsplit version,

00:25:00.601 --> 00:25:04.467
requires 108K gzipped,

00:25:04.467 --> 00:25:08.167
which is like, I think,
388K on gzipped.

00:25:08.167 --> 00:25:11.367
But you should always
sort of script gzipped.

00:25:11.367 --> 00:25:13.167
Anyway, 108K.

00:25:13.167 --> 00:25:14.868
And then the split version
can actually get

00:25:14.868 --> 00:25:18.133
the Showcase UI up
and interactive

00:25:18.133 --> 00:25:20.901
with about half
that amount of script

00:25:20.901 --> 00:25:23.534
just by carefully dropping
some split points in.

00:25:23.534 --> 00:25:26.667
Let's look at the way
we did that in Showcase.

00:25:35.033 --> 00:25:36.667
That's what happens

00:25:36.667 --> 00:25:40.501
if you just stop the Java side

00:25:40.501 --> 00:25:43.234
of hosted mode.

00:25:43.234 --> 00:25:48.701
All right...

00:25:48.701 --> 00:25:50.667
It's also, I guess,
worth mentioning

00:25:50.667 --> 00:25:53.100
that code splitting--

00:25:53.100 --> 00:25:55.534
we designed it to not require
any particular

00:25:55.534 --> 00:25:57.434
server-side support.

00:25:57.434 --> 00:26:00.133
So you can actually even
run split code directly

00:26:00.133 --> 00:26:02.601
from the file system,
which is what I'm doing here.

00:26:02.601 --> 00:26:05.634
'Cause the last thing you want
is to be forced to use

00:26:05.634 --> 00:26:07.901
some complicated servlet
configuration,

00:26:07.901 --> 00:26:08.934
and that sort of thing.

00:26:08.934 --> 00:26:11.267
So we did not do that.

00:26:11.267 --> 00:26:14.167
So if you'll just watch
over here on the screen

00:26:14.167 --> 00:26:15.634
to the right,

00:26:15.634 --> 00:26:18.234
you can watch as new bits
of code are being fetched.

00:26:18.234 --> 00:26:20.334
We've created a split point
everywhere that there's

00:26:20.334 --> 00:26:23.801
a primary hyperlink here
in the tree.

00:26:27.601 --> 00:26:30.601
So you can see it--
There's really two things.

00:26:30.601 --> 00:26:34.334
You can see that the code loads,
which is cool.

00:26:34.334 --> 00:26:36.667
But even cooler is the fact
that you can't tell

00:26:36.667 --> 00:26:37.801
that the code is loading.

00:26:37.801 --> 00:26:42.834
Just watch the UI for
a second.

00:26:42.834 --> 00:26:45.701
I mean, it pops in,
essentially, immediately.

00:26:45.701 --> 00:26:49.567
Because we've amortized the cost
of loading that code.

00:26:49.567 --> 00:26:52.934
You know, we split
what was 108K

00:26:52.934 --> 00:26:54.701
across a bunch
of different actions.

00:26:54.701 --> 00:26:58.100
And users do expect, sometimes,
there to be a slight delay

00:26:58.100 --> 00:26:59.567
when they do something.

00:26:59.567 --> 00:27:02.000
If you can make your code
split well,

00:27:02.000 --> 00:27:04.534
then the delay will be
negligible.

00:27:04.534 --> 00:27:10.501
And so it's good
all around.

00:27:10.501 --> 00:27:12.434
Okay, we saw that.

00:27:12.434 --> 00:27:14.868
So there's a few things to know
about runAsync.

00:27:14.868 --> 00:27:18.167
So it is intentionally
developer-guided.

00:27:18.167 --> 00:27:20.033
As these sorts of techniques

00:27:20.033 --> 00:27:21.601
are starting to become
popular,

00:27:21.601 --> 00:27:22.934
there's different philosophies
about

00:27:22.934 --> 00:27:24.934
how code splitting
should work.

00:27:24.934 --> 00:27:28.801
We say that it should not be
an automatic process.

00:27:28.801 --> 00:27:32.601
We say that the developer
has to know

00:27:32.601 --> 00:27:37.267
what sort of functionality
might be appropriate time

00:27:37.267 --> 00:27:38.934
to split out some code.

00:27:38.934 --> 00:27:40.767
Where there might be
a network delay.

00:27:40.767 --> 00:27:43.100
For example, clicking
on the settings page

00:27:43.100 --> 00:27:44.601
is a perfect thing.

00:27:44.601 --> 00:27:45.868
You rarely click
on settings--

00:27:45.868 --> 00:27:48.067
like once out of every ten times
you use an application.

00:27:48.067 --> 00:27:49.634
That's a perfect time

00:27:49.634 --> 00:27:51.534
to be willing to suffer
a delay.

00:27:51.534 --> 00:27:54.834
So you would put the UI
for showing settings page

00:27:54.834 --> 00:27:56.534
behind the split point.

00:27:56.534 --> 00:27:59.334
Let's think about a system
that didn't work this way.

00:27:59.334 --> 00:28:01.100
That just sort of
magically figured out

00:28:01.100 --> 00:28:02.534
how to split your code.

00:28:02.534 --> 00:28:04.367
You don't know what's
gonna get split out when.

00:28:04.367 --> 00:28:06.767
I mean, maybe there's some sort
of magical machine

00:28:06.767 --> 00:28:09.167
learning algorithm or something
that could do this for you.

00:28:09.167 --> 00:28:14.501
But that may be a ways out.

00:28:14.501 --> 00:28:16.601
It's actually intentionally
asynchronous

00:28:16.601 --> 00:28:18.300
because it's really
important

00:28:18.300 --> 00:28:19.734
not to lock up
the browser UI

00:28:19.734 --> 00:28:21.300
while the code
is being fetched.

00:28:21.300 --> 00:28:22.834
And importantly,
the user might click

00:28:22.834 --> 00:28:24.100
on the settings page,

00:28:24.100 --> 00:28:26.067
or some other expensive piece
of functionality,

00:28:26.067 --> 00:28:27.934
but then immediately change
his or her mind

00:28:27.934 --> 00:28:29.567
and want to go do
something else.

00:28:29.567 --> 00:28:32.234
So we can't have a situation
where you call a method

00:28:32.234 --> 00:28:34.200
that requires code
to be fetched,

00:28:34.200 --> 00:28:36.834
that literally hangs execution
of the JavaScript thread.

00:28:36.834 --> 00:28:38.734
Because that thread is
the same thread

00:28:38.734 --> 00:28:40.634
that allows you to interact
with the browser.

00:28:40.634 --> 00:28:42.000
So it is asynchronous.

00:28:42.000 --> 00:28:44.000
It's not the easiest
programming model in the world.

00:28:44.000 --> 00:28:46.000
But it does provide
the best user experience,

00:28:46.000 --> 00:28:48.267
which is ultimately
what we're after.

00:28:48.267 --> 00:28:50.767
It also forces you to think
about failure paths.

00:28:50.767 --> 00:28:52.868
Imagine a situation where
there weren't a callback,

00:28:52.868 --> 00:28:55.300
and there weren't a method
called "on failure"

00:28:55.300 --> 00:28:56.634
that you had to fill in.

00:28:56.634 --> 00:28:58.434
You might never think
about it.

00:28:58.434 --> 00:29:00.767
If just some random exception
got thrown

00:29:00.767 --> 00:29:02.234
in the case of failure,

00:29:02.234 --> 00:29:03.801
you would never know where
you should and shouldn't try

00:29:03.801 --> 00:29:06.300
to catch this "fragment failed
to load" exception,

00:29:06.300 --> 00:29:07.467
and so on.

00:29:07.467 --> 00:29:08.901
So either you don't ever
catch it,

00:29:08.901 --> 00:29:10.801
in which case you don't have
good error handling.

00:29:10.801 --> 00:29:13.968
Or you get paranoid
and wrap every single method

00:29:13.968 --> 00:29:15.334
in a try catch.

00:29:15.334 --> 00:29:17.200
Because anything could
potentially fail.

00:29:17.200 --> 00:29:19.434
And that's bad for the reason
that it would increase code size

00:29:19.434 --> 00:29:20.701
and slow things down.

00:29:20.701 --> 00:29:23.467
So we tried to be really careful
in how we design it.

00:29:23.467 --> 00:29:28.434
And as you get to know the way
that code splitting works,

00:29:28.434 --> 00:29:29.934
and use it in your own
applications,

00:29:29.934 --> 00:29:32.133
we hope that you'll be mindful
of the reasons

00:29:32.133 --> 00:29:33.601
that it was designed
the way that it is.

00:29:33.601 --> 00:29:36.567
Also important to note
that the split point

00:29:36.567 --> 00:29:39.067
doesn't actually mean
it will delay at that point.

00:29:39.067 --> 00:29:42.667
It's not necessarily true
that you will fetch

00:29:42.667 --> 00:29:44.901
exactly at the moment
the split point is reached

00:29:44.901 --> 00:29:45.901
in the control flow.

00:29:45.901 --> 00:29:47.834
We can do things like
pre-fetch.

00:29:47.834 --> 00:29:49.000
That would be possible.

00:29:49.000 --> 00:29:51.434
You can do that by creating
a custom linker.

00:29:51.434 --> 00:29:52.968
It would also--

00:29:52.968 --> 00:29:55.133
the fragments
are perfectly cacheable.

00:29:55.133 --> 00:29:59.000
They have strong name URLs
so that you can provide

00:29:59.000 --> 00:30:00.934
never expires headers

00:30:00.934 --> 00:30:02.767
so they can be cached locally
in the browser.

00:30:02.767 --> 00:30:04.634
So it doesn't necessarily
mean slow.

00:30:04.634 --> 00:30:06.834
It also doesn't necessarily
mean split.

00:30:06.834 --> 00:30:09.834
The compiler can choose
to ignore a split point.

00:30:09.834 --> 00:30:12.801
It tries to do a good job
of finding a balance

00:30:12.801 --> 00:30:15.400
of minimizing the total number
of fragments,

00:30:15.400 --> 00:30:17.367
making them cacheable.

00:30:17.367 --> 00:30:19.133
Honoring all the different
static dependencies

00:30:19.133 --> 00:30:20.400
in your code.

00:30:20.400 --> 00:30:23.367
And--which is all that stuff
I just said--

00:30:23.367 --> 00:30:26.834
And to understand more
about the specifics here,

00:30:26.834 --> 00:30:29.234
I invite you to come to the
"Story of Your Compile/

00:30:29.234 --> 00:30:31.901
Reading Tea Leaves" talk that
Lex and I are doing tomorrow.

00:30:31.901 --> 00:30:34.467
We'll be going into this
in a lot more detail.

00:30:34.467 --> 00:30:37.267
I guess one last point is...

00:30:37.267 --> 00:30:39.133
we are really excited
about this feature

00:30:39.133 --> 00:30:42.601
because it is so very hard
to do this any other way.

00:30:42.601 --> 00:30:46.033
We've seen teams
try to split code manually

00:30:46.033 --> 00:30:48.534
across JavaScript files,

00:30:48.534 --> 00:30:50.801
and think about
when they should load,

00:30:50.801 --> 00:30:53.033
which module, and create
these elaborate diagrams

00:30:53.033 --> 00:30:54.634
and so on.

00:30:54.634 --> 00:30:56.400
And they might get it working
this week.

00:30:56.400 --> 00:30:59.801
But then a month from now,
other people come along,

00:30:59.801 --> 00:31:01.367
and they write code
not understanding

00:31:01.367 --> 00:31:02.934
the dependency order,

00:31:02.934 --> 00:31:05.767
and they call a function that
wouldn't yet have been loaded.

00:31:05.767 --> 00:31:08.767
And, you know,
you have an explosion.

00:31:08.767 --> 00:31:12.767
Okay, now, ClientBundle.

00:31:12.767 --> 00:31:15.801
First let's revisit
ImageBundle,

00:31:15.801 --> 00:31:18.167
which is sort of
a new direction

00:31:18.167 --> 00:31:21.200
that we went in 1.4
with GWT.

00:31:21.200 --> 00:31:24.400
And it leverages the fact
that GWT can do

00:31:24.400 --> 00:31:26.634
compile time cogeneration,

00:31:26.634 --> 00:31:29.100
and compile time
resource generation.

00:31:29.100 --> 00:31:31.033
I'll explain how that works
a little bit.

00:31:31.033 --> 00:31:33.501
So let's say the easiest thing
for you to do

00:31:33.501 --> 00:31:39.133
in your email application
is to organize your files

00:31:39.133 --> 00:31:41.701
as separate, you know,
jpegs or something.

00:31:41.701 --> 00:31:44.701
And they're scattered in a way
that makes sense to you

00:31:44.701 --> 00:31:45.767
or to your designers.

00:31:45.767 --> 00:31:47.334
Okay, that's great.

00:31:47.334 --> 00:31:51.534
But that's not the same as
what's good for the end user.

00:31:51.534 --> 00:31:53.868
So there is this divide
between

00:31:53.868 --> 00:31:55.701
how you're going to organize
your code in development,

00:31:55.701 --> 00:31:58.767
and how you'd like it to be
served for high performance.

00:31:58.767 --> 00:32:01.734
User experience,
you know, in production.

00:32:01.734 --> 00:32:04.400
So when we add up the sizes--
and I actually did this--

00:32:04.400 --> 00:32:07.868
add up the sizes
of these individual images,

00:32:07.868 --> 00:32:09.934
it comes out as something
like 20K.

00:32:09.934 --> 00:32:14.901
But what GWT lets you do is
construct an ImageBundle,

00:32:14.901 --> 00:32:19.367
which is a simple,
cogeneration-based API

00:32:19.367 --> 00:32:23.734
that can, at compile time,
take those images,

00:32:23.734 --> 00:32:26.801
put them together
in a single-image strip,

00:32:26.801 --> 00:32:29.734
and provide you hooks so that
you can refer to them

00:32:29.734 --> 00:32:32.634
as viewports, basically--
sprites--

00:32:32.634 --> 00:32:35.767
within the one image.

00:32:35.767 --> 00:32:38.501
So that means
some goodness happens.

00:32:38.501 --> 00:32:41.734
Some of the goodness is
you remove

00:32:41.734 --> 00:32:45.501
all the redundant image file
header information.

00:32:45.501 --> 00:32:47.968
There's just a boiler plate
in every individual image file.

00:32:47.968 --> 00:32:50.100
By combining these into one,

00:32:50.100 --> 00:32:52.300
you actually can remove
that redundancy.

00:32:52.300 --> 00:32:53.968
And so, literally,
the combined image is

00:32:53.968 --> 00:32:58.234
actually smaller than
the individual images in total.

00:32:58.234 --> 00:33:00.834
In terms of HTTP requests,
it's really huge.

00:33:00.834 --> 00:33:05.167
It means one request,
that is, instead of 11.

00:33:05.167 --> 00:33:07.434
Which is really important
because some browsers still have

00:33:07.434 --> 00:33:10.067
a two-connection limit.

00:33:10.067 --> 00:33:11.334
In other words,
if I'm going to fetch

00:33:11.334 --> 00:33:12.701
11 different images,

00:33:12.701 --> 00:33:17.067
the two outgoing connections
are completely saturated.

00:33:17.067 --> 00:33:19.467
So if I've got an RPC
that I need to do,

00:33:19.467 --> 00:33:22.400
it's waiting in line
behind 11 images

00:33:22.400 --> 00:33:24.033
being requested
at the same time.

00:33:24.033 --> 00:33:25.467
So your user is
twiddling their thumbs

00:33:25.467 --> 00:33:26.868
and maybe thinking about
going to check out

00:33:26.868 --> 00:33:30.367
Twitter or Facebook
or something.

00:33:30.367 --> 00:33:32.200
There's also a really nice
caching story

00:33:32.200 --> 00:33:34.534
because we are able to generate
the bundled image

00:33:34.534 --> 00:33:37.601
such that its name is
an MB5 hash

00:33:37.601 --> 00:33:39.701
of its very pixel content.

00:33:39.701 --> 00:33:43.434
So you can set
"never expires" headers

00:33:43.434 --> 00:33:45.801
on that resource.

00:33:45.801 --> 00:33:47.567
The browser can cache it
locally.

00:33:47.567 --> 00:33:49.834
And if the code ever changes--

00:33:49.834 --> 00:33:52.000
Like, if you change
one of the images and redeploy,

00:33:52.000 --> 00:33:55.234
then your script
would have a reference

00:33:55.234 --> 00:33:59.667
to a different MB5-named
image.

00:33:59.667 --> 00:34:00.934
So in other words,

00:34:00.934 --> 00:34:03.000
you can cache permanently
on the client,

00:34:03.000 --> 00:34:07.067
but you're never at risk that
that client code will refer

00:34:07.067 --> 00:34:09.634
to the wrong image.

00:34:09.634 --> 00:34:11.300
It's a little complicated,
but really, the point is

00:34:11.300 --> 00:34:12.534
you don't have to think
about it,

00:34:12.534 --> 00:34:14.000
you just get the benefit.

00:34:14.000 --> 00:34:17.300
Okay, so with that
as background,

00:34:17.300 --> 00:34:19.267
let's talk about
what ClientBundle is.

00:34:19.267 --> 00:34:22.300
ClientBundle generalizes
this concept

00:34:22.300 --> 00:34:25.100
to arbitrary resource types.

00:34:25.100 --> 00:34:26.767
Let's walk through one.

00:34:26.767 --> 00:34:28.667
So I'm gonna create an interface
called MyBundle

00:34:28.667 --> 00:34:30.767
that extends ClientBundle.

00:34:30.767 --> 00:34:33.501
I'll create an instance
using GWT.create,

00:34:33.501 --> 00:34:37.100
which is the magic call
that allows this cogeneration

00:34:37.100 --> 00:34:39.267
to happen.

00:34:39.267 --> 00:34:40.601
And then I can do--

00:34:40.601 --> 00:34:42.467
this is very much in line
with ImageBundle.

00:34:42.467 --> 00:34:45.234
I can refer to smiley.gif.

00:34:45.234 --> 00:34:49.300
And when I call this method
"smileyImage" in code,

00:34:49.300 --> 00:34:52.501
it'll return me a resource
that represents a sprite

00:34:52.501 --> 00:34:55.267
within the bundled image.

00:34:55.267 --> 00:34:57.033
I can have another image,

00:34:57.033 --> 00:34:58.167
and I can be sure that
this will get

00:34:58.167 --> 00:35:00.000
bundled together nicely.

00:35:00.000 --> 00:35:01.767
But for the first time
with ClientBundle,

00:35:01.767 --> 00:35:03.033
you can do other things.

00:35:03.033 --> 00:35:05.234
You can bundle in, for example,
text resources.

00:35:05.234 --> 00:35:07.968
So let's say, rather than
configuring your application

00:35:07.968 --> 00:35:09.534
in Javacode,

00:35:09.534 --> 00:35:12.267
you'd like to keep the config
in a separate XML file

00:35:12.267 --> 00:35:13.868
as part of your
project structure.

00:35:13.868 --> 00:35:16.501
That doesn't mean you actually
want to serve an XML file

00:35:16.501 --> 00:35:19.067
to the client in order
to make this go, right?

00:35:19.067 --> 00:35:21.267
It would be wasteful.

00:35:21.267 --> 00:35:25.667
So I can instead create a method
like this called appConfig.

00:35:25.667 --> 00:35:29.367
And it will automatically
compile in the text

00:35:29.367 --> 00:35:35.334
of that XML
into my JavaScript.

00:35:35.334 --> 00:35:37.367
I can do the same thing
with--

00:35:37.367 --> 00:35:38.834
for example,

00:35:38.834 --> 00:35:42.267
if it's a larger
text resource,

00:35:42.267 --> 00:35:46.634
I can specify
the external text resource type

00:35:46.634 --> 00:35:48.334
as the return value.

00:35:48.334 --> 00:35:51.767
And that has an API
that allows there

00:35:51.767 --> 00:35:52.901
to be a level of indirection.

00:35:52.901 --> 00:35:54.901
It's an asynchronous request.

00:35:54.901 --> 00:35:57.167
So that,
depending on other settings,

00:35:57.167 --> 00:35:59.534
it can either be bundled,
or it can be fetched.

00:35:59.534 --> 00:36:01.033
In the case where
it's fetched--

00:36:01.033 --> 00:36:03.601
if it's a large file that's
rarely used, for example--

00:36:03.601 --> 00:36:07.534
its contents are MB5-encoded.

00:36:07.534 --> 00:36:09.334
I mean, its name
is MB5-encoded.

00:36:09.334 --> 00:36:11.300
So you can use the same
perfect caching trick

00:36:11.300 --> 00:36:12.667
for large things.

00:36:12.667 --> 00:36:14.267
I used wordlist as an example.

00:36:14.267 --> 00:36:15.968
Because you can imagine
a spellchecker

00:36:15.968 --> 00:36:18.934
with a large wordlist
that you wanted to download

00:36:18.934 --> 00:36:21.934
might be something
you would want to cache.

00:36:21.934 --> 00:36:24.667
You can even do crazy things,
like PDFs.

00:36:24.667 --> 00:36:27.434
If there was some reason
you needed a PDF or,

00:36:27.434 --> 00:36:30.267
I don't know,
WAV data or MP3 data,

00:36:30.267 --> 00:36:32.133
you can actually do that
as well.

00:36:32.133 --> 00:36:36.334
And this data resource type--
the return type here--

00:36:36.334 --> 00:36:38.901
it has a method called
"get URL."

00:36:38.901 --> 00:36:41.801
And that URL, depending
on the browser,

00:36:41.801 --> 00:36:43.901
may be one of a couple
different things.

00:36:43.901 --> 00:36:46.167
On a browser--
say an older browser--

00:36:46.167 --> 00:36:49.868
it might be an actual URL
to your server.

00:36:49.868 --> 00:36:53.167
But on a newer browser
that supports data URLs,

00:36:53.167 --> 00:36:56.834
it actually might literally be
a data URL containing

00:36:56.834 --> 00:37:00.868
the Base64-encoded bits
of that thing.

00:37:00.868 --> 00:37:03.534
In other words,
I can bundle PDF data--

00:37:03.534 --> 00:37:05.033
just as an example--

00:37:05.033 --> 00:37:08.133
directly into my compiled
JavaScript.

00:37:08.133 --> 00:37:11.400
So you have a lot of control
over how your resources

00:37:11.400 --> 00:37:14.300
get deployed
and downloaded.

00:37:14.300 --> 00:37:15.434
One of the coolest things,

00:37:15.434 --> 00:37:17.000
which I'll come back to
in a second,

00:37:17.000 --> 00:37:18.667
is CSS processing.

00:37:18.667 --> 00:37:20.634
You can do, um--

00:37:20.634 --> 00:37:23.100
you can bundle CSS files
directly

00:37:23.100 --> 00:37:24.334
into your JavaScript code

00:37:24.334 --> 00:37:26.701
instead of making separate
HTTP requests.

00:37:26.701 --> 00:37:29.701
But you can also do a lot
of fancy things with the CSS

00:37:29.701 --> 00:37:31.834
as you bundle it,
which I'll come back to.

00:37:31.834 --> 00:37:33.534
But let's just go
really quickly

00:37:33.534 --> 00:37:36.133
through the text resource
example.

00:37:36.133 --> 00:37:39.934
So again, I'm gonna have
my app.config.xml file.

00:37:39.934 --> 00:37:42.300
I want to make it available
to my application code

00:37:42.300 --> 00:37:44.934
by calling this method
appConfig.

00:37:44.934 --> 00:37:46.767
Just declare it like that.

00:37:46.767 --> 00:37:52.033
Let's say that the XML file
itself looks like this.

00:37:52.033 --> 00:37:54.734
It's got settings that I want
to compile into my app,

00:37:54.734 --> 00:37:59.467
so animation speed may be
a failover strategy.

00:37:59.467 --> 00:38:01.467
All right, this just needs
to be available

00:38:01.467 --> 00:38:03.767
on your class path
at compile time.

00:38:03.767 --> 00:38:05.834
So this is some code where

00:38:05.834 --> 00:38:07.601
I'm actually gonna use
this bundle.

00:38:07.601 --> 00:38:10.901
I'll grab the instance
in the bundle variable there.

00:38:10.901 --> 00:38:12.767
I'll call the appConfig
method,

00:38:12.767 --> 00:38:14.033
which returns
the text resource.

00:38:14.033 --> 00:38:17.234
It has a getText method
that gives me the XML

00:38:17.234 --> 00:38:20.167
that was attached
to my compiled script.

00:38:20.167 --> 00:38:24.167
And then I can pass that into
the GWT XML library,

00:38:24.167 --> 00:38:27.234
and set up my application.

00:38:27.234 --> 00:38:29.367
So there's a few
really cool points here.

00:38:29.367 --> 00:38:32.400
Obviously,
it's great to know

00:38:32.400 --> 00:38:35.133
that this is going
to succeed.

00:38:35.133 --> 00:38:36.434
It's not gonna require
a round trip.

00:38:36.434 --> 00:38:38.634
It's compiled into
your script.

00:38:38.634 --> 00:38:41.501
You can use the final format
you want--in this case, XML.

00:38:41.501 --> 00:38:44.067
You might use JSON
for config these days.

00:38:44.067 --> 00:38:48.200
And then
the most exciting part

00:38:48.200 --> 00:38:51.367
is CSS resource.

00:38:51.367 --> 00:38:54.367
We actually have
a CSS parser.

00:38:54.367 --> 00:38:57.267
And because we're going through
all the trouble of parsing it,

00:38:57.267 --> 00:38:58.501
we figured we might as well
throw in

00:38:58.501 --> 00:39:00.367
some extra features
to help you deal with CSS

00:39:00.367 --> 00:39:01.834
while you're at it.

00:39:01.834 --> 00:39:04.300
Things like defining constants
in CSS

00:39:04.300 --> 00:39:05.367
is something that
a lot of people have wanted

00:39:05.367 --> 00:39:06.634
for a long time.

00:39:06.634 --> 00:39:08.234
And we can give that
to you today

00:39:08.234 --> 00:39:11.767
with ClientBundle.

00:39:11.767 --> 00:39:14.934
I mean, maybe, maybe,
if you're extremely ambitious,

00:39:14.934 --> 00:39:17.167
you'd use some sort of crazy,
you know,

00:39:17.167 --> 00:39:19.534
SED script or PERL script
in your own CSS

00:39:19.534 --> 00:39:21.100
to achieve the same effect.

00:39:21.100 --> 00:39:24.000
But it's nice to know that
you're getting a real parser

00:39:24.000 --> 00:39:27.601
that can actually crosscheck
if you refer to it a value.

00:39:27.601 --> 00:39:30.033
For example, scary color
for an error message, right?

00:39:30.033 --> 00:39:32.834
Scary color does actually,
in fact,

00:39:32.834 --> 00:39:35.067
map onto something
that was defined, right?

00:39:35.067 --> 00:39:37.133
If I misspelled it, that would
be a compile time error.

00:39:37.133 --> 00:39:40.133
That's another
really nice benefit.

00:39:40.133 --> 00:39:44.834
Because CSS is still
awesome right now,

00:39:44.834 --> 00:39:46.434
and it's not--

00:39:46.434 --> 00:39:50.834
it's more awesome
than reliable.

00:39:50.834 --> 00:39:53.367
For now.
Obviously it's going to improve.

00:39:53.367 --> 00:39:54.901
But for now.

00:39:54.901 --> 00:39:56.834
There may be cases where
you need to do different things.

00:39:56.834 --> 00:39:59.901
Right now, the rounded
border radius is an example

00:39:59.901 --> 00:40:01.501
of where you might want
to do that.

00:40:01.501 --> 00:40:05.968
So you can actually
use conditional constructs

00:40:05.968 --> 00:40:09.467
to define CSS rules differently
in different cases.

00:40:09.467 --> 00:40:11.501
I think this one's
pretty self-evident.

00:40:11.501 --> 00:40:14.467
But the values there are--

00:40:14.467 --> 00:40:17.667
differ by name properties.

00:40:17.667 --> 00:40:19.934
And then, really,
there's way more to say

00:40:19.934 --> 00:40:23.167
about what CssResource
can do.

00:40:23.167 --> 00:40:26.367
It obviously can adminify--
so remove white space

00:40:26.367 --> 00:40:28.734
and comments from your CSS,
which really adds up.

00:40:28.734 --> 00:40:32.434
It can even obfuscate the names
of the CSS classes.

00:40:32.434 --> 00:40:36.534
If you're careful about how--
the discipline you use

00:40:36.534 --> 00:40:41.968
to refer to CSS names
within your Java source code,

00:40:41.968 --> 00:40:45.167
the CSS generator can actually
obfuscate those names.

00:40:45.167 --> 00:40:47.067
Your code never knows
the difference.

00:40:47.067 --> 00:40:49.467
But what's actually downloaded
is smaller,

00:40:49.467 --> 00:40:51.300
runs faster, and so on.

00:40:51.300 --> 00:40:54.701
There's additional
fancy spriting with tiling.

00:40:54.701 --> 00:40:57.467
And you can even,
from a CSS rule,

00:40:57.467 --> 00:41:01.100
call back into your Java code
to get a value

00:41:01.100 --> 00:41:02.968
that gets concatenated into
the CSS

00:41:02.968 --> 00:41:04.133
that then gets injected.

00:41:04.133 --> 00:41:05.667
So lots of fancy stuff.

00:41:05.667 --> 00:41:07.968
If you research it--
just do a Google search

00:41:07.968 --> 00:41:09.467
and you'll see lots
of examples.

00:41:09.467 --> 00:41:13.934
There's a CSS resource
cookbook on Google Code.

00:41:13.934 --> 00:41:18.200
Okay, so layouts.
Another big area.

00:41:20.567 --> 00:41:22.901
First thing to know
about layout is don't do it.

00:41:22.901 --> 00:41:24.767
In other words,
don't do it yourself.

00:41:24.767 --> 00:41:27.501
If you find yourself
writing code

00:41:27.501 --> 00:41:30.133
in response to the resize
event--

00:41:30.133 --> 00:41:31.567
the window resize event--

00:41:31.567 --> 00:41:33.534
you're already losing.

00:41:33.534 --> 00:41:36.234
Because it's such
a worse user experience

00:41:36.234 --> 00:41:39.634
when you have to run code
to adjust the way

00:41:39.634 --> 00:41:40.934
things are laid out

00:41:40.934 --> 00:41:44.200
than to have the browser
do it itself in native code.

00:41:44.200 --> 00:41:46.334
So if you're doing anything
like measuring things,

00:41:46.334 --> 00:41:50.400
like, how long is this div,
exactly?

00:41:50.400 --> 00:41:52.267
You know, you're asking
for offset widths

00:41:52.267 --> 00:41:54.334
and things like that.

00:41:54.334 --> 00:41:56.834
You're almost guaranteed
to be on a path

00:41:56.834 --> 00:41:59.334
to bad performance.

00:41:59.334 --> 00:42:01.601
Instead, like I said,
you want to use implicit layout.

00:42:01.601 --> 00:42:03.100
Have the browser do it.

00:42:03.100 --> 00:42:07.901
So for probably borderline
excruciating details--

00:42:07.901 --> 00:42:10.868
no, no, no, extremely
interesting details--

00:42:10.868 --> 00:42:14.367
talk to Kelly Norton and--
I mean, talk to him,

00:42:14.367 --> 00:42:17.000
but go to his talk
"Measuring Milliseconds,"

00:42:17.000 --> 00:42:19.934
which is, I think,
the one right after this.

00:42:19.934 --> 00:42:22.968
And you will really
find it interesting.

00:42:22.968 --> 00:42:26.033
Okay, but the downside is
we use tables

00:42:26.033 --> 00:42:28.834
and a lot of other things
that are lamented by us

00:42:28.834 --> 00:42:30.834
and everybody else in order
to try to simulate

00:42:30.834 --> 00:42:33.901
the right kind of
constraint-base layout.

00:42:33.901 --> 00:42:36.634
Width 100% works really well

00:42:36.634 --> 00:42:39.000
and consistently,
generally.

00:42:39.000 --> 00:42:43.100
But inevitably people want--
occasionally want

00:42:43.100 --> 00:42:44.801
application-style layout,

00:42:44.801 --> 00:42:46.968
where it takes
the entire browser window.

00:42:46.968 --> 00:42:48.367
And if you resize
the browser window,

00:42:48.367 --> 00:42:50.767
everything resizes
along with it.

00:42:50.767 --> 00:42:54.334
So you want to use Height 100%,
naturally.

00:42:54.334 --> 00:42:56.234
It's the first thing
people do, right?

00:42:56.234 --> 00:42:58.200
But that never works.

00:42:58.200 --> 00:42:59.601
[laughter]

00:42:59.601 --> 00:43:01.234
It just doesn't.

00:43:01.234 --> 00:43:04.701
And it fails wonderfully
and differently

00:43:04.701 --> 00:43:06.133
in different browsers.

00:43:06.133 --> 00:43:07.667
And I day "fails"--

00:43:07.667 --> 00:43:10.334
I mean, it fails if you consider
it looking completely awful

00:43:10.334 --> 00:43:11.968
and not working well.
That's--that's--

00:43:11.968 --> 00:43:13.467
It doesn't actually crash
your computer.

00:43:13.467 --> 00:43:14.634
It doesn't format
your hard drive,

00:43:14.634 --> 00:43:17.000
but it makes your app
completely useless.

00:43:17.000 --> 00:43:19.501
So that's a pretty big fail.

00:43:19.501 --> 00:43:21.234
But--oh, actually, yeah.

00:43:21.234 --> 00:43:23.267
Let me show you what I mean.

00:43:23.267 --> 00:43:25.667
So this isn't--this isn't
so much a failure.

00:43:25.667 --> 00:43:30.200
This is more just
how things can not look great.

00:43:33.434 --> 00:43:35.501
So in the mail sample
that we ship--

00:43:35.501 --> 00:43:36.901
I mean, we're actually
doing this right now

00:43:36.901 --> 00:43:38.033
because we didn't have
a better way of doing it

00:43:38.033 --> 00:43:39.501
in the past.

00:43:39.501 --> 00:43:40.934
You guys have,
I'm sure, seen this.

00:43:40.934 --> 00:43:42.968
But, like, watch
as I drag this around.

00:43:42.968 --> 00:43:47.067
See that laginess?

00:43:47.067 --> 00:43:49.434
That's horrible.

00:43:49.434 --> 00:43:51.067
And I'm not blaming Firefox
for this.

00:43:51.067 --> 00:43:52.901
This is just sort of the way
it has to happen.

00:43:52.901 --> 00:43:56.167
Because the window
on resize event

00:43:56.167 --> 00:43:59.100
has to run some
JavaScript code and so on.

00:43:59.100 --> 00:44:02.534
But back--you know,
this is Firefox 3.

00:44:02.534 --> 00:44:06.000
At this time, the layout
engine's still somewhat slow.

00:44:06.000 --> 00:44:08.300
So you can't literally
run that event

00:44:08.300 --> 00:44:11.234
for every single time
that the browser is resized

00:44:11.234 --> 00:44:12.367
by a single pixel, right?

00:44:12.367 --> 00:44:14.534
So it has to have
this artificial delay.

00:44:14.534 --> 00:44:17.133
And consequently
you get this yuckiness.

00:44:17.133 --> 00:44:19.200
All right, not to mention
getting the code

00:44:19.200 --> 00:44:21.634
to work well at all
is hard.

00:44:21.634 --> 00:44:23.701
and you have to kind of
already be an Ajax expert,

00:44:23.701 --> 00:44:26.567
which is kind of the reason
GWT was invented

00:44:26.567 --> 00:44:28.300
is so that you don't have
to be right.

00:44:28.300 --> 00:44:32.133
All right, now I'll show you
what it looks like--

00:44:32.133 --> 00:44:37.267
Actually, first I'll tell you
a couple more things.

00:44:37.267 --> 00:44:39.968
In Standards mode, we do have
some additional

00:44:39.968 --> 00:44:42.400
reliable behavior with CSS.

00:44:42.400 --> 00:44:44.100
And you can actually get
constraint-based layout

00:44:44.100 --> 00:44:45.267
that does what you want.

00:44:45.267 --> 00:44:47.133
And you don't have
to hook re--resize.

00:44:47.133 --> 00:44:49.667
So we're gonna have
an updated set of panels in 2.0.

00:44:49.667 --> 00:44:53.567
And I'll show you the new
and improved DockPanel.

00:44:53.567 --> 00:44:55.934
This is the well-known
onModuleLoad.

00:44:55.934 --> 00:44:59.067
So this probably isn't
the final name of this panel.

00:44:59.067 --> 00:45:01.701
This is really still
basically prototype code.

00:45:01.701 --> 00:45:04.200
But let's say
you instantiate it.

00:45:04.200 --> 00:45:06.734
You specify a unit,
but that unit can be anything.

00:45:06.734 --> 00:45:09.133
And then you specify sizes
for things

00:45:09.133 --> 00:45:10.601
in various types
of constraints.

00:45:10.601 --> 00:45:13.934
It looks pretty familiar
if you've used DockPanel before.

00:45:13.934 --> 00:45:16.267
We did also add the ability
to add splitters

00:45:16.267 --> 00:45:17.567
just directly into
the DockPanel.

00:45:17.567 --> 00:45:20.634
So for sophisticated layouts,
it can work well.

00:45:20.634 --> 00:45:24.334
And a couple of other things
I want to set.

00:45:24.334 --> 00:45:27.968
So this is pretty
familiar-looking UI code.

00:45:27.968 --> 00:45:30.968
This is the code you've always
been wanting to write.

00:45:30.968 --> 00:45:34.701
But let's look at how
this actually looks.

00:45:34.701 --> 00:45:37.234
So first of all, it's fast.

00:45:37.234 --> 00:45:41.334
Because we're using
CSS for everything.

00:45:41.334 --> 00:45:44.667
You can see that I can't
move the window fast enough

00:45:44.667 --> 00:45:46.834
to outpace what's happening.

00:45:46.834 --> 00:45:50.434
Here it keeps up with me.

00:45:50.434 --> 00:45:52.467
Now, it's interesting
to note that

00:45:52.467 --> 00:45:55.467
no JavaScript code is running
as I'm resizing here.

00:45:55.467 --> 00:45:58.200
This is all based
on CSS constraints

00:45:58.200 --> 00:46:00.033
and the way that
that panel happens to be--

00:46:00.033 --> 00:46:03.767
to use them and construct them.

00:46:03.767 --> 00:46:05.200
As I mentioned,
you got splitters here

00:46:05.200 --> 00:46:07.067
that you can use.

00:46:07.067 --> 00:46:12.267
You've got internal scrolling.

00:46:12.267 --> 00:46:15.100
We also did a little example
of a stack panel

00:46:15.100 --> 00:46:17.334
that uses the same sort
of technique.

00:46:17.334 --> 00:46:20.000
And getting the stack panel
to resize properly

00:46:20.000 --> 00:46:21.334
when nested in another thing--

00:46:21.334 --> 00:46:22.567
I don't know,
if you've ever tried this,

00:46:22.567 --> 00:46:23.934
it can be a real hassle.

00:46:23.934 --> 00:46:27.701
It just works
with the new approach.

00:46:27.701 --> 00:46:30.234
So you specify various
different kinds of constraints.

00:46:34.300 --> 00:46:36.601
In fact,
it was recognized that

00:46:36.601 --> 00:46:38.534
this is pretty much
the same set of constraints

00:46:38.534 --> 00:46:41.734
that you get when designing
Cocoa apps on OS X.

00:46:41.734 --> 00:46:44.100
And then we even
were able to--

00:46:44.100 --> 00:46:47.000
as you specify
that you want to change

00:46:47.000 --> 00:46:50.067
the size of something
from one size to another--

00:46:50.067 --> 00:46:51.667
we can make that animate.

00:46:51.667 --> 00:46:55.000
So for example,
if I double click on this,

00:46:55.000 --> 00:46:57.267
I will get an automatic
resize,

00:46:57.267 --> 00:47:01.567
which is nice.

00:47:01.567 --> 00:47:04.601
So what I'm really showing
there

00:47:04.601 --> 00:47:09.234
is an approach to layouts.

00:47:09.234 --> 00:47:11.200
So that particular panel
isn't the thing

00:47:11.200 --> 00:47:13.000
to be excited about
necessarily.

00:47:13.000 --> 00:47:15.367
It's that we're gonna be able
to take that same approach

00:47:15.367 --> 00:47:17.834
to recreate
all the other panels.

00:47:17.834 --> 00:47:19.167
And they will tend
to just work

00:47:19.167 --> 00:47:22.601
exactly like you
had hoped they would.

00:47:22.601 --> 00:47:24.634
Okay, a few last things

00:47:24.634 --> 00:47:28.734
that I just can't
not mention.

00:47:28.734 --> 00:47:30.200
We've added some compiler flags.

00:47:30.200 --> 00:47:32.968
There's one called
disableClassMetadata.

00:47:32.968 --> 00:47:35.400
The -X means you better know
what you're doing

00:47:35.400 --> 00:47:36.934
before you do this.

00:47:36.934 --> 00:47:39.267
But there's certain constructs
in Java--

00:47:39.267 --> 00:47:41.834
Callingobj.getClass
or clazz.getName--

00:47:41.834 --> 00:47:46.033
forces us to compile
in class literals.

00:47:46.033 --> 00:47:49.667
And those class literals
have names that are strings

00:47:49.667 --> 00:47:51.567
that show up and, you know,
for a couple reasons,

00:47:51.567 --> 00:47:53.067
that's not great.

00:47:53.067 --> 00:47:54.667
But if you really don't
actually care

00:47:54.667 --> 00:47:56.100
what clazz.getName returns--

00:47:56.100 --> 00:47:58.734
You don't care that is says,
you know,

00:47:58.734 --> 00:48:01.834
com.example.mywonderfulapp.

00:48:01.834 --> 00:48:04.501
You just want it to return
a stable string.

00:48:04.501 --> 00:48:05.767
Then we can do this.

00:48:05.767 --> 00:48:08.534
Here's the Showcase metadata.

00:48:08.534 --> 00:48:12.567
I snipped out just the part
where there are class literals,

00:48:12.567 --> 00:48:14.100
with their names
and everything.

00:48:14.100 --> 00:48:17.467
That's at one-point font.

00:48:17.467 --> 00:48:19.834
And I flip this switch on,
and we've got

00:48:19.834 --> 00:48:22.767
between 5% and 10%
script reduction.

00:48:22.767 --> 00:48:24.534
And here's what it looks like
after.

00:48:24.534 --> 00:48:26.000
It's not huge,
but on a big application,

00:48:26.000 --> 00:48:28.033
this can really add up.

00:48:28.033 --> 00:48:30.267
But again,
less code to download,

00:48:30.267 --> 00:48:31.901
less code to parse.

00:48:31.901 --> 00:48:33.434
It actually runs faster
because

00:48:33.434 --> 00:48:34.767
you're not constructing
as much

00:48:34.767 --> 00:48:36.267
when you're creating
class literals.

00:48:36.267 --> 00:48:38.501
And it's a little bit more
of an obscurity benefit.

00:48:38.501 --> 00:48:40.133
When people are looking
at your source,

00:48:40.133 --> 00:48:43.634
they don't see all
the type names and so on.

00:48:43.634 --> 00:48:46.467
In a similar vein
we've got disableCastChecking.

00:48:46.467 --> 00:48:51.400
Because nobody--I hope nobody--
writes code like this.

00:48:51.400 --> 00:48:53.300
So somebody wrote
this silly method that

00:48:53.300 --> 00:48:55.200
you pass in an animal,

00:48:55.200 --> 00:48:58.200
and then just you try
to make it quack,

00:48:58.200 --> 00:48:59.601
but you don't know what kind
of animal it is.

00:48:59.601 --> 00:49:02.334
So you just--you cast it
to a quacker.

00:49:02.334 --> 00:49:05.367
And then you call quack on it.

00:49:05.367 --> 00:49:07.267
But you know,
you're being defensive,

00:49:07.267 --> 00:49:09.934
so you catch
the ClassCastException, right?

00:49:09.934 --> 00:49:12.300
Because, I mean,
people could pass in

00:49:12.300 --> 00:49:17.968
non-quackable objects,
obviously.

00:49:17.968 --> 00:49:20.234
But people are laughing
because

00:49:20.234 --> 00:49:21.467
nobody writes this code,
right?

00:49:21.467 --> 00:49:24.701
But yet, we still, you know,
technically,

00:49:24.701 --> 00:49:27.100
have to generate code
that checks this anyway

00:49:27.100 --> 00:49:28.100
at run time.

00:49:28.100 --> 00:49:29.434
And that's unfortunate
because

00:49:29.434 --> 00:49:31.267
it means there's lots
of tables

00:49:31.267 --> 00:49:32.701
that we have to produce
to say

00:49:32.701 --> 00:49:34.367
this can be cast to that,
and so on.

00:49:34.367 --> 00:49:35.801
And we have to emit
the code

00:49:35.801 --> 00:49:38.601
to do the dynamic
cast checking,

00:49:38.601 --> 00:49:41.234
which actually
slows things down a lot.

00:49:41.234 --> 00:49:44.000
You turn this flag on,
and this is what you get

00:49:44.000 --> 00:49:45.534
in the compiled output.

00:49:45.534 --> 00:49:47.200
So in other words,
it trusts you.

00:49:47.200 --> 00:49:48.434
It basically says,

00:49:48.434 --> 00:49:50.434
"I'm never gonna throw
ClassCastException.

00:49:50.434 --> 00:49:53.167
You better not depend
on that being thrown."

00:49:53.167 --> 00:49:55.267
But assuming you didn't write
stupid code,

00:49:55.267 --> 00:49:57.300
in my humble opinion,

00:49:57.300 --> 00:49:59.934
then you're gonna see
real speed-ups.

00:49:59.934 --> 00:50:02.167
So, um, a 1% size reduction

00:50:02.167 --> 00:50:05.267
and 10% speed improvement
in performance-sensitive code.

00:50:05.267 --> 00:50:09.968
Which, 10% for merely
flipping on a flag is not bad.

00:50:09.968 --> 00:50:11.400
That was actually an average.

00:50:11.400 --> 00:50:15.200
We worked with them
to try out this flag,

00:50:15.200 --> 00:50:19.367
and indeed, 10% faster
with a simple rebuild.

00:50:19.367 --> 00:50:22.167
Okay, a couple more tidbits,
and then we'll do some Q &amp; A.

00:50:22.167 --> 00:50:25.934
So GWT RPC is polymorphic.

00:50:25.934 --> 00:50:28.300
And so one of the things
that you find

00:50:28.300 --> 00:50:33.100
if you use a lot of RPC
is that

00:50:33.100 --> 00:50:36.400
the RPC cogenerator tries
to infer what types

00:50:36.400 --> 00:50:38.000
might be serializable.

00:50:38.000 --> 00:50:41.467
So it kind of walks
the type hierarchy.

00:50:41.467 --> 00:50:44.968
And if you send an animal,
it will try to find, you know,

00:50:44.968 --> 00:50:46.934
all the different kind
of animals that there are.

00:50:46.934 --> 00:50:51.634
Whether or not you actually
do want to send a rhinoceros

00:50:51.634 --> 00:50:54.100
from the server
to the client...

00:50:54.100 --> 00:50:56.501
It kind of--
If you have an RPC method

00:50:56.501 --> 00:50:57.968
that returns type animal,

00:50:57.968 --> 00:51:00.968
it has to be prepared
to receive a rhinoceros

00:51:00.968 --> 00:51:02.634
over the wire.

00:51:02.634 --> 00:51:05.300
So there are cases
where you can look at

00:51:05.300 --> 00:51:07.767
your code output and say,

00:51:07.767 --> 00:51:11.467
"I definitely will not
be sending rhinoceroses

00:51:11.467 --> 00:51:13.100
from the server
to the client."

00:51:13.100 --> 00:51:16.701
Rhinoceri? Anyway...

00:51:16.701 --> 00:51:19.567
And so you can just tell
the RPC code generator,

00:51:19.567 --> 00:51:21.868
"Here's a list of types
that I am definitely

00:51:21.868 --> 00:51:24.200
not wanting you
to serialize."

00:51:24.200 --> 00:51:27.434
And it turns out that
this is really beneficial.

00:51:27.434 --> 00:51:31.534
So you can just go through
and easily just chop out

00:51:31.534 --> 00:51:34.501
a whole bunch of code,
and make your script smaller.

00:51:34.501 --> 00:51:38.734
So it's really pragmatic
and easy to use.

00:51:38.734 --> 00:51:42.634
Another one that comes up a lot
with RPC is the fact

00:51:42.634 --> 00:51:44.834
that people sometimes want
to have

00:51:44.834 --> 00:51:47.534
the functionality
of RequestBuilder,

00:51:47.534 --> 00:51:49.901
but with the simplicity
of RPC.

00:51:49.901 --> 00:51:53.133
And so we've introduced a way
to actually combine the two.

00:51:53.133 --> 00:51:55.234
So you can take
an RPC interface

00:51:55.234 --> 00:51:57.934
and specify the RPC
RequestBuilder instance

00:51:57.934 --> 00:52:00.267
that you'd like to use.

00:52:00.267 --> 00:52:02.033
So that allows you
to do things like

00:52:02.033 --> 00:52:06.434
set custom request headers
in HTTP.

00:52:06.434 --> 00:52:08.634
Set time-outs--
all sorts of things.

00:52:08.634 --> 00:52:11.234
You do that
to the RPC interface itself,

00:52:11.234 --> 00:52:14.200
and every individual
RPC method call

00:52:14.200 --> 00:52:15.467
within that interface

00:52:15.467 --> 00:52:19.100
will use exactly that same
RequestBuilder process.

00:52:19.100 --> 00:52:21.667
If you've used RPC
for anything non-trivial,

00:52:21.667 --> 00:52:23.133
that will make sense.

00:52:23.133 --> 00:52:25.200
And if you haven't,
it probably didn't make sense.

00:52:25.200 --> 00:52:27.501
But that's okay.

00:52:27.501 --> 00:52:30.734
There's even client-side
stack traces

00:52:30.734 --> 00:52:32.133
on some browsers now.

00:52:32.133 --> 00:52:36.601
So at least on Firefox,
this is reliable.

00:52:36.601 --> 00:52:38.868
And we do it without
actually generating

00:52:38.868 --> 00:52:40.133
any additional code.

00:52:40.133 --> 00:52:42.000
There's a way to do it,
obviously,

00:52:42.000 --> 00:52:44.534
by generating code
into the compiled script.

00:52:44.534 --> 00:52:47.534
The compiler could do
all the bookkeeping and so on.

00:52:47.534 --> 00:52:49.868
But we think that might be
a little too costly

00:52:49.868 --> 00:52:51.501
in terms of size and speed.

00:52:51.501 --> 00:52:54.133
But actually,
the browser is able to

00:52:54.133 --> 00:52:57.834
give you stack backtrace
on exceptions in JavaScript.

00:52:57.834 --> 00:53:01.300
It's tricky because
the names are obfuscated

00:53:01.300 --> 00:53:02.801
in production.

00:53:02.801 --> 00:53:06.634
So the stack traces look like
a bunch of obfuscated names.

00:53:06.634 --> 00:53:09.534
But the compiler now also
produces symbol maps

00:53:09.534 --> 00:53:11.667
that you can have
on the server.

00:53:11.667 --> 00:53:14.801
So that if you catch
an exception on the client,

00:53:14.801 --> 00:53:16.234
generate a stack trace,

00:53:16.234 --> 00:53:18.701
send that up in obfuscated form
to your server,

00:53:18.701 --> 00:53:21.534
Then you can combine that
with the symbol maps,

00:53:21.534 --> 00:53:24.067
and then you can see
the full--

00:53:24.067 --> 00:53:26.400
the actual names
of the methods

00:53:26.400 --> 00:53:28.300
that were involved in
the stack trace on the client.

00:53:28.300 --> 00:53:31.834
So it's pretty cool
when you actually see it.

00:53:31.834 --> 00:53:34.801
And that is increasingly
working.

00:53:34.801 --> 00:53:38.567
Last thing that came up is...
people--

00:53:38.567 --> 00:53:40.968
We introduced last year at I/O
something called

00:53:40.968 --> 00:53:42.167
JavaScript Overlay Types,

00:53:42.167 --> 00:53:45.400
which let's you model
JavaScript objects

00:53:45.400 --> 00:53:47.467
directly into
the Java type system.

00:53:47.467 --> 00:53:50.534
So I can create a Java class
that I superimpose

00:53:50.534 --> 00:53:51.567
directly on a JavaScript
object.

00:53:51.567 --> 00:53:52.901
And it can be faster.

00:53:52.901 --> 00:53:54.767
Especially for JSON,
it's a really efficient way

00:53:54.767 --> 00:53:58.334
to interact with JSON objects.

00:53:58.334 --> 00:54:01.234
The problem is people wanted
to use it for JSON.

00:54:01.234 --> 00:54:03.467
So they want to send
JSON structures

00:54:03.467 --> 00:54:05.000
from the server to
the client.

00:54:05.000 --> 00:54:08.534
But the server can't
actually use the JSNI--

00:54:08.534 --> 00:54:10.400
the JavaScript code
on the server.

00:54:10.400 --> 00:54:14.234
And overlay types
didn't support interfaces.

00:54:14.234 --> 00:54:15.834
So in other words,

00:54:15.834 --> 00:54:19.901
for the server to use
that same class is impossible.

00:54:19.901 --> 00:54:23.234
So now we've introduced
the ability for overlay types

00:54:23.234 --> 00:54:25.801
to implement interfaces
so that on the server side

00:54:25.801 --> 00:54:29.968
you can implement
some JSON-oriented interface--

00:54:29.968 --> 00:54:31.334
let's say person--

00:54:31.334 --> 00:54:34.067
that's basically
a being-like interface.

00:54:34.067 --> 00:54:35.734
You know, get first name,
get last name.

00:54:35.734 --> 00:54:37.467
You can implement it
on the server

00:54:37.467 --> 00:54:39.467
using regular Java bytecode.

00:54:39.467 --> 00:54:41.133
You can implement it
on the client

00:54:41.133 --> 00:54:42.834
using an overlay type.

00:54:42.834 --> 00:54:45.234
And so you can actually share
a whole bunch of code,

00:54:45.234 --> 00:54:46.634
in terms of that interface,

00:54:46.634 --> 00:54:48.000
between the client
and the server.

00:54:48.000 --> 00:54:49.400
Again, if you've
never done this,

00:54:49.400 --> 00:54:50.734
that probably doesn't make
a whole lot of sense.

00:54:50.734 --> 00:54:53.534
But if you have, hopefully
you will see the benefit.

00:54:53.534 --> 00:54:55.267
And we can talk a lot more
about that.

00:54:55.267 --> 00:54:58.234
We have office hours
we're gonna have scheduled

00:54:58.234 --> 00:55:00.834
to talk about the compiler
and lots of other good stuff.

00:55:00.834 --> 00:55:03.234
And hopefully, we'll just
bump into each other

00:55:03.234 --> 00:55:05.300
in the hallways.

00:55:05.300 --> 00:55:07.400
And that is pretty much it.

00:55:07.400 --> 00:55:11.367
Um, I think let's go ahead
and, uh--

00:55:11.367 --> 00:55:13.834
We have about five minutes
left.

00:55:13.834 --> 00:55:15.501
We can do some quick Q &amp; A,

00:55:15.501 --> 00:55:18.234
but please, do come
to the microphones

00:55:18.234 --> 00:55:21.734
since the audio needs to go
into YouTube.

00:55:21.734 --> 00:55:23.234
[applause]

00:55:23.234 --> 00:55:25.267
Thank you.

00:55:25.267 --> 00:55:28.300
[applause]

00:55:32.834 --> 00:55:33.901
Yes?

00:55:33.901 --> 00:55:35.734
man: The, uh--
Sorry, it's loud.

00:55:35.734 --> 00:55:37.033
The code splitting stuff
looks really cool.

00:55:37.033 --> 00:55:40.267
I'm wondering what it does
for localized resources.

00:55:40.267 --> 00:55:42.901
Um, CSS...
If there's anything...

00:55:42.901 --> 00:55:45.033
Johnson: Oh, yeah.
That's a great question.

00:55:45.033 --> 00:55:47.133
That was a huge point
I failed to make.

00:55:47.133 --> 00:55:51.868
When you combine ClientBundle
and code splitting,

00:55:51.868 --> 00:55:55.901
it's really awesome
because ClientBundle, you know,

00:55:55.901 --> 00:55:58.934
literally can, like, bundle in
the variables and so on.

00:55:58.934 --> 00:56:01.601
In other words, you have fields
that get generated

00:56:01.601 --> 00:56:05.234
by the ClientBundle that
contain things like CSS values--

00:56:05.234 --> 00:56:08.334
literals, and even
the PDF example, right?

00:56:08.334 --> 00:56:10.901
That would become a field
at compile time.

00:56:10.901 --> 00:56:13.400
And then code splitting
can actually do

00:56:13.400 --> 00:56:17.067
the static analysis to say
this huge chunk of CSS

00:56:17.067 --> 00:56:19.634
isn't actually reachable
from the startup fragment.

00:56:19.634 --> 00:56:22.167
And so it actually can push
resources automatically

00:56:22.167 --> 00:56:23.767
out into the different
fragments.

00:56:23.767 --> 00:56:26.701
So they're loaded only along
with the code that needs them.

00:56:26.701 --> 00:56:29.267
Thank you for that question.

00:56:29.267 --> 00:56:33.534
Glad I messed that one up.

00:56:33.534 --> 00:56:36.267
Uh, yes? Whomever.

00:56:36.267 --> 00:56:38.434
man: Okay, so the--
[clears throat]

00:56:38.434 --> 00:56:41.667
Obviously, as soon as we can
start debugging in any browser,

00:56:41.667 --> 00:56:43.367
we're gonna upgrade right away.

00:56:43.367 --> 00:56:45.033
That's pretty awesome.

00:56:45.033 --> 00:56:47.167
But I noticed that
console window

00:56:47.167 --> 00:56:49.501
that has an instance
for each browser.

00:56:49.501 --> 00:56:53.901
I mean, can we still run
in hosted mode

00:56:53.901 --> 00:56:55.734
with our own server?

00:56:55.734 --> 00:56:56.968
Johnson: Yes.
man: Okay.

00:56:56.968 --> 00:56:58.501
Johnson: Yes, definitely.
man: Cool. Awesome.

00:56:58.501 --> 00:57:00.834
Good improvement.
Johnson: Yes, you can.

00:57:00.834 --> 00:57:03.133
man: So the question is,
do you have any plans

00:57:03.133 --> 00:57:06.901
to have a different way
of organizing the layout

00:57:06.901 --> 00:57:08.400
instead of writing code?

00:57:08.400 --> 00:57:10.467
I had a quick look
at Android,

00:57:10.467 --> 00:57:12.634
and they have this XML
declaration

00:57:12.634 --> 00:57:15.000
of the positioning
of the widgets.

00:57:15.000 --> 00:57:18.100
Do you have some plan
of putting some work into it

00:57:18.100 --> 00:57:20.534
so that we don't have to build
the panels in Java and...

00:57:20.534 --> 00:57:23.501
Johnson: Yes. It's a little bit
further out in the pipeline,

00:57:23.501 --> 00:57:27.000
but you might have seen
a design doc on our wiki

00:57:27.000 --> 00:57:28.601
for something called
Declarative UI.

00:57:28.601 --> 00:57:30.334
It's now called UI Binder.

00:57:30.334 --> 00:57:32.868
But it is--it's an XML-based
declarative way

00:57:32.868 --> 00:57:36.634
of specifying all the same stuff
that you would do in code.

00:57:36.634 --> 00:57:40.334
man: And you have no timeline
on when this would be able

00:57:40.334 --> 00:57:41.534
to play around?

00:57:41.534 --> 00:57:43.501
Johnson: I mean,
I can't be trusted

00:57:43.501 --> 00:57:45.033
because I'm always the guy
saying, "Yeah,

00:57:45.033 --> 00:57:46.601
let's add it to 2.0!"

00:57:46.601 --> 00:57:49.234
But then, you know,
the product managers and so on,

00:57:49.234 --> 00:57:50.934
they don't like that.

00:57:50.934 --> 00:57:52.501
So I have to underpromise.

00:57:52.501 --> 00:57:54.033
Maybe--
hopefully overdeliver.

00:57:54.033 --> 00:57:57.434
But I can't really say that
it'll be ready for 2.0.

00:57:57.434 --> 00:58:00.801
But not too much longer.
It's in use at Google.

00:58:00.801 --> 00:58:04.167
In fact, you'll see--
If you go to a lot of GWT talks,

00:58:04.167 --> 00:58:08.567
you'll see examples of apps
that use that heavily already

00:58:08.567 --> 00:58:11.767
within Google, so...
Yes?

00:58:11.767 --> 00:58:13.767
man: Hi. The code splitting
stuff looks great.

00:58:13.767 --> 00:58:16.467
We've been really hurting
for the lack of it.

00:58:16.467 --> 00:58:18.400
The question I have is,

00:58:18.400 --> 00:58:20.400
you say that you build
a dependence graph.

00:58:20.400 --> 00:58:23.901
And so the thing that naturally
pops into my mind is

00:58:23.901 --> 00:58:28.534
how do I either avoid
or break those dependences?

00:58:28.534 --> 00:58:30.267
What kind of things
do I have to worry about?

00:58:30.267 --> 00:58:34.067
Johnson: Okay, so that is
exactly what the story

00:58:34.067 --> 00:58:35.968
of your compile is all about?
man: Mm-hmm.

00:58:35.968 --> 00:58:37.267
Johnson: So the story
of your compile,

00:58:37.267 --> 00:58:39.567
Reading Tea Leaves for
an Optimized Future talk,

00:58:39.567 --> 00:58:40.834
goes into that.

00:58:40.834 --> 00:58:42.367
It takes you step by step
through that scenario

00:58:42.367 --> 00:58:43.400
and how to solve it.

00:58:43.400 --> 00:58:46.167
man: Great. Thanks.
Johnson: Yeah.

00:58:46.167 --> 00:58:47.667
man: Hi.
Johnson: Hi.

00:58:47.667 --> 00:58:49.868
man: Does the CSS compiler
warn you

00:58:49.868 --> 00:58:52.767
if you write CSS
that doesn't actually get used,

00:58:52.767 --> 00:58:54.033
or the other way around?

00:58:54.033 --> 00:58:56.334
Reference CSS that you forgot
to put in?

00:58:56.334 --> 00:58:58.534
Johnson: Yes, that's another
thing I forgot to mention.

00:58:58.534 --> 00:59:00.467
If you organize your CSS
right,

00:59:00.467 --> 00:59:02.300
it's like dead CSS
elimination.

00:59:02.300 --> 00:59:04.634
man: Nice.
Johnson: Right.

00:59:04.634 --> 00:59:08.868
man: Hi, um, what's the timeline
for the 2.0 general release?

00:59:08.868 --> 00:59:10.467
Johnson: That's another one
of those things

00:59:10.467 --> 00:59:13.300
where I have made
bold proclamations in the past

00:59:13.300 --> 00:59:17.801
and gotten burned
because I was too optimistic.

00:59:17.801 --> 00:59:21.667
I really--I can't say,
but it will be--

00:59:21.667 --> 00:59:23.667
we would like to start
thinking about

00:59:23.667 --> 00:59:25.734
trying to get it out Q3.

00:59:25.734 --> 00:59:27.934
[laughter]
man: Okay, thanks.

00:59:27.934 --> 00:59:29.834
Johnson: So it's not, like,
a year out.

00:59:29.834 --> 00:59:32.300
So to be clear,
all this stuff is actually

00:59:32.300 --> 00:59:33.534
in the trunk right now.

00:59:33.534 --> 00:59:35.434
You could--
if you're sufficiently brave,

00:59:35.434 --> 00:59:37.467
you can check this out as
a version and run it yourself.

00:59:37.467 --> 00:59:40.734
In fact, Google projects
using GWT

00:59:40.734 --> 00:59:42.901
do run off the tip of trunk.

00:59:42.901 --> 00:59:46.767
So again, the apps that
you'll see today and tomorrow,

00:59:46.767 --> 00:59:50.701
I think you'll find
very compelling applications.

00:59:50.701 --> 00:59:53.334
These are all built
with the Bleeding Edge.

00:59:53.334 --> 00:59:54.767
Yes?

00:59:54.767 --> 00:59:56.133
man: When you were talking
about code splitting,

00:59:56.133 --> 00:59:59.267
you mentioned the example
of, say, a settings page.

00:59:59.267 --> 01:00:00.734
And it struck me that
one of the first things

01:00:00.734 --> 01:00:02.367
that a settings page
might want to do

01:00:02.367 --> 01:00:04.534
once the code is down
is go to the server

01:00:04.534 --> 01:00:06.200
and get all my settings.

01:00:06.200 --> 01:00:09.300
Is there any way
to package data

01:00:09.300 --> 01:00:10.968
with the code
and the code split

01:00:10.968 --> 01:00:12.400
to avoid that extra
round trip?

01:00:12.400 --> 01:00:14.067
Johnson:
That's a good question.

01:00:14.067 --> 01:00:15.400
It's probably one--

01:00:15.400 --> 01:00:17.601
We'll have a little more time
to talk about that

01:00:17.601 --> 01:00:20.100
if you come to the
Reading the Tea Leaves talk.

01:00:20.100 --> 01:00:21.834
Or maybe in the hallway.

01:00:21.834 --> 01:00:23.701
But not out of the question.

01:00:23.701 --> 01:00:25.033
You have to think about
cachability.

01:00:25.033 --> 01:00:28.100
If you mix code that doesn't
change over time

01:00:28.100 --> 01:00:29.501
with data that does--

01:00:29.501 --> 01:00:31.634
man: Yeah, but I mean the
first time you get that code...

01:00:31.634 --> 01:00:32.968
Johnson: Yeah, yeah,
potentially.

01:00:32.968 --> 01:00:35.167
So there might be some tricks
like that we can pull.

01:00:35.167 --> 01:00:36.467
But let's talk more.
man: Thanks.

01:00:36.467 --> 01:00:38.334
Johnson: We are out of time now,
guys, I'm sorry.

01:00:38.334 --> 01:00:39.567
If there are still
remaining questions,

01:00:39.567 --> 01:00:41.067
we'll catch you guys
out in the hallway.

01:00:41.067 --> 01:00:42.734
Thanks.

01:00:42.734 --> 01:00:44.467
[applause]

01:00:44.467 --> 01:00:47.701
And stick around
for Kelly's talk.

