WEBVTT
Kind: captions
Language: en

00:00:01.000 --> 00:00:01.133
Matt Papakipos:
Okay, let's get started.

00:00:01.133 --> 00:00:02.767
Can you hear me okay?

00:00:02.767 --> 00:00:05.534
Okay, first I'd like
to introduce the talk,

00:00:05.534 --> 00:00:08.234
and then myself
and my co-presenter.

00:00:08.234 --> 00:00:10.801
So we'll be talking today
about HTML5.

00:00:10.801 --> 00:00:12.934
As you saw from
this morning's keynote,

00:00:12.934 --> 00:00:15.000
HTML5 is a big focus for us
at Google

00:00:15.000 --> 00:00:16.767
for Google I/O this year.

00:00:16.767 --> 00:00:18.467
So I wanna talk
really specifically

00:00:18.467 --> 00:00:19.868
about some of the details,

00:00:19.868 --> 00:00:22.667
what we're doing specifically
in Chrome around HTML5.

00:00:22.667 --> 00:00:24.300
So my name is Matt Papakipos.

00:00:24.300 --> 00:00:27.267
I head up on the engineering
side the efforts

00:00:27.267 --> 00:00:31.868
to implement the HTML5 APIs
inside the Chromium code base.

00:00:31.868 --> 00:00:33.467
And that's the code base

00:00:33.467 --> 00:00:35.133
out of which we build
our Chrome browser,

00:00:35.133 --> 00:00:36.901
so it's very important to us.

00:00:36.901 --> 00:00:38.634
I'd like to also introduce
Ian Fette.

00:00:38.634 --> 00:00:42.934
Ian is the Product Manager
for the HTML5 work inside Chrome

00:00:42.934 --> 00:00:45.334
and many other aspects
of Chrome.

00:00:45.334 --> 00:00:47.667
Ian Fette: Thanks, Matt.

00:00:49.734 --> 00:00:51.367
Papakipos: I should also
mention we've got...

00:00:51.367 --> 00:00:54.300
questions for this talk
posted on Google Moderator,

00:00:54.300 --> 00:00:56.133
so you're welcome
to submit questions there,

00:00:56.133 --> 00:00:58.133
and we'll go through
some of those at the end.

00:00:58.133 --> 00:00:59.934
So I'll leave ample time
for questions

00:00:59.934 --> 00:01:02.934
both live and for Moderator
at the end of the talk.

00:01:05.200 --> 00:01:07.300
So what got us here?
What are we trying to do?

00:01:07.300 --> 00:01:08.901
So browsers
started a revolution

00:01:08.901 --> 00:01:10.534
that continues to this day.

00:01:10.534 --> 00:01:13.934
We've all seen this accelerating
trend for applications

00:01:13.934 --> 00:01:17.133
to move from desktop machines
into the web.

00:01:17.133 --> 00:01:21.133
This all began with Netscape,
right, way back.

00:01:21.133 --> 00:01:23.501
And initially,
as you all recall,

00:01:23.501 --> 00:01:26.200
the web was initially
quite static, right?

00:01:26.200 --> 00:01:28.567
You could go to a site.
You could read some stuff.

00:01:28.567 --> 00:01:30.601
People started adding
dynamic content

00:01:30.601 --> 00:01:33.133
initially by adding it
on the server side, right?

00:01:33.133 --> 00:01:35.601
So you could do some sort of
form fill out,

00:01:35.601 --> 00:01:37.868
do a post, get something
back from the server

00:01:37.868 --> 00:01:39.701
that was somewhat dynamic.

00:01:39.701 --> 00:01:42.200
But there's always that
server latency in the loop.

00:01:42.200 --> 00:01:44.300
And there were certain kinds
of dynamic stuff

00:01:44.300 --> 00:01:46.567
that were just infeasible
in that world.

00:01:46.567 --> 00:01:50.000
In '95, Netscape
introduced JavaScript,

00:01:50.000 --> 00:01:52.167
which was quite revolutionary
at the time, right?

00:01:52.167 --> 00:01:55.501
The notion that the web could
run code in the client side

00:01:55.501 --> 00:01:57.267
was a radical concept.

00:01:57.267 --> 00:01:59.300
And I think if we think
way back,

00:01:59.300 --> 00:02:00.868
we can remember
some of those

00:02:00.868 --> 00:02:02.467
early applications
of JavaScript.

00:02:02.467 --> 00:02:04.534
They look kind of comical now.

00:02:04.534 --> 00:02:06.534
They were JavaScript clocks.

00:02:06.534 --> 00:02:08.267
They were little things where,
you know,

00:02:08.267 --> 00:02:09.834
it would say,
"Hello. Type your name."

00:02:09.834 --> 00:02:12.434
You'd type your name
and it would say, "Hello, Matt."

00:02:12.434 --> 00:02:14.033
They look pretty lame today.

00:02:14.033 --> 00:02:16.501
But it's amazing to see
what's grown out of that

00:02:16.501 --> 00:02:18.601
in the years to come.

00:02:18.601 --> 00:02:20.200
The other side of the problem

00:02:20.200 --> 00:02:22.901
that got some significant
innovation in the late '90s

00:02:22.901 --> 00:02:25.634
was around network fetches.

00:02:25.634 --> 00:02:27.868
So initially,
there was XMLHTTP

00:02:27.868 --> 00:02:30.133
and then XMLHttpRequest

00:02:30.133 --> 00:02:32.300
which added the ability
for webapps to do

00:02:32.300 --> 00:02:34.467
asynchronous requests
to the server,

00:02:34.467 --> 00:02:36.400
get asynchronous data
coming back,

00:02:36.400 --> 00:02:39.067
which was the other sort of
missing piece of the puzzle.

00:02:39.067 --> 00:02:40.601
And again we saw
a bit of a lag

00:02:40.601 --> 00:02:43.267
between the introduction
of the feature and the apps.

00:02:43.267 --> 00:02:45.567
In this case, it wasn't
until a couple years later

00:02:45.567 --> 00:02:47.167
with Gmail that we saw

00:02:47.167 --> 00:02:49.467
some of the first AJAX style
apps really take off,

00:02:49.467 --> 00:02:52.601
apps that were doing lots of
JavaScript in a client,

00:02:52.601 --> 00:02:55.000
lots of asynchronous
network requests.

00:02:55.000 --> 00:02:57.167
And then with the advents
of Google Maps,

00:02:57.167 --> 00:02:59.467
we started adding graphics
into this whole equation,

00:02:59.467 --> 00:03:00.901
using JPEGs dynamically,

00:03:00.901 --> 00:03:02.901
moving them around
in the client side,

00:03:02.901 --> 00:03:04.267
scrolling them.

00:03:04.267 --> 00:03:05.701
And that's, at least for me,

00:03:05.701 --> 00:03:07.701
when this all started
to get quite interesting.

00:03:07.701 --> 00:03:09.467
'Cause I looked at the web
and said, "Wow.

00:03:09.467 --> 00:03:11.067
"It's starting to do graphics.

00:03:11.067 --> 00:03:14.033
It's starting to do real
client/server applications."

00:03:14.033 --> 00:03:15.767
Now we find ourselves
in a world

00:03:15.767 --> 00:03:20.634
where developers want
even more...

00:03:20.634 --> 00:03:22.434
more radical capabilities.

00:03:22.434 --> 00:03:24.968
So things like playing video
inside web applications

00:03:24.968 --> 00:03:27.133
seems like a mainstream
idea today.

00:03:27.133 --> 00:03:29.133
It certainly wasn't
ten years ago.

00:03:29.133 --> 00:03:31.400
There's lots of other devices

00:03:31.400 --> 00:03:34.033
your PCU would also like
to use for web applications.

00:03:34.033 --> 00:03:36.267
Microphone and camera
might sound a little odd,

00:03:36.267 --> 00:03:38.067
but if you're doing a video
conferencing application,

00:03:38.067 --> 00:03:39.734
that's a very natural thing
to want to do

00:03:39.734 --> 00:03:41.367
from a web application.

00:03:41.367 --> 00:03:42.501
For many of these,

00:03:42.501 --> 00:03:44.634
we're starting to see
browser plugins

00:03:44.634 --> 00:03:47.534
that allow you to do
some of these things.

00:03:47.534 --> 00:03:50.634
For example,
for Google Talk video

00:03:50.634 --> 00:03:52.667
we can do video conferencing
in Gmail,

00:03:52.667 --> 00:03:54.501
but we have to provide
a browser plugin

00:03:54.501 --> 00:03:56.634
and API plugin
to let you do that.

00:03:56.634 --> 00:03:57.868
It's cool, it does work,

00:03:57.868 --> 00:03:59.601
but it's not intrinsic
to the web itself.

00:03:59.601 --> 00:04:01.834
So that's what we're here
today to talk about.

00:04:01.834 --> 00:04:05.033
Other capabilities
people want in their webapps

00:04:05.033 --> 00:04:08.501
is better ability to control
file uploads,

00:04:08.501 --> 00:04:10.634
do multiple selections,
do drag and drop,

00:04:10.634 --> 00:04:12.300
things of that nature.

00:04:12.300 --> 00:04:14.601
Geolocation
is another big example.

00:04:14.601 --> 00:04:16.234
Phones started this,

00:04:16.234 --> 00:04:18.934
but we're seeing it move
into laptops as well.

00:04:18.934 --> 00:04:21.200
My computer moves around a lot.
I'd like to know where it is.

00:04:21.200 --> 00:04:24.267
I can offer you a better path
to a local pizza restaurant

00:04:24.267 --> 00:04:26.033
if I know where you are.

00:04:26.033 --> 00:04:27.968
Offline capabilities.

00:04:27.968 --> 00:04:31.501
Google got started in this with
Gears a couple of years ago.

00:04:31.501 --> 00:04:33.868
And we're very interested
in trying to figure out

00:04:33.868 --> 00:04:36.133
how can we make a webapp work
even when you're off line?

00:04:36.133 --> 00:04:38.767
How can we do syncing
capabilities for webapps?

00:04:38.767 --> 00:04:40.834
Apps like Gmail let you use
your email

00:04:40.834 --> 00:04:43.801
when you're on an airplane
and you have no conductivity.

00:04:43.801 --> 00:04:46.334
We're now seeing this move
into mainstream HTML5,

00:04:46.334 --> 00:04:47.834
and I'll talk about that
today.

00:04:47.834 --> 00:04:50.067
3D graphics--

00:04:50.067 --> 00:04:52.167
another area I'm very
passionate about is 3D.

00:04:52.167 --> 00:04:54.534
I also run a project
called O3D,

00:04:54.534 --> 00:04:56.567
and we're doing a tech talk
later today.

00:04:56.567 --> 00:04:58.167
O3D is a 3D graphics API.

00:04:58.167 --> 00:05:00.934
Again, as with Gears,
starting its life as a plugin,

00:05:00.934 --> 00:05:03.534
but we're expecting this to move
into the mainstream browsers

00:05:03.534 --> 00:05:05.334
and into the standards
over time.

00:05:05.334 --> 00:05:09.467
Audio--there's a lot left
to do in audio.

00:05:09.467 --> 00:05:11.200
There hasn't been a lot
of progress in this area,

00:05:11.200 --> 00:05:13.267
but there's many capabilities
your machine has

00:05:13.267 --> 00:05:15.701
in terms of doing positional
audio, multichannel audio,

00:05:15.701 --> 00:05:18.234
and mixing that the web really
doesn't take advantage of today

00:05:18.234 --> 00:05:20.467
that we think are gonna
be interesting for webapps

00:05:20.467 --> 00:05:22.868
over the next few years.

00:05:25.334 --> 00:05:27.000
So what's our goal, right?

00:05:27.000 --> 00:05:28.634
What's the end point
that we want to get to?

00:05:28.634 --> 00:05:32.067
The end point I want to get to
is if a native app can do it,

00:05:32.067 --> 00:05:34.234
a webapp
should be able to do it.

00:05:34.234 --> 00:05:37.067
There are definitely
some challenges here

00:05:37.067 --> 00:05:38.868
around security, privacy,

00:05:38.868 --> 00:05:42.334
all the things that we know
are important on the web today.

00:05:42.334 --> 00:05:45.601
But we can make the web much
more compelling and interesting

00:05:45.601 --> 00:05:47.267
if we can bring
these capabilities

00:05:47.267 --> 00:05:50.701
to the applications.

00:05:50.701 --> 00:05:53.334
The challenge is--
or the opportunity is

00:05:53.334 --> 00:05:56.000
to also do that in a way
that is still conducive

00:05:56.000 --> 00:05:57.501
to taking advantage of

00:05:57.501 --> 00:06:00.767
the very positive aspects
of the web today--

00:06:00.767 --> 00:06:02.901
the fact that I don't
have to install applications.

00:06:02.901 --> 00:06:04.734
The fact that
they're always updated.

00:06:04.734 --> 00:06:08.300
The fact that they're
integrated well with the cloud.

00:06:08.300 --> 00:06:09.734
They work well
when they're online.

00:06:09.734 --> 00:06:11.400
All these are great things
about the web

00:06:11.400 --> 00:06:13.634
we want to make sure
not to lose in the process.

00:06:13.634 --> 00:06:15.567
So the process we've been
going through at Google

00:06:15.567 --> 00:06:17.067
is to spend a lot of time

00:06:17.067 --> 00:06:19.267
talking to application
developers--that's you.

00:06:19.267 --> 00:06:21.767
So we'd like to have
a continuing dialogue with you

00:06:21.767 --> 00:06:25.033
about what you'd want to be
able to do from your webapps,

00:06:25.033 --> 00:06:27.400
figure out what native
applications people run,

00:06:27.400 --> 00:06:29.334
and figure out how can we move
those into the cloud,

00:06:29.334 --> 00:06:30.868
how can we move those
into the web?

00:06:30.868 --> 00:06:32.968
That's the way we think
about the problem.

00:06:32.968 --> 00:06:34.934
The next stage
is implementation,

00:06:34.934 --> 00:06:36.567
so Gears is an example
of that.

00:06:36.567 --> 00:06:38.100
O3D is an example of that.

00:06:38.100 --> 00:06:39.767
We're trying hard to innovate

00:06:39.767 --> 00:06:43.167
and create new APIs
that do new things

00:06:43.167 --> 00:06:44.868
and get them out there
in developers' hands

00:06:44.868 --> 00:06:47.133
as quickly as possible
so you can try them out...

00:06:47.133 --> 00:06:49.701
with the full expectation
that you'll want changes,

00:06:49.701 --> 00:06:51.601
you'll want new capabilities.

00:06:51.601 --> 00:06:53.100
We need to figure out
how useful they are.

00:06:53.100 --> 00:06:54.734
And as we start
to understand that,

00:06:54.734 --> 00:06:58.567
we work on integrating it
inside our browser itself

00:06:58.567 --> 00:07:00.467
and then work
on standardization

00:07:00.467 --> 00:07:03.033
as the way to get it
into other browsers as well.

00:07:03.033 --> 00:07:04.834
None of this works
if it's Chrome only.

00:07:04.834 --> 00:07:06.534
It's very important to us
that this happens

00:07:06.534 --> 00:07:07.901
in all the major browsers,

00:07:07.901 --> 00:07:10.767
and the key to that
is standardization.

00:07:12.400 --> 00:07:15.367
So canvas is one of
the great success stories

00:07:15.367 --> 00:07:18.400
with HTML5 so far.

00:07:18.400 --> 00:07:21.567
I think some of you saw this
in the keynote,

00:07:21.567 --> 00:07:24.367
but canvas basically gives you
the ability to,

00:07:24.367 --> 00:07:27.801
from JavaScript code
in your webapp,

00:07:27.801 --> 00:07:29.968
do direct rendering
to the screen.

00:07:29.968 --> 00:07:31.968
So you have
pixel-level control--

00:07:31.968 --> 00:07:34.000
you can draw arcs and lines
and text

00:07:34.000 --> 00:07:36.767
in a way that looks
a lot like you would

00:07:36.767 --> 00:07:39.000
in a native application
when you want to use graphics,

00:07:39.000 --> 00:07:42.367
using an API like GDI or WPF

00:07:42.367 --> 00:07:45.200
or any number of different
rendering libraries.

00:07:45.200 --> 00:07:48.200
So it's 2D graphics,
fully dynamic,

00:07:48.200 --> 00:07:50.200
callable from JavaScript.

00:07:50.200 --> 00:07:52.000
It's a surface on which
you can draw 2D images

00:07:52.000 --> 00:07:54.167
so you can identify
part of your window

00:07:54.167 --> 00:07:56.367
that you want to do
this rendering onto

00:07:56.367 --> 00:07:58.000
and then make calls
from JavaScript

00:07:58.000 --> 00:07:59.400
to do the rendering calls.

00:07:59.400 --> 00:08:01.467
Now, there are a lot of
interesting uses of this

00:08:01.467 --> 00:08:05.667
being demonstrated in the client
developer sandbox out there.

00:08:05.667 --> 00:08:08.434
Some great examples
are Bespin, for example,

00:08:08.434 --> 00:08:10.634
which is using canvas

00:08:10.634 --> 00:08:13.234
for a lot of the rendering
of the UI itself.

00:08:13.234 --> 00:08:16.267
I put a simple example
up in the slide here

00:08:16.267 --> 00:08:20.634
to give the feel for
what it looks like to do...

00:08:20.634 --> 00:08:23.434
to use canvas from JavaScript,
and it's quite simple.

00:08:23.434 --> 00:08:28.033
You locate the canvas object
in your HTML code

00:08:28.033 --> 00:08:29.467
and do getcontext.

00:08:29.467 --> 00:08:31.267
You now have a JavaScript
object that you can use

00:08:31.267 --> 00:08:32.868
to do 2D rendering.

00:08:32.868 --> 00:08:35.434
And now you just make
a series of calls on that object

00:08:35.434 --> 00:08:38.901
in order to render into
the rectangle on the screen.

00:08:38.901 --> 00:08:43.033
So fillrect will draw
a 50x50 rectangle

00:08:43.033 --> 00:08:45.667
positioned at (0,0)
in the coordinate system.

00:08:45.667 --> 00:08:48.868
We can draw rectangles,
we can draw arcs,

00:08:48.868 --> 00:08:50.267
we can draw text.

00:08:50.267 --> 00:08:51.434
So you have all the basic

00:08:51.434 --> 00:08:53.033
2D rendering capabilities
you need

00:08:53.033 --> 00:08:55.367
to do a bunch of interesting
applications.

00:08:58.067 --> 00:09:02.033
So let's jump into
a quick demo of canvas.

00:09:02.033 --> 00:09:04.100
Ian, do you want to talk
to this?

00:09:04.100 --> 00:09:05.234
Fette: Sure.

00:09:05.234 --> 00:09:07.434
So this demo in particular,

00:09:07.434 --> 00:09:09.267
and a number of demos
using canvas,

00:09:09.267 --> 00:09:11.667
are actually available
on Chrome Experiments,

00:09:11.667 --> 00:09:13.467
which you might have
seen earlier.

00:09:13.467 --> 00:09:16.434
One of my favorites
was actually done by

00:09:16.434 --> 00:09:19.634
a guy at Google named Dean,
and it's called The Monster.

00:09:19.634 --> 00:09:23.067
And it starts off very simple.
He's just drawing a square.

00:09:23.067 --> 00:09:25.133
But all of a sudden,
he's evolving this.

00:09:25.133 --> 00:09:28.767
He's using JavaScript
to control this,

00:09:28.767 --> 00:09:31.534
to rotate this box,
and all of sudden,

00:09:31.534 --> 00:09:33.067
it starts getting
more complex.

00:09:33.067 --> 00:09:35.167
It starts splitting up
into a bunch of polygons.

00:09:35.167 --> 00:09:36.801
It grows arms.

00:09:36.801 --> 00:09:39.534
And this thing just gets
amazingly complex.

00:09:39.534 --> 00:09:41.901
But the cool part is,
it's all in JavaScript.

00:09:41.901 --> 00:09:43.868
This looks like, you know,

00:09:43.868 --> 00:09:46.200
something that I would find
in a 3D screensaver.

00:09:46.200 --> 00:09:51.367
This is not a simple, you know,
fill rectangle 50x50.

00:09:51.367 --> 00:09:53.534
This is incredibly complex.

00:09:53.534 --> 00:09:54.901
But if you look at the source,

00:09:54.901 --> 00:09:57.300
it's all just
a bunch of rectangles,

00:09:57.300 --> 00:10:00.234
it's all just a bunch
of JavaScript API calls.

00:10:00.234 --> 00:10:05.100
So here we're providing
a very basic, fundamental API,

00:10:05.100 --> 00:10:07.367
and people are able
to build on top of that

00:10:07.367 --> 00:10:09.501
and do incredibly
complicated things,

00:10:09.501 --> 00:10:12.534
which I think is the most
exciting part.

00:10:12.534 --> 00:10:14.667
Papakipos: Thank you.

00:10:18.133 --> 00:10:20.400
Another area
that we've been working on

00:10:20.400 --> 00:10:22.200
is local storage.

00:10:22.200 --> 00:10:26.467
So in general, this is to
support offline applications--

00:10:26.467 --> 00:10:28.534
so applications that want to
work when you're on the airplane

00:10:28.534 --> 00:10:29.968
when you're in airplane mode,

00:10:29.968 --> 00:10:32.434
when you're in an area
with bad reception

00:10:32.434 --> 00:10:34.133
and you don't have Wi-Fi
available.

00:10:34.133 --> 00:10:37.000
So it's a way to store data
client side.

00:10:37.000 --> 00:10:39.868
So it gives you access
to the local disc

00:10:39.868 --> 00:10:42.634
so that you can store
your offline email,

00:10:42.634 --> 00:10:45.000
you can store images
that you want to work with--

00:10:45.000 --> 00:10:46.901
whatever the webapp
wants to do.

00:10:46.901 --> 00:10:49.234
And the cool thing is,
since this is an API,

00:10:49.234 --> 00:10:50.701
it's really up to your
application

00:10:50.701 --> 00:10:53.367
to figure out how you want
to use offline capabilities.

00:10:53.367 --> 00:10:55.334
So you should look at it
from the point of view

00:10:55.334 --> 00:10:56.901
of, well,
what is my application?

00:10:56.901 --> 00:10:58.501
Is it a photo editing
application?

00:10:58.501 --> 00:11:02.501
Is it an email application?
Is it a social application?

00:11:02.501 --> 00:11:04.100
And figure out what are
the aspects of that

00:11:04.100 --> 00:11:06.167
that make sense to do
while you're offline.

00:11:06.167 --> 00:11:07.534
And certainly, for Gmail,
if you're offline,

00:11:07.534 --> 00:11:09.934
writing email while offline,
reading email

00:11:09.934 --> 00:11:12.033
are perfectly sensible
things to do.

00:11:12.033 --> 00:11:14.567
And local store provides
the mechanism for doing that.

00:11:14.567 --> 00:11:17.400
So there's two APIs--
the database API,

00:11:17.400 --> 00:11:20.934
which is basically
a SQLite interface

00:11:20.934 --> 00:11:22.934
that gives you
an SQL interface

00:11:22.934 --> 00:11:25.167
to do inserts and deletes

00:11:25.167 --> 00:11:29.067
and lookups inside
a SQL database

00:11:29.067 --> 00:11:31.934
stored on
the local computer.

00:11:31.934 --> 00:11:34.501
The other one
is the structured storage API.

00:11:34.501 --> 00:11:36.167
This is what's called
local store,

00:11:36.167 --> 00:11:39.367
which is a somewhat simpler,
easier-to-use API

00:11:39.367 --> 00:11:41.901
that gives you effectively
a persistent hash table.

00:11:41.901 --> 00:11:43.868
So from your JavaScript code,

00:11:43.868 --> 00:11:46.100
you can store things,
key-value pairs

00:11:46.100 --> 00:11:47.534
from your webapp.

00:11:47.534 --> 00:11:50.067
When you do that,
if you then fetch them later

00:11:50.067 --> 00:11:52.367
from your same webapp,

00:11:52.367 --> 00:11:54.067
whether you're online
or offline,

00:11:54.067 --> 00:11:55.467
you get the same values
back.

00:11:55.467 --> 00:11:57.567
So basically, a persistent
hash table that you can use

00:11:57.567 --> 00:11:59.367
to store data
on the local machine

00:11:59.367 --> 00:12:00.767
and get it reliably,

00:12:00.767 --> 00:12:03.400
whether you're connected
to the network or not.

00:12:03.400 --> 00:12:06.467
This is something
we pioneered with Gears,

00:12:06.467 --> 00:12:08.801
originally,
a couple of years ago.

00:12:08.801 --> 00:12:11.400
And the cool part
is we've been successful

00:12:11.400 --> 00:12:13.801
over the last year
of getting it standardized

00:12:13.801 --> 00:12:15.334
by the W3C.

00:12:15.334 --> 00:12:17.734
So it's now part of
the web standards themselves.

00:12:17.734 --> 00:12:19.634
And so we're hard at work
right now

00:12:19.634 --> 00:12:22.434
integrating this into Chromium
and Chrome.

00:12:22.434 --> 00:12:24.868
And some of the other browsers,
in fact, ship this already.

00:12:24.868 --> 00:12:26.133
For example,

00:12:26.133 --> 00:12:30.234
Safari browser currently
supports the database API fully.

00:12:30.234 --> 00:12:32.634
So to give you a feel
for what it looks like,

00:12:32.634 --> 00:12:34.634
I put a code sample up here.

00:12:34.634 --> 00:12:38.534
So here we have--
we're doing...

00:12:38.534 --> 00:12:40.934
we're fundamentally
just executing an SQL statement.

00:12:40.934 --> 00:12:42.667
So if you're familiar
with SQL,

00:12:42.667 --> 00:12:45.334
this is the language
or the syntax you use

00:12:45.334 --> 00:12:47.834
to do modifications
of the database,

00:12:47.834 --> 00:12:50.100
whether to look up or store
or whatever.

00:12:50.100 --> 00:12:52.667
So in this case we're doing
executeSql.

00:12:52.667 --> 00:12:54.133
We're doing a Select,

00:12:54.133 --> 00:12:56.634
and a Select in SQL lingo
is just a lookup.

00:12:56.634 --> 00:12:58.701
So if you look up SQL syntax,

00:12:58.701 --> 00:13:00.901
that's how you look something up
in the database.

00:13:00.901 --> 00:13:03.434
So it's saying fetch all fields
from MyTable.

00:13:03.434 --> 00:13:05.834
And SQL
is quite a flexible format.

00:13:05.834 --> 00:13:09.767
You can do searches with it
and find things that match.

00:13:09.767 --> 00:13:12.801
It's quite a sophisticated way
to manage the local database.

00:13:12.801 --> 00:13:14.901
The good news is if you're
familiar with doing

00:13:14.901 --> 00:13:17.868
server-side web applications,

00:13:17.868 --> 00:13:19.968
you're already using
a database of some kind,

00:13:19.968 --> 00:13:21.767
and in fact, you're probably
using SQL.

00:13:21.767 --> 00:13:23.901
So it's actually quite easy
to learn this

00:13:23.901 --> 00:13:28.767
if you're familiar with
server-side webapp development.

00:13:31.534 --> 00:13:33.901
The best demo here
of local store

00:13:33.901 --> 00:13:36.501
that I can think of
is probably Gmail offline.

00:13:36.501 --> 00:13:38.133
It's worth giving that a try

00:13:38.133 --> 00:13:40.234
if you want to get a feel
for sort of what it feels like

00:13:40.234 --> 00:13:42.601
to use an offline
capable app.

00:13:42.601 --> 00:13:44.701
And the interesting demo
is just turn it on,

00:13:44.701 --> 00:13:46.501
wait for it
to sync your email,

00:13:46.501 --> 00:13:48.501
then turn off all your
network connections,

00:13:48.501 --> 00:13:50.100
open your Gmail,
and it's still there,

00:13:50.100 --> 00:13:52.701
and it still works.

00:13:56.267 --> 00:13:57.701
Another interesting aspect

00:13:57.701 --> 00:14:01.067
of the offline application
problem is syncing.

00:14:01.067 --> 00:14:03.400
I just mentioned it.

00:14:03.400 --> 00:14:05.667
We all know that
you've gotta be really careful

00:14:05.667 --> 00:14:08.534
when you write web applications
not to lock up the browser.

00:14:08.534 --> 00:14:11.167
If I write a while (1) loop
in JavaScript,

00:14:11.167 --> 00:14:13.934
the whole thing locks up,
it stops refreshing the screen,

00:14:13.934 --> 00:14:16.234
bad things happen,
users are unhappy.

00:14:16.234 --> 00:14:18.067
This is quite a challenge

00:14:18.067 --> 00:14:19.701
when you're doing
offline applications

00:14:19.701 --> 00:14:22.067
because if I turn on
offline in Gmail,

00:14:22.067 --> 00:14:25.033
I may need to sync, you know,
200 megabytes of email

00:14:25.033 --> 00:14:26.701
if I've never synced before.

00:14:26.701 --> 00:14:28.868
I don't want to just do that
inside a loop

00:14:28.868 --> 00:14:30.367
in my main JavaScript thread,

00:14:30.367 --> 00:14:31.934
or I'm gonna lock up
the browser.

00:14:31.934 --> 00:14:34.868
So workers are a nice solution
to this problem.

00:14:34.868 --> 00:14:36.501
They give you the capability

00:14:36.501 --> 00:14:39.334
to run a background thread
effectively.

00:14:39.334 --> 00:14:43.200
So if you look at desktop
operating systems,

00:14:43.200 --> 00:14:45.701
they have threads,
and they have processes, right?

00:14:45.701 --> 00:14:47.767
They have ways that you can,
in your application,

00:14:47.767 --> 00:14:50.734
express concurrency through
additional threads of control.

00:14:50.734 --> 00:14:52.801
Fundamentally,
that's what workers are.

00:14:52.801 --> 00:14:55.767
They give you the ability
to start up a background thread

00:14:55.767 --> 00:14:57.334
called the worker,

00:14:57.334 --> 00:15:00.934
and it runs in parallel
with your main display thread,

00:15:00.934 --> 00:15:02.667
which means
in the background thread,

00:15:02.667 --> 00:15:04.400
you can do as much IO
as you want

00:15:04.400 --> 00:15:05.901
and you don't have to
worry about

00:15:05.901 --> 00:15:08.234
locking up
the browser display.

00:15:08.234 --> 00:15:10.834
So workers are quite rich.

00:15:10.834 --> 00:15:13.267
There's there different
flavors of workers

00:15:13.267 --> 00:15:17.000
that are in process
and are...at various points

00:15:17.000 --> 00:15:19.467
of specification
and standardization.

00:15:19.467 --> 00:15:21.167
The most mature of them
right now

00:15:21.167 --> 00:15:23.534
are dedicated
and shared workers.

00:15:23.534 --> 00:15:25.167
So dedicated workers

00:15:25.167 --> 00:15:28.200
are effectively bound
to a single tab.

00:15:28.200 --> 00:15:29.901
So what this means is

00:15:29.901 --> 00:15:31.767
if I have a browser
with multiple tabs open

00:15:31.767 --> 00:15:33.534
or multiple windows open,

00:15:33.534 --> 00:15:35.601
if I start a worker up
in that tab,

00:15:35.601 --> 00:15:37.601
that worker's specific
to that one tab.

00:15:37.601 --> 00:15:40.634
So if I have multiple
Gmail.com tabs open,

00:15:40.634 --> 00:15:42.501
this worker's specific
to this tab

00:15:42.501 --> 00:15:44.734
and the other one
can start a separate tab.

00:15:44.734 --> 00:15:47.801
There's a different flavor
of these called shared workers.

00:15:47.801 --> 00:15:49.567
And what this means is

00:15:49.567 --> 00:15:51.734
I have one background
worker thread

00:15:51.734 --> 00:15:54.534
that I want to share between
all the tabs at my domain.

00:15:54.534 --> 00:15:56.901
So if I have multiple tabs
open at Gmail.com,

00:15:56.901 --> 00:15:59.567
shared worker,
if you start that one worker up,

00:15:59.567 --> 00:16:02.334
it's shared by all of the tabs
at that domain.

00:16:02.334 --> 00:16:03.601
So a good example

00:16:03.601 --> 00:16:05.501
of why you would want
to use a shared worker

00:16:05.501 --> 00:16:07.300
is something like
syncing your email, right?

00:16:07.300 --> 00:16:10.300
But if I have multiple tabs
open at the same email address

00:16:10.300 --> 00:16:11.834
and the same account,

00:16:11.834 --> 00:16:13.968
I'd just as soon have them
share the syncing

00:16:13.968 --> 00:16:18.100
rather than sync separately,
which would make no sense.

00:16:18.100 --> 00:16:20.767
The last category of them--
and this is the newest ones

00:16:20.767 --> 00:16:22.701
not quite finished with
standardization yet--

00:16:22.701 --> 00:16:24.734
is what we call
persistent workers.

00:16:24.734 --> 00:16:27.300
The idea here is there are
some things you'd like to do

00:16:27.300 --> 00:16:28.701
in web applications

00:16:28.701 --> 00:16:32.100
where you'd like background
execution ability,

00:16:32.100 --> 00:16:35.100
but you want to run it even
when the browser isn't running.

00:16:35.100 --> 00:16:38.100
And a great example here
is Gmail itself, right?

00:16:38.100 --> 00:16:39.901
I would love to have
my Gmail sync,

00:16:39.901 --> 00:16:41.300
even if the browser's
not running,

00:16:41.300 --> 00:16:44.100
even if Gmail's not
up in a tab right now.

00:16:44.100 --> 00:16:46.767
I'd like to make sure
it's synced all the time.

00:16:46.767 --> 00:16:48.801
Another good example
is notifications.

00:16:48.801 --> 00:16:51.300
There's certain applications
like email

00:16:51.300 --> 00:16:53.701
where you'd love to be notified
when you get email

00:16:53.701 --> 00:16:56.100
even if you're not
running email right now.

00:16:56.100 --> 00:16:57.501
So persistent workers

00:16:57.501 --> 00:16:59.133
are still in
a somewhat experimental stage,

00:16:59.133 --> 00:17:01.167
but there's an ongoing
implementation effort

00:17:01.167 --> 00:17:03.968
in the Chromium and WebKit
code base

00:17:03.968 --> 00:17:06.767
to try to bring this out.

00:17:06.767 --> 00:17:09.801
And the development of this
is ongoing in WebKit

00:17:09.801 --> 00:17:11.367
and Google Chrome.

00:17:11.367 --> 00:17:14.133
So some versions of this
work in Safari now.

00:17:14.133 --> 00:17:15.501
It works in Gears now.

00:17:15.501 --> 00:17:18.367
Dedicated and shared workers
work in Gears.

00:17:18.367 --> 00:17:20.767
And we're working in Chromium
and WebKit

00:17:20.767 --> 00:17:23.901
on persistent worker
implementation as well.

00:17:28.601 --> 00:17:31.100
Okay. Application cache.

00:17:31.100 --> 00:17:34.267
So the last piece of the puzzle
for offline capable applications

00:17:34.267 --> 00:17:35.467
is appcache.

00:17:35.467 --> 00:17:38.033
The problem that appcache solves
is, you know,

00:17:38.033 --> 00:17:39.901
picture yourself
going in the airplane.

00:17:39.901 --> 00:17:41.834
You've got no internet
connectivity.

00:17:41.834 --> 00:17:43.601
You type in Gmail.com.

00:17:43.601 --> 00:17:46.601
Well, you're gonna get
a server not found error

00:17:46.601 --> 00:17:48.300
'cause you're not
on the network.

00:17:48.300 --> 00:17:50.200
So appcache
solves this problem.

00:17:50.200 --> 00:17:51.834
Appcache provides a mechanism

00:17:51.834 --> 00:17:54.601
where your application
can create a manifest file

00:17:54.601 --> 00:17:56.968
where you specify--
these are the URLs

00:17:56.968 --> 00:17:59.434
that I want to have access to
when I'm offline.

00:17:59.434 --> 00:18:01.133
So you literally
specify a list of

00:18:01.133 --> 00:18:04.267
these are all the URLs
at Gmail.com,

00:18:04.267 --> 00:18:05.934
or whatever your domain is,

00:18:05.934 --> 00:18:08.567
where these are the URLs I want
to access when I'm offline.

00:18:08.567 --> 00:18:10.801
Appcache then syncs those
for you

00:18:10.801 --> 00:18:12.634
so you have a local copy
on the machine,

00:18:12.634 --> 00:18:15.501
and thereafter,
once you've enabled this,

00:18:15.501 --> 00:18:17.701
if it finds itself
not in the network

00:18:17.701 --> 00:18:19.934
and you try to fetch
a specific URL,

00:18:19.934 --> 00:18:22.734
it'll fetch the version
off the local disc.

00:18:22.734 --> 00:18:25.400
So this can include
your HTML content,

00:18:25.400 --> 00:18:27.434
it can include
your JavaScript content,

00:18:27.434 --> 00:18:29.434
and it can include JPEGs

00:18:29.434 --> 00:18:32.167
so you can basically sort of
freeze-dry your application

00:18:32.167 --> 00:18:33.701
on your local machine

00:18:33.701 --> 00:18:38.567
and then fetch it
as if you were on the network.

00:18:38.567 --> 00:18:41.033
Again, the key to how this works
is this manifest file,

00:18:41.033 --> 00:18:43.868
and what that means is
that you have full control

00:18:43.868 --> 00:18:45.868
over which parts of your
application are accessible

00:18:45.868 --> 00:18:47.501
while offline.

00:18:47.501 --> 00:18:48.968
There may be parts
of your application

00:18:48.968 --> 00:18:50.901
that don't make sense to do
while you're offline.

00:18:50.901 --> 00:18:53.601
For example, searching
a big database backend

00:18:53.601 --> 00:18:55.200
may not be feasible
when you're offline,

00:18:55.200 --> 00:18:57.300
so you can decide
that parts of your application

00:18:57.300 --> 00:18:59.234
are cached and parts of it
are not cached--

00:18:59.234 --> 00:19:01.901
both statically
in the manifest file

00:19:01.901 --> 00:19:03.534
or you can dynamically
add things

00:19:03.534 --> 00:19:06.701
to that list
of cached entities.

00:19:06.701 --> 00:19:09.000
This is implemented
in WebKit today.

00:19:09.000 --> 00:19:11.601
It works in Safari today.

00:19:11.601 --> 00:19:13.501
We have it working in Gears

00:19:13.501 --> 00:19:16.300
and then implementation
in Chromium is ongoing,

00:19:16.300 --> 00:19:18.934
so we're most of the way
through implementation of this

00:19:18.934 --> 00:19:21.534
in Chrome itself.

00:19:23.300 --> 00:19:24.701
Video.

00:19:24.701 --> 00:19:26.834
So moving
out of the offline arena

00:19:26.834 --> 00:19:28.767
into some of the newer areas,

00:19:28.767 --> 00:19:30.300
video is one
that we're very excited about.

00:19:30.300 --> 00:19:32.701
So we recently launched this
in Chrome,

00:19:32.701 --> 00:19:34.367
in the dev channel of Chrome.

00:19:34.367 --> 00:19:36.000
So the sort of experimental
builds of Chrome

00:19:36.000 --> 00:19:37.901
now have video tag support.

00:19:37.901 --> 00:19:40.167
The problem this is solving
is sort of

00:19:40.167 --> 00:19:42.067
how do I play video
on my website

00:19:42.067 --> 00:19:44.667
and do it in a way
that's intrinsic to the web?

00:19:44.667 --> 00:19:46.400
So what's neat about
the video tag is

00:19:46.400 --> 00:19:48.734
without using
any plugins at all,

00:19:48.734 --> 00:19:50.801
I can create a web page

00:19:50.801 --> 00:19:53.634
where I just create
a simple video tag--

00:19:53.634 --> 00:19:56.367
so I said
video src=video.mp4,

00:19:56.367 --> 00:19:57.901
position it where I want it,

00:19:57.901 --> 00:20:00.467
and then there's video playing
at that part of my web page.

00:20:00.467 --> 00:20:03.267
So putting video
in your web page

00:20:03.267 --> 00:20:06.067
becomes as simple as putting
an image in your web page.

00:20:06.067 --> 00:20:08.567
Today to put an image in,
you put an image tag,

00:20:08.567 --> 00:20:10.601
you say where you want
the JPEG, you're done.

00:20:10.601 --> 00:20:12.467
Video now becomes that simple.

00:20:12.467 --> 00:20:14.834
There are built-in
playback controls,

00:20:14.834 --> 00:20:18.367
so it comes with a stop
and a pause and a play button.

00:20:18.367 --> 00:20:21.701
And there are controls
that you can use from HTML

00:20:21.701 --> 00:20:23.667
or from your
dynamic JavaScript

00:20:23.667 --> 00:20:25.501
to turn the controls
on or off,

00:20:25.501 --> 00:20:26.968
depending on whether
you want to use

00:20:26.968 --> 00:20:28.100
an alternate control
representation,

00:20:28.100 --> 00:20:29.501
you want built-in controls--

00:20:29.501 --> 00:20:33.634
it's fully under your control
as the web developer.

00:20:33.634 --> 00:20:36.567
There's also full script
control over the video itself,

00:20:36.567 --> 00:20:40.067
so if you want to control
when the video starts

00:20:40.067 --> 00:20:41.968
or what happens
when it finishes,

00:20:41.968 --> 00:20:44.400
you can set up callbacks,
you can trigger play,

00:20:44.400 --> 00:20:46.567
you can change video streams.

00:20:46.567 --> 00:20:49.334
There's quite a flexible
JavaScript API.

00:20:49.334 --> 00:20:51.968
So Chrome--for Chrome
what we've done

00:20:51.968 --> 00:20:54.601
is we support
the MP4 container

00:20:54.601 --> 00:20:59.901
with H.264 video decoder
and an AAC audio decoder.

00:20:59.901 --> 00:21:04.968
So some nice, commonly
supported formats built in,

00:21:04.968 --> 00:21:08.167
and the Chrome dev channel
will be making their way out

00:21:08.167 --> 00:21:11.167
through to all
the Chrome users very soon.

00:21:11.167 --> 00:21:14.367
There's also a set of formats
that Apple currently supports.

00:21:14.367 --> 00:21:18.200
So Safari has got
great support for video,

00:21:18.200 --> 00:21:19.801
and we're excited
to see this moving

00:21:19.801 --> 00:21:21.834
into a bunch of browsers.

00:21:21.834 --> 00:21:26.567
The other codec set
that Chrome supports

00:21:26.567 --> 00:21:29.567
is an Ogg package
with Theora and Vorbis decoders.

00:21:29.567 --> 00:21:33.567
So we've got both
a traditional H264,

00:21:33.567 --> 00:21:35.767
the same format
that we use on YouTube,

00:21:35.767 --> 00:21:37.567
available today,

00:21:37.567 --> 00:21:41.167
and then there's also
a full open source code stack

00:21:41.167 --> 00:21:44.367
for an IP free stack
for doing it as well,

00:21:44.367 --> 00:21:48.167
for Theora and Vorbis.

00:21:48.167 --> 00:21:49.767
Uh...okay.

00:21:49.767 --> 00:21:53.167
So let's do a demo really quick
of video.

00:21:53.167 --> 00:21:57.167
It's fun to give video demos,
'cause they are just cool.

00:21:57.167 --> 00:21:59.767
Fette: Great.
So as Matt said,

00:21:59.767 --> 00:22:02.701
video is actually
extremely simple to use.

00:22:02.701 --> 00:22:04.601
One of the...
you know, I like to say

00:22:04.601 --> 00:22:07.033
it's as simple as putting
an image on a tag, on a page.

00:22:07.033 --> 00:22:11.434
So I want to actually
demo that.

00:22:11.434 --> 00:22:15.968
What I have right here
is a video on a page.

00:22:15.968 --> 00:22:17.667
It's simple.
It's a simple video.

00:22:17.667 --> 00:22:19.801
It's a simple page.
[light music playing]

00:22:19.801 --> 00:22:23.033
And you can see that
the video is playing.

00:22:23.033 --> 00:22:26.067
If I hover over it,
I see I've got--

00:22:26.067 --> 00:22:28.000
Papakipos: Just gonna
kill the audio.

00:22:28.000 --> 00:22:29.634
Fette: Thank you.
If I hover over it,

00:22:29.634 --> 00:22:31.000
I've got the default controls.

00:22:31.000 --> 00:22:33.801
I didn't have to build these.
They came for free.

00:22:33.801 --> 00:22:37.400
I've got pause over here.
I've got a little slider.

00:22:37.400 --> 00:22:40.667
And I can mess with the volume
settings if I want.

00:22:40.667 --> 00:22:42.501
And to show you
how simple this is,

00:22:42.501 --> 00:22:45.801
I want to show you
the source code for this page.

00:22:45.801 --> 00:22:47.968
Can make this a little bigger.

00:22:47.968 --> 00:22:49.501
Papakipos: As it should be.
It's tiny.

00:22:49.501 --> 00:22:51.667
Fette: Yes. It's very tiny.

00:22:51.667 --> 00:22:54.534
All I have to do is just
put in the video tag,

00:22:54.534 --> 00:22:56.434
point to my video,

00:22:56.434 --> 00:22:58.868
and I just put in two
optional attributes here.

00:22:58.868 --> 00:23:01.033
Controls gives me
those default controls

00:23:01.033 --> 00:23:02.868
that you saw,

00:23:02.868 --> 00:23:05.501
and autoplay makes the video
play as soon as it's loaded.

00:23:05.501 --> 00:23:07.100
Dead simple.

00:23:07.100 --> 00:23:08.667
There's some
alternate text here

00:23:08.667 --> 00:23:10.667
in case your video doesn't--
excuse me--

00:23:10.667 --> 00:23:12.868
in case your browser
doesn't support video,

00:23:12.868 --> 00:23:14.400
and that's it.

00:23:14.400 --> 00:23:16.534
If you want, you can make
this more complicated.

00:23:16.534 --> 00:23:18.100
You can script it.

00:23:18.100 --> 00:23:20.200
You can change
the playback speed.

00:23:20.200 --> 00:23:22.300
There's all sorts of things
you can do,

00:23:22.300 --> 00:23:26.567
but if you want to be
dead simple, you can.

00:23:26.567 --> 00:23:28.801
Papakipos: Cool. Thank you.

00:23:33.701 --> 00:23:35.701
Another big area
we've been working on

00:23:35.701 --> 00:23:37.300
is rich text editing.

00:23:37.300 --> 00:23:40.667
So...many of you have
tried this, I'm sure,

00:23:40.667 --> 00:23:42.834
and spent a lot of time
working on rich text.

00:23:42.834 --> 00:23:44.734
Rich text today on the web
is quite hard.

00:23:44.734 --> 00:23:46.834
What I mean by
rich text editing is,

00:23:46.834 --> 00:23:49.067
you know,
having a text entry field

00:23:49.067 --> 00:23:50.601
where the user
can look at text

00:23:50.601 --> 00:23:53.200
which is rich in the sense
of having bold and italics

00:23:53.200 --> 00:23:57.133
and fonts
and different point sizes,

00:23:57.133 --> 00:23:59.133
all the things that
we're accustomed to expecting

00:23:59.133 --> 00:24:01.534
out of modern
document systems.

00:24:01.534 --> 00:24:04.400
Well, the only thing really
built into the web here today

00:24:04.400 --> 00:24:08.267
is text boxes, which are
very lean and mean, right,

00:24:08.267 --> 00:24:11.834
no control over fonts or bold
or italic or any of that.

00:24:11.834 --> 00:24:14.133
The web, for a long time,
has had this capability

00:24:14.133 --> 00:24:15.567
called contentEditable

00:24:15.567 --> 00:24:17.968
where you can specify
at a tag level

00:24:17.968 --> 00:24:20.567
that a certain sub-tree
of JavaScript--I'm sorry--

00:24:20.567 --> 00:24:24.067
of HTML is to be editable
in the browser window.

00:24:24.067 --> 00:24:26.067
The problem with this
is the implementations

00:24:26.067 --> 00:24:28.734
have been wildly inconsistent,
as many of you know.

00:24:28.734 --> 00:24:31.334
So how certain tags behave

00:24:31.334 --> 00:24:33.534
when they're in
a contentEditable region

00:24:33.534 --> 00:24:35.467
changes dramatically
between browsers,

00:24:35.467 --> 00:24:37.801
whether they support selections
in copy and paste

00:24:37.801 --> 00:24:39.434
varies dramatically.

00:24:39.434 --> 00:24:41.634
What this means for us at Google
is that in Google

00:24:41.634 --> 00:24:45.534
when we do an application
like...like Google documents

00:24:45.534 --> 00:24:48.400
where we let you edit text
in a rich text format,

00:24:48.400 --> 00:24:51.634
we're using contentEditable,
but we also have to download

00:24:51.634 --> 00:24:53.534
200 kilobytes
of JavaScript code

00:24:53.534 --> 00:24:56.067
to handle
all the browser differences

00:24:56.067 --> 00:24:59.434
that are entailed from these
implementation differences

00:24:59.434 --> 00:25:01.734
and how contentEditable
is implemented

00:25:01.734 --> 00:25:03.033
in different browsers.

00:25:03.033 --> 00:25:06.033
So 200 kilobytes of code
may not sound like a lot,

00:25:06.033 --> 00:25:07.601
but that's a big deal,
right?

00:25:07.601 --> 00:25:09.834
It's a big deal if you're
running this thing on a phone

00:25:09.834 --> 00:25:11.434
or you're running
in a bad network connection

00:25:11.434 --> 00:25:12.701
or in a part of the world

00:25:12.701 --> 00:25:14.834
that has very slow
internet connectivity.

00:25:14.834 --> 00:25:16.734
And even for the rest of us,
with a, you know,

00:25:16.734 --> 00:25:18.634
right here with
a good network connection,

00:25:18.634 --> 00:25:19.868
it adds latency, right?

00:25:19.868 --> 00:25:21.434
This is adding latency
to page loads.

00:25:21.434 --> 00:25:23.834
It's kind of crazy that
when I go to Google Docs

00:25:23.834 --> 00:25:25.634
and open a document,
I have to spend time

00:25:25.634 --> 00:25:29.434
downloading 200 kilobytes
of JavaScript code

00:25:29.434 --> 00:25:31.434
just to deal with
browser differences

00:25:31.434 --> 00:25:33.434
and rich text editing.

00:25:33.434 --> 00:25:35.634
So we're very excited
about this area,

00:25:35.634 --> 00:25:38.734
and we're doing quite a bit
of work in it right now.

00:25:38.734 --> 00:25:41.234
A lot of the work right now
is in specification.

00:25:41.234 --> 00:25:43.033
The weakness
of contentEditable

00:25:43.033 --> 00:25:44.834
has always been
that the spec has been weak,

00:25:44.834 --> 00:25:46.234
and this is why
the implementations

00:25:46.234 --> 00:25:47.634
are all so different.

00:25:47.634 --> 00:25:50.133
So we're working quite a bit
right now to spec out

00:25:50.133 --> 00:25:51.834
with the W3C--

00:25:51.834 --> 00:25:54.701
a better spec for exactly
how should contentEditable work,

00:25:54.701 --> 00:25:57.434
how do we spec it in a way
where we have built-in support

00:25:57.434 --> 00:26:01.100
for cut and paste,
for good support for selections,

00:26:01.100 --> 00:26:04.701
for a consistent set of fonts
and bold and italics

00:26:04.701 --> 00:26:07.067
and all the things
that we make sense--

00:26:07.067 --> 00:26:08.701
that we expect in there?

00:26:08.701 --> 00:26:10.501
I mentioned exec command
in here.

00:26:10.501 --> 00:26:13.901
This is the ability to,
once the users made a selection,

00:26:13.901 --> 00:26:15.701
make it bold,
make it italic.

00:26:15.701 --> 00:26:17.434
This is an example
of one of the areas

00:26:17.434 --> 00:26:19.901
that's very inconsistent
between browsers right now

00:26:19.901 --> 00:26:21.501
and one of the reasons
we have to download

00:26:21.501 --> 00:26:24.100
so much JavaScript code
to work around these issues.

00:26:24.100 --> 00:26:26.100
So the end point
we're working to get towards

00:26:26.100 --> 00:26:28.300
is to make it so that
rich text editing

00:26:28.300 --> 00:26:30.100
is also a one-liner, right?

00:26:30.100 --> 00:26:33.901
It becomes as simple as
TextBox has always been, right?

00:26:33.901 --> 00:26:35.901
I just say, "Give me
a rich text area.

00:26:35.901 --> 00:26:37.767
Make it all fully editable."

00:26:37.767 --> 00:26:40.300
And then I can expect
a consistent set of HTML

00:26:40.300 --> 00:26:43.501
that will come out
in response to user actions.

00:26:43.501 --> 00:26:46.701
So we want to make it easy
for the apps.

00:26:46.701 --> 00:26:49.100
So that's still
in the early days,

00:26:49.100 --> 00:26:52.100
but expect more from us
over time.

00:26:52.100 --> 00:26:55.467
Notifications are another
big area we've been working on.

00:26:55.467 --> 00:26:58.968
Currently, for web application,
you have a limited set of ways

00:26:58.968 --> 00:27:01.300
that you can get
the attention of your users.

00:27:01.300 --> 00:27:03.200
You can do something
in the tab, right?

00:27:03.200 --> 00:27:04.534
But then you have the problem

00:27:04.534 --> 00:27:06.267
of what if they're not
in the tab right now?

00:27:06.267 --> 00:27:08.868
So the other alternative
is alert boxes.

00:27:08.868 --> 00:27:11.467
Problem is,
users hate alert boxes, right?

00:27:11.467 --> 00:27:14.167
I come into work every day
and find an alert box open

00:27:14.167 --> 00:27:16.334
saying that I have
a calendar entry coming up,

00:27:16.334 --> 00:27:18.868
and my whole browser's locked up
till I address that alert box.

00:27:18.868 --> 00:27:20.667
It's not a great
user experience.

00:27:20.667 --> 00:27:24.033
Alert boxes
are not very flexible,

00:27:24.033 --> 00:27:25.634
and I don't get alert boxes

00:27:25.634 --> 00:27:27.467
if I'm not running the browser
as well.

00:27:27.467 --> 00:27:30.267
So we've been working quite hard
on trying to figure out

00:27:30.267 --> 00:27:33.200
what is a less intrusive
event notification mechanism

00:27:33.200 --> 00:27:36.567
and one that has better control
over presentation

00:27:36.567 --> 00:27:38.334
and one that is more reliable?

00:27:38.334 --> 00:27:39.968
By control over presentation
I mean

00:27:39.968 --> 00:27:41.767
how do I do rich text in it,
right?

00:27:41.767 --> 00:27:43.167
The current alert box is--

00:27:43.167 --> 00:27:44.968
it's really just
an ascii string.

00:27:44.968 --> 00:27:46.567
I'd like a little bit
more control.

00:27:46.567 --> 00:27:49.767
I'd like it to look like
the web and feel interesting.

00:27:49.767 --> 00:27:52.000
And I want it to work,

00:27:52.000 --> 00:27:54.567
regardless of which tab
or window has focus

00:27:54.567 --> 00:27:55.968
or whether it's iconified

00:27:55.968 --> 00:27:57.767
or any number
of different factors.

00:27:57.767 --> 00:28:00.167
So we're currently prototyping
some implementations of this.

00:28:00.167 --> 00:28:02.267
Again, this one is in
the very early stages.

00:28:02.267 --> 00:28:04.033
There's no standard here yet.

00:28:04.033 --> 00:28:06.267
And we're in
a prototyping stage

00:28:06.267 --> 00:28:08.434
and would love input
about what people want.

00:28:08.434 --> 00:28:10.234
But what we're trying
to achieve

00:28:10.234 --> 00:28:12.033
is to create
a notification system

00:28:12.033 --> 00:28:14.234
where your web application
can just register,

00:28:14.234 --> 00:28:16.434
say I want to present
notifications,

00:28:16.434 --> 00:28:17.834
make API calls.

00:28:17.834 --> 00:28:19.634
When you want to present
a notification,

00:28:19.634 --> 00:28:21.234
know that the user
will get it reliably,

00:28:21.234 --> 00:28:23.834
have a way to get back
to your application.

00:28:23.834 --> 00:28:25.434
And it won't lock up
the browser

00:28:25.434 --> 00:28:28.367
in the way that the alert
dialogue box does today.

00:28:31.033 --> 00:28:32.767
Web sockets.

00:28:32.767 --> 00:28:34.501
As you notice, we started
with sort of the stuff

00:28:34.501 --> 00:28:36.000
that's furthest along
in implementation,

00:28:36.000 --> 00:28:37.501
the things that
we're shipping already.

00:28:37.501 --> 00:28:39.133
Now we're moving into
the realm of things

00:28:39.133 --> 00:28:40.801
that we're just beginning
work on

00:28:40.801 --> 00:28:42.334
but areas we think
are very important

00:28:42.334 --> 00:28:43.767
and things
that we'll be launching

00:28:43.767 --> 00:28:45.734
over the next few months.

00:28:45.734 --> 00:28:48.434
So Web sockets.
This is a very interesting area.

00:28:48.434 --> 00:28:50.601
So if you look at how network
communication works

00:28:50.601 --> 00:28:54.367
for web applications today,
it's, frankly, really weird.

00:28:54.367 --> 00:28:56.033
It manages to work,

00:28:56.033 --> 00:28:58.534
but when you look at how
traditional desktop applications

00:28:58.534 --> 00:29:02.968
do client/server
and client/client communication,

00:29:02.968 --> 00:29:04.534
it's a very different model,
right?

00:29:04.534 --> 00:29:06.501
You open a TCP connection
to a server,

00:29:06.501 --> 00:29:08.033
you have a persistent
connection open.

00:29:08.033 --> 00:29:09.834
You can send packets
both directions,

00:29:09.834 --> 00:29:11.234
receive packets.

00:29:11.234 --> 00:29:13.334
It's always synchronous.
It's all very simple.

00:29:13.334 --> 00:29:16.100
The web has a very different
model, as you know.

00:29:16.100 --> 00:29:17.901
You do these
asynchronous requests.

00:29:17.901 --> 00:29:21.033
When you want a persistent
connection to the server today,

00:29:21.033 --> 00:29:23.100
it's actually
quite complicated.

00:29:23.100 --> 00:29:24.667
There are two challenges.

00:29:24.667 --> 00:29:28.300
One is how does the server
notify me asynchronously?

00:29:28.300 --> 00:29:30.033
Because there is
no persistent connection.

00:29:30.033 --> 00:29:32.634
The other one is how do I have
a consistent connection

00:29:32.634 --> 00:29:35.767
that I can do bidirectional
sends and receives on?

00:29:35.767 --> 00:29:37.501
So today what people do
is things like

00:29:37.501 --> 00:29:39.901
hanging post requests
as a mechanism

00:29:39.901 --> 00:29:42.167
to allow you to get
asynchronous notifications.

00:29:42.167 --> 00:29:45.067
It's a weird way,
and it's somewhat unreliable,

00:29:45.067 --> 00:29:46.834
and there are many challenges

00:29:46.834 --> 00:29:50.234
that I'm sure you're familiar
with with hanging post requests.

00:29:50.234 --> 00:29:51.701
Web sockets are an API

00:29:51.701 --> 00:29:54.434
that are already specified
in the HTML5 spec

00:29:54.434 --> 00:29:56.100
that try to solve
this problem.

00:29:56.100 --> 00:29:58.901
So it's an API
that looks a lot more like

00:29:58.901 --> 00:30:00.501
a normal TCP connection,

00:30:00.501 --> 00:30:03.300
so it's a way to create
a connection back to your server

00:30:03.300 --> 00:30:05.501
from the client

00:30:05.501 --> 00:30:07.501
and then simply do
sends and receives

00:30:07.501 --> 00:30:10.501
and asynchronous callbacks
when you get receives.

00:30:10.501 --> 00:30:13.901
Sort of very sort of TCP-like
protocol for web applications.

00:30:13.901 --> 00:30:17.300
So it means it becomes easy to
get asynchronous notifications.

00:30:17.300 --> 00:30:19.133
You already have
the socket open.

00:30:19.133 --> 00:30:20.901
You just get
an asynchronous send.

00:30:20.901 --> 00:30:22.901
You do a receive.
You get a callback.

00:30:22.901 --> 00:30:25.300
It becomes much simpler
to implement...

00:30:25.300 --> 00:30:27.234
to implement
asynchronous notifies.

00:30:27.234 --> 00:30:29.000
It becomes much simpler to do
the sort of

00:30:29.000 --> 00:30:31.434
persistent connection with
bidirectional communication.

00:30:31.434 --> 00:30:35.100
There is a specification
already here for HTML5.

00:30:35.100 --> 00:30:38.300
There's some work still ongoing
to refine defining the protocol

00:30:38.300 --> 00:30:40.300
for how connections work
with the server

00:30:40.300 --> 00:30:42.300
and several other aspects.

00:30:42.300 --> 00:30:44.334
And we're beginning
prototype implementation

00:30:44.334 --> 00:30:46.300
so that we can start
to use this,

00:30:46.300 --> 00:30:47.701
start to experiment it,

00:30:47.701 --> 00:30:50.501
and get it in the hands
of folks like yourselves.

00:30:50.501 --> 00:30:51.901
But the goal here
with Web sockets

00:30:51.901 --> 00:30:53.701
is to make persistent
server communication,

00:30:53.701 --> 00:30:57.400
asynchronous notification
to the server much simpler.

00:30:59.901 --> 00:31:01.434
3D graphics.

00:31:01.434 --> 00:31:03.801
So this is an area I'm
personally very excited about.

00:31:03.801 --> 00:31:05.501
So there are two big efforts

00:31:05.501 --> 00:31:07.334
that have been going on
in this area

00:31:07.334 --> 00:31:10.567
that we've been contributing to
with Chrome.

00:31:10.567 --> 00:31:12.467
One of them is Canvas 3D,

00:31:12.467 --> 00:31:15.667
So Canvas 3D is a system
developed by Mozilla,

00:31:15.667 --> 00:31:17.334
command line--
or, I'm sorry,

00:31:17.334 --> 00:31:19.534
an immediate-mode API
that allows developers

00:31:19.534 --> 00:31:22.267
to make OpenGL calls
from JavaScript.

00:31:22.267 --> 00:31:25.133
So OpenGL is one of the dominant
3D graphics APIs

00:31:25.133 --> 00:31:28.934
that we'd use from Windows
or on the Mac or on Linux.

00:31:28.934 --> 00:31:32.968
It's the industry standard
for 3D graphics

00:31:32.968 --> 00:31:34.567
for native applications.

00:31:34.567 --> 00:31:37.367
So Canvas 3D is effectively
a set of JavaScript bindings

00:31:37.367 --> 00:31:40.734
that let you call OpenGL from
your JavaScript application.

00:31:40.734 --> 00:31:45.300
So this is running
as an extension in Mozilla today

00:31:45.300 --> 00:31:46.701
and has very cool stuff,

00:31:46.701 --> 00:31:48.934
and we're actively
collaborating with them

00:31:48.934 --> 00:31:50.868
on figuring out
how to bring this into Chrome.

00:31:50.868 --> 00:31:53.067
It's something
we're very excited about.

00:31:53.067 --> 00:31:55.801
O3D is another effort
in this area.

00:31:55.801 --> 00:31:58.567
This is a plugin
that Google launched

00:31:58.567 --> 00:32:00.334
just over a month ago,

00:32:00.334 --> 00:32:06.334
and it's a set of APIs for doing
3D graphics from JavaScript.

00:32:06.334 --> 00:32:08.667
This one is different
from Canvas 3D

00:32:08.667 --> 00:32:10.734
in that it's a retain-mode API.

00:32:10.734 --> 00:32:12.968
So I guess the way to think
about the difference between

00:32:12.968 --> 00:32:18.033
Canvas 3D and O3D
is Canvas 3D is immediate mode,

00:32:18.033 --> 00:32:20.634
and O3D is retain mode.

00:32:20.634 --> 00:32:24.767
So there's a good analogy there
between Canvas 2D and SVG.

00:32:24.767 --> 00:32:26.734
SVG is a retain-mode API

00:32:26.734 --> 00:32:29.434
whereas Canvas 2D
is an immediate-mode API.

00:32:29.434 --> 00:32:31.701
And so what we're seeing
in 3D is

00:32:31.701 --> 00:32:33.701
that there's a similar
dichotomy there,

00:32:33.701 --> 00:32:35.300
different kinds of APIs,

00:32:35.300 --> 00:32:36.868
depending on whether you want
immediate mode

00:32:36.868 --> 00:32:38.968
to make rendering calls
that render right now

00:32:38.968 --> 00:32:41.300
or whether you want to make
retain-mode rendering calls

00:32:41.300 --> 00:32:43.234
where you define a scene graph

00:32:43.234 --> 00:32:45.634
which is then rendered
by the system automatically

00:32:45.634 --> 00:32:48.434
in the same way that SVG is
or the DOM is, right?

00:32:48.434 --> 00:32:51.234
In a sense,
the DOM is a retain-mode API.

00:32:51.234 --> 00:32:52.634
I create the DOM,

00:32:52.634 --> 00:32:55.434
and then the browser takes care
of the rendering for me.

00:32:55.434 --> 00:32:57.634
So our expectation here

00:32:57.634 --> 00:32:59.901
is that this is gonna
continue to evolve.

00:32:59.901 --> 00:33:03.300
We're in the very early
stages right now

00:33:03.300 --> 00:33:05.701
of working on standardization.

00:33:05.701 --> 00:33:07.901
There's a couple of different
prototype implementations

00:33:07.901 --> 00:33:09.501
out there right now,

00:33:09.501 --> 00:33:11.300
and we expect it will take
several months

00:33:11.300 --> 00:33:12.701
to really get to a...

00:33:12.701 --> 00:33:15.100
to final set
of specifications.

00:33:15.100 --> 00:33:16.501
Could easily take years.

00:33:16.501 --> 00:33:18.501
So we're actively working
with Apple

00:33:18.501 --> 00:33:22.300
and Opera and Mozilla
to move this forward,

00:33:22.300 --> 00:33:24.300
and it's in
the very early stage.

00:33:24.300 --> 00:33:25.400
If you're interested in this,

00:33:25.400 --> 00:33:27.901
I'd encourage you
to go to the...

00:33:27.901 --> 00:33:29.901
to the client demo pod
outside.

00:33:29.901 --> 00:33:31.501
There's some pretty
neat games

00:33:31.501 --> 00:33:33.501
that folks have written
with this stuff,

00:33:33.501 --> 00:33:37.100
games and other applications
from ABC and Disney

00:33:37.100 --> 00:33:40.834
and some game developers
we've been talking to.

00:33:42.968 --> 00:33:44.501
And there's a lot more,

00:33:44.501 --> 00:33:47.801
so I'll say a lot on this slide
about some of the other things

00:33:47.801 --> 00:33:50.334
that we're thinking about,
that we're beginning work on.

00:33:50.334 --> 00:33:53.701
These are the things
that are the furthest away.

00:33:53.701 --> 00:33:55.734
Many of these are ones
we haven't started on

00:33:55.734 --> 00:33:57.334
really at all yet,

00:33:57.334 --> 00:33:59.434
but we've realized
that they're important areas,

00:33:59.434 --> 00:34:00.701
and they're areas where we,

00:34:00.701 --> 00:34:02.434
the open source
browser community,

00:34:02.434 --> 00:34:04.000
need to make progress.

00:34:04.000 --> 00:34:05.534
And we'd love to hear from you

00:34:05.534 --> 00:34:08.000
about what the additional things
are that aren't on our list.

00:34:08.000 --> 00:34:09.167
What else do you need?

00:34:09.167 --> 00:34:10.467
But let me go briefly through

00:34:10.467 --> 00:34:12.767
the ones that we know
are important.

00:34:12.767 --> 00:34:14.934
So there are some
that are already defined

00:34:14.934 --> 00:34:17.634
in the HTML5 specs that just
haven't been implemented

00:34:17.634 --> 00:34:19.100
that we think are important.

00:34:19.100 --> 00:34:21.300
Geolocation
is a good example there.

00:34:21.300 --> 00:34:22.868
So there are
good specifications

00:34:22.868 --> 00:34:25.801
for how to make JavaScript API
calls from the client

00:34:25.801 --> 00:34:28.801
to figure out where you are
in the real world, right?

00:34:28.801 --> 00:34:30.767
What are my
geolocation coordinates?

00:34:30.767 --> 00:34:34.567
Those work by using backends
that are either cell tower based

00:34:34.567 --> 00:34:37.601
or Wi-Fi network based

00:34:37.601 --> 00:34:41.300
or based on GPS hardware
in your device if you have it.

00:34:41.300 --> 00:34:42.801
What's neat about the API

00:34:42.801 --> 00:34:44.400
is you don't have to know
how it works.

00:34:44.400 --> 00:34:46.501
You just make
a simple API call

00:34:46.501 --> 00:34:48.133
and say, "Where am I?",

00:34:48.133 --> 00:34:50.200
and it gives you latitude
and longitude coordinates.

00:34:50.200 --> 00:34:51.734
Very simple.

00:34:51.734 --> 00:34:54.033
Forms2.

00:34:54.033 --> 00:34:58.934
So Forms2 attempts to improve
how forms work on the web.

00:34:58.934 --> 00:35:01.133
It's, again,
one that is specified.

00:35:01.133 --> 00:35:02.901
There hasn't been
much work on it.

00:35:02.901 --> 00:35:04.501
The main things
that are interesting

00:35:04.501 --> 00:35:07.167
about the Forms2 specification,
if you want to check it out,

00:35:07.167 --> 00:35:11.801
is it's got consistent
HTML interfaces

00:35:11.801 --> 00:35:13.934
for things like calendars,
right?

00:35:13.934 --> 00:35:15.534
We've all seen
web applications

00:35:15.534 --> 00:35:17.968
where you click on a date field
and it pops up a calendar.

00:35:17.968 --> 00:35:20.033
Well, that's always
a custom piece of code.

00:35:20.033 --> 00:35:21.601
There is no built-in thing
in the web

00:35:21.601 --> 00:35:23.167
that says
let me pick a date now,

00:35:23.167 --> 00:35:25.367
which is why all those
calendars look different.

00:35:25.367 --> 00:35:27.300
What Forms2 tries to do
is say

00:35:27.300 --> 00:35:28.834
let's standardize
all that stuff.

00:35:28.834 --> 00:35:30.267
Let's make it so that

00:35:30.267 --> 00:35:32.300
doing a form
that needs a date entry

00:35:32.300 --> 00:35:34.167
is just a one-liner.

00:35:34.167 --> 00:35:36.767
Where I say "it's a date",
I use the date tag

00:35:36.767 --> 00:35:38.400
and it gives me a calendar.

00:35:38.400 --> 00:35:40.434
I select the date,
and it fills it in in the form.

00:35:40.434 --> 00:35:42.934
So Forms2 aspires to do this

00:35:42.934 --> 00:35:45.167
for as many different
data types as possible,

00:35:45.167 --> 00:35:46.968
make it easy to enter them

00:35:46.968 --> 00:35:49.467
in a visually interesting,
sensible way

00:35:49.467 --> 00:35:51.968
with less code
from the app developer.

00:35:51.968 --> 00:35:55.467
Datagrid is another API
that's been specced out

00:35:55.467 --> 00:35:57.234
that hasn't been
implemented yet

00:35:57.234 --> 00:35:58.667
that we think's
pretty interesting.

00:35:58.667 --> 00:36:00.067
So Datagrid attempts
to give you

00:36:00.067 --> 00:36:04.667
better control over
table-like layouts.

00:36:04.667 --> 00:36:07.701
So let me get into
some of the more exotic things.

00:36:07.701 --> 00:36:09.734
So in the last category
are things

00:36:09.734 --> 00:36:11.767
that are really not
very well defined right now.

00:36:11.767 --> 00:36:13.501
We think they're broad areas
that are important

00:36:13.501 --> 00:36:16.701
and interesting to add
as capabilities for webapps,

00:36:16.701 --> 00:36:19.701
and we'd love to get
your comments and questions

00:36:19.701 --> 00:36:22.701
during the Q&amp;A at the end
about these.

00:36:22.701 --> 00:36:24.634
So some of the ones
we've been thinking about

00:36:24.634 --> 00:36:26.534
are peer-to-peer APIs,
right?

00:36:26.534 --> 00:36:28.467
There are a lot of applications
I'd like to do

00:36:28.467 --> 00:36:30.901
like chat applications
or games,

00:36:30.901 --> 00:36:33.901
any number of different things,
customer support

00:36:33.901 --> 00:36:35.267
where I really...

00:36:35.267 --> 00:36:37.367
it doesn't necessarily
make sense

00:36:37.367 --> 00:36:39.534
to do client/server-based
communication.

00:36:39.534 --> 00:36:42.033
I'd just as soon do
peer-to-peer communication.

00:36:42.033 --> 00:36:44.300
Why? Well, one issue
is latency, right?

00:36:44.300 --> 00:36:46.234
If I can do peer-to-peer,
it's one hop.

00:36:46.234 --> 00:36:48.267
If I have to go
client to server to client,

00:36:48.267 --> 00:36:49.634
it's two hops.

00:36:49.634 --> 00:36:51.067
If I'm playing a game

00:36:51.067 --> 00:36:52.801
with the guy sitting
at the desk next to me,

00:36:52.801 --> 00:36:54.467
that really makes no sense.

00:36:54.467 --> 00:36:56.000
It should just be one hop

00:36:56.000 --> 00:36:58.567
to the guy who's 2 milliseconds
away on the network.

00:36:58.567 --> 00:37:01.868
So if we look at conventional
desktop operating systems,

00:37:01.868 --> 00:37:03.968
there are great
peer-to-peer networking APIs.

00:37:03.968 --> 00:37:06.934
The challenge for us
is to figure out

00:37:06.934 --> 00:37:09.100
how do we bring that
to the web?

00:37:09.100 --> 00:37:11.467
How can we create a peer-to-peer
networking API for the web

00:37:11.467 --> 00:37:14.000
that's safe and secure that
gives you these capabilities?

00:37:14.000 --> 00:37:16.000
So it's something
we're starting to think about.

00:37:16.000 --> 00:37:17.100
Drag and drop support.

00:37:17.100 --> 00:37:18.534
This is another thing

00:37:18.534 --> 00:37:20.334
that doesn't work very well
on the web today

00:37:20.334 --> 00:37:22.634
and is gonna require
some work from the browsers.

00:37:22.634 --> 00:37:25.767
I'd really like to be able
to drag files from my desktop

00:37:25.767 --> 00:37:27.334
into my web application

00:37:27.334 --> 00:37:28.934
and then have that
work reliably.

00:37:28.934 --> 00:37:30.968
And I'd like to be able to drag
it between web applications.

00:37:30.968 --> 00:37:32.501
If I'm looking
at an attachment

00:37:32.501 --> 00:37:35.000
that I just downloaded in
Gmail--or I haven't downloaded,

00:37:35.000 --> 00:37:37.234
I see it in my Gmail,
I'd love to be able

00:37:37.234 --> 00:37:38.834
to just drag that
to another web application.

00:37:38.834 --> 00:37:40.234
Why can't I do that today?

00:37:40.234 --> 00:37:42.200
Well, because we don't
have the APIs.

00:37:42.200 --> 00:37:44.234
There's no rocket science
here.

00:37:44.234 --> 00:37:46.801
We just need to figure out
how should the API work,

00:37:46.801 --> 00:37:48.267
how should
the security model work,

00:37:48.267 --> 00:37:50.400
how does the user
grant permission for this?

00:37:50.400 --> 00:37:52.501
The wonderful thing about
drag and drop

00:37:52.501 --> 00:37:54.801
is, in a sense, the user's
already granting permission

00:37:54.801 --> 00:37:56.200
by doing the dragging.

00:37:56.200 --> 00:37:58.434
So it does seem like
a solvable problem,

00:37:58.434 --> 00:38:00.501
and it's something
that we're starting to...

00:38:00.501 --> 00:38:02.033
starting to look at
pretty seriously,

00:38:02.033 --> 00:38:04.200
and we'd love to hear
from you about.

00:38:04.200 --> 00:38:06.033
Webcam and microphone.

00:38:06.033 --> 00:38:07.467
As I mentioned,

00:38:07.467 --> 00:38:10.033
I mentioned the Google Talk
video conferencing example.

00:38:10.033 --> 00:38:12.434
There are lots of apps
people use today

00:38:12.434 --> 00:38:14.501
for doing video conferencing
on the web.

00:38:14.501 --> 00:38:16.601
None of them
are really webapps, right?

00:38:16.601 --> 00:38:19.934
So they may have a web
interface of some sort

00:38:19.934 --> 00:38:22.734
or a control panel,
but doing the heavy lifting

00:38:22.734 --> 00:38:25.534
of accessing the webcam,
accessing the microphone,

00:38:25.534 --> 00:38:27.167
running the compressors

00:38:27.167 --> 00:38:28.901
is always stuff
that people have to do

00:38:28.901 --> 00:38:30.734
either in native applications
or in plugins.

00:38:30.734 --> 00:38:32.968
What we're trying to figure out
is how do we get to a world

00:38:32.968 --> 00:38:34.968
where I could write
an application like that

00:38:34.968 --> 00:38:36.367
purely in JavaScript?

00:38:36.367 --> 00:38:37.868
And it doesn't look that hard.

00:38:37.868 --> 00:38:39.434
You really just need to add
JavaScript APIs

00:38:39.434 --> 00:38:41.000
for getting access
to the webcam,

00:38:41.000 --> 00:38:42.767
access to the microphone,

00:38:42.767 --> 00:38:45.434
support for our reasonable
array of codecs

00:38:45.434 --> 00:38:47.901
for live encoding and video.

00:38:47.901 --> 00:38:51.033
So it's an area we're starting
to look at quite seriously.

00:38:51.033 --> 00:38:53.367
O/S integration.

00:38:53.367 --> 00:38:55.868
So this again gets back sort of
to the drag and drop thing,

00:38:55.868 --> 00:38:57.701
but there's a broad
category of things

00:38:57.701 --> 00:39:01.434
that native apps can do
that webapps can't do

00:39:01.434 --> 00:39:03.667
that are hard to put in
any other bucket.

00:39:03.667 --> 00:39:05.100
So I've put them
in this bucket.

00:39:05.100 --> 00:39:07.701
These are things like,
you know...

00:39:07.701 --> 00:39:11.367
there are files I may have
on my desktop, like a doc file,

00:39:11.367 --> 00:39:13.334
where I could double-click
on the application,

00:39:13.334 --> 00:39:15.300
and I can get that
to launch Office today.

00:39:15.300 --> 00:39:17.501
But what if I want it to launch
into Google Docs?

00:39:17.501 --> 00:39:21.701
What if I want it to launch
into an online PDF previewer?

00:39:21.701 --> 00:39:24.501
So beginning to think of it,
how could we do that?

00:39:24.501 --> 00:39:26.300
How could we have
local file handlers

00:39:26.300 --> 00:39:28.901
that respond to OS events
like opening a file

00:39:28.901 --> 00:39:31.701
that are capable of launching
web applications, right?

00:39:31.701 --> 00:39:33.400
There are an increasing number
of web applications

00:39:33.400 --> 00:39:36.701
that can handle things like
doc files or XL spreadsheets

00:39:36.701 --> 00:39:38.901
or any number
of different formats.

00:39:38.901 --> 00:39:41.934
Photos, right?
Photo editing, for example.

00:39:41.934 --> 00:39:43.300
So we're starting
to think about

00:39:43.300 --> 00:39:45.367
that level of OS integration.

00:39:45.367 --> 00:39:47.367
Another one I think about
a lot is CD-ROM drive

00:39:47.367 --> 00:39:48.801
or a USB key.

00:39:48.801 --> 00:39:50.300
There are various devices

00:39:50.300 --> 00:39:52.501
that are hard to get to
right now from the web.

00:39:52.501 --> 00:39:54.801
It would be nice to be able
to pop in a CD

00:39:54.801 --> 00:39:58.100
that has photos on it
and have it bring me to Picasa.

00:39:58.100 --> 00:39:59.701
We're not there yet.

00:39:59.701 --> 00:40:01.701
So we're beginning work on this,
starting to think about it,

00:40:01.701 --> 00:40:04.100
and we'd love to hear
your thoughts.

00:40:04.100 --> 00:40:06.767
Another broad area,
one of the last I'll talk about,

00:40:06.767 --> 00:40:07.901
is uploads.

00:40:07.901 --> 00:40:09.300
Uploads on the web today

00:40:09.300 --> 00:40:11.467
are not a good experience
for users, right?

00:40:11.467 --> 00:40:14.701
If I decide to go upload
a bunch of photos to a website,

00:40:14.701 --> 00:40:16.300
if it's a pure webapp,

00:40:16.300 --> 00:40:17.901
that's a pretty
awful experience.

00:40:17.901 --> 00:40:21.300
I have to go to the website.
I say I want to upload a photo.

00:40:21.300 --> 00:40:22.901
It brings me a file open
dialogue box.

00:40:22.901 --> 00:40:24.901
I have to go find the thing
in my file system

00:40:24.901 --> 00:40:26.701
by traversing around
the directory hierarchy

00:40:26.701 --> 00:40:27.701
and clicking.

00:40:27.701 --> 00:40:29.334
I find it.
It closes.

00:40:29.334 --> 00:40:31.701
And now I say, "Oh, now I got
another 50 to add."

00:40:31.701 --> 00:40:33.701
So now I do it again
50 times.

00:40:33.701 --> 00:40:35.701
It's a really horrible
experience,

00:40:35.701 --> 00:40:37.234
so we're working
to think through--

00:40:37.234 --> 00:40:38.601
how should this work?

00:40:38.601 --> 00:40:40.300
How should the user
select multiple files?

00:40:40.300 --> 00:40:42.234
How do we handle the upload?

00:40:42.234 --> 00:40:43.901
How can we handle
re-startable uploads?

00:40:43.901 --> 00:40:47.901
You know, a big issue is
the user will begin an upload,

00:40:47.901 --> 00:40:51.000
you know, close their machine,
walk away, it goes to sleep.

00:40:51.000 --> 00:40:52.501
I've just destroyed
the upload.

00:40:52.501 --> 00:40:54.234
How do we make this
a better experience?

00:40:54.234 --> 00:40:56.267
That's something
we're beginning to think about,

00:40:56.267 --> 00:40:59.100
and we think it's a very
important area for users.

00:40:59.100 --> 00:41:00.601
Lots of evidence from that
in that

00:41:00.601 --> 00:41:04.167
there are many third-party
Windows applications

00:41:04.167 --> 00:41:06.501
that are sort of
uploader applications

00:41:06.501 --> 00:41:10.300
whether for Flickr
or for Facebook or whatever.

00:41:10.300 --> 00:41:11.767
We're trying to figure out

00:41:11.767 --> 00:41:14.767
how could we move those
into the web itself?

00:41:14.767 --> 00:41:16.367
These are some of the areas
we've been thinking about

00:41:16.367 --> 00:41:18.167
in terms of things
that the web needs

00:41:18.167 --> 00:41:20.167
in terms of
client-side capabilities.

00:41:20.167 --> 00:41:23.167
But again, we'd love to hear
from you about what's important,

00:41:23.167 --> 00:41:24.801
what's not important,

00:41:24.801 --> 00:41:28.067
and what's missing
from our list.

00:41:28.067 --> 00:41:30.901
So a quick summary.
My last slide.

00:41:30.901 --> 00:41:32.567
And then we'll open it up
to questions.

00:41:32.567 --> 00:41:35.434
So here's a rough timeline
of what we're working on.

00:41:35.434 --> 00:41:37.067
So we've been hard at work
on video

00:41:37.067 --> 00:41:38.901
and launching that
into the dev channel.

00:41:38.901 --> 00:41:40.834
That's sort of where
we are right now.

00:41:40.834 --> 00:41:43.601
We're hard at work
on local store, appcache,

00:41:43.601 --> 00:41:45.434
workers database.

00:41:45.434 --> 00:41:47.801
A bunch of those
offline capabilities

00:41:47.801 --> 00:41:50.367
are already shipping in Gears
and have been for some time.

00:41:50.367 --> 00:41:52.801
We're working on shipping them
in Chrome as fast as we can

00:41:52.801 --> 00:41:55.000
and checking them into
the Chromium code base.

00:41:55.000 --> 00:41:57.067
So if you look at
the source tree,

00:41:57.067 --> 00:41:58.868
you can see the check-ins
happening now,

00:41:58.868 --> 00:42:01.267
and those'll be coming out
as soon as we're done.

00:42:01.267 --> 00:42:03.801
The next-gen stuff
we're working on--

00:42:03.801 --> 00:42:05.234
I mentioned a couple
of them today--

00:42:05.234 --> 00:42:06.567
are Web sockets.

00:42:06.567 --> 00:42:08.901
Another one I didn't mention
is CSS3,

00:42:08.901 --> 00:42:11.000
so we're doing a lot of work
with CSS3

00:42:11.000 --> 00:42:13.067
to support some of
the advanced features

00:42:13.067 --> 00:42:16.300
like vertical text rendering
for Asian languages,

00:42:16.300 --> 00:42:18.734
support for things like Ruby

00:42:18.734 --> 00:42:21.701
and other things that are used
in a lot of languages

00:42:21.701 --> 00:42:24.067
with multiple character sets

00:42:24.067 --> 00:42:25.701
to show different
representations

00:42:25.701 --> 00:42:27.400
for the same text.

00:42:27.400 --> 00:42:29.167
Working on that.

00:42:29.167 --> 00:42:31.868
And then longer term,
working on some of these

00:42:31.868 --> 00:42:33.634
more exotic things
that I mentioned,

00:42:33.634 --> 00:42:36.267
so 3D certainly
being one of them.

00:42:36.267 --> 00:42:38.234
But also things like
peer-to-peer,

00:42:38.234 --> 00:42:42.133
better support for, you know,
clicking a doc file,

00:42:42.133 --> 00:42:45.067
having it open a webapp,
so this is our road map.

00:42:45.067 --> 00:42:46.501
These are the things
we're thinking about.

00:42:46.501 --> 00:42:48.334
We'd love to hear from you.

00:42:48.334 --> 00:42:50.934
So I will open it up
to questions.

00:42:50.934 --> 00:42:53.167
And we also have
a Google Moderator forum

00:42:53.167 --> 00:42:56.300
we'll pull up to answer
questions on the web.

00:42:56.300 --> 00:42:58.701
So why don't I take
a live question first?

00:42:58.701 --> 00:43:01.200
We've got a microphone there
and a microphone there.

00:43:01.200 --> 00:43:03.701
So please walk up to the mic.

00:43:03.701 --> 00:43:06.234
We'd love comments
or questions.

00:43:08.367 --> 00:43:11.133
Fette: We've got 17 questions
on the Moderator.

00:43:11.133 --> 00:43:13.267
man: Um, one thing
I was wondering

00:43:13.267 --> 00:43:14.901
if it's being thought about

00:43:14.901 --> 00:43:16.968
for the future
of browser support

00:43:16.968 --> 00:43:18.868
is window management.

00:43:18.868 --> 00:43:21.667
Because we build and maintain
a web application

00:43:21.667 --> 00:43:24.367
that we wrap in Chrome,

00:43:24.367 --> 00:43:26.501
and it's designed to be used
on multiple--

00:43:26.501 --> 00:43:28.100
computers
with multiple monitors.

00:43:28.100 --> 00:43:31.534
So we're dealing with
multiple windows,

00:43:31.534 --> 00:43:33.300
multiple tabs,
and even inside those

00:43:33.300 --> 00:43:34.501
some of them are frame sets,

00:43:34.501 --> 00:43:36.300
some of them have
high frames and stuff.

00:43:36.300 --> 00:43:38.100
And frankly,
it's very difficult

00:43:38.100 --> 00:43:41.901
to find a window
from another window,

00:43:41.901 --> 00:43:43.868
depending on, you know,
some are popped up

00:43:43.868 --> 00:43:45.901
because they were, you know,
called by window.open.

00:43:45.901 --> 00:43:49.701
Some were created by somebody
browsed to the same domain

00:43:49.701 --> 00:43:51.501
on a URL,
that kind of thing,

00:43:51.501 --> 00:43:53.100
which is very hard to get,
you know,

00:43:53.100 --> 00:43:55.334
to be able to call--
hit a button in one window,

00:43:55.334 --> 00:43:57.200
find out where that other
window lives

00:43:57.200 --> 00:43:59.334
to actually call that action
and do some work.

00:43:59.334 --> 00:44:00.767
I don't know.

00:44:00.767 --> 00:44:02.968
Has there been any discussion
or progress or thoughts on that?

00:44:02.968 --> 00:44:04.767
Papakipos: It's not something
I've thought about personally.

00:44:04.767 --> 00:44:06.868
I think it's a great question.
You're right.

00:44:06.868 --> 00:44:08.968
If we look at how
desktop applications behave,

00:44:08.968 --> 00:44:11.567
they'll often bring up
a set of windows, right?

00:44:11.567 --> 00:44:13.601
I'm thinking of like
a video editing application

00:44:13.601 --> 00:44:15.734
or a 3D graphics modeler,
right?

00:44:15.734 --> 00:44:17.367
It'll bring up
the main editing window,

00:44:17.367 --> 00:44:19.767
some extra views,
a list view, a file view.

00:44:19.767 --> 00:44:21.767
You're right--why can't we do
that from web applications?

00:44:21.767 --> 00:44:25.167
That's a great comment.
We'll think about it.

00:44:25.167 --> 00:44:28.567
Cool. Cool idea.

00:44:28.567 --> 00:44:30.000
Yes? In red.

00:44:30.000 --> 00:44:34.067
man: Um...how is HTML5
going to be able to handle

00:44:34.067 --> 00:44:38.767
when a user does not have
a codec installed for video?

00:44:38.767 --> 00:44:40.367
Papakipos:
That's a good question.

00:44:40.367 --> 00:44:42.133
So how do we handle
a missing codec?

00:44:42.133 --> 00:44:44.767
So we've defined the set
of codecs that we do support

00:44:44.767 --> 00:44:46.701
and the implementation
right now.

00:44:46.701 --> 00:44:49.834
Today it's a fixed set
of codecs,

00:44:49.834 --> 00:44:52.901
so there isn't any way
to sort of plug in another one.

00:44:52.901 --> 00:44:55.701
I mean, of course, you could
check in code into the code base

00:44:55.701 --> 00:44:58.400
and do edits
all open source.

00:44:58.400 --> 00:45:01.267
Yeah. I don't have any
specific thoughts there.

00:45:01.267 --> 00:45:02.501
Ian?

00:45:02.501 --> 00:45:04.567
Fette: We're definitely
trying to talk to

00:45:04.567 --> 00:45:05.868
other browser vendors,

00:45:05.868 --> 00:45:08.767
to other people
that are involved in the space

00:45:08.767 --> 00:45:10.634
of video editing software.

00:45:10.634 --> 00:45:12.834
And ideally,
we'd like to come to a place

00:45:12.834 --> 00:45:14.434
where there is...

00:45:14.434 --> 00:45:17.434
a set of things
that if you do, it just works.

00:45:17.434 --> 00:45:21.000
Like right now,
I know that if I make a JPEG,

00:45:21.000 --> 00:45:23.734
a GIF or a PNG
without transparency,

00:45:23.734 --> 00:45:26.133
it'll just work
in pretty much all the browsers.

00:45:26.133 --> 00:45:27.434
We're trying to get to a point

00:45:27.434 --> 00:45:29.767
where there's something
similar for video.

00:45:29.767 --> 00:45:33.133
So we're supporting H.264
and Ogg.

00:45:33.133 --> 00:45:36.567
There's not
100% agreement yet.

00:45:36.567 --> 00:45:38.601
We're working to try to get
some consensus

00:45:38.601 --> 00:45:40.601
and some sort of--
I don't think this is

00:45:40.601 --> 00:45:42.000
gonna be something
that's part of the standard,

00:45:42.000 --> 00:45:43.434
but we're trying to get
some sort of

00:45:43.434 --> 00:45:46.968
industry best practice
and consensus around

00:45:46.968 --> 00:45:49.834
if you make a video like this,
it will just work.

00:45:49.834 --> 00:45:52.234
So that's something
that's really...on us

00:45:52.234 --> 00:45:55.534
but also on everyone else
to sort of, you know,

00:45:55.534 --> 00:45:58.434
help participate
in that discussion,

00:45:58.434 --> 00:46:01.701
help reach out to other people
involved in the video space,

00:46:01.701 --> 00:46:05.734
and help this discussion move
forward towards a consensus.

00:46:09.100 --> 00:46:11.100
man: Hi. My question is that

00:46:11.100 --> 00:46:14.501
the file name
you put in the video tag

00:46:14.501 --> 00:46:17.701
is limited
to the docu-file

00:46:17.701 --> 00:46:20.901
or can refer to
the remote file?

00:46:20.901 --> 00:46:22.501
Fette:
It's just like an image.

00:46:22.501 --> 00:46:25.300
It can be...you know,
this one happened to be

00:46:25.300 --> 00:46:27.734
a local file on my computer,

00:46:27.734 --> 00:46:32.734
but I could say HTTP
someothersite.com/video.mp4,

00:46:32.734 --> 00:46:34.200
and assuming
that they didn't have

00:46:34.200 --> 00:46:37.467
some HT access rule
restricting it, it would work.

00:46:37.467 --> 00:46:40.400
Papakipos: You can also do HTPS.
I don't know if FTP works.

00:46:40.400 --> 00:46:41.701
If you're brave.

00:46:41.701 --> 00:46:43.300
[man speaking indistinctly]

00:46:43.300 --> 00:46:45.601
Fette: So streaming is something
that we still have to look at.

00:46:45.601 --> 00:46:47.701
Right now we don't support
any streaming protocols,

00:46:47.701 --> 00:46:50.100
but it's something
that we're looking at.

00:46:50.100 --> 00:46:51.901
We should also be sure to take
some of the Moderator questions.

00:46:51.901 --> 00:46:53.267
Papakipos: Yeah, let's take
a couple questions

00:46:53.267 --> 00:46:56.000
from Moderator to be fair
to the web folks here.

00:46:56.000 --> 00:46:58.067
The first one?
Okay.

00:46:58.067 --> 00:47:00.734
Okay. "Do you believe
it's safe enough

00:47:00.734 --> 00:47:02.767
"for us to start
developing sites or webapps

00:47:02.767 --> 00:47:05.067
leveraging HTML5?"

00:47:05.067 --> 00:47:07.167
That's a good question.

00:47:07.167 --> 00:47:09.767
I think the ones
that are implemented in

00:47:09.767 --> 00:47:12.968
multiple browsers
are certainly...

00:47:12.968 --> 00:47:15.167
are certainly things
I would be comfortable

00:47:15.167 --> 00:47:17.501
using in a webapp
that I shipped.

00:47:17.501 --> 00:47:19.968
I mean, you gotta figure out
what makes sense for you.

00:47:19.968 --> 00:47:23.767
The way that the security
policies around these APIs work

00:47:23.767 --> 00:47:25.801
tends to be fairly
browser-specific, right?

00:47:25.801 --> 00:47:29.968
In many cases, for things
that are privacy-related

00:47:29.968 --> 00:47:33.400
or things that may consume
local resources like disk space,

00:47:33.400 --> 00:47:35.167
browsers tend to go
with interfaces

00:47:35.167 --> 00:47:36.667
where they bring up
a dialogue box

00:47:36.667 --> 00:47:38.567
to check with the user
on first use,

00:47:38.567 --> 00:47:40.634
to ask the user explicitly
to grant permission.

00:47:40.634 --> 00:47:42.367
Should this thing be able
to work offline?

00:47:42.367 --> 00:47:45.567
Should this thing be able
to pop up notifications?

00:47:45.567 --> 00:47:46.901
In general,
the browser vendors

00:47:46.901 --> 00:47:48.667
have done a very good,
thoughtful job

00:47:48.667 --> 00:47:50.767
at making sure that they
seek user permission,

00:47:50.767 --> 00:47:52.367
when important,
for this stuff.

00:47:52.367 --> 00:47:54.567
So I think, in general,
there has been

00:47:54.567 --> 00:47:57.367
a lot of thoughtful work
about security and privacy

00:47:57.367 --> 00:47:59.167
for these APIs.

00:47:59.167 --> 00:48:00.567
Certainly, some of them

00:48:00.567 --> 00:48:02.834
are in the more experimental
stage still.

00:48:02.834 --> 00:48:04.234
I'll be the first to say that.

00:48:04.234 --> 00:48:06.000
Like 3D graphics,
for example,

00:48:06.000 --> 00:48:07.667
is still in the early stage,

00:48:07.667 --> 00:48:09.834
somewhat experimental
at this point.

00:48:09.834 --> 00:48:11.634
It's not built into
the browser itself.

00:48:11.634 --> 00:48:13.534
But the ones that are
built into the browser--

00:48:13.534 --> 00:48:14.834
I can only speak for myself--

00:48:14.834 --> 00:48:16.634
I would be comfortable deploying
a webapp that used them.

00:48:16.634 --> 00:48:18.834
Fette: And we should point out
that if you go out

00:48:18.834 --> 00:48:20.234
to the developer sandbox,

00:48:20.234 --> 00:48:21.834
there's a number of people
that are using that.

00:48:21.834 --> 00:48:24.234
So Mozilla
has the Bespin project,

00:48:24.234 --> 00:48:26.033
which is using canvas.

00:48:26.033 --> 00:48:30.834
And, you know, there's always
some chicken and egg scenario,

00:48:30.834 --> 00:48:33.634
but certainly a lot of these
do already have

00:48:33.634 --> 00:48:36.634
good implementation
across multiple browsers,

00:48:36.634 --> 00:48:39.434
and I think that if you are
doing something

00:48:39.434 --> 00:48:42.834
that is so new, so innovative,
and just looks so cool,

00:48:42.834 --> 00:48:45.834
I think if you say, you know,
you need to upgrade your browser

00:48:45.834 --> 00:48:47.834
and you need to get
something new,

00:48:47.834 --> 00:48:49.634
it's not gonna work
for 100% of people,

00:48:49.634 --> 00:48:51.634
but that's how
we move forward.

00:48:51.634 --> 00:48:54.667
Papakipos: Cool. Okay.
Let's take a live question.

00:48:54.667 --> 00:48:56.434
man: So I got a quick
question for you

00:48:56.434 --> 00:48:58.067
regarding the canvas.

00:48:58.067 --> 00:49:01.133
There is no event
on individual graphic elements

00:49:01.133 --> 00:49:02.701
that are on your canvas.

00:49:02.701 --> 00:49:05.701
Is there any plans
at any point in time

00:49:05.701 --> 00:49:06.934
to be able to support that?

00:49:06.934 --> 00:49:10.467
Because SVG has it.
VML has it.

00:49:10.467 --> 00:49:12.300
And, I mean, that is just
imperative for us

00:49:12.300 --> 00:49:13.901
to be able to have that.

00:49:13.901 --> 00:49:15.501
Any plans at all?

00:49:15.501 --> 00:49:17.033
Papakipos:
That's a great question.

00:49:17.033 --> 00:49:18.501
And that actually gets back

00:49:18.501 --> 00:49:19.901
to one of the issues
I was discussing,

00:49:19.901 --> 00:49:22.100
sort of the differences between
immediate-mode APIs

00:49:22.100 --> 00:49:23.300
and retain-mode APIs.

00:49:23.300 --> 00:49:25.701
The challenge
with immediate-mode APIs

00:49:25.701 --> 00:49:27.300
is that things like picking--

00:49:27.300 --> 00:49:29.100
which is what
you're describing, right,

00:49:29.100 --> 00:49:30.701
how do I click something
and get a call-back--

00:49:30.701 --> 00:49:33.901
make more sense in the context
of a retain-mode API like SVG

00:49:33.901 --> 00:49:36.501
than they do in an
immediate-mode API like canvas.

00:49:36.501 --> 00:49:40.300
My prediction is canvas probably
won't grow that ability,

00:49:40.300 --> 00:49:43.300
but some of the retain-mode
versions of it

00:49:43.300 --> 00:49:45.267
are probably easier ways
to do that.

00:49:45.267 --> 00:49:46.701
I guess I'm thinking of it
that specifically

00:49:46.701 --> 00:49:47.901
in the 3D realm.

00:49:47.901 --> 00:49:49.434
I haven't heard specifically

00:49:49.434 --> 00:49:52.067
about any sort of picking
support for canvas

00:49:52.067 --> 00:49:53.701
in the works so far.

00:49:53.701 --> 00:49:55.067
I think you might find SVG

00:49:55.067 --> 00:49:56.901
is better for that sort of
thing, though.

00:49:56.901 --> 00:49:58.300
man: Right.
And you guess...

00:49:58.300 --> 00:50:01.901
all the presentations,
even this morning...

00:50:01.901 --> 00:50:05.701
you always seem to exclude IE
out of this whole equation.

00:50:05.701 --> 00:50:10.701
But unfortunately,
IE, IE6 is still around,

00:50:10.701 --> 00:50:12.100
and it's really killing us,

00:50:12.100 --> 00:50:14.701
and is there any effort
on your side

00:50:14.701 --> 00:50:17.100
to kind of bring them
onto the table

00:50:17.100 --> 00:50:19.300
and try and say, hey,
you know what,

00:50:19.300 --> 00:50:21.901
you guys have to start
adopting the HTML5 stuff?

00:50:21.901 --> 00:50:23.300
Fette: It's--
Papakipos: It's a good question.

00:50:23.300 --> 00:50:25.300
Fette: I think we should
give some props to Microsoft.

00:50:25.300 --> 00:50:27.000
Like, they have started
implementing

00:50:27.000 --> 00:50:29.501
some of the HTML5 features
in IE8.

00:50:29.501 --> 00:50:31.100
Obviously, we'd love
to see them do more.

00:50:31.100 --> 00:50:34.501
It's an open standard
and, you know...

00:50:34.501 --> 00:50:37.300
there are Microsoft people
in attendance.

00:50:37.300 --> 00:50:39.701
They have name badges
that say Microsoft.

00:50:39.701 --> 00:50:41.300
[laughter]
You should corner one of them

00:50:41.300 --> 00:50:43.300
and share your opinion.

00:50:43.300 --> 00:50:45.100
man: It's like they come
to conferences and say,

00:50:45.100 --> 00:50:48.701
"Hey, we got CSS 2.1
completely implemented now."

00:50:48.701 --> 00:50:50.701
You're like, come on.
People are at 2.0.

00:50:50.701 --> 00:50:52.300
Papakipos: Yeah, I think...

00:50:52.300 --> 00:50:54.133
yeah, we can't implement it
for them,

00:50:54.133 --> 00:50:56.501
but I have seen a lot of signs
that they're--

00:50:56.501 --> 00:50:58.901
man: You guys at Google, you
should be able to implement it.

00:50:58.901 --> 00:51:00.901
Come on.
[laughter]

00:51:00.901 --> 00:51:04.367
Papakipos: Thanks. Let's take
another Moderator question.

00:51:04.367 --> 00:51:07.067
So the question is,
"Chrome...Chrome for Mac?"

00:51:07.067 --> 00:51:08.801
That's a short question.

00:51:08.801 --> 00:51:11.734
Let's see.
Well, it's open source.

00:51:11.734 --> 00:51:14.367
Go build it and run it.
[laughter]

00:51:14.367 --> 00:51:16.167
Fette: It runs Gmail now.
Papakipos: Right.

00:51:16.167 --> 00:51:18.367
I mean, that's what I do.
Fette: It's getting better.

00:51:18.367 --> 00:51:21.167
Papakipos: So but nothing
specific to announce

00:51:21.167 --> 00:51:24.801
about public plans
for an official build,

00:51:24.801 --> 00:51:27.400
but definitely,
there's lots of code

00:51:27.400 --> 00:51:29.167
in a very workable,
usable state,

00:51:29.167 --> 00:51:31.567
and we want to make sure
it's really polished

00:51:31.567 --> 00:51:36.767
before we do anything final
that would affect end-users.

00:51:36.767 --> 00:51:39.167
Cool. Okay, another live
question.

00:51:39.167 --> 00:51:41.767
man: This is actually
about the worker threads,

00:51:41.767 --> 00:51:43.367
and I was curious if there's
any sort of, like,

00:51:43.367 --> 00:51:47.334
mutual exclusion to avoid,
like, race conditions.

00:51:47.334 --> 00:51:50.167
Fette: So...JavaScript
in general

00:51:50.167 --> 00:51:53.133
tries to avoid
the notion of...

00:51:53.133 --> 00:51:56.701
locking anything that would
require you to do locking.

00:51:56.701 --> 00:51:58.767
[man speaking indistinctly]

00:51:58.767 --> 00:52:00.601
Papakipos: Oops.
We lost a mic.

00:52:00.601 --> 00:52:03.534
man: But, uh...what I was
thinking about

00:52:03.534 --> 00:52:05.033
is, like, for file access

00:52:05.033 --> 00:52:07.033
when you have offline
programs and all that,

00:52:07.033 --> 00:52:10.634
and you start doing stuff that
is, like, on the file system

00:52:10.634 --> 00:52:12.634
or just not necessarily
a variable.

00:52:12.634 --> 00:52:16.634
Is there any sort of thought
on that, maybe?

00:52:16.634 --> 00:52:18.033
Papakipos: I mean,
the general style,

00:52:18.033 --> 00:52:20.133
the way it works, tends to
avoid that kind of stuff.

00:52:20.133 --> 00:52:22.634
I think you probably could
get yourself in a deadlock

00:52:22.634 --> 00:52:23.834
if you tried,

00:52:23.834 --> 00:52:26.033
but it tends to be somewhat
immune to that

00:52:26.033 --> 00:52:28.434
because of the way
the API works.

00:52:28.434 --> 00:52:30.667
There's two factors
that make that the case.

00:52:30.667 --> 00:52:33.834
One is that all of
the receive calls

00:52:33.834 --> 00:52:35.834
are basically call-back based.

00:52:35.834 --> 00:52:38.634
So you tend to receive
a call back and do something.

00:52:38.634 --> 00:52:40.434
In a lot of deadlock cases,

00:52:40.434 --> 00:52:42.634
I've seen in conventional
operating systems,

00:52:42.634 --> 00:52:44.133
you get into deadlock
situations

00:52:44.133 --> 00:52:46.434
'cause you've got reads going on
on both sides of a pipe.

00:52:46.434 --> 00:52:48.834
So this is a more call-back
oriented thing,

00:52:48.834 --> 00:52:50.434
so it's somewhat immune to that.

00:52:50.434 --> 00:52:52.434
I think you probably
could make it deadlock

00:52:52.434 --> 00:52:54.234
if you really try.

00:52:54.234 --> 00:52:55.968
If you push a bunch of messages
to someone

00:52:55.968 --> 00:52:57.467
and the other side's
not listening,

00:52:57.467 --> 00:52:59.033
eventually, it will back up.

00:52:59.033 --> 00:53:00.834
Fette: I would say that if you
come into one of these scenarios

00:53:00.834 --> 00:53:02.467
where you think
that you need locking

00:53:02.467 --> 00:53:04.501
or you think that there
might be a deadlock,

00:53:04.501 --> 00:53:06.100
these are definitely
new APIs.

00:53:06.100 --> 00:53:09.100
The best thing to do is get on
the WhatWG mailing list.

00:53:09.100 --> 00:53:11.300
They're open.
Anyone can email to them.

00:53:11.300 --> 00:53:13.100
And just send an email saying
like, "Look,

00:53:13.100 --> 00:53:15.300
"I think this is a scenario
where, you know,

00:53:15.300 --> 00:53:18.300
locking would be really useful
or I might need locking,"

00:53:18.300 --> 00:53:20.501
and then start a discussion
around that.

00:53:20.501 --> 00:53:23.300
Because, you know, these still
are at the early stages,

00:53:23.300 --> 00:53:24.901
and discussion
is most welcome.

00:53:24.901 --> 00:53:26.300
Papakipos:
And it's entirely possible

00:53:26.300 --> 00:53:28.200
we need to add something
we haven't figure out yet,

00:53:28.200 --> 00:53:30.701
so let us know if you need it.

00:53:30.701 --> 00:53:33.968
Cool. Let's take one more
Moderator question.

00:53:33.968 --> 00:53:35.868
"Is there any work
for client side web applications

00:53:35.868 --> 00:53:38.667
"to gain access to server side
persistence model

00:53:38.667 --> 00:53:42.934
using a standard spaced
protocol?"

00:53:42.934 --> 00:53:44.901
That's a good question.

00:53:44.901 --> 00:53:47.701
Well, let's see...

00:53:47.701 --> 00:53:49.300
Not that I'm aware of.

00:53:49.300 --> 00:53:52.501
Most of our thinking
about offline so far

00:53:52.501 --> 00:53:54.567
has been on the client side
in terms of

00:53:54.567 --> 00:53:57.100
how do we have the fundamental
storage capabilities,

00:53:57.100 --> 00:53:59.300
how do we do appcache,

00:53:59.300 --> 00:54:01.367
how do we have a way
to capture URLs

00:54:01.367 --> 00:54:03.767
and display something
off the local file system?

00:54:03.767 --> 00:54:05.367
So I think, for the most part,

00:54:05.367 --> 00:54:08.567
we've been thinking primarily
about the client side thus far.

00:54:08.567 --> 00:54:11.167
There certainly are
Google technologies

00:54:11.167 --> 00:54:12.567
like App Engine you could use

00:54:12.567 --> 00:54:15.000
to store things
on the server side.

00:54:15.000 --> 00:54:19.000
And you could build
a persistent storage mechanism

00:54:19.000 --> 00:54:20.567
that way.

00:54:20.567 --> 00:54:22.968
But I think it's largely
up to the folks in this room.

00:54:22.968 --> 00:54:24.367
You guys are the developers.

00:54:24.367 --> 00:54:26.968
We sort of are providing
the low-level client mechanisms

00:54:26.968 --> 00:54:29.367
and the sever side services
like App Engine.

00:54:29.367 --> 00:54:31.167
You should be able to,
I think,

00:54:31.167 --> 00:54:33.367
build the kind of persistent
system you're looking for

00:54:33.367 --> 00:54:36.167
on top of that.

00:54:36.167 --> 00:54:37.767
Yes. Live question.

00:54:37.767 --> 00:54:41.367
man: Okay, you talked about
APIs,

00:54:41.367 --> 00:54:43.200
the device function
on your location

00:54:43.200 --> 00:54:44.767
on the camera/microphone.

00:54:44.767 --> 00:54:49.567
And I wonder, W3C's is current
to stop an activity to finding--

00:54:49.567 --> 00:54:52.367
intended to find a number
of a bunch of device APIs

00:54:52.367 --> 00:54:54.968
for web applications...

00:54:54.968 --> 00:54:56.367
and also security monitor.

00:54:56.367 --> 00:54:58.968
Which is Google's view
on that?

00:54:58.968 --> 00:55:02.434
Will you support
that activity, and uh...

00:55:02.434 --> 00:55:04.634
be active in that group?

00:55:04.634 --> 00:55:06.634
Fette: So I don't know
if we actually need

00:55:06.634 --> 00:55:08.667
a full W3C activity for this.

00:55:08.667 --> 00:55:10.834
I think a lot of these
are more straightforward,

00:55:10.834 --> 00:55:13.634
and we'll just have to see,
as time goes on,

00:55:13.634 --> 00:55:16.634
sort of what gains traction
and what doesn't.

00:55:16.634 --> 00:55:18.234
I don't know at this
point in time

00:55:18.234 --> 00:55:22.234
that we would say we support
a W3C activity.

00:55:22.234 --> 00:55:25.234
man: So you don't believe
it's a good idea

00:55:25.234 --> 00:55:30.033
to standardize device APIs
or, uh...

00:55:30.033 --> 00:55:33.033
Fette: I don't--
I think that as time goes on,

00:55:33.033 --> 00:55:36.634
we'll try to figure out what
APIs make sense to standardize.

00:55:36.634 --> 00:55:39.200
I'm not making any statements
about whether

00:55:39.200 --> 00:55:41.834
a W3C activity is necessary
for that or not.

00:55:41.834 --> 00:55:44.234
I think that, you know,
certainly we've got

00:55:44.234 --> 00:55:46.434
a lot of browser vendors
involved.

00:55:46.434 --> 00:55:48.434
We've got a lot of interested
developers involved

00:55:48.434 --> 00:55:51.033
and that as time goes on,
we'll see...

00:55:51.033 --> 00:55:53.434
we'll see what direction
this goes in.

00:55:53.434 --> 00:55:55.100
Papakipos: In general,

00:55:55.100 --> 00:55:57.033
the approach we found works best
with standardization,

00:55:57.033 --> 00:56:00.434
and I guess I found in my career
even before Google works best,

00:56:00.434 --> 00:56:04.100
is to prototype something first
and then try to standardize it.

00:56:04.100 --> 00:56:07.300
So for many of these things--
we're talking about today

00:56:07.300 --> 00:56:08.901
like peer-to-peer
and stuff like that--

00:56:08.901 --> 00:56:10.501
honestly, I don't know
what I would propose

00:56:10.501 --> 00:56:12.300
to the standards organization
today, right?

00:56:12.300 --> 00:56:13.501
The first step for me

00:56:13.501 --> 00:56:15.300
is to start sketching out
some APIs,

00:56:15.300 --> 00:56:17.501
prototyping some things,
seeing what actually works,

00:56:17.501 --> 00:56:19.300
getting some people
to try it.

00:56:19.300 --> 00:56:21.300
So for many of these,
we're not quite at the point

00:56:21.300 --> 00:56:22.901
of standardization yet.

00:56:22.901 --> 00:56:25.501
So far the model that the
standard orgs have been doing

00:56:25.501 --> 00:56:29.300
is to do individual standards
for these individual APIs.

00:56:29.300 --> 00:56:32.300
You're describing a somewhat
more overarching thing.

00:56:32.300 --> 00:56:34.901
There hasn't been any movement
in that direction thus far.

00:56:34.901 --> 00:56:36.501
It's been more
individual standards

00:56:36.501 --> 00:56:38.901
for specific proposed APIs.

00:56:38.901 --> 00:56:42.100
Fette: So let's take
another question. Thanks.

00:56:42.100 --> 00:56:45.901
man: Hi. So with HTML5,
and going forward,

00:56:45.901 --> 00:56:49.100
basically we'll be using
more and more

00:56:49.100 --> 00:56:51.100
of desktop capabilities.

00:56:51.100 --> 00:56:54.100
So wouldn't the browser
actually turn into

00:56:54.100 --> 00:56:56.501
a cross-platform runtime,

00:56:56.501 --> 00:57:01.200
which is capable of running
applications anyway?

00:57:01.200 --> 00:57:04.567
So are we actually
moving towards

00:57:04.567 --> 00:57:06.367
an application model only,

00:57:06.367 --> 00:57:07.767
or how is that
actually different?

00:57:07.767 --> 00:57:09.467
Apart from I do not need

00:57:09.467 --> 00:57:11.167
to probably install
and uninstall an application.

00:57:11.167 --> 00:57:13.767
What other differences
would I get?

00:57:13.767 --> 00:57:16.567
Papakipos: That is very much
how I think about it, right?

00:57:16.567 --> 00:57:19.767
We are, in a sense, making
this application runtime.

00:57:19.767 --> 00:57:21.567
That's what a browser is,
right?

00:57:21.567 --> 00:57:22.968
A browser is--in effect,

00:57:22.968 --> 00:57:24.968
to the applications
running on it,

00:57:24.968 --> 00:57:27.234
a browser's almost like
your operating system, right?

00:57:27.234 --> 00:57:29.234
You think when you're developing
a web application

00:57:29.234 --> 00:57:30.767
and debugging it,

00:57:30.767 --> 00:57:32.367
you're thinking more about
the browser you're in

00:57:32.367 --> 00:57:33.834
than the OS you're on.

00:57:33.834 --> 00:57:35.968
So I think we very much think
about it the way you describe.

00:57:35.968 --> 00:57:38.367
I think that's a fair thought.

00:57:38.367 --> 00:57:41.767
The browser is the runtime
for applications.

00:57:41.767 --> 00:57:43.567
man: Okay, so the only
difference would be

00:57:43.567 --> 00:57:46.167
that the applications would be
cross-platform, right?

00:57:46.167 --> 00:57:47.968
Papakipos: Yeah. And I think
that's one of the neat things

00:57:47.968 --> 00:57:49.567
that browsers bring
to the table

00:57:49.567 --> 00:57:51.167
is that if I know I run
in Safari,

00:57:51.167 --> 00:57:52.968
then I run in Safari
on Windows and Mac.

00:57:52.968 --> 00:57:55.367
And if I run in Firefox,

00:57:55.367 --> 00:57:57.367
I know I run on a variety
of operating systems,

00:57:57.367 --> 00:57:59.767
Linux and Windows
and Mac and others, right?

00:57:59.767 --> 00:58:01.167
So I agree.

00:58:01.167 --> 00:58:03.033
That's one of the really
cool things about the web,

00:58:03.033 --> 00:58:05.033
and it's one of the properties
we want to preserve

00:58:05.033 --> 00:58:06.834
as we add these new
capabilities.

00:58:06.834 --> 00:58:09.234
Great question.

00:58:09.234 --> 00:58:11.234
Cool, should we do
one more Moderator?

00:58:11.234 --> 00:58:12.634
Fette: I think we have time
for one more.

00:58:12.634 --> 00:58:15.067
So it's a question on,
"There are many HTML5 features

00:58:15.067 --> 00:58:17.567
"that support accessibility,
e.g., deep linking

00:58:17.567 --> 00:58:19.334
"into applications
for screen readers.

00:58:19.334 --> 00:58:21.234
"Can you detail what work
Google is doing

00:58:21.234 --> 00:58:23.734
to extend the web
in those directions?"

00:58:23.734 --> 00:58:26.234
So I think a lot of
the work that we're doing

00:58:26.234 --> 00:58:30.033
is trying to make
as much possible

00:58:30.033 --> 00:58:33.834
in HTML and open standards
as possible.

00:58:33.834 --> 00:58:37.434
So one great example for that
is the video tag.

00:58:37.434 --> 00:58:40.234
We're trying to work on
support for

00:58:40.234 --> 00:58:43.634
closed captioning in video
in multiple formats.

00:58:43.634 --> 00:58:46.634
We're looking at what do you
need to do subtitles?

00:58:46.634 --> 00:58:48.834
We're looking at simple
subtitles

00:58:48.834 --> 00:58:52.033
like SubRip and--

00:58:52.033 --> 00:58:54.434
more complicated things
like ASS

00:58:54.434 --> 00:58:59.234
so that it is possible to do...

00:58:59.234 --> 00:59:04.033
to make better accessibility
for these new APIs.

00:59:07.100 --> 00:59:08.367
Papakipos: Cool.
Fette: Okay.

00:59:08.367 --> 00:59:10.067
Papakipos: Okay. Time for
one more live question.

00:59:10.067 --> 00:59:11.334
Go ahead.

00:59:11.334 --> 00:59:15.501
man: Hi. We can see that
HTML5 is really powerful.

00:59:15.501 --> 00:59:17.501
Everybody is happy with that.

00:59:17.501 --> 00:59:20.701
But based on here
that the browser must be

00:59:20.701 --> 00:59:23.501
very complicated,
it becomes a monster,

00:59:23.501 --> 00:59:26.501
it has DBMS
to support SQL.

00:59:26.501 --> 00:59:30.100
It has codecs
to support videos.

00:59:30.100 --> 00:59:32.968
And it will become
bigger and bigger.

00:59:32.968 --> 00:59:37.901
How can we get this browser
into our mobile devices?

00:59:37.901 --> 00:59:39.501
Papakipos: Okay, so, yeah,

00:59:39.501 --> 00:59:41.501
the question is how do we get
these to mobile devices?

00:59:41.501 --> 00:59:44.501
Well, the good news is
they're on mobile devices.

00:59:44.501 --> 00:59:47.133
Many of the HTML5 APIs
I talked about today

00:59:47.133 --> 00:59:48.901
work on mobile browsers.

00:59:48.901 --> 00:59:50.501
And again, as with desktops,

00:59:50.501 --> 00:59:52.701
it varies depending
on which browser you're on

00:59:52.701 --> 00:59:54.701
and which phone device
that you're on.

00:59:54.701 --> 00:59:57.100
But a lot of the capabilities
I talked about

00:59:57.100 --> 00:59:59.901
like appcache and database
and geolocation

00:59:59.901 --> 01:00:01.701
work on the Android browser
today.

01:00:01.701 --> 01:00:03.000
Fette: And the iPhone browser.

01:00:03.000 --> 01:00:04.300
Papakipos:
And the iPhone browser.

01:00:04.300 --> 01:00:05.701
Yeah, we should give
a lot of props to iPhone.

01:00:05.701 --> 01:00:08.701
iPhone has been very early
in a lot of these HTML5 features

01:00:08.701 --> 01:00:10.300
for the browser for iPhone.

01:00:10.300 --> 01:00:12.901
So we're seeing some very
encouraging work going on

01:00:12.901 --> 01:00:14.300
in that area.

01:00:14.300 --> 01:00:16.901
The good news is the memory
and flash capacity

01:00:16.901 --> 01:00:18.501
and whatnot on the phones
are going up,

01:00:18.501 --> 01:00:20.300
so they do seem
to be adding these things.

01:00:20.300 --> 01:00:22.901
There may be some APIs
that phones don't add

01:00:22.901 --> 01:00:24.300
as quickly as desktop.

01:00:24.300 --> 01:00:26.701
I think a good example there
is 3D, right?

01:00:26.701 --> 01:00:30.100
3D graphics is just starting
to take hold, I think,

01:00:30.100 --> 01:00:32.701
for laptops doing web browsing.

01:00:32.701 --> 01:00:34.300
Not quite ready for that
on the phone.

01:00:34.300 --> 01:00:35.701
It will come.

01:00:35.701 --> 01:00:38.701
But I think we're a little bit
early on that still.

01:00:38.701 --> 01:00:40.300
So we will, in some cases,

01:00:40.300 --> 01:00:42.300
see the phone come
a little bit later.

01:00:42.300 --> 01:00:44.901
But the gap there is getting
shorter every year.

01:00:44.901 --> 01:00:47.934
It seems like phones
are starting to

01:00:47.934 --> 01:00:49.501
take up some of these features

01:00:49.501 --> 01:00:51.701
faster than I would have
predicted a couple years ago.

01:00:51.701 --> 01:00:53.501
Which is great to see.

01:00:53.501 --> 01:00:57.100
man: And as we can see
in the demo,

01:00:57.100 --> 01:01:01.100
we only support like
two, three codecs for video,

01:01:01.100 --> 01:01:05.167
and I believe in the future
and we all want to support

01:01:05.167 --> 01:01:07.367
almost all kinds of codecs.

01:01:07.367 --> 01:01:13.767
And for the CQ, we want to
be as good as the DBMS.

01:01:13.767 --> 01:01:17.901
So we have transactions,
we have the...

01:01:17.901 --> 01:01:19.767
Fette: I'm gonna jump in there
really quick

01:01:19.767 --> 01:01:21.167
with regard to video codecs.

01:01:21.167 --> 01:01:22.467
I don't know if we actually

01:01:22.467 --> 01:01:23.767
want to make it that
complicated.

01:01:23.767 --> 01:01:25.367
One of the nice things
that we have right now

01:01:25.367 --> 01:01:26.968
is it's something new
and we can define

01:01:26.968 --> 01:01:29.200
how do we make it simple
and work?

01:01:29.200 --> 01:01:30.767
Like if you're a browser vendor,
you have to worry about

01:01:30.767 --> 01:01:32.767
50 different image formats
right now.

01:01:32.767 --> 01:01:36.167
You have worry about GIF,
GIF98H, JPEG, JPEG2000,

01:01:36.167 --> 01:01:39.968
TGA, X--tons of codecs.

01:01:39.968 --> 01:01:41.968
And it's just complicated.

01:01:41.968 --> 01:01:43.167
So I think what we want to do

01:01:43.167 --> 01:01:45.167
is we want to make it simple
if we can.

01:01:45.167 --> 01:01:46.567
So I think we're running
out of time.

01:01:46.567 --> 01:01:47.968
Papakipos: Yep.
We have to wrap up.

01:01:47.968 --> 01:01:49.968
Thank you all for coming
and for the great questions.

01:01:49.968 --> 01:01:53.100
[applause]

