WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.010
BRUNO OLIVEIRA: All right,
welcome everyone.

00:00:03.010 --> 00:00:03.900
My name is Bruno Oliveira.

00:00:03.900 --> 00:00:06.230
And I work with Android
Developer Relations.

00:00:06.230 --> 00:00:09.340
And we're going to talk about
In-App Billing Version 3.

00:00:09.340 --> 00:00:10.790
So it's pretty cool.

00:00:10.790 --> 00:00:12.370
In-App Billing is actually
a pretty cool thing.

00:00:12.370 --> 00:00:14.920
And every time we talk to
someone about In-App Billing,

00:00:14.920 --> 00:00:17.620
we sort of expect them
to go like this.

00:00:17.620 --> 00:00:20.450
And but sometimes, in the
previous versions of the API,

00:00:20.450 --> 00:00:23.030
if you've worked with In-App
Billing V2, they

00:00:23.030 --> 00:00:25.250
sometimes go like that.

00:00:25.250 --> 00:00:27.500
And we really don't understand
why that happens.

00:00:27.500 --> 00:00:29.040
Because if they're all in
a billing spree, it's in

00:00:29.040 --> 00:00:30.450
command, right?

00:00:30.450 --> 00:00:32.820
So just to go back in
time a little bit,

00:00:32.820 --> 00:00:33.790
things used to be--

00:00:33.790 --> 00:00:34.710
well, things were
actually pretty

00:00:34.710 --> 00:00:37.650
straightforward back then.

00:00:37.650 --> 00:00:39.900
In V2, you would just have
to make a purchase,

00:00:39.900 --> 00:00:40.540
kind of like that.

00:00:40.540 --> 00:00:42.380
And then that's done, right?

00:00:42.380 --> 00:00:42.970
Easy.

00:00:42.970 --> 00:00:45.510
Well, actually, I'm just
oversimplifying a little bit.

00:00:45.510 --> 00:00:48.430
You actually had to have code
to handle the purchase date

00:00:48.430 --> 00:00:49.420
changes, like that.

00:00:49.420 --> 00:00:51.990
Still, it's not that
much code.

00:00:51.990 --> 00:00:54.330
But then you have that case
where the app could be

00:00:54.330 --> 00:00:56.690
sleeping when you got
that message.

00:00:56.690 --> 00:00:59.110
So you also had to have a
broadcast receiver to make

00:00:59.110 --> 00:01:03.240
sure that that didn't happen,
so just broadcast receiver.

00:01:03.240 --> 00:01:04.769
Still not complicated, right?

00:01:04.769 --> 00:01:06.870
And then, of course, the
broadcast receiver couldn't

00:01:06.870 --> 00:01:09.620
really run for very long because
it would get killed by

00:01:09.620 --> 00:01:10.150
the system.

00:01:10.150 --> 00:01:12.420
So it's probably good
practice [INAUDIBLE]

00:01:12.420 --> 00:01:15.340
a service, like pretty simple
and straightforward service,

00:01:15.340 --> 00:01:17.600
to handle that broadcast
receiver.

00:01:17.600 --> 00:01:21.600
And of course, then since you
can't credit for the purchases

00:01:21.600 --> 00:01:24.740
all the time because it's an
expensive API call, you

00:01:24.740 --> 00:01:26.920
probably need to persist at
using a database of some sort.

00:01:26.920 --> 00:01:27.470
But that's OK.

00:01:27.470 --> 00:01:28.490
Everyone loves databases.

00:01:28.490 --> 00:01:30.490
It's SQL.

00:01:30.490 --> 00:01:33.190
And well, why does it really
gets so complicated?

00:01:33.190 --> 00:01:36.750
And even this is an
oversimplification because you

00:01:36.750 --> 00:01:38.520
have to encrypt the database.

00:01:38.520 --> 00:01:40.430
Make sure that the users
don't tamper with it.

00:01:40.430 --> 00:01:42.840
So why does it get so
complicated with In-App

00:01:42.840 --> 00:01:44.360
Billing in the previous
versions?

00:01:44.360 --> 00:01:46.380
Well, let's start with
a simple case.

00:01:46.380 --> 00:01:49.110
So the user-- that's my
drawing of a user.

00:01:49.110 --> 00:01:52.780
Again, it's probably fortunate
that I write code better than

00:01:52.780 --> 00:01:53.800
I draw pictures.

00:01:53.800 --> 00:01:55.510
But then the user
buys something.

00:01:55.510 --> 00:01:56.900
And that gets delivered
to the app.

00:01:56.900 --> 00:01:57.730
No problem there, right?

00:01:57.730 --> 00:01:59.580
So standard.

00:01:59.580 --> 00:02:01.640
But what happens if the
application is not there to

00:02:01.640 --> 00:02:03.940
receive the package, because
applications on Android

00:02:03.940 --> 00:02:05.240
sometimes have other
stuff to do?

00:02:05.240 --> 00:02:07.180
So sometimes apps go to
sleep on Android.

00:02:07.180 --> 00:02:08.280
They take naps.

00:02:08.280 --> 00:02:10.020
So what if the app
is sleeping?

00:02:10.020 --> 00:02:12.760
Then a different component has
to pick up the package.

00:02:12.760 --> 00:02:16.490
And then that component has to
take care of delivering the

00:02:16.490 --> 00:02:19.720
item to the application when
it finally wakes up.

00:02:19.720 --> 00:02:21.860
And that's when the problems
might happen because that

00:02:21.860 --> 00:02:25.430
component right there could end
up losing your package.

00:02:25.430 --> 00:02:28.460
As you can see from this diagram
in V2, the developer

00:02:28.460 --> 00:02:31.220
had to write many components
that had to work together to

00:02:31.220 --> 00:02:33.150
ensure that the user's
purchase went

00:02:33.150 --> 00:02:34.280
to the right place.

00:02:34.280 --> 00:02:36.830
And of course, it can get
a little complicated.

00:02:36.830 --> 00:02:40.790
In comparison, this is what
the V3 diagram looks like.

00:02:40.790 --> 00:02:42.520
Actually, let me use a little
bit more of the slide.

00:02:42.520 --> 00:02:44.110
No, let's make it
a full slide.

00:02:44.110 --> 00:02:46.640
The diagram for V3 has
seven subcomponents.

00:02:46.640 --> 00:02:48.980
We're going to spend the next
several minutes discussing

00:02:48.980 --> 00:02:51.820
each component and subcomponent
in detail.

00:02:51.820 --> 00:02:52.860
Actually, just kidding.

00:02:52.860 --> 00:02:55.870
This is the actual diagram.

00:02:55.870 --> 00:02:56.920
So the [INAUDIBLE]

00:02:56.920 --> 00:03:00.910
in V3, apart from glass boxes,
is that API calls are now

00:03:00.910 --> 00:03:01.610
synchronous.

00:03:01.610 --> 00:03:03.460
This means that your application
gets a response

00:03:03.460 --> 00:03:03.980
right away.

00:03:03.980 --> 00:03:06.350
So if I want to-- and it's also
much more straightforward

00:03:06.350 --> 00:03:07.040
to think about too.

00:03:07.040 --> 00:03:10.610
So if I want to buy something
like 50 gold coins, all I have

00:03:10.610 --> 00:03:13.660
to do is make a request that
looks like buy 50 gold coins.

00:03:13.660 --> 00:03:16.910
Then if Google Play thinks a
purchase is OK, it's going to

00:03:16.910 --> 00:03:21.730
return something that's pretty
intuitive, like say OK.

00:03:21.730 --> 00:03:23.500
And you get that response
right away.

00:03:23.500 --> 00:03:25.690
If you worked with V2 before,
you're probably going to

00:03:25.690 --> 00:03:29.000
remember that our advice, the
advice we gave every time is

00:03:29.000 --> 00:03:32.650
that listing items, which we
call restoring purchases, was

00:03:32.650 --> 00:03:34.240
a very, very expensive
operation.

00:03:34.240 --> 00:03:36.960
Nobody could afford to do that
a whole bunch of times.

00:03:36.960 --> 00:03:39.560
So you couldn't just get away
with calling it every single

00:03:39.560 --> 00:03:40.550
time the app launched.

00:03:40.550 --> 00:03:44.140
You had to somehow keep a
client-side storage to know

00:03:44.140 --> 00:03:45.740
which items either owns.

00:03:45.740 --> 00:03:48.260
So that's no longer the case
because in V3, Google Play

00:03:48.260 --> 00:03:51.170
implements a client-side cache
and takes care of keeping that

00:03:51.170 --> 00:03:52.750
cache in sync with the server.

00:03:52.750 --> 00:03:55.730
So whenever you make your query
to the API, you're going

00:03:55.730 --> 00:03:58.230
to hit that client-side cache
instead of incurring that cost

00:03:58.230 --> 00:03:59.570
of a network round trip.

00:03:59.570 --> 00:04:01.970
So you can call it as many
times as you want.

00:04:01.970 --> 00:04:04.945
So listing the user's items has
actually become a pretty

00:04:04.945 --> 00:04:06.760
cheap operation.

00:04:06.760 --> 00:04:08.130
And you can do that as
often as you need.

00:04:08.130 --> 00:04:10.060
For example, you can do that
every time the application

00:04:10.060 --> 00:04:12.800
starts, which we figure is a
pretty natural place where you

00:04:12.800 --> 00:04:16.705
might want to ask yourself, what
items does this user own?

00:04:16.705 --> 00:04:18.860
All right, so I probably sound
like I'm trying to sell you

00:04:18.860 --> 00:04:19.390
something, right?

00:04:19.390 --> 00:04:21.570
So if you're a developer, I
mean, if you're in this room,

00:04:21.570 --> 00:04:23.550
you've probably grown a healthy
mistrust over the

00:04:23.550 --> 00:04:26.280
years of people who stand on a
stage like me and then don't

00:04:26.280 --> 00:04:28.650
show you any actual code.

00:04:28.650 --> 00:04:32.180
So let's stop with the sales
and talk about something

00:04:32.180 --> 00:04:33.150
that's entirely different.

00:04:33.150 --> 00:04:34.740
Let's talk about
selling stuff.

00:04:34.740 --> 00:04:38.730
So before you can make V3 API
calls, you have to check that

00:04:38.730 --> 00:04:39.650
it's actually supported.

00:04:39.650 --> 00:04:43.230
You can do that by calling the
isBillingSupported API call.

00:04:43.230 --> 00:04:45.440
The good news is that In-App
Billing is actually supported

00:04:45.440 --> 00:04:51.020
on a whole variety of devices,
so running Froyo and above and

00:04:51.020 --> 00:04:52.480
a recent version of
the Play Store.

00:04:52.480 --> 00:04:54.940
And there was actually more than
90% on the day that we

00:04:54.940 --> 00:04:57.290
launched, which was back
a few months ago.

00:04:57.290 --> 00:04:59.840
And right now, of course,
there's much more than that.

00:04:59.840 --> 00:05:03.190
So you don't have to be too
worried about that.

00:05:03.190 --> 00:05:05.610
Now how do you go ahead and get
a list of the items that

00:05:05.610 --> 00:05:06.480
the user owns?

00:05:06.480 --> 00:05:10.780
Well, we just call the
getPurchases API call.

00:05:10.780 --> 00:05:13.680
And remember that this call is
actually pretty cheap on V3.

00:05:13.680 --> 00:05:15.090
Notice also that you
get the results

00:05:15.090 --> 00:05:16.160
right away right there.

00:05:16.160 --> 00:05:19.360
So there's no funny call backs
or state management, no funny

00:05:19.360 --> 00:05:24.110
business you have to implement
to get the result right away.

00:05:24.110 --> 00:05:26.050
All right, so now this
is very important.

00:05:26.050 --> 00:05:28.550
It's that single moment your
application has been waiting

00:05:28.550 --> 00:05:30.430
for ever since the
user launched it.

00:05:30.430 --> 00:05:32.770
It's that profound moment in
modern technology that's very

00:05:32.770 --> 00:05:35.570
hard to explain to older
generations, where the user

00:05:35.570 --> 00:05:38.820
actually realizes that the
virtual item or service that

00:05:38.820 --> 00:05:41.540
you're offering them is so
valuable and they like it so

00:05:41.540 --> 00:05:44.030
much that they are actually
willing to give you

00:05:44.030 --> 00:05:45.400
real money for it.

00:05:45.400 --> 00:05:46.540
That's awesome, right?

00:05:46.540 --> 00:05:49.410
So it's at that singular moment
you have something

00:05:49.410 --> 00:05:51.810
that's really, really, really,
really very valuable.

00:05:51.810 --> 00:05:53.315
And I'm not talking
about those $0.99

00:05:53.315 --> 00:05:55.080
that you just made.

00:05:55.080 --> 00:05:57.750
What you have on that moment
is the user's trust.

00:05:57.750 --> 00:05:59.340
So they give you their money.

00:05:59.340 --> 00:06:01.250
And they expect to get
something in return.

00:06:01.250 --> 00:06:03.720
And nothing is more valuable to
an application than that.

00:06:03.720 --> 00:06:06.820
So what happens if at that
critical moment you take the

00:06:06.820 --> 00:06:09.880
user's money and then
you lose a purchase?

00:06:09.880 --> 00:06:11.930
That's going to be a very
bad user experience.

00:06:11.930 --> 00:06:14.930
So again, they've paid for
something and didn't get it.

00:06:14.930 --> 00:06:17.690
The least you can expect after
that is a pretty bad review.

00:06:17.690 --> 00:06:20.660
And of course, if you're
unlucky, it may be very, very

00:06:20.660 --> 00:06:23.960
much worse than that, as this
very reliable data that I in

00:06:23.960 --> 00:06:26.670
no way made up clearly
demonstrates.

00:06:26.670 --> 00:06:30.530
So you don't want the user to
lose their purchase ever,

00:06:30.530 --> 00:06:33.100
which is why one of the central
points in V3 was to

00:06:33.100 --> 00:06:35.320
make it easier to
do exactly that.

00:06:35.320 --> 00:06:37.390
So it was to make it easier
not to lose purchases.

00:06:37.390 --> 00:06:40.120
One of the ways we do that is
by making all items managed,

00:06:40.120 --> 00:06:42.520
which means that Google Play
keeps track of the ownership

00:06:42.520 --> 00:06:45.200
of those items for you.

00:06:45.200 --> 00:06:47.470
So going back to code, how do
you write this reliable

00:06:47.470 --> 00:06:48.240
purchase flow?

00:06:48.240 --> 00:06:49.890
First of all, you launch
the purchase screen.

00:06:49.890 --> 00:06:52.330
And that can be done by
calling getBuyIntent.

00:06:52.330 --> 00:06:55.450
So that's going to get to a
ready-to-use intent that you

00:06:55.450 --> 00:06:57.270
can then fire, and that's
going to bring you the

00:06:57.270 --> 00:06:58.260
purchase screen.

00:06:58.260 --> 00:07:00.010
And what does that look like?

00:07:00.010 --> 00:07:01.890
So I have a game called
Nostalgic Racer.

00:07:01.890 --> 00:07:04.570
And then I have 1,000 points,
1,000 nostalgic points, if you

00:07:04.570 --> 00:07:06.530
will, and that the user
can purchase.

00:07:06.530 --> 00:07:09.840
So notice that this dialogue is
pretty much it's simple and

00:07:09.840 --> 00:07:10.310
to the point.

00:07:10.310 --> 00:07:12.980
And the user doesn't lose
context, because it's overlaid

00:07:12.980 --> 00:07:13.990
on top of the game.

00:07:13.990 --> 00:07:18.980
This is an improvement we
launched a few months ago.

00:07:18.980 --> 00:07:21.270
So and there's really only
one button in that UI.

00:07:21.270 --> 00:07:22.440
And it really says, click me.

00:07:22.440 --> 00:07:22.760
Right?

00:07:22.760 --> 00:07:25.260
And so there's no context
lost, no confusion.

00:07:25.260 --> 00:07:27.970
And the result of the dialogue
when the user clicks Buy is

00:07:27.970 --> 00:07:29.020
that you're going to
get the results

00:07:29.020 --> 00:07:31.430
through an activity result.

00:07:31.430 --> 00:07:32.710
So what do you do
at the point?

00:07:32.710 --> 00:07:34.910
Well, at that point, you have
the purchase result.

00:07:34.910 --> 00:07:36.190
So you have the response code.

00:07:36.190 --> 00:07:37.740
You have the purchase data and
the purchase signature.

00:07:37.740 --> 00:07:38.980
Everything is right there.

00:07:38.980 --> 00:07:42.910
So when I say purchase data,
what I mean is just this J as

00:07:42.910 --> 00:07:44.530
an object that looks
kind of like that.

00:07:44.530 --> 00:07:45.715
So you have the order ID.

00:07:45.715 --> 00:07:48.170
You have the package name
that bought the product.

00:07:48.170 --> 00:07:50.920
You have the product ID, which
is also known as your SKU.

00:07:50.920 --> 00:07:52.910
You have the purchase time,
the purchase date, the

00:07:52.910 --> 00:07:53.810
developer payload.

00:07:53.810 --> 00:07:55.160
That's something very important
that we're going to

00:07:55.160 --> 00:07:56.460
talk about next.

00:07:56.460 --> 00:07:58.670
And you have the purchase
token, which is a long,

00:07:58.670 --> 00:08:00.290
alphanumeric string
that identifies

00:08:00.290 --> 00:08:01.860
that particular purchase.

00:08:01.860 --> 00:08:03.770
So that's pretty much all
there is for a simple

00:08:03.770 --> 00:08:04.230
application.

00:08:04.230 --> 00:08:06.560
So on startup, you call
getPurchases to figure out

00:08:06.560 --> 00:08:07.790
what the user owns.

00:08:07.790 --> 00:08:10.360
And then when the user wants
to purchase something, you

00:08:10.360 --> 00:08:11.140
call getBuyIntent.

00:08:11.140 --> 00:08:13.260
That gives you a ready-to-use
intent that you can fire.

00:08:13.260 --> 00:08:15.200
When you fire that intent, you
get the purchase flow.

00:08:15.200 --> 00:08:18.080
And then onActivityResult,
you handle that purchase.

00:08:18.080 --> 00:08:20.230
Notice that it's actually
pretty hard to lose a

00:08:20.230 --> 00:08:21.170
purchase that way.

00:08:21.170 --> 00:08:23.120
You would actually have to
make an effort to lose a

00:08:23.120 --> 00:08:25.790
purchase this way, because
even if the unthinkable

00:08:25.790 --> 00:08:29.380
happens and, say, your
application has a bug, what

00:08:29.380 --> 00:08:31.810
happens, if your application
crashes right after the

00:08:31.810 --> 00:08:34.840
purchase and never gets the
onActivityResult, that's not a

00:08:34.840 --> 00:08:36.659
problem because then the next
time the user is going to

00:08:36.659 --> 00:08:39.030
start the app, you're going
to call getPurchases.

00:08:39.030 --> 00:08:40.750
And you're going to realize
that the item's there.

00:08:40.750 --> 00:08:43.619
So the user has not
lost the purchase.

00:08:43.619 --> 00:08:46.270
All right, so phones are
funny things, actually.

00:08:46.270 --> 00:08:48.200
So they have a tendency to
fall into all sorts of

00:08:48.200 --> 00:08:50.760
liquids, like from sea
to margaritas.

00:08:50.760 --> 00:08:51.620
So they have a tendency.

00:08:51.620 --> 00:08:53.660
They have an attraction
to liquids that

00:08:53.660 --> 00:08:55.460
science doesn't explain.

00:08:55.460 --> 00:08:57.560
What also happens is that
phones tend to fall.

00:08:57.560 --> 00:09:00.060
But as you know, contrary to
popular belief, falling

00:09:00.060 --> 00:09:01.770
doesn't really do anything
to a phone.

00:09:01.770 --> 00:09:03.430
The problem is when the phone
collides with something

00:09:03.430 --> 00:09:05.100
massive, like say a planet.

00:09:05.100 --> 00:09:07.030
So the planet tends to
win in that case.

00:09:07.030 --> 00:09:08.290
But don't worry.

00:09:08.290 --> 00:09:11.230
That's OK, because the beauty of
managed In-App purchases is

00:09:11.230 --> 00:09:12.760
that they're like diamonds.

00:09:12.760 --> 00:09:13.490
They're forever.

00:09:13.490 --> 00:09:16.100
So even if the user deletes the
app or even if they switch

00:09:16.100 --> 00:09:18.370
to a different device, it's OK
because the purchase is still

00:09:18.370 --> 00:09:19.050
going to be there.

00:09:19.050 --> 00:09:20.310
And they haven't lost it.

00:09:20.310 --> 00:09:22.700
So this is good for things
that the user should only

00:09:22.700 --> 00:09:25.400
purchase once, like for
instance, a premium upgrade--

00:09:25.400 --> 00:09:27.390
even if the user switches
phones, you don't want them to

00:09:27.390 --> 00:09:28.420
lose that--

00:09:28.420 --> 00:09:31.870
an ad-free upgrade, special
items that the user can never

00:09:31.870 --> 00:09:34.670
lose, or even level packs,
content, and

00:09:34.670 --> 00:09:35.640
so on and so forth.

00:09:35.640 --> 00:09:38.390
So for all that, it's this
purchase once and use

00:09:38.390 --> 00:09:40.160
everywhere is a pretty
good approach.

00:09:40.160 --> 00:09:42.410
But sometimes, of course,
you don't want a

00:09:42.410 --> 00:09:43.690
purchase to be forever.

00:09:43.690 --> 00:09:46.120
You want to implement things
like consumable items, like

00:09:46.120 --> 00:09:49.620
health potions and whatnot, gold
coins that are put into

00:09:49.620 --> 00:09:51.720
the player's wallet and then
they go away, things that

00:09:51.720 --> 00:09:53.520
expires like season passes.

00:09:53.520 --> 00:09:56.090
And then you have to, of course,
to purchases that are

00:09:56.090 --> 00:09:56.840
not permanent.

00:09:56.840 --> 00:10:00.010
And this is what unmanaged
item was used for in V2.

00:10:00.010 --> 00:10:02.560
But of course, there are no
unmanaged items in V3.

00:10:02.560 --> 00:10:04.240
So how do you do that?

00:10:04.240 --> 00:10:07.410
Well, this is why we have the
consumption APIs on V3.

00:10:07.410 --> 00:10:10.030
So to understand how this works,
so somewhere in Google

00:10:10.030 --> 00:10:12.630
Play-- so there's a building
where Google Play works.

00:10:12.630 --> 00:10:15.500
And in the basement of that
building, every single user at

00:10:15.500 --> 00:10:16.850
Google has a box.

00:10:16.850 --> 00:10:18.830
And inside that box, with
my name on it, are

00:10:18.830 --> 00:10:19.660
all my virtual items.

00:10:19.660 --> 00:10:19.800
I know.

00:10:19.800 --> 00:10:20.320
I've been there.

00:10:20.320 --> 00:10:22.070
I've seen that box.

00:10:22.070 --> 00:10:25.230
When I buy a cool item, what
happens is that somebody goes

00:10:25.230 --> 00:10:27.580
in there and puts the cool item
inside the box that has

00:10:27.580 --> 00:10:28.270
my name on it.

00:10:28.270 --> 00:10:31.390
And from that point on, I know
I own the cool item.

00:10:31.390 --> 00:10:33.860
When I subsequently ask, what
items does Bruno own, through

00:10:33.860 --> 00:10:36.600
an API call, it returns well,
Bruno owns a cool item.

00:10:36.600 --> 00:10:39.270
Then what happens when I tell
the API to consume cool item?

00:10:39.270 --> 00:10:41.050
What happens is that
the item goes up in

00:10:41.050 --> 00:10:42.750
flames, just like that.

00:10:42.750 --> 00:10:45.750
And then, if I ask what items
does Bruno own, I don't own

00:10:45.750 --> 00:10:46.350
anything at all.

00:10:46.350 --> 00:10:48.200
So consumption is the opposite
of a purchase.

00:10:48.200 --> 00:10:49.870
When you consume, the
item goes away.

00:10:49.870 --> 00:10:51.950
As far as code goes, this is
how you consume an item.

00:10:51.950 --> 00:10:54.740
We would just call the
consumePurchase on the API.

00:10:54.740 --> 00:10:56.070
And then you give it
the purchase token

00:10:56.070 --> 00:10:57.460
associated with that item.

00:10:57.460 --> 00:10:59.360
Remember that the purchase token
is the same one that you

00:10:59.360 --> 00:11:01.340
got when you got the
getPurchases call.

00:11:01.340 --> 00:11:05.690
And then that's the purchase
token field on that JSON.

00:11:05.690 --> 00:11:08.180
And then, well, then
you call that.

00:11:08.180 --> 00:11:10.330
And the item's going
to be consumed.

00:11:10.330 --> 00:11:13.330
Now, there is one decision that
you're going to have to

00:11:13.330 --> 00:11:15.020
make, which is when to
consume something.

00:11:15.020 --> 00:11:16.830
So it's up to you how to
decide how to use the

00:11:16.830 --> 00:11:18.060
consumption API.

00:11:18.060 --> 00:11:19.340
The contract is that
when you consume

00:11:19.340 --> 00:11:21.360
something, it goes away.

00:11:21.360 --> 00:11:23.470
So we're going to talk about two
of the most used methods

00:11:23.470 --> 00:11:25.930
when you're using the
consumption API.

00:11:25.930 --> 00:11:29.310
First of all, maybe you want to
consume the item when it's

00:11:29.310 --> 00:11:31.790
actually used because that's, by
far, the most intuitive way

00:11:31.790 --> 00:11:33.070
to consume an item, right?

00:11:33.070 --> 00:11:35.300
Then you don't need to manage
the items yourself.

00:11:35.300 --> 00:11:37.970
Now the second approach, which
is pretty popular, is to

00:11:37.970 --> 00:11:39.960
consume it immediately
upon purchase.

00:11:39.960 --> 00:11:41.430
In that case, your
app takes care of

00:11:41.430 --> 00:11:43.200
managing the user's inventory.

00:11:43.200 --> 00:11:44.950
So you might call that inventory
a wallet, a purse, a

00:11:44.950 --> 00:11:47.900
bag, account, or
any other name.

00:11:47.900 --> 00:11:50.360
But you will manage the user's
inventory in that case.

00:11:50.360 --> 00:11:53.670
So to explain method
one quickly--

00:11:53.670 --> 00:11:55.240
so let's give an example.

00:11:55.240 --> 00:11:57.910
So again, that's me.

00:11:57.910 --> 00:11:59.990
It's a stick figure
character of me,

00:11:59.990 --> 00:12:02.120
anyway, somewhat slimmer.

00:12:02.120 --> 00:12:04.460
And those are the items that
I own in Google Play.

00:12:04.460 --> 00:12:06.290
So right now, it's an
empty box, right?

00:12:06.290 --> 00:12:09.665
Now, as we all know, the world
out there is a pretty

00:12:09.665 --> 00:12:12.080
dangerous place, especially for
stick figure characters

00:12:12.080 --> 00:12:13.180
like myself.

00:12:13.180 --> 00:12:15.780
So I decided before I go out
into the world, I'm going to

00:12:15.780 --> 00:12:17.070
buy a health potion.

00:12:17.070 --> 00:12:18.290
So I buy a health potion.

00:12:18.290 --> 00:12:21.160
And when I do that, it appears
in my inventory.

00:12:21.160 --> 00:12:23.260
Also like everybody else, I walk
around with a head point

00:12:23.260 --> 00:12:24.955
bar on top of my head
that tells me what

00:12:24.955 --> 00:12:26.300
my life points are.

00:12:26.300 --> 00:12:28.390
So now I have a potion
that I bought.

00:12:28.390 --> 00:12:30.200
And it's on my box
in Google Play.

00:12:30.200 --> 00:12:31.750
And I own that potion.

00:12:31.750 --> 00:12:36.420
Now I go out, and I venture into
the wild lands of bugs.

00:12:36.420 --> 00:12:38.535
And then I battle bugs,
and I write code.

00:12:38.535 --> 00:12:39.870
Pretty soon I realize
that I'm starting to

00:12:39.870 --> 00:12:41.060
get low on life points.

00:12:41.060 --> 00:12:43.070
And then I decide to
consume the potion.

00:12:43.070 --> 00:12:45.740
That's when your application
would call the consumption API

00:12:45.740 --> 00:12:48.830
to make that potion disappear
and then restore my life point

00:12:48.830 --> 00:12:50.770
bar back to what
it was before.

00:12:50.770 --> 00:12:53.490
So this is consumption
upon usage.

00:12:53.490 --> 00:12:57.060
Now, that's a perfectly good
method, except that it has one

00:12:57.060 --> 00:12:58.110
fundamental limitation.

00:12:58.110 --> 00:12:59.640
And that has to do with
how Google Play

00:12:59.640 --> 00:13:01.180
thinks about numbers.

00:13:01.180 --> 00:13:03.650
So Google Play, at least as far
as In-App purchases are

00:13:03.650 --> 00:13:06.140
concerned, only really
knows two numbers.

00:13:06.140 --> 00:13:07.920
And they are 0 and 1.

00:13:07.920 --> 00:13:10.470
So if the world out there is
really, really dangerous, and

00:13:10.470 --> 00:13:12.990
I think I'm going to need more
than one healing potion out

00:13:12.990 --> 00:13:15.280
there to battle bugs,
then I'm going to

00:13:15.280 --> 00:13:17.280
want to buy two potions.

00:13:17.280 --> 00:13:19.360
But what happens if I try
to buy a potion when I

00:13:19.360 --> 00:13:20.050
already have one?

00:13:20.050 --> 00:13:22.030
So Google Play is going to look
at me, and it's going to

00:13:22.030 --> 00:13:23.790
see that I have a potion
right there.

00:13:23.790 --> 00:13:25.130
And it's going to say,
that makes no sense.

00:13:25.130 --> 00:13:25.980
You already have a potion.

00:13:25.980 --> 00:13:28.060
Why are you trying to
buy a second one?

00:13:28.060 --> 00:13:31.100
So clearly, this approach
doesn't work if you want to

00:13:31.100 --> 00:13:34.290
have more than one item of each
kind, which is why method

00:13:34.290 --> 00:13:37.430
two might come in handy, which
is consuming upon purchase.

00:13:37.430 --> 00:13:39.880
In this case, your application
is actually responsible for

00:13:39.880 --> 00:13:41.340
managing the user's inventory.

00:13:41.340 --> 00:13:43.420
So notice my excellent
[INAUDIBLE] of a plastic bag

00:13:43.420 --> 00:13:46.150
right there, which is my
client-side inventory or

00:13:46.150 --> 00:13:46.980
service-side.

00:13:46.980 --> 00:13:48.890
Either way, it's managed
by my application.

00:13:48.890 --> 00:13:50.440
So I buy a potion.

00:13:50.440 --> 00:13:53.750
And now the potion exists in
my Google Play inventory.

00:13:53.750 --> 00:13:56.300
Then what I do is, regardless
of when the user is going to

00:13:56.300 --> 00:13:58.470
consume this, I consume
the potion right

00:13:58.470 --> 00:13:59.580
away through the API.

00:13:59.580 --> 00:14:04.210
And I credit that to my
in-game inventory.

00:14:04.210 --> 00:14:06.310
And then if the user buys a
second one, that's no problem

00:14:06.310 --> 00:14:08.660
because Google Play doesn't know
about a potion anymore.

00:14:08.660 --> 00:14:11.350
So I can buy a second potion and
consume it right away and

00:14:11.350 --> 00:14:12.680
credit it to my bag.

00:14:12.680 --> 00:14:15.580
So now I have two potions
in my inventory.

00:14:15.580 --> 00:14:18.190
If you're using method two, it's
very important not only

00:14:18.190 --> 00:14:22.810
to consume upon purchase,
but also upon startup.

00:14:22.810 --> 00:14:25.370
And then on startup, you check
if there any outstanding items

00:14:25.370 --> 00:14:26.830
that you should be consumed.

00:14:26.830 --> 00:14:29.380
This is going to be necessary,
for example, if your

00:14:29.380 --> 00:14:31.330
application crashed before
it consumed the item.

00:14:31.330 --> 00:14:33.210
So suppose the user
made the purchase.

00:14:33.210 --> 00:14:34.630
The purchase went through.

00:14:34.630 --> 00:14:36.470
But then your application
crashed.

00:14:36.470 --> 00:14:38.680
Then when your application
recovers and starts again,

00:14:38.680 --> 00:14:41.720
you're going to make sure that
on startup you check if

00:14:41.720 --> 00:14:44.870
there's any item in the user's
inventory that should have

00:14:44.870 --> 00:14:46.440
been consumed, but was not.

00:14:46.440 --> 00:14:49.980
So in our example, what I'm
going to do on startup is call

00:14:49.980 --> 00:14:50.640
getPurchases.

00:14:50.640 --> 00:14:52.640
And if I realize that I own a
potion that should have been

00:14:52.640 --> 00:14:54.980
consumed, I'm going to consume
it right away and then put it

00:14:54.980 --> 00:14:55.950
into the player's inventory.

00:14:55.950 --> 00:14:58.050
You don't even have to notify
the player that you're

00:14:58.050 --> 00:14:58.640
actually doing that.

00:14:58.640 --> 00:15:00.560
You can do that in
the background.

00:15:00.560 --> 00:15:03.280
So summarizing what we have so
far-- on startup, you would

00:15:03.280 --> 00:15:04.190
call getPurchases.

00:15:04.190 --> 00:15:06.450
Then if I notice that there is
a potion there that should

00:15:06.450 --> 00:15:08.990
have been consumed before,
I consume it.

00:15:08.990 --> 00:15:12.100
When the user wants to make a
purchase, I call getBuyIntent

00:15:12.100 --> 00:15:14.020
and then launch that intent
to get the purchase flow.

00:15:14.020 --> 00:15:15.860
And that's the window
that prompts

00:15:15.860 --> 00:15:17.530
the user to buy something.

00:15:17.530 --> 00:15:19.750
Then when I get the
onActivityResult call back,

00:15:19.750 --> 00:15:22.310
what I do is I check if the
purchase was successful.

00:15:22.310 --> 00:15:24.120
And then I consume the purchase
if the purchase was

00:15:24.120 --> 00:15:25.010
successful.

00:15:25.010 --> 00:15:28.650
And then when I get the consume
call back, I see if

00:15:28.650 --> 00:15:29.720
the consume was successful.

00:15:29.720 --> 00:15:32.720
If the consume was successful,
then I finally add the potion

00:15:32.720 --> 00:15:33.900
to the inventory.

00:15:33.900 --> 00:15:35.950
It's very important to wait for
the last part before you

00:15:35.950 --> 00:15:38.900
actually credit the item to the
user's inventory because

00:15:38.900 --> 00:15:41.580
what may happen is that--
remember that the Google Play

00:15:41.580 --> 00:15:43.070
inventory is the same
for every device.

00:15:43.070 --> 00:15:45.410
So it's per user and
not per device.

00:15:45.410 --> 00:15:47.830
So if I own a potion on one
device, then I own a potion on

00:15:47.830 --> 00:15:48.750
all devices.

00:15:48.750 --> 00:15:50.970
So when you are going to consume
that potion, you

00:15:50.970 --> 00:15:54.920
should make sure that you only
created the potion once.

00:15:54.920 --> 00:15:57.040
So if you try to consume the
same potion from several

00:15:57.040 --> 00:15:58.380
devices, only one of those

00:15:58.380 --> 00:15:59.850
consumptions is going to succeed.

00:15:59.850 --> 00:16:00.700
So that's guaranteed.

00:16:00.700 --> 00:16:03.330
So this means you should only
credit the potion once it's

00:16:03.330 --> 00:16:05.760
been successfully consumed.

00:16:05.760 --> 00:16:07.250
All right?

00:16:07.250 --> 00:16:10.470
So In-App Billing V3 also brings
a long-anticipated

00:16:10.470 --> 00:16:13.150
feature that developers have
been really asking for a long

00:16:13.150 --> 00:16:16.585
time, which is the ability to
query for a product's details

00:16:16.585 --> 00:16:20.070
from code, like for instance,
title, description, and price.

00:16:20.070 --> 00:16:22.390
So if you take a look at the
API, you're going to find this

00:16:22.390 --> 00:16:24.920
method call, which is called
getSkuDetails.

00:16:24.920 --> 00:16:26.740
It's actually pretty
straightforward.

00:16:26.740 --> 00:16:29.390
You just specify the list of
SKUs that you want to get

00:16:29.390 --> 00:16:30.580
information about.

00:16:30.580 --> 00:16:32.440
And when you make that call,
the API returns the

00:16:32.440 --> 00:16:34.160
information in a bundle.

00:16:34.160 --> 00:16:37.030
And that bundle kind
of looks like this.

00:16:37.030 --> 00:16:40.420
So it has your product's ID,
which is the SKU, the type,

00:16:40.420 --> 00:16:43.140
whether it's in a product or a
subscription, the price, the

00:16:43.140 --> 00:16:46.020
title, description, so
on and so forth.

00:16:46.020 --> 00:16:48.560
One thing that's pretty nice
about this is that the price

00:16:48.560 --> 00:16:50.820
is actually returned in a way
that's formatted according to

00:16:50.820 --> 00:16:52.310
the user's locale.

00:16:52.310 --> 00:16:54.240
So it's going to look right to
the user when you display it

00:16:54.240 --> 00:16:55.220
on the screen.

00:16:55.220 --> 00:16:59.540
However, one thing to be careful
about is that price is

00:16:59.540 --> 00:17:02.130
only formatted for display
and not for parsing.

00:17:02.130 --> 00:17:03.650
So don't try to use
that as a number.

00:17:03.650 --> 00:17:05.280
Don't try to add two together.

00:17:05.280 --> 00:17:07.680
This is just a number that's
formatted for display only.

00:17:07.680 --> 00:17:10.280
And you can show
it to the user.

00:17:10.280 --> 00:17:12.040
Now let's talk about
subscriptions.

00:17:12.040 --> 00:17:14.369
So in V3, that's actually
pretty simple too.

00:17:14.369 --> 00:17:16.660
If you have used V2, you'll
remember that there was a

00:17:16.660 --> 00:17:19.319
whole bunch of messages and
call backs and broadcast

00:17:19.319 --> 00:17:22.270
receivers that you had to write
to implement and to know

00:17:22.270 --> 00:17:23.849
the status of a particular
subscription

00:17:23.849 --> 00:17:24.720
at any given time.

00:17:24.720 --> 00:17:26.390
And there were asynchronous
call backs

00:17:26.390 --> 00:17:27.310
that you had to implement.

00:17:27.310 --> 00:17:28.880
But in V3, it's much easier.

00:17:28.880 --> 00:17:30.450
They are actually
just like items.

00:17:30.450 --> 00:17:31.700
They're much simpler.

00:17:34.480 --> 00:17:36.710
To check if substitutions are
supported, you can call

00:17:36.710 --> 00:17:38.090
isBillingSupported API call.

00:17:38.090 --> 00:17:40.670
So it's the same as before,
except you pass

00:17:40.670 --> 00:17:41.920
subs instead of in-app.

00:17:41.920 --> 00:17:43.900
And then that's going to
return whether or not

00:17:43.900 --> 00:17:46.000
subscription are supported
on that device.

00:17:46.000 --> 00:17:47.660
So it's important to
make that check.

00:17:47.660 --> 00:17:50.180
Now launching the purchase flow
for a subscription is not

00:17:50.180 --> 00:17:51.920
really very different from
launching the purchase flow

00:17:51.920 --> 00:17:53.280
for a regular item.

00:17:53.280 --> 00:17:54.910
So we just use getBuyIntent.

00:17:54.910 --> 00:17:58.060
But except that instead of
saying in-app, you say subs.

00:17:58.060 --> 00:18:01.260
And then you go past the item
type, and then get an intent.

00:18:01.260 --> 00:18:02.300
You can launch the intent.

00:18:02.300 --> 00:18:06.130
And that brings the purchase
window, just like did before.

00:18:06.130 --> 00:18:08.750
One thing to be careful
about is that

00:18:08.750 --> 00:18:10.250
subscriptions can't be consumed.

00:18:10.250 --> 00:18:12.340
So you cannot use the
consumption API on a

00:18:12.340 --> 00:18:13.430
subscription.

00:18:13.430 --> 00:18:15.810
If the effect that you're trying
to accomplish is to

00:18:15.810 --> 00:18:18.050
cancel a subscription, then
this is another way to do.

00:18:18.050 --> 00:18:21.020
You're going to have to do that
through the server-side,

00:18:21.020 --> 00:18:23.208
as we're going to see next.

00:18:23.208 --> 00:18:26.490
All right, so remember how I
said that in V2 it's actually

00:18:26.490 --> 00:18:28.000
pretty difficult to know
what's the state of a

00:18:28.000 --> 00:18:28.720
subscription?

00:18:28.720 --> 00:18:31.180
So in V3, it's actually pretty
easy because you just call

00:18:31.180 --> 00:18:32.280
getPurchases.

00:18:32.280 --> 00:18:34.170
When you call getPurchases
with the item type set to

00:18:34.170 --> 00:18:38.030
subs, it's going to return all
the subscriptions that are

00:18:38.030 --> 00:18:39.930
actually active right now.

00:18:39.930 --> 00:18:42.300
What I mean by actually active
is that while subscriptions

00:18:42.300 --> 00:18:45.190
are either in the active state
or in the trial state--

00:18:45.190 --> 00:18:47.270
the trial state that the user
can have before buying the

00:18:47.270 --> 00:18:48.250
subscription--

00:18:48.250 --> 00:18:52.350
those are going to appear in
your getPurchases results.

00:18:52.350 --> 00:18:54.870
Now once a subscription expires,
you're not going to

00:18:54.870 --> 00:18:56.650
get any notification of that.

00:18:56.650 --> 00:18:58.550
But then the next time you
call getPurchases--

00:18:58.550 --> 00:19:00.950
which, remember, became a pretty
cheap call, so every

00:19:00.950 --> 00:19:03.650
time your application starts,
you can call getPurchases.

00:19:03.650 --> 00:19:05.670
So the very next time you call
getPurchases, what's going to

00:19:05.670 --> 00:19:08.630
happen is that the expired
subscription is no longer

00:19:08.630 --> 00:19:09.510
going to be there.

00:19:09.510 --> 00:19:11.150
So it does not appear
on getPurchases.

00:19:11.150 --> 00:19:13.520
So your whole logic can be, if
I see the subscription in

00:19:13.520 --> 00:19:15.700
getPurchases, then I provide
the content.

00:19:15.700 --> 00:19:17.680
If I don't see the subscription
in getPurchases,

00:19:17.680 --> 00:19:18.680
then I don't provide
the content.

00:19:18.680 --> 00:19:21.460
It's much easier logic than
trying to manage what's a

00:19:21.460 --> 00:19:24.360
subscription state at
any given point.

00:19:24.360 --> 00:19:25.960
So how about canceled
subscriptions?

00:19:25.960 --> 00:19:28.320
Well, we do the right thing for
canceled subscriptions as

00:19:28.320 --> 00:19:30.140
well, which is canceled
subscriptions are actually

00:19:30.140 --> 00:19:34.590
going to appear in getPurchases
until the end of

00:19:34.590 --> 00:19:37.260
the billing period that
the user has paid for.

00:19:37.260 --> 00:19:39.590
So after that expires,
they cease to appear.

00:19:39.590 --> 00:19:42.810
So you may see canceled
subscriptions in getPurchases.

00:19:42.810 --> 00:19:45.190
And that may happen because
the user has paid for the

00:19:45.190 --> 00:19:46.880
billing period, but they
have canceled it.

00:19:46.880 --> 00:19:48.880
So on the next billing
period, that

00:19:48.880 --> 00:19:50.630
subscription's going to expire.

00:19:50.630 --> 00:19:54.320
So as far as the developer's
concerned, all they have to do

00:19:54.320 --> 00:19:55.800
is check if it's in
getPurchases.

00:19:55.800 --> 00:19:57.230
If it is, you deliver
the content.

00:19:57.230 --> 00:19:59.520
If it's not, you
don't deliver.

00:19:59.520 --> 00:20:02.360
Now remember that Google Play
actually now has a local cache

00:20:02.360 --> 00:20:04.670
on the client, which means
that when a subscription

00:20:04.670 --> 00:20:06.660
expires, it might actually
take some time for it to

00:20:06.660 --> 00:20:08.440
disappear from getPurchases.

00:20:08.440 --> 00:20:09.760
Usually that doesn't really
take more than

00:20:09.760 --> 00:20:11.300
24 hours, of course.

00:20:11.300 --> 00:20:14.620
So that cache is refreshed
every 24 hours at most.

00:20:14.620 --> 00:20:17.090
So you might actually see a
subscription there that has

00:20:17.090 --> 00:20:17.780
already expired.

00:20:17.780 --> 00:20:19.500
But then, hopefully, that's
only going to

00:20:19.500 --> 00:20:21.670
last 24 hours or so.

00:20:21.670 --> 00:20:23.980
That's usually not a big deal.

00:20:23.980 --> 00:20:24.890
All right?

00:20:24.890 --> 00:20:27.230
So when you're making any API
calls, it's very important to

00:20:27.230 --> 00:20:28.860
be careful about
the UI thread.

00:20:28.860 --> 00:20:31.380
So the UI thread's something
that's very delicate.

00:20:31.380 --> 00:20:31.630
Why?

00:20:31.630 --> 00:20:33.870
Because if you block the UI
thread, your application is

00:20:33.870 --> 00:20:35.410
going to stop responding,
of course.

00:20:35.410 --> 00:20:38.940
And in the Android world, I
mean, actually in any mobile

00:20:38.940 --> 00:20:42.900
application, that's not just
something that's frowned upon.

00:20:42.900 --> 00:20:45.050
The system actually punishes
your app for that.

00:20:45.050 --> 00:20:48.370
And the punishment, of course,
this is very, very friendly

00:20:48.370 --> 00:20:49.680
dialogue box.

00:20:49.680 --> 00:20:53.100
So if you don't want the users
to see this dialogue box,

00:20:53.100 --> 00:20:55.670
because users just absolutely
love that dialogue box, then

00:20:55.670 --> 00:20:57.690
you shouldn't ever block the
UI thread by calling

00:20:57.690 --> 00:21:00.490
[INAUDIBLE] that take a
long time to return.

00:21:00.490 --> 00:21:03.970
Particularly in the In-App
Billing API, the safe ones to

00:21:03.970 --> 00:21:06.160
call are isBillingSupported
and getBuyIntent.

00:21:06.160 --> 00:21:08.330
Those two you can call safely
from the UI thread because

00:21:08.330 --> 00:21:09.740
they're returned right away.

00:21:09.740 --> 00:21:12.910
Now the other three that we
talked about are not safe to

00:21:12.910 --> 00:21:14.840
call from the UI thread because
they might actually

00:21:14.840 --> 00:21:15.910
take a while to execute.

00:21:15.910 --> 00:21:18.030
So if you're calling
getPurchases, consumePurchase,

00:21:18.030 --> 00:21:21.200
getSkuDetails, remember that
they might actually take a

00:21:21.200 --> 00:21:21.900
while to execute.

00:21:21.900 --> 00:21:24.160
So you definitely do not want
to call them from the UI

00:21:24.160 --> 00:21:26.425
thread in order not to
risk a application

00:21:26.425 --> 00:21:27.690
not responding error.

00:21:27.690 --> 00:21:30.070
So always call them from a
separate thread, async task,

00:21:30.070 --> 00:21:30.710
whatever else.

00:21:30.710 --> 00:21:32.950
But whatever you do, don't
block the UI thread while

00:21:32.950 --> 00:21:34.710
waiting for that response.

00:21:34.710 --> 00:21:37.170
If you download the sample
that's called Trivial Drive,

00:21:37.170 --> 00:21:39.900
it implements that for you
because it has asynchronous

00:21:39.900 --> 00:21:42.850
wrappers so that you can
actually call them from the UI

00:21:42.850 --> 00:21:45.890
thread and get a call back
when they are done.

00:21:45.890 --> 00:21:47.620
Now many developers
don't know this.

00:21:47.620 --> 00:21:50.550
But there's actually a
server-side API that allows

00:21:50.550 --> 00:21:52.270
you to check for
subscriptions.

00:21:52.270 --> 00:21:55.250
The way it works is this API
allows you to take a

00:21:55.250 --> 00:21:57.990
particular subscription and then
query whether or not it's

00:21:57.990 --> 00:22:01.280
valid, when it's going to
expire, and whether or not

00:22:01.280 --> 00:22:03.210
it's going to renew itself
automatically.

00:22:03.210 --> 00:22:06.030
It also allows you to cancel an
existing subscription from

00:22:06.030 --> 00:22:07.180
the server side.

00:22:07.180 --> 00:22:10.850
So how do you go ahead and
specify a particular

00:22:10.850 --> 00:22:11.460
subscription?

00:22:11.460 --> 00:22:15.547
Well, remember the purchase data
on the client side when

00:22:15.547 --> 00:22:16.510
you call getPurchases?

00:22:16.510 --> 00:22:19.500
So one of the fields in that
is called purchaseToken.

00:22:19.500 --> 00:22:22.560
So that identifies that
particular subscription for

00:22:22.560 --> 00:22:23.760
that particular user.

00:22:23.760 --> 00:22:27.060
So that's the string that you
need to use on the server side

00:22:27.060 --> 00:22:28.390
to call that API.

00:22:28.390 --> 00:22:31.360
So this is what I know of what
a sample API call looks like.

00:22:31.360 --> 00:22:32.610
It's basically REST.

00:22:32.610 --> 00:22:34.810
And I'm calling the state of
that particular subscription.

00:22:34.810 --> 00:22:35.510
So I pass it to you.

00:22:35.510 --> 00:22:37.060
Your package name goes there.

00:22:37.060 --> 00:22:40.400
Your subscription ID, so this is
the SKU of the subscription

00:22:40.400 --> 00:22:41.190
goes there.

00:22:41.190 --> 00:22:44.720
And then that's the token that
you get from the client-side.

00:22:44.720 --> 00:22:46.910
The response looks something
like this.

00:22:46.910 --> 00:22:49.950
And it gives you when the
subscription started, when

00:22:49.950 --> 00:22:52.800
it's going to expire, and then
whether or not it's going to

00:22:52.800 --> 00:22:54.000
renew automatically.

00:22:54.000 --> 00:22:56.760
If you want to know more about
this API, there's that URL

00:22:56.760 --> 00:22:57.160
right there.

00:22:57.160 --> 00:22:59.800
So there's the full
specification of that API.

00:22:59.800 --> 00:23:03.550
It also allows you to cancel a
subscription from the server

00:23:03.550 --> 00:23:07.130
side, which might be useful
for your application.

00:23:07.130 --> 00:23:09.480
Now, next, let's talk about
a very important

00:23:09.480 --> 00:23:11.750
topic, which is security.

00:23:11.750 --> 00:23:15.120
Now security is important
because, believe it or not,

00:23:15.120 --> 00:23:17.030
there are some shady characters
out there in the

00:23:17.030 --> 00:23:18.540
interwebs who might
want to take your

00:23:18.540 --> 00:23:20.140
stuff without paying.

00:23:20.140 --> 00:23:21.750
I know, it's shocking.

00:23:21.750 --> 00:23:23.500
And they are out there on
the web, on the loose.

00:23:23.500 --> 00:23:25.060
So it's very important to
implement some measure of

00:23:25.060 --> 00:23:26.340
security in applications.

00:23:26.340 --> 00:23:29.530
So I don't really know what
the technical term is.

00:23:29.530 --> 00:23:32.020
But I'm going to say they're
pirates, mostly because we

00:23:32.020 --> 00:23:34.320
spent a really long time drawing
this character, and I

00:23:34.320 --> 00:23:36.400
wanted to use it in
a presentation.

00:23:36.400 --> 00:23:38.730
So actually, I think they're
called crackers.

00:23:38.730 --> 00:23:40.250
But let's go with pirates.

00:23:40.250 --> 00:23:43.310
So anyway, anytime you see
a purchase result in your

00:23:43.310 --> 00:23:45.870
application, you should always
ask yourself if you should

00:23:45.870 --> 00:23:47.660
trust the purchase or not.

00:23:47.660 --> 00:23:51.090
Of course, a pirate's is going
to be-- pirates spend all day

00:23:51.090 --> 00:23:52.200
being a pirate.

00:23:52.200 --> 00:23:55.500
And their job is to convince you
that a particular purchase

00:23:55.500 --> 00:23:56.690
is correct.

00:23:56.690 --> 00:23:59.990
And of course, your job is to
detect that lie and see that

00:23:59.990 --> 00:24:01.390
that purchase is a fake.

00:24:01.390 --> 00:24:03.040
So how do you go ahead
and do that?

00:24:03.040 --> 00:24:06.250
Well, depending on your
particular type of app and

00:24:06.250 --> 00:24:08.400
market, piracy might
be a small problem,

00:24:08.400 --> 00:24:09.320
might be a big problem.

00:24:09.320 --> 00:24:11.020
That's going to depend
on your type of app.

00:24:11.020 --> 00:24:14.070
But you should always think in
terms of risk model that takes

00:24:14.070 --> 00:24:16.690
into account several variables,
such as the target

00:24:16.690 --> 00:24:19.020
audience, the item's value, the
likelihood that somebody

00:24:19.020 --> 00:24:21.815
would make a fake purchase, the
technical difficulty in

00:24:21.815 --> 00:24:22.920
making a purchase.

00:24:22.920 --> 00:24:25.290
And based on that, make a
decision on how much security

00:24:25.290 --> 00:24:25.860
to implement.

00:24:25.860 --> 00:24:27.730
Of course, in the best case
scenario, we implement all

00:24:27.730 --> 00:24:29.350
possible security.

00:24:29.350 --> 00:24:31.280
But then you might have to
balance that against

00:24:31.280 --> 00:24:32.750
engineering time and
so on and so forth.

00:24:32.750 --> 00:24:35.050
So it's important to be
conscious of that.

00:24:35.050 --> 00:24:36.960
Of course, nobody can stop
piracy all together.

00:24:36.960 --> 00:24:38.980
I would be lying to you if I
said that I had a method to

00:24:38.980 --> 00:24:40.180
stop piracy.

00:24:40.180 --> 00:24:42.280
But of course, you should always
make life hard for

00:24:42.280 --> 00:24:44.150
piracy because that's fun.

00:24:44.150 --> 00:24:47.230
So here's some of the defenses
that you can employ to make a

00:24:47.230 --> 00:24:48.950
pirate's life hard.

00:24:48.950 --> 00:24:51.770
First of all is use our
developer payload, and then

00:24:51.770 --> 00:24:53.810
use signature verification,
and also server-side

00:24:53.810 --> 00:24:54.460
validation.

00:24:54.460 --> 00:24:56.850
We're going to give a quick
overview of each one of those.

00:24:56.850 --> 00:24:59.160
So what's this developer
payload thing?

00:24:59.160 --> 00:25:00.660
Well, developer payload
is really just a

00:25:00.660 --> 00:25:02.070
fancy term for a tag.

00:25:02.070 --> 00:25:03.672
So it's just a tag that
gets attached to

00:25:03.672 --> 00:25:04.870
a particular purchase.

00:25:04.870 --> 00:25:06.480
It's an arbitrary string.

00:25:06.480 --> 00:25:08.820
Anytime you launch the purchase
flow, you can specify

00:25:08.820 --> 00:25:09.940
what the string is.

00:25:09.940 --> 00:25:11.740
It's just a string that gets
attached to the purchase.

00:25:11.740 --> 00:25:14.340
And then every single time you
credit for that purchase and

00:25:14.340 --> 00:25:16.800
you get that purchase, that
string's going to be there.

00:25:16.800 --> 00:25:19.800
Now, of course, you can write
anything into it.

00:25:19.800 --> 00:25:23.020
But of course, one of the most
useful applications of this is

00:25:23.020 --> 00:25:25.540
to identify the owner of
a particular purchase.

00:25:25.540 --> 00:25:26.775
Why do you want to identify
the owner of

00:25:26.775 --> 00:25:27.490
a particular purchase?

00:25:27.490 --> 00:25:29.630
Because then it makes it very
hard for somebody to take the

00:25:29.630 --> 00:25:33.690
purchase data and then replay
it into s different device.

00:25:33.690 --> 00:25:37.110
So again, that's me, the stick
figure, of course.

00:25:37.110 --> 00:25:37.890
Like everyone else--

00:25:37.890 --> 00:25:39.550
I mean, it's a scientific
fact.

00:25:39.550 --> 00:25:42.510
It's been scientifically proven
that everyone, everyone

00:25:42.510 --> 00:25:44.390
has an evil twin somewhere.

00:25:44.390 --> 00:25:47.080
Now this is Onurb,
my evil twin.

00:25:47.080 --> 00:25:48.790
He is not nearly as
honest as I am.

00:25:48.790 --> 00:25:52.110
So last week, he picked up my
device and did a database dump

00:25:52.110 --> 00:25:55.510
of the items that I had and
then replayed them on his

00:25:55.510 --> 00:25:58.170
device, hoping to get some
of my items for free.

00:25:58.170 --> 00:26:00.650
So of course, if your
application is using developer

00:26:00.650 --> 00:26:02.340
payload, this is what's
going to happen.

00:26:02.340 --> 00:26:05.050
So Onurb, my evil twin, is
going to run your app.

00:26:05.050 --> 00:26:07.570
And then you're going to check
what items does Onurb own.

00:26:07.570 --> 00:26:10.220
And you're going to
see this purchase.

00:26:10.220 --> 00:26:13.020
Do you see anything suspicious
at all about this purchase?

00:26:13.020 --> 00:26:14.440
Well, of course.

00:26:14.440 --> 00:26:16.350
The developer payload says
it belongs to Bruno.

00:26:16.350 --> 00:26:18.030
But it's Onurb that's
running the app.

00:26:18.030 --> 00:26:20.220
Of course, on a real
application, you would not use

00:26:20.220 --> 00:26:22.360
first names because some people
have evil twins that

00:26:22.360 --> 00:26:23.650
have the same first name.

00:26:23.650 --> 00:26:28.330
So you would not use names, but
some unique ID, like for

00:26:28.330 --> 00:26:30.760
instance, the Google+ ID
or something like that.

00:26:30.760 --> 00:26:32.950
Also it's actually pretty hard
to fake that signature,

00:26:32.950 --> 00:26:36.280
because every purchase comes
signed from the server.

00:26:36.280 --> 00:26:39.280
So it's not actually trivial
just to change that purchase.

00:26:39.280 --> 00:26:42.060
So speaking about signature
verification, well, what is

00:26:42.060 --> 00:26:43.570
this thing about signature
verification?

00:26:43.570 --> 00:26:47.280
Well, every application has a
public key and a private key.

00:26:47.280 --> 00:26:49.030
The private key never
leaves Google.

00:26:49.030 --> 00:26:51.870
So the private key is only
known to Google.

00:26:51.870 --> 00:26:54.410
And you know the public key
for your application.

00:26:54.410 --> 00:26:57.010
What this means is that whenever
somebody signs

00:26:57.010 --> 00:26:59.140
something with your private key
and that, of course, by

00:26:59.140 --> 00:27:01.310
definition, has to be Google
because we are the only ones

00:27:01.310 --> 00:27:04.410
that have the private key, then
you can use the public

00:27:04.410 --> 00:27:06.430
key for your app to verify
that signature to know

00:27:06.430 --> 00:27:07.740
that we signed it.

00:27:07.740 --> 00:27:11.080
So Google Play signs every
single purchase that goes

00:27:11.080 --> 00:27:13.760
through Google Play gets signed
with your application's

00:27:13.760 --> 00:27:16.370
private key, which means that,
when you get a purchase on

00:27:16.370 --> 00:27:18.380
your application, you should use
your application's public

00:27:18.380 --> 00:27:21.070
key to check that the
signature matches.

00:27:21.070 --> 00:27:22.730
If it does not, it's a fake.

00:27:22.730 --> 00:27:24.430
It's not actually difficult
to implement signature

00:27:24.430 --> 00:27:25.050
verification.

00:27:25.050 --> 00:27:26.850
But if you don't want to
implement that, that's

00:27:26.850 --> 00:27:28.230
actually available
in our sample.

00:27:28.230 --> 00:27:30.880
So Trivial Drive has a helper
class that does all that

00:27:30.880 --> 00:27:32.490
signature verification
for you.

00:27:32.490 --> 00:27:34.410
So you don't even have
to implement that.

00:27:34.410 --> 00:27:36.350
Now, all right, even though--

00:27:36.350 --> 00:27:38.200
client-side signature
verification is

00:27:38.200 --> 00:27:40.590
pretty cool, right?

00:27:40.590 --> 00:27:43.400
But don't think that client-side
security alone is

00:27:43.400 --> 00:27:44.590
going to be enough
for your app.

00:27:44.590 --> 00:27:46.570
That would be a mistake because
regardless of how

00:27:46.570 --> 00:27:49.410
difficult you make things,
the reality is that

00:27:49.410 --> 00:27:50.670
phones can be hacked.

00:27:50.670 --> 00:27:52.110
So you should definitely
secure the

00:27:52.110 --> 00:27:53.690
server side as well.

00:27:53.690 --> 00:27:56.450
So when we say server-side
verification, what we mean is

00:27:56.450 --> 00:27:58.690
that on the server side, you
should check the signature

00:27:58.690 --> 00:28:00.620
again just to make sure that
the client does not

00:28:00.620 --> 00:28:01.590
compromise.

00:28:01.590 --> 00:28:04.460
And then one cool thing you can
do on the server, which

00:28:04.460 --> 00:28:06.500
you can't do on the client, is
that you can check the order

00:28:06.500 --> 00:28:09.170
number because the server is
seeing every single purchase

00:28:09.170 --> 00:28:10.620
that comes from every
single person.

00:28:10.620 --> 00:28:13.210
So every purchase comes
with an order number.

00:28:13.210 --> 00:28:14.240
And they should be unique.

00:28:14.240 --> 00:28:16.960
So if you ever see a second
purchase with the same number

00:28:16.960 --> 00:28:19.330
as a purchase that you've
already provisioned before,

00:28:19.330 --> 00:28:23.040
then you know that that second
purchase is a fake.

00:28:23.040 --> 00:28:25.560
So you should always check the
order number and dedup it.

00:28:25.560 --> 00:28:28.190
Also, if you're doing this,
make sure to secure the

00:28:28.190 --> 00:28:30.660
handshake because I've seen
pretty sad stories of

00:28:30.660 --> 00:28:34.550
developers that spent countless
man hours devising

00:28:34.550 --> 00:28:37.050
this perfect server-side
security system.

00:28:37.050 --> 00:28:39.710
And then their handshake was
like a boolean call.

00:28:39.710 --> 00:28:41.940
It was like a REST call that
returned to boolean, saying

00:28:41.940 --> 00:28:43.740
true, you are validated
or not.

00:28:43.740 --> 00:28:46.140
And then, of course, that can be
easily circumvented with a

00:28:46.140 --> 00:28:47.210
man in the middle attack.

00:28:47.210 --> 00:28:49.570
So make sure that the handshake
is secure if you're

00:28:49.570 --> 00:28:51.470
going through the trouble of
implementing a server-side

00:28:51.470 --> 00:28:52.670
security like that.

00:28:52.670 --> 00:28:55.140
Also make sure that the
handshake between the server

00:28:55.140 --> 00:28:58.250
and the client is secure and
not triggered to break.

00:28:58.250 --> 00:29:00.390
Now to give a summary of the
security methods that we

00:29:00.390 --> 00:29:01.140
talked about.

00:29:01.140 --> 00:29:03.130
Of course, you are free
not to do anything.

00:29:03.130 --> 00:29:05.450
If you don't do anything, then
you're pretty much vulnerable

00:29:05.450 --> 00:29:06.070
to any attack.

00:29:06.070 --> 00:29:08.690
Maybe for your application
that's not going to matter.

00:29:08.690 --> 00:29:11.770
But then you should probably
just add at least client-side

00:29:11.770 --> 00:29:14.780
security because if you at
least add client-side

00:29:14.780 --> 00:29:16.700
signature verification, that's
actually very easy to do

00:29:16.700 --> 00:29:18.440
because it's implemented
for you.

00:29:18.440 --> 00:29:20.220
It's available in the sample.

00:29:20.220 --> 00:29:21.880
It's just a matter of copying
and pasting that.

00:29:21.880 --> 00:29:25.255
So if you add client-side
signature verification, you're

00:29:25.255 --> 00:29:27.190
going to be protected against
man in the middle attacks.

00:29:27.190 --> 00:29:28.900
So you're going to be protected
against everyone's

00:29:28.900 --> 00:29:31.530
evil twin who tries to
replay a purchase

00:29:31.530 --> 00:29:32.830
on a different device.

00:29:32.830 --> 00:29:35.560
Now if you want to go the extra
mile and then add a

00:29:35.560 --> 00:29:38.670
unique developer payload, of
course, you are also protected

00:29:38.670 --> 00:29:41.660
against the more elaborate
forms of purchase replay.

00:29:41.660 --> 00:29:44.750
And next, if you want to be
really secure, you should, of

00:29:44.750 --> 00:29:47.580
course, implement server-side
signature verification.

00:29:47.580 --> 00:29:49.310
The server-side signature
verification's going to

00:29:49.310 --> 00:29:53.330
protect you even in the case
that the client's phone is

00:29:53.330 --> 00:29:56.110
hacked, and then the framework
has been compromised.

00:29:56.110 --> 00:29:57.470
So definitely think about

00:29:57.470 --> 00:30:00.280
implementing server-side security.

00:30:00.280 --> 00:30:02.920
Well, so overall, it's important
to approach the

00:30:02.920 --> 00:30:04.740
problem of piracy in a
very rational way.

00:30:04.740 --> 00:30:08.190
And that means don't panic and
implement methods that are

00:30:08.190 --> 00:30:09.200
known to be effective.

00:30:09.200 --> 00:30:10.860
So at least as far as the In-App
Billing platform's

00:30:10.860 --> 00:30:13.600
concerned, these are the three
that we talked about.

00:30:13.600 --> 00:30:15.530
And definitely they are the ones
that you should have in

00:30:15.530 --> 00:30:17.820
mind because they're very easy
to implement-- so developer

00:30:17.820 --> 00:30:21.550
payload that identifies the user
of course, then signature

00:30:21.550 --> 00:30:26.430
verification, and also doing
server-side validation.

00:30:26.430 --> 00:30:29.210
And the last topic for today,
it's something that developers

00:30:29.210 --> 00:30:31.210
have been asking us
for a long time.

00:30:31.210 --> 00:30:34.080
So I'm actually glad
that this launched.

00:30:34.080 --> 00:30:35.750
So and this is the In-App
Billing sandbox.

00:30:35.750 --> 00:30:37.250
So what's the sandbox thing?

00:30:37.250 --> 00:30:40.180
Well, if you remember how things
used to be, when you

00:30:40.180 --> 00:30:42.050
wanted to test to make sure
that your In-App Billing

00:30:42.050 --> 00:30:45.180
implementation was working
right, you essentially had two

00:30:45.180 --> 00:30:46.610
choices when testing
In-App purchase.

00:30:46.610 --> 00:30:49.940
You could just use the test
SKUs, the purchased and

00:30:49.940 --> 00:30:53.420
canceled SKUs, which are, of
course, fake product codes.

00:30:53.420 --> 00:30:55.870
And they always return a
given purchase result.

00:30:55.870 --> 00:30:57.110
So you could, of course,
use that.

00:30:57.110 --> 00:30:58.610
And those are, of course,
mock products with a

00:30:58.610 --> 00:30:59.280
mock purchase flow.

00:30:59.280 --> 00:31:02.200
They don't actually go
through the server.

00:31:02.200 --> 00:31:04.170
And then they get
a mock result.

00:31:04.170 --> 00:31:07.480
Of course, if you were not
satisfied with that and, of

00:31:07.480 --> 00:31:09.870
course, if you wanted to do
something that's closer to

00:31:09.870 --> 00:31:11.500
production, you could
use that.

00:31:11.500 --> 00:31:12.900
You could use a test account.

00:31:12.900 --> 00:31:15.640
And of course, if you list
somebody as a test account,

00:31:15.640 --> 00:31:18.440
the only privilege they used
to have is that they could

00:31:18.440 --> 00:31:20.030
make purchases from
an application

00:31:20.030 --> 00:31:21.690
that was not yet published.

00:31:21.690 --> 00:31:25.730
But you had to use real money,
had to use a real credit card,

00:31:25.730 --> 00:31:27.040
has to use a real
purchase flow.

00:31:27.040 --> 00:31:29.250
And then you would actually
get charged for that.

00:31:29.250 --> 00:31:31.500
Of course, you could revert the
charge by refunding it.

00:31:31.500 --> 00:31:33.290
But then maybe the bank's not
going to be happy and so on

00:31:33.290 --> 00:31:34.020
and so forth.

00:31:34.020 --> 00:31:35.950
But it's just very
complicated.

00:31:35.950 --> 00:31:38.000
So with In-App Billing sandbox,
you can now test

00:31:38.000 --> 00:31:40.830
purchases with the real
products, using the actual

00:31:40.830 --> 00:31:42.790
real purchase flow, with
a real credit card.

00:31:42.790 --> 00:31:44.850
So everything is as real as
possible, except that that

00:31:44.850 --> 00:31:47.930
last step, when your credit card
is about to be charged,

00:31:47.930 --> 00:31:49.100
that doesn't happen.

00:31:49.100 --> 00:31:52.370
So that's the only
part that's mock.

00:31:52.370 --> 00:31:54.010
But that's the only part that
doesn't happen is you don't

00:31:54.010 --> 00:31:54.540
get charged.

00:31:54.540 --> 00:31:57.690
But otherwise, the whole
flow is actually real.

00:31:57.690 --> 00:32:00.190
So how do you go ahead
and set this up?

00:32:00.190 --> 00:32:03.183
To enable that, you simply add
some test account to the list

00:32:03.183 --> 00:32:04.980
of test accounts in the
publisher's site.

00:32:04.980 --> 00:32:06.630
So this is the Android
publisher site.

00:32:06.630 --> 00:32:08.280
You go to Account Details.

00:32:08.280 --> 00:32:10.810
Then you add a list of test
accounts over there, so some

00:32:10.810 --> 00:32:12.810
Gmail accounts that you want
to test the app with.

00:32:12.810 --> 00:32:15.420
So apart from those accounts
apart from being able to

00:32:15.420 --> 00:32:19.560
purchase from your unpublished
app, what's going to happen

00:32:19.560 --> 00:32:21.710
when you try to publish with any
of those accounts is that

00:32:21.710 --> 00:32:23.770
you're going to see a screen
just like this.

00:32:23.770 --> 00:32:25.620
So do you notice any difference
from the screen

00:32:25.620 --> 00:32:26.470
that we saw before?

00:32:26.470 --> 00:32:28.400
It's exactly the same one,
except there's a warning

00:32:28.400 --> 00:32:31.210
saying, this is a test purchase
and you won't

00:32:31.210 --> 00:32:32.160
actually be charged.

00:32:32.160 --> 00:32:34.570
But everything else is going
to work exactly in the same

00:32:34.570 --> 00:32:36.270
way as a real purchase would.

00:32:36.270 --> 00:32:39.530
So this means that you can test
your In-App purchase in

00:32:39.530 --> 00:32:43.230
an environment that is pretty
much identical to the real

00:32:43.230 --> 00:32:45.060
life production system.

00:32:45.060 --> 00:32:46.510
But you won't actually
be charged.

00:32:50.390 --> 00:32:52.130
Of course, if you want to see
the In-App Billing Version 3

00:32:52.130 --> 00:32:54.630
code in practice, we have a
sample called Trivial Drive.

00:32:54.630 --> 00:32:57.220
So it's an exciting driving
game that I wrote.

00:32:57.220 --> 00:32:59.470
So you get burn fuel and
then buy more fuel.

00:32:59.470 --> 00:33:00.570
It's kind of like the
experience of having

00:33:00.570 --> 00:33:02.100
a car in real life.

00:33:02.100 --> 00:33:05.240
And it's available through
the SDK manager.

00:33:05.240 --> 00:33:07.590
And it's also available through
the Google code site.

00:33:07.590 --> 00:33:10.280
I recommend that you get the
code directly from Google code

00:33:10.280 --> 00:33:13.600
site because it's more
up-to-date there.

00:33:13.600 --> 00:33:16.740
And pretty soon, we're going
to launch an update to that

00:33:16.740 --> 00:33:20.230
app that's going to include
self-driving cars.

00:33:20.230 --> 00:33:23.170
So summarizing, we talked about
the most challenging

00:33:23.170 --> 00:33:24.270
points of In-App Billing V2.

00:33:24.270 --> 00:33:26.870
We talked about how In-App
Billing V3 was designed to

00:33:26.870 --> 00:33:29.080
address those points and make
things much easier for

00:33:29.080 --> 00:33:30.080
developers.

00:33:30.080 --> 00:33:31.180
We talked about subscriptions.

00:33:31.180 --> 00:33:33.970
We talked about new API
features, such as consumption.

00:33:33.970 --> 00:33:37.350
We talked about the new product
details API feature.

00:33:37.350 --> 00:33:39.560
Then we talked about the server
API and gave some

00:33:39.560 --> 00:33:41.670
pointers on security
best practices.

00:33:41.670 --> 00:33:45.000
And we also presented IAB
sandbox, which makes it much

00:33:45.000 --> 00:33:47.460
easier to test your apps
in a real environment.

00:33:47.460 --> 00:33:50.220
So the reason we are improving
the API constantly and adding

00:33:50.220 --> 00:33:53.920
these new features is we are
always striving to improve the

00:33:53.920 --> 00:33:57.565
developer experience because we
know that if we give you a

00:33:57.565 --> 00:33:59.570
good experience as a developer,
you can focus on

00:33:59.570 --> 00:34:01.000
what makes your apps great.

00:34:01.000 --> 00:34:03.350
So you can make a better
experience for your users,

00:34:03.350 --> 00:34:05.070
which is everybody's
final goal.

00:34:05.070 --> 00:34:07.060
So I hope that the tips
that I gave you are

00:34:07.060 --> 00:34:08.429
useful in that respect.

00:34:08.429 --> 00:34:10.389
And I thank you very much for
coming to this session.

00:34:10.389 --> 00:34:13.800
If you have any feedback, there
is the rate this session

00:34:13.800 --> 00:34:14.610
poster over there.

00:34:14.610 --> 00:34:17.239
On previous I/Os, I know that we
had real life tomatoes you

00:34:17.239 --> 00:34:17.870
could throw on stage.

00:34:17.870 --> 00:34:19.909
But that was pretty messy.

00:34:19.909 --> 00:34:22.130
So if you want to give your
feedback, just scan that QR

00:34:22.130 --> 00:34:25.889
code over there or use
the Google I/O app

00:34:25.889 --> 00:34:26.670
to give your feedback.

00:34:26.670 --> 00:34:27.690
So thank you very much.

00:34:27.690 --> 00:34:29.871
[APPLAUSE]

