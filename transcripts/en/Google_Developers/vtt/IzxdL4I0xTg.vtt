WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.540
BEN FRIED: Are we ready?

00:00:03.540 --> 00:00:09.118
OK, let's get started.

00:00:09.118 --> 00:00:13.838
The Wave for this event is at
http://bit.ly/appengine2 and

00:00:13.838 --> 00:00:15.698
the moderator gadget inside the
Wave is a great place for you

00:00:15.698 --> 00:00:17.660
to post questions as
they come to you.

00:00:17.660 --> 00:00:20.058
We'll make sure we visit the
moderator at the end of the

00:00:20.058 --> 00:00:22.260
session and answer all the
questions that are there, so

00:00:22.260 --> 00:00:27.058
please take advantage of it.

00:00:27.058 --> 00:00:28.538
Excuse me.

00:00:28.538 --> 00:00:30.920
We did this crazy thing.

00:00:30.920 --> 00:00:33.100
We took a whole bunch of
corporate applications, the

00:00:33.100 --> 00:00:36.420
kind of things an enterprise
would never think about running

00:00:36.420 --> 00:00:39.800
anywhere except in their own
data center, and we wrote them

00:00:39.800 --> 00:00:41.980
and run them on AppEngine.

00:00:41.980 --> 00:00:44.140
We're here today to tell
you how we did it, so

00:00:44.140 --> 00:00:45.740
you can do it too.

00:00:45.740 --> 00:00:47.260
I'm Ben, Ben Fried.

00:00:47.260 --> 00:00:48.240
I'm Google's CIO.

00:00:48.240 --> 00:00:50.798
I'm here with Justin, Matt,
and Irwin, and we're going to

00:00:50.798 --> 00:00:54.100
talk to you more about this.

00:00:54.100 --> 00:00:57.360
So, IT at Google, for us,
we think of ourselves

00:00:57.360 --> 00:00:58.740
as Google's pit crew.

00:00:58.740 --> 00:01:00.360
We're the people who do
the engineering that runs

00:01:00.360 --> 00:01:02.440
the business of Google.

00:01:02.440 --> 00:01:04.378
And the way that we do that,
our goal in doing this, is to

00:01:04.378 --> 00:01:08.238
use exactly the same tools,
like AppEngine, for example,

00:01:08.238 --> 00:01:10.460
that you all came to
IO to learn about.

00:01:10.460 --> 00:01:13.900
The goal that we have, the
mission for the organization is

00:01:13.900 --> 00:01:16.520
to have Google itself as an
enterprise run completely in

00:01:16.520 --> 00:01:18.120
the crowd-- in the cloud,
excuse me, you're the

00:01:18.120 --> 00:01:20.160
crowd, we're the cloud.

00:01:20.160 --> 00:01:23.000
So, let's find out a
little bit about you all.

00:01:23.380 --> 00:01:25.560
How many of you have done
anything with AppEngine before?

00:01:25.560 --> 00:01:28.340
Written anything, tried it
out, using it right now?

00:01:28.340 --> 00:01:29.320
Awesome, awesome, that's great.

00:01:29.320 --> 00:01:31.740
That's a lot of hands
for all you on Youtube.

00:01:31.740 --> 00:01:36.778
How many of you are curious
about using AppEngine for your

00:01:36.778 --> 00:01:38.780
organizations or businesses?

00:01:38.780 --> 00:01:38.980
Excellent.

00:01:38.980 --> 00:01:40.940
All right, you're in
the right place.

00:01:40.940 --> 00:01:43.620
Just as a spot check, how many
of you came here because you

00:01:43.620 --> 00:01:46.260
heard we'd be giving out
t-shirts at the end?

00:01:46.260 --> 00:01:47.900
All right.

00:01:47.900 --> 00:01:49.120
So, it's really us we're
selling, that's good.

00:01:49.120 --> 00:01:50.800
That's great.

00:01:50.800 --> 00:01:53.340
So what is the what?

00:01:53.340 --> 00:01:55.320
Our supposition, which proves
to have been correct, was that

00:01:55.320 --> 00:01:58.220
you're here because you want to
understand how you can write

00:01:58.220 --> 00:02:01.280
and run applications for
your businesses, for your

00:02:01.280 --> 00:02:05.060
organizations, that run on
AppEngine in the Google cloud.

00:02:05.060 --> 00:02:08.080
So great, that's what we're
here to tell you about.

00:02:08.080 --> 00:02:10.900
As Google's CIO, I feel an
obligation to step back a

00:02:10.900 --> 00:02:13.000
little bit and make sure we're
all on the same page about why

00:02:13.000 --> 00:02:15.320
this is a good idea and
something that you'd want to do

00:02:15.320 --> 00:02:17.938
for your organizations.

00:02:18.018 --> 00:02:23.698
So kind of the nightmare side
of every CIO's life is the fact

00:02:23.698 --> 00:02:27.418
that the stuff that we do, the
IT that gets valued by our

00:02:27.418 --> 00:02:29.700
users, is like the part of the
iceberg that's above the water.

00:02:29.700 --> 00:02:32.360
But the reality of it is, in
order to do that stuff that

00:02:32.360 --> 00:02:35.758
people can actually see and
touch and experience, we have

00:02:35.758 --> 00:02:37.878
to make an enormous effort and
investment in all this

00:02:37.878 --> 00:02:39.460
technology that's
below the water line.

00:02:39.460 --> 00:02:41.800
This is the stuff that our
end-users never directly

00:02:41.800 --> 00:02:44.608
interact with and never
actually kind of-- they

00:02:44.608 --> 00:02:45.618
only care about it when
it doesn't work, right?

00:02:45.618 --> 00:02:48.178
That stuff only exists to
enable the technology that

00:02:48.178 --> 00:02:50.638
makes our organizations
better in some way.

00:02:50.638 --> 00:02:53.478
But the problem is, is that-- I
think the stat I heard at the

00:02:53.478 --> 00:02:56.098
keynote was, you can spend up
to 60% of your IT spend

00:02:56.098 --> 00:02:59.080
actually engaged in just
operating your environment, and

00:02:59.080 --> 00:03:02.840
all that is a distraction of
every sort from what you really

00:03:02.840 --> 00:03:04.880
should be doing, which is
building technology that

00:03:04.880 --> 00:03:07.740
matters to your company, makes
a difference to your company,

00:03:07.740 --> 00:03:12.738
and delivering the technology
to the people in your company.

00:03:12.738 --> 00:03:15.260
Now, you know, part one of the
problem is, of course, you

00:03:15.260 --> 00:03:15.920
have to support hardware.

00:03:15.920 --> 00:03:17.480
You need hardware
to do this, right?

00:03:17.480 --> 00:03:23.080
That means you need servers and
storage and networks and data

00:03:23.080 --> 00:03:25.918
centers and guys in
fuschia-colored shirts who

00:03:25.918 --> 00:03:28.618
probably went to Cal Tech to
run all that stuff for you, so

00:03:28.618 --> 00:03:31.158
you can have-- so you can
have a place to run

00:03:31.158 --> 00:03:31.358
your apps, right?

00:03:31.358 --> 00:03:32.240
And this is problem number one.

00:03:32.240 --> 00:03:34.800
The hardware environment
that you need to invest in,

00:03:34.800 --> 00:03:39.118
in order to run your own
apps, is really expensive.

00:03:39.118 --> 00:03:41.908
And ultimately, it's not,
again, what your IT department

00:03:41.908 --> 00:03:43.418
is about, and what your IT
department is about is all the

00:03:43.418 --> 00:03:45.698
stuff that this stuff enables.

00:03:45.698 --> 00:03:47.498
So by way of comparison, let's
talk about what AppEngine

00:03:47.498 --> 00:03:50.818
offers that changes
the game here.

00:03:50.818 --> 00:03:53.160
So, this is a picture of
a Google data center.

00:03:53.160 --> 00:03:55.900
That's Larry Hefley, who is a
Google data center operations

00:03:55.900 --> 00:03:58.918
technician, he's been with
the company for some time.

00:03:58.918 --> 00:04:00.198
And if a picture actually tells
a thousand words, then we might

00:04:00.198 --> 00:04:02.798
have to look into this picture
a little bit to understand

00:04:02.798 --> 00:04:03.158
the differences.

00:04:03.158 --> 00:04:05.280
Larry's in a Google data
center, and if you'll notice,

00:04:05.280 --> 00:04:08.418
look closely, you'll see that
servers that surround him don't

00:04:08.418 --> 00:04:11.418
look like the servers that are
probably in your company.

00:04:12.338 --> 00:04:14.628
Google-- fundamentally, part
one of the value proposition of

00:04:14.628 --> 00:04:17.418
AppEngine and the Google cloud
is that Google presents a

00:04:17.418 --> 00:04:21.398
unique economy of scale that we
can share with you,

00:04:21.398 --> 00:04:21.538
through AppEngine.

00:04:21.538 --> 00:04:24.258
And to give an example of what
that economy of scale is, it's

00:04:24.258 --> 00:04:26.618
cost effective for Google
to actually design and

00:04:26.618 --> 00:04:28.818
build its own servers.

00:04:28.818 --> 00:04:30.758
These are Google servers that
actually have batteries

00:04:30.758 --> 00:04:33.560
attached to them for
power purposes.

00:04:33.560 --> 00:04:35.800
But we have teams that design
and build servers for us.

00:04:35.800 --> 00:04:36.138
That makes sense.

00:04:36.138 --> 00:04:38.958
We get great cost efficiencies
out of doing that.

00:04:38.958 --> 00:04:41.578
And on top of that, we design
custom data centers to

00:04:41.578 --> 00:04:43.218
house these servers, right?

00:04:43.218 --> 00:04:46.640
And because of the unique
relationship between the Google

00:04:46.640 --> 00:04:48.100
servers and the software that
runs on those Google servers,

00:04:48.100 --> 00:04:51.160
and the Google data centers,
we're able to achieve, you

00:04:51.160 --> 00:04:54.058
know, industry-leading power
utilization efficiency

00:04:54.058 --> 00:04:56.398
numbers for these data
centers as a result.

00:04:56.398 --> 00:04:58.846
Finally, on top of that,
because those data centers are

00:04:58.846 --> 00:05:01.958
so big, we can put them in
places where we can get the

00:05:01.958 --> 00:05:03.538
cheapest possible power.

00:05:03.538 --> 00:05:06.798
As a case in point, I mean, it
makes sense for us to go and

00:05:06.798 --> 00:05:08.318
find fully-depreciated
hydroelectric dams, places

00:05:08.318 --> 00:05:10.458
where we'd want to plop down
one of these massive

00:05:10.458 --> 00:05:11.220
data centers.

00:05:11.220 --> 00:05:13.058
You know, there's only a
handful of organizations in the

00:05:13.058 --> 00:05:15.638
world that are ever going to
have these opportunities

00:05:15.638 --> 00:05:17.920
and these kinds of
economies of scale.

00:05:17.920 --> 00:05:20.488
And the first element, what's
great about AppEngine, and why

00:05:20.488 --> 00:05:22.660
you should all be interested in
it-- or if you're not CIOs, why

00:05:22.660 --> 00:05:25.820
your CIOs should be interested
in it-- is that AppEngine

00:05:25.820 --> 00:05:27.740
is-- you know, all clouds
are not created equal.

00:05:27.740 --> 00:05:30.920
AppEngine is a vehicle for you
to tap into these unique

00:05:30.920 --> 00:05:34.298
economies of scale that Google
and very few others have.

00:05:35.378 --> 00:05:37.398
But it's not just about the
hardware, and doing hardware

00:05:37.398 --> 00:05:41.740
and all the stuff that runs
that hardware cheaper.

00:05:41.740 --> 00:05:43.360
The great point of AppEngine
is that it's a platform.

00:05:43.360 --> 00:05:44.220
It's a web-run time.

00:05:44.220 --> 00:05:46.898
And what that means is, when
you write apps that run on

00:05:46.898 --> 00:05:49.100
AppEngine, there's a whole
bunch of platform issues that

00:05:49.100 --> 00:05:50.878
you don't have to make an
investment in that you get

00:05:50.878 --> 00:05:56.778
for free just by writing
to the AppEngine APIs.

00:05:56.778 --> 00:05:58.518
The stuff on this little--
stack of library books is

00:05:58.518 --> 00:06:01.820
incredibly important for every
organization to do, to deliver

00:06:01.820 --> 00:06:03.818
technology, but these things
themselves don't make an

00:06:03.818 --> 00:06:04.378
organization great, right?

00:06:04.378 --> 00:06:07.718
These are part of a platform
for applications that make

00:06:07.718 --> 00:06:09.278
your organization great.

00:06:09.278 --> 00:06:11.058
And what's so cool about
AppEngine is you get all this

00:06:11.058 --> 00:06:13.800
stuff for free, you have to
make no conceptual investment

00:06:13.800 --> 00:06:16.678
in these sorts of areas of
technology in order to deliver

00:06:16.678 --> 00:06:18.838
great applications
to your company.

00:06:18.838 --> 00:06:21.458
So, part one of the AppEngine
advantage is unique economies

00:06:21.458 --> 00:06:25.138
of scale on the hardware side,
and part two is you're buying

00:06:25.138 --> 00:06:27.040
into an entire platform.

00:06:27.040 --> 00:06:30.726
And the virtue of that platform
is there's a whole set of

00:06:30.726 --> 00:06:31.480
systems activities you don't
have to be concerned with

00:06:31.480 --> 00:06:34.418
anymore and you don't have
to dilute your focus from

00:06:34.418 --> 00:06:37.118
delivering applications that
make your company better.

00:06:37.118 --> 00:06:39.658
So there's a better way, and
it's based on running in the

00:06:39.658 --> 00:06:42.420
cloud and running on AppEngine,
but in order to take advantage

00:06:42.420 --> 00:06:44.458
of this, you can't just build
applications exactly the way

00:06:44.458 --> 00:06:49.858
you were before, right?

00:06:49.858 --> 00:06:52.338
It's not easy to make
this transition.

00:06:52.338 --> 00:06:56.218
Making a transition-- I think
any organization that wasn't

00:06:56.218 --> 00:06:58.598
started today has the problem
that they've got a bunch of

00:06:58.598 --> 00:07:00.778
stuff in their data
centers running their

00:07:00.778 --> 00:07:01.360
companies already.

00:07:01.360 --> 00:07:03.320
Google has exactly these same
problems, we're just like

00:07:03.320 --> 00:07:05.160
all of you in that regard.

00:07:05.160 --> 00:07:07.180
We've got a bunch of the
same business concerns that

00:07:07.180 --> 00:07:08.080
every organization has.

00:07:08.080 --> 00:07:10.820
We've got a bunch of corporate
data centers that host

00:07:10.820 --> 00:07:14.098
applications that were written
in the age before there

00:07:14.098 --> 00:07:16.398
was an AppEngine.

00:07:16.398 --> 00:07:19.558
And figuring out how to make
this transition, how to move to

00:07:19.558 --> 00:07:21.778
being a cloud-based enterprise,
is hard when so many of your

00:07:21.778 --> 00:07:24.660
key assets, whether they be
software or services or

00:07:24.660 --> 00:07:25.458
whatever, are still
inside your data center.

00:07:25.458 --> 00:07:28.338
So that's-- the transition
is point number one about

00:07:28.338 --> 00:07:29.258
what makes this hard.

00:07:29.258 --> 00:07:31.518
And point number two about what
makes this hard is that,

00:07:31.518 --> 00:07:34.132
although AppEngine is great,
because you're using familiar

00:07:34.132 --> 00:07:36.220
tools and languages that we all
know and love, like Python and

00:07:36.220 --> 00:07:38.980
Java, you can't write
your applications in

00:07:38.980 --> 00:07:40.758
exactly the same way.

00:07:40.758 --> 00:07:42.606
Part of the platform
requires you to make

00:07:42.606 --> 00:07:43.040
some coding changes.

00:07:43.040 --> 00:07:44.420
And this stuff isn't
necessarily obvious, there

00:07:44.420 --> 00:07:48.378
aren't a lot of footprints to
be followed for enterprises in

00:07:48.378 --> 00:07:50.360
making this transaction.

00:07:50.360 --> 00:07:51.420
But we figured it out.

00:07:51.420 --> 00:07:53.378
This is part of our
organization's mission, is to

00:07:53.378 --> 00:07:55.180
do this and share it with you.

00:07:55.180 --> 00:07:58.118
And we're here to
do that right now.

00:07:58.118 --> 00:08:00.418
And so with that, I'm going to
introduce the first of the

00:08:00.418 --> 00:08:02.558
three development teams, the
first of the three corporate

00:08:02.558 --> 00:08:05.118
engineers and development
teams, who're going to talk

00:08:05.118 --> 00:08:07.198
about how we did this for some
applications that run the

00:08:07.198 --> 00:08:08.318
business of Google today.

00:08:08.318 --> 00:08:14.878
First up is Justin who's here
to talk about AppReduce.
202
00:08:14,878 --&gt; 00:08:14,33
JUSTIN MCWILLIAMS: Thanks, Ben.

00:08:14.330 --> 00:08:14.558
Hello

00:08:14.558 --> 00:08:17.258
everyone, I'm Justin
McWilliams, one of two

00:08:17.258 --> 00:08:18.638
engineers that built AppReduce.

00:08:20.598 --> 00:08:23.638
So, by a show of hands, how
many of you have licensed

00:08:23.638 --> 00:08:27.398
software on your
corporate workstations?

00:08:27.398 --> 00:08:29.220
So, as expected, a lot of you.

00:08:29.220 --> 00:08:32.078
And how many of you, at some
point, have realized that you

00:08:32.078 --> 00:08:35.640
no longer needed a piece of
licensed software, or maybe

00:08:35.640 --> 00:08:38.500
even forgotten that it was
installed in the first place?

00:08:38.500 --> 00:08:40.380
Again, a lot of you.

00:08:40.380 --> 00:08:44.100
So lastly, how many of your
companies attempt to reclaim

00:08:44.100 --> 00:08:47.560
unused software licenses?

00:08:47.560 --> 00:08:49.040
I see a couple of
hands here and there.

00:08:49.040 --> 00:08:49.460
OK.

00:08:49.460 --> 00:08:52.080
So that's exactly what
AppReduce addresses.

00:08:52.080 --> 00:08:56.400
And we do this by providing
transparency to our employees

00:08:56.400 --> 00:08:58.798
around the software licenses
that are in use by

00:08:58.798 --> 00:09:00.580
their computers.

00:09:00.580 --> 00:09:03.100
So you can see here, we
provide them with the overall

00:09:03.100 --> 00:09:04.700
cost of their computer.

00:09:04.700 --> 00:09:08.100
Compare that to the average
Googler, the average Googler in

00:09:08.100 --> 00:09:11.200
their department maybe, and
then down below, up-- a quick

00:09:11.200 --> 00:09:14.440
list of the software that's
installed on their computer,

00:09:14.440 --> 00:09:17.200
associated licensing costs,
and an uninstall button.

00:09:17.200 --> 00:09:20.260
So, when this uninstall button
is clicked, we actually make a

00:09:20.260 --> 00:09:22.540
call back to a corporate
inventory service that

00:09:22.540 --> 00:09:25.060
automatically uninstalls that
application from

00:09:25.060 --> 00:09:26.700
their computer.

00:09:26.700 --> 00:09:27.824
And I'll go into a little
bit more detail about

00:09:27.824 --> 00:09:29.800
how that works later.

00:09:29.800 --> 00:09:30.800
So how did we build AppReduce?

00:09:30.800 --> 00:09:34.520
Well, initially, we designed
and developed for a traditional

00:09:34.520 --> 00:09:38.980
LAMP stack, where we basically
had an Apache server, and when

00:09:38.980 --> 00:09:41.860
the user visited the site, we
would directly connect to four

00:09:41.860 --> 00:09:46.180
or five databases and APIs on
the fly, pull down all of the

00:09:46.180 --> 00:09:49.760
application data, loop over it,
do, you know, regular

00:09:49.760 --> 00:09:53.160
expression matching for
licenses, do some cost

00:09:53.160 --> 00:09:55.520
calculation, all this stuff on
the fly, and then present

00:09:55.520 --> 00:09:57.480
the page to the user.

00:09:57.480 --> 00:09:59.780
So we decided to port to
AppEngine for many of the

00:09:59.780 --> 00:10:03.600
reasons that Ben mentioned, and
we found that we could use the

00:10:03.600 --> 00:10:06.300
same frameworks that we were
familiar with the LAMP stack.

00:10:06.300 --> 00:10:10.980
So AppReduce is built with
Django and Python, we used

00:10:10.980 --> 00:10:13.058
Google Closure JavaScript
Library for much of our

00:10:13.058 --> 00:10:18.340
front-end and UI elements, and
the chart API for various

00:10:18.340 --> 00:10:21.340
reports, one of which you saw
on the first slide, and Google

00:10:21.340 --> 00:10:24.780
Analytics for usage tracking.

00:10:24.780 --> 00:10:27.940
So importing to AppEngine, we
did encounter some challenges,

00:10:27.940 --> 00:10:30.260
however, and one of
them is fairly obvious.

00:10:30.260 --> 00:10:32.820
How do we get at this data
that's residing in our

00:10:32.820 --> 00:10:35.900
corporate network
from AppEngine?

00:10:35.900 --> 00:10:38.220
And the answer here is
Secure Data Connector.

00:10:38.220 --> 00:10:41.880
So, Secure Data Connector is a
way to create a secure tunnel

00:10:41.880 --> 00:10:45.160
from AppEngine, or out in the
cloud-- anywhere in the cloud--

00:10:45.160 --> 00:10:47.640
to make HTTP calls back into
your corporate network

00:10:47.640 --> 00:10:48.080
to whitelisted URLs.

00:10:49.400 --> 00:10:53.740
So a good example of where we
use this, was to access our

00:10:53.740 --> 00:10:56.740
Remedy helpdesk ticketing
system API, which

00:10:56.740 --> 00:10:56.840
was pre-existing.

00:10:57.460 --> 00:11:03.520
So we're able to file tickets
from AppReduce, Googlers could

00:11:03.520 --> 00:11:06.580
report inaccurate inventory
data, or ask questions about a

00:11:06.580 --> 00:11:09.760
particular license or
open-source alternatives,

00:11:09.760 --> 00:11:11.920
things like this.

00:11:11.920 --> 00:11:15.180
So you might ask, what
about non-HTTP services?

00:11:15.180 --> 00:11:20.100
And the answer is to write an
HTTP wrapper around that

00:11:20.100 --> 00:11:25.340
service, and one example of
this was for Microsoft System

00:11:25.340 --> 00:11:27.940
Center Configuration Manager,
formerly known as System

00:11:27.940 --> 00:11:30.080
Management Server, which is a
corporate inventory system

00:11:30.080 --> 00:11:32.800
built by Microsoft.

00:11:32.800 --> 00:11:36.420
So we wrote an HTTP wrapper
around this service, so when

00:11:36.420 --> 00:11:38.760
users click that uninstall
button that you saw, we would

00:11:38.760 --> 00:11:42.760
make an HTTP call through SDC
into our HTTP wrapper, which

00:11:42.760 --> 00:11:45.760
would then translate that call
to Windows Management

00:11:45.760 --> 00:11:50.560
instrumentation to interface
with SDC or SMS to push out

00:11:50.560 --> 00:11:52.144
that uninstaller
to the machine.

00:11:53.960 --> 00:11:56.220
So the next challenge was
real-time user performance.

00:11:56.220 --> 00:11:59.300
If you remember, back on the
LAMP slide that I showed you, I

00:11:59.300 --> 00:12:01.480
mentioned that we were directly
connecting to all of these

00:12:01.480 --> 00:12:04.160
databases and APIs on the fly.

00:12:04.160 --> 00:12:07.220
And we found that, when moving
to AppEngine, this was

00:12:07.220 --> 00:12:10.120
providing for a sub-optimal
user experience due to the fact

00:12:10.120 --> 00:12:14.480
that the-- your back ends and
your databases are inside of

00:12:14.480 --> 00:12:17.580
your corporate network, and the
AppEngines front ends may be,

00:12:17.580 --> 00:12:19.720
you know, somewhere else
out in the internet, so

00:12:19.720 --> 00:12:20.480
there's added latency.

00:12:21.760 --> 00:12:24.060
So to get around this, we
actually ended up caching a lot

00:12:24.060 --> 00:12:26.560
of our corporate data in the
cloud, using Bulkloader.

00:12:27.600 --> 00:12:31.300
So we have code that runs in
our corporate network that

00:12:31.300 --> 00:12:35.520
fetches this same data on a
regular basis, does all of the

00:12:35.520 --> 00:12:38.220
aggregation and the cost
calculation and license

00:12:38.220 --> 00:12:41.340
matching up front, and
then hands it off over to

00:12:41.340 --> 00:12:45.340
Bulkloader to shovel up into
AppEngine's data store.

00:12:45.340 --> 00:12:49.920
So we're actually using this to
push about 75,000 rows of data,

00:12:49.920 --> 00:12:53.420
three times per day, and it's
been really great for us.

00:12:53.420 --> 00:12:58.340
Bulkloader handles, like,
automatic error retrying, it

00:12:58.340 --> 00:13:00.700
handles throttling, threading,
it's really just a-- it's a

00:13:00.700 --> 00:13:03.900
great way to get data from
your corporate network

00:13:03.900 --> 00:13:06.860
up into the cloud.

00:13:06.860 --> 00:13:08.200
So here's an overall
design of AppReduce.

00:13:09.520 --> 00:13:11.820
And a lot of this should be
familiar, you'll see the

00:13:11.820 --> 00:13:13.980
corporate network on the
right-hand side with all of

00:13:13.980 --> 00:13:17.220
your inventory systems and
services, and AppEngine and

00:13:17.220 --> 00:13:18.120
AppReduce on the
left-hand side.

00:13:19.480 --> 00:13:21.700
Secure Data Connector and
Bulkloader bridging the gap

00:13:21.700 --> 00:13:25.180
between the two of those, and
again, as mentioned, when the

00:13:25.180 --> 00:13:28.060
user visits the AppReduce front
end, all of this data is going

00:13:28.060 --> 00:13:31.860
to be loaded from the local
data store, and we even have a

00:13:31.860 --> 00:13:33.720
memcache layer in between there
to reduce redundant hits

00:13:33.720 --> 00:13:35.540
on the data store.

00:13:36.440 --> 00:13:39.878
The new piece here is the
section up top, the GAE

00:13:39.878 --> 00:13:41.320
Cron and Task Queue.

00:13:41.320 --> 00:13:45.480
So task queues are a way to run
code in the background in

00:13:45.480 --> 00:13:48.280
AppEngine, sort of independent
from the user's interaction

00:13:48.280 --> 00:13:52.160
with the site, and we use this
for various-- various reasons.

00:13:52.160 --> 00:13:54.040
But I'll give you a
couple of examples.

00:13:54.040 --> 00:13:56.840
So, first off, status E-mails.

00:13:56.220 --> 00:14:00.500
We send Googlers E-mails on a
regular basis, reminding them

00:14:00.500 --> 00:14:04.460
of AppReduce, reminding them of
the licenses they have on their

00:14:04.460 --> 00:14:07.440
machine, and asking them to
come uninstall applications

00:14:07.440 --> 00:14:09.360
that they no longer need.

00:14:09.360 --> 00:14:11.820
Another example is
uninstallation verification.

00:14:11.820 --> 00:14:15.400
So, on a regular basis, we're
checking to make sure that,

00:14:15.400 --> 00:14:18.240
when that uninstall button is
clicked, those applications are

00:14:18.240 --> 00:14:21.740
actually being uninstalled by
the inventory systems, and if

00:14:21.740 --> 00:14:24.940
not, then we can, you know,
raise flags and E-mail the

00:14:24.940 --> 00:14:26.640
administrators of those systems
so they can have a look and

00:14:26.640 --> 00:14:29.660
see why it's not working.

00:14:29.660 --> 00:14:33.400
So, all in all, we found that
putting information into

00:14:33.400 --> 00:14:36.720
Googler's hands can be very
powerful, and transparency at

00:14:36.720 --> 00:14:38.420
Google is well-received
in general.

00:14:39.798 --> 00:14:44.060
To date, we've saved over
$450,000 by recycling licenses,

00:14:44.060 --> 00:14:48.160
and within twenty-four hours of
launch, we actually had over a

00:14:48.160 --> 00:14:50.060
$150,000 worth of savings.

00:14:51.960 --> 00:14:57.372
Which, by the way, we had QPS
spikes up to fifty, and it's

00:14:57.372 --> 00:14:59.120
the same twenty QPS for
several hours after launch.

00:14:59.120 --> 00:15:03.560
We totally did not expect
adoption like this up front,

00:15:03.560 --> 00:15:07.140
due to the corporate nature of
this application, but AppEngine

00:15:07.140 --> 00:15:08.400
handled it quite well
for us, so that was

00:15:08.400 --> 00:15:10.140
a pleasant surprise.

00:15:11.240 --> 00:15:14.060
So it's also worth mentioning
that AppReduce was built,

00:15:14.060 --> 00:15:16.560
released, and supported
by only two engineers,

00:15:16.560 --> 00:15:17.800
myself and one other.

00:15:18.660 --> 00:15:22.280
And I think this is a good
testament of what it takes to

00:15:22.280 --> 00:15:24.100
build something like this
in the cloud, on AppEngine.

00:15:24.260 --> 00:15:27.400
You don't really need a team
of ten or twenty people.

00:15:27.400 --> 00:15:32.260
And lastly, about two weeks
after we launched AppReduce,

00:15:32.260 --> 00:15:34.200
myself and the other engineer
were actually allocated on

00:15:34.200 --> 00:15:37.820
other projects, and AppReduce
kept on chugging

00:15:37.820 --> 00:15:38.140
along by itself.

00:15:38.140 --> 00:15:39.620
We didn't really have
to worry about it.

00:15:39.620 --> 00:15:43.200
The AppEngine platform took
care of things like server

00:15:43.200 --> 00:15:46.798
uptime and monitoring and all
those sorts of things that a

00:15:46.798 --> 00:15:51.420
normal developer would have
to handle themselves.

00:15:51.420 --> 00:15:56.520
So I think this is a-- this is
our experience with building an

00:15:56.520 --> 00:16:01.000
application in the cloud that
requires corporate inventory

00:16:01.000 --> 00:16:04.440
systems and data that's behind
your corporate network, and

00:16:04.440 --> 00:16:05.820
this is a theme that I
think you'll see in

00:16:05.820 --> 00:16:07.320
the next presentation.

00:16:07.320 --> 00:16:09.800
Please welcome Matthew
Simmons with the

00:16:09.800 --> 00:16:16.280
TechStop Online Project.
363
00:16:16,28 --&gt; 00:16:16,058
MATTHEW SIMMONS:
Thank you, Justin.

00:16:18.058 --> 00:16:19.158
Thank you all for being here.

00:16:19.158 --> 00:16:20.180
Welcome.

00:16:20.180 --> 00:16:22.980
As Justin said, my name
is Matthew Simmons.

00:16:22.980 --> 00:16:25.038
The project I work on is
TechStop Online, I'm one of the

00:16:25.038 --> 00:16:28.400
developers that work on that.

00:16:28.400 --> 00:16:30.580
So, what is TechStop Online?

00:16:30.580 --> 00:16:33.060
Well, TechStop Online is where
we keep all of our internal IT

00:16:33.060 --> 00:16:36.920
support documentation that we
use to support our users.

00:16:36.920 --> 00:16:39.640
Its namesake actually tells
you a little bit about

00:16:39.640 --> 00:16:41.380
what TechStop Online is.

00:16:41.380 --> 00:16:43.200
Techstops are rooms in each
Google office where you can

00:16:43.200 --> 00:16:47.540
go to get fast, friendly,
efficient IT support.

00:16:47.540 --> 00:16:51.572
We aim to be the online
equivalent of that.

00:16:51.572 --> 00:16:51.800
In

00:16:51.800 --> 00:16:55.800
essence, you can think of
it like a CMS, or content

00:16:55.800 --> 00:16:56.900
management system.

00:16:56.900 --> 00:16:59.100
We provide a lot of the same
features, and we have a lot

00:16:59.100 --> 00:17:02.220
of the same requirements.

00:17:02.220 --> 00:17:05.380
Previously, we were deployed in
a managed LAMP environment,

00:17:05.380 --> 00:17:11.118
using an OSS/CMS solution, and
we migrated to AppEngine for a

00:17:11.118 --> 00:17:14.740
variety of reasons, many of
which Ben covered, and some of

00:17:14.740 --> 00:17:17.860
which I will cover in a second.

00:17:18.320 --> 00:17:21.400
Like AppReduce, we deployed
using the Django framework on

00:17:21.400 --> 00:17:25.980
AppEngine, and the Google
Closure JavaScript Library.

00:17:25.980 --> 00:17:29.340
We make use of a lot of the
same technologies: Secure

00:17:29.340 --> 00:17:30.980
Tata Connector, Task
Queue, Bulkloader.

00:17:33.280 --> 00:17:36.040
So I mentioned that we
had some motivations for

00:17:36.040 --> 00:17:36.460
moving on to AppEngine.

00:17:39.840 --> 00:17:42.020
Primarily I'm going to cover
scalability, which was one of

00:17:42.020 --> 00:17:45.200
the places where we saw
the greatest benefit.

00:17:45.200 --> 00:17:48.640
I'm also going to cover some of
the challenges we encountered

00:17:48.640 --> 00:17:51.980
moving to AppEngine, some of
the shifts in development

00:17:51.980 --> 00:17:54.080
paradigm that we had to
accommodate and I'm going to

00:17:54.080 --> 00:17:59.280
close out with a couple of tips
that we found to be useful.

00:17:59.280 --> 00:18:02.720
So, I mentioned scalability,
I kind of think of

00:18:02.720 --> 00:18:04.460
it as bursty demand.

00:18:04.460 --> 00:18:06.440
This is-- these graphs
are going to look pretty

00:18:06.440 --> 00:18:08.000
familiar to anyone who
runs web applications.

00:18:08.000 --> 00:18:12.720
On one side, you're going to
have your normal periodic

00:18:12.720 --> 00:18:14.400
demand on your application.

00:18:14.400 --> 00:18:17.038
For us as a support
documentation thing, this is

00:18:17.038 --> 00:18:22.140
your weekly demand spiked with
weekdays high, weekends low,

00:18:22.140 --> 00:18:24.520
and represents things
like users saying aah!

00:18:24.520 --> 00:18:26.660
Coffee plus keyboard
equals bad!

00:18:26.660 --> 00:18:29.640
Tell me how to get
a new keyboard!

00:18:29.640 --> 00:18:33.400
And on the other side, you
have A sudden surge in

00:18:33.400 --> 00:18:35.738
demand for a single thing.

00:18:35.738 --> 00:18:36.998
Again, that's going to
vary by what application

00:18:36.998 --> 00:18:37.998
we're talking about.

00:18:37.998 --> 00:18:41.940
For us, it could be we change
our remote access policy, and

00:18:41.940 --> 00:18:44.360
the night before everyone needs
to get the documentation to

00:18:44.360 --> 00:18:50.320
see how to install the new
remote access software.

00:18:50.320 --> 00:18:52.540
That's when the documentation
system is the most valuable.

00:18:52.540 --> 00:18:54.920
It's when it's under
the most load.

00:18:54.920 --> 00:18:57.260
It's also when it's the most
brittle, traditionally.

00:18:57.260 --> 00:18:58.900
It's the most likely to break.

00:18:58.900 --> 00:19:02.380
Which is bad, because everyone
needs the same information, and

00:19:02.380 --> 00:19:05.160
the fallback are the people
sitting in the tech stops, and

00:19:05.160 --> 00:19:08.140
they don't parallelize as
well as documentation does.

00:19:08.140 --> 00:19:15.880
So, we did handle scalability
when we were deployed in

00:19:15.880 --> 00:19:17.600
a different environment.

00:19:17.600 --> 00:19:20.998
The challenge we faced was it
took a lot of our attention.

00:19:20.258 --> 00:19:23.920
We had to develop-- devote a
lot of cycles to dealing with

00:19:23.920 --> 00:19:25.760
these scalability concerns.

00:19:25.760 --> 00:19:30.660
We were kind of having to
allocate development cycles to

00:19:30.660 --> 00:19:34.580
platform concerns, instead of
develop-- devoting them to

00:19:34.580 --> 00:19:36.060
actually making the
application better.

00:19:36.660 --> 00:19:41.260
Things that we wanted to
deliver on for our users.

00:19:41.260 --> 00:19:44.120
So, when we moved to AppEngine,
we were really pleasantly

00:19:44.120 --> 00:19:48.060
surprised to find that we
stopped having to really devote

00:19:48.060 --> 00:19:51.720
a lot of thought to how we
make sure our app scales.

00:19:51.720 --> 00:19:53.740
We freed up a lot of cycles.

00:19:53.740 --> 00:19:57.100
It allowed us to address a lot
of these application-level

00:19:57.100 --> 00:20:00.240
concerns that we
wanted to address.

00:20:00.240 --> 00:20:03.420
What were some of those?

00:20:03.420 --> 00:20:05.800
Well, our philosophy is that
you can have the best,

00:20:05.800 --> 00:20:08.140
most accurate support
documentation in the world.

00:20:08.140 --> 00:20:11.100
It can be the most appropriate
for the problem at hand, but if

00:20:11.100 --> 00:20:13.760
the user can't find
it, it's worthless.

00:20:13.760 --> 00:20:17.080
So, navigation, specifically
in this case search, was

00:20:17.080 --> 00:20:20.820
one of the first things
that we looked at.

00:20:20.820 --> 00:20:24.720
So, what we found was that,
because we implemented our

00:20:24.720 --> 00:20:28.838
article content with AppEngine
text properties, and at the

00:20:28.838 --> 00:20:32.320
time they weren't indexed, we
didn't have a quick convenient

00:20:32.320 --> 00:20:36.090
way to search within the
article content and return

00:20:36.090 --> 00:20:39.080
a specific article within
the AppEngine framework.

00:20:39.080 --> 00:20:41.260
This is a problem that we
decided that we needed

00:20:41.260 --> 00:20:41.420
to tackle ourselves.

00:20:43.020 --> 00:20:44.500
We had a couple of approaches.

00:20:44.500 --> 00:20:48.360
The first approach was we
decided to try and do

00:20:48.360 --> 00:20:49.380
information retrieval
ourselves.

00:20:49.380 --> 00:20:53.020
We stripped the HTML, we
tokenized it, we built indexes,

00:20:53.020 --> 00:20:55.420
we did all that jazz, and we
did all it in AppEngine,

00:20:55.420 --> 00:20:57.640
and it worked.

00:20:57.640 --> 00:21:00.300
But then we got to thinking.

00:21:00.300 --> 00:21:02.700
You know, we're spending
a lot of time trying to

00:21:02.700 --> 00:21:04.920
implement search here.

00:21:04.920 --> 00:21:09.120
Maybe, at a big company like
this, someone has tackled

00:21:09.120 --> 00:21:11.020
the search problem before.

00:21:11.020 --> 00:21:14.380
Maybe we can work off of
someone else's work.

00:21:14.380 --> 00:21:16.760
Well, it turns out, someone at
Google has thought about search

00:21:16.760 --> 00:21:23.140
before, and we were able to use
the Google Search Appliance

00:21:23.140 --> 00:21:27.400
that sits in our corporate
network to index our help

00:21:27.400 --> 00:21:29.580
support documentation.

00:21:29.580 --> 00:21:32.680
We again encountered a
challenge, that challenge

00:21:32.680 --> 00:21:36.380
being that our documentation
repository was now in the

00:21:36.380 --> 00:21:38.980
cloud, and our Google search
appliance was on our

00:21:38.980 --> 00:21:40.040
corporate network, and a
firewall lay betwixt.

00:21:42.740 --> 00:21:45.358
This is where we used the SDC,
and you heard Justin talk a

00:21:45.358 --> 00:21:47.520
little bit about the SDC
earlier, the Secure

00:21:47.520 --> 00:21:49.660
Data Connector.

00:21:49.660 --> 00:21:52.480
We found it to be a great way
to communicate and to leverage

00:21:52.480 --> 00:21:55.240
these resources that we already
had in our corporate

00:21:55.240 --> 00:21:57.860
environment, and sort of get a
lot of efficiency out of things

00:21:57.860 --> 00:22:02.260
that we-- work that had
already been done.

00:22:02.260 --> 00:22:04.660
Additionally, SDC is really
easy to use, or we found

00:22:04.660 --> 00:22:06.840
it really easy to use.

00:22:06.840 --> 00:22:11.080
This is an example call to SDC.

00:22:11.080 --> 00:22:13.280
If you take away the
highlighted part, it looks

00:22:13.280 --> 00:22:14.618
just like a URL fetch.

00:22:14.618 --> 00:22:17.700
The resource in question
happens to be behind the

00:22:17.700 --> 00:22:20.480
corporate firewall and would
otherwise be denied, but by

00:22:20.480 --> 00:22:24.600
adding this header's use
intranet yes, you've turned

00:22:24.600 --> 00:22:26.920
it into an SDC call.

00:22:26.920 --> 00:22:31.160
Really, we found it to be
a fantastic solution.

00:22:31.160 --> 00:22:35.900
The next thing we went after
was, again, along the

00:22:35.900 --> 00:22:41.120
navigation theme, was tackling
what happened if a user didn't

00:22:41.120 --> 00:22:44.858
get the perfect document on the
first hit of their search

00:22:44.858 --> 00:22:46.460
results, or if they clicked on
a search result and it

00:22:46.460 --> 00:22:48.020
wasn't the right one.

00:22:48.020 --> 00:22:50.298
We wanted to provide them a
link to what they were really

00:22:50.298 --> 00:22:55.420
looking for on the page, so we
wanted a recommendation system.

00:22:55.420 --> 00:22:57.520
We decided to implement it
using similarity calculations,

00:22:57.520 --> 00:22:59.400
and that's kind of
all beside the point.

00:22:59.400 --> 00:23:01.880
The point is that all of
those calculations took a

00:23:01.880 --> 00:23:04.700
really long time to run.

00:23:04.700 --> 00:23:06.520
And every time you add a new
article in a CMS, you would

00:23:06.520 --> 00:23:08.260
have to rebuild this
similarity index.

00:23:09.920 --> 00:23:12.620
So this is a very
long running task.

00:23:12.620 --> 00:23:15.880
It would almost always run
longer than the thirty second

00:23:15.880 --> 00:23:17.880
request response cycle allowed.

00:23:19.540 --> 00:23:22.700
What we found is we could use
the Task Queue, the AppEngine

00:23:22.700 --> 00:23:31.800
Task Queue functionality,
to not only-- oh!
508
00:23:31,8 --&gt; 00:23:31,584
Technological failure!

00:23:31.584 --> 00:23:35.038
There we go-- not only get the
job done, because we could

00:23:35.038 --> 00:23:38.838
split it up and defer it and
run these task-- these

00:23:38.838 --> 00:23:40.920
similarity calculations
asynchronously, which is what

00:23:40.920 --> 00:23:42.800
Task Queue does fantastically,
but it also got it out

00:23:42.800 --> 00:23:44.460
of the way of the user.

00:23:44.460 --> 00:23:44.800
Right?

00:23:44.800 --> 00:23:47.440
So an article author finishes,
they submit their article, and

00:23:47.440 --> 00:23:50.720
we have to figure out the
similarity, but they don't

00:23:50.720 --> 00:23:52.960
need to wait what happens.

00:23:52.960 --> 00:23:55.058
So, Task Queue's ability to
make-- to get the task out-- or

00:23:55.058 --> 00:23:58.220
the technology out of the way
of the task, we really

00:23:58.220 --> 00:24:02.360
enjoyed as well.

00:24:02.360 --> 00:24:06.460
Now, when I think about
database design, my first

00:24:06.460 --> 00:24:10.618
reaction is to think in terms
of relational database systems.

00:24:10.618 --> 00:24:13.200
So I start thinking about
normalization, I start thinking

00:24:13.200 --> 00:24:15.686
about, you know, which
normal form, et cetera.

00:24:16.720 --> 00:24:18.320
This was a shift for us.

00:24:18.320 --> 00:24:23.980
AppEngine works really well a
de-normalized data schema.

00:24:23.980 --> 00:24:28.660
So, we eventually came around
to not thinking about

00:24:28.660 --> 00:24:31.520
normalization as much, and it
worked out really well for us.

00:24:31.520 --> 00:24:33.280
That's not saying that
you can't have links

00:24:33.280 --> 00:24:34.640
between entities.
531
00:24:34,64 --&gt; 00:24:34,58
You can.

00:24:34.580 --> 00:24:38.380
You can use the AppEngine
reference property.

00:24:38.380 --> 00:24:40.200
One of the things that we
encountered while using the

00:24:40.200 --> 00:24:45.078
reference property is that
every time you access an

00:24:45.078 --> 00:24:48.320
attribute that's a reference
property, it'll fire an RPC

00:24:48.320 --> 00:24:51.400
to data store to pull the
reference down to the end.

00:24:51.400 --> 00:24:53.920
If you're iterating over
something, a set of entities

00:24:53.920 --> 00:24:57.360
that have reference properties,
and you want to access

00:24:57.360 --> 00:25:01.318
something on the referenced
entity, you're going to be

00:25:01.318 --> 00:25:07.328
throwing an RPC to retrieve
that in every part of the loop.

00:25:08.300 --> 00:25:10.500
That can lead to some issues.

00:25:10.500 --> 00:25:13.300
What we found is it's really
efficient to figure out what

00:25:13.300 --> 00:25:16.118
you're going to want and to
cache it, to take that piece of

00:25:16.118 --> 00:25:20.298
data and programmatically cache
it on the entity you're

00:25:20.298 --> 00:25:22.960
iterating over.

00:25:22.960 --> 00:25:26.180
That, for our application,
solved some of the problems

00:25:26.180 --> 00:25:28.780
that we were having, and
it's a very good thing

00:25:28.780 --> 00:25:32.520
to keep in mind.

00:25:32.520 --> 00:25:35.680
Another thing that we found,
another advantage of developing

00:25:35.680 --> 00:25:38.440
on AppEngine is, as a small
team-- and we are a fairly

00:25:38.440 --> 00:25:43.200
small team-- maintaining
a test instance was a

00:25:43.200 --> 00:25:43.980
significant of work.

00:25:43.980 --> 00:25:45.240
More work than we
wanted it to be.

00:25:45.240 --> 00:25:47.400
We had to spin up a separate
environment and then we had to

00:25:47.400 --> 00:25:50.680
keep it roughly representative
of the production environment.

00:25:50.680 --> 00:25:53.220
So when we were testing new
changes, we were actually

00:25:53.220 --> 00:25:55.838
testing it against something
that represented the

00:25:55.838 --> 00:25:57.920
real environment.

00:25:57.920 --> 00:26:01.380
With AppEngine, one of the
approaches that we found to

00:26:01.380 --> 00:26:05.860
be useful was to register a
second application with a

00:26:05.860 --> 00:26:07.200
slightly different name.

00:26:07.200 --> 00:26:10.558
In our case, we would append
-QA, Quality Assurance

00:26:10.558 --> 00:26:16.720
instance, and you could
use anything, really.

00:26:16.720 --> 00:26:21.420
But the idea is that you would
push out, when you pushed your

00:26:21.420 --> 00:26:23.220
production instance, to this
other instance that you have

00:26:23.220 --> 00:26:26.620
registered at the same time,
and now you have the same code

00:26:26.620 --> 00:26:29.120
base on two AppEngine apps,
and you have sort of a

00:26:29.120 --> 00:26:31.100
baked-in test environment.

00:26:31.100 --> 00:26:35.400
On top of that, we had multiple
people on the team that were

00:26:35.400 --> 00:26:36.640
testing multiple different
functionalities.

00:26:37.860 --> 00:26:41.660
We found that the version
string for each app was a great

00:26:41.660 --> 00:26:45.718
way to give each developer
their own little sandbox to

00:26:45.718 --> 00:26:49.940
test their own feature changes.

00:26:49.940 --> 00:26:52.320
So in summary, we found
AppEngine for TSOL, or

00:26:52.320 --> 00:26:56.480
TechStop Online to be
scalable by default.

00:26:56.220 --> 00:26:58.580
The ability to fetch
corporate data with the

00:26:58.580 --> 00:26:59.640
SDC was a great boon.

00:27:00.680 --> 00:27:05.420
Deferring expensive jobs to the
task queue was essential in

00:27:05.420 --> 00:27:09.380
making TechStop Online work
the way we wanted it to.

00:27:09.480 --> 00:27:12.340
And then, learning about data
storage normalization and

00:27:12.340 --> 00:27:14.960
setting up a test instance
really helped us sort of

00:27:14.960 --> 00:27:18.220
iterate away and create
great applications.

00:27:18.220 --> 00:27:27.700
And with that, I'm going
to hand it over to Irwin.

00:27:27.700 --> 00:27:28.352
IRWIN BOUTBOUL: Thanks, Matt.

00:27:28.352 --> 00:27:28.400
Hi.

00:27:28.400 --> 00:27:30.960
My name is Irwin, and I'm
one of the two engineers

00:27:30.960 --> 00:27:32.480
who built CloudCourse.

00:27:32.480 --> 00:27:34.260
During this presentation, which
is going to be a bit more

00:27:34.260 --> 00:27:38.398
technical, we'll go quickly
over what CloudCourse is, then

00:27:38.398 --> 00:27:40.438
we'll look at the challenges we
faced building this application

00:27:40.438 --> 00:27:43.840
and how we addressed
those challenges.

00:27:43.840 --> 00:27:44.900
So what is CloudCourse?

00:27:44.900 --> 00:27:48.860
CloudCourse is a course
scheduling system, so basically

00:27:48.860 --> 00:27:51.980
it's a platform which allows
people who want to teach a

00:27:51.980 --> 00:27:53.358
particular course to reach out
to people who want

00:27:53.358 --> 00:27:56.460
to learn about it.

00:27:56.460 --> 00:27:59.760
Say, for example, I want to
teach a Python 101 class.

00:27:59.760 --> 00:28:02.340
I would go into the system,
create a new activity Python

00:28:02.340 --> 00:28:04.680
101, and then I would
schedule some sessions.

00:28:04.680 --> 00:28:08.980
I'm going to teach it in New
York City on Monday, in

00:28:08.980 --> 00:28:10.560
Mountain View on Friday,
and over webcast also.

00:28:12.980 --> 00:28:14.960
I'm going to add some
constraints to this.

00:28:14.960 --> 00:28:18.478
I don't want more than ten
people to sign up for my class.

00:28:19.920 --> 00:28:22.020
At some point later, someone
would go into the system

00:28:22.020 --> 00:28:23.080
and make a search.

00:28:23.080 --> 00:28:27.240
Say, all right, I want to learn
about Python, tell me what you

00:28:27.240 --> 00:28:29.480
have next month in
San Francisco.

00:28:29.480 --> 00:28:31.278
And then we're going to return
a list of sessions available.

00:28:32.660 --> 00:28:34.880
Some of them are going to be
open, people can sign up, some

00:28:34.880 --> 00:28:37.078
of them are going to be full
and the user is going

00:28:37.078 --> 00:28:37.880
to be wait-listed.

00:28:38.500 --> 00:28:40.920
That's in a nutshell
what CloudCourse is.

00:28:40.920 --> 00:28:42.960
A course scheduling system.

00:28:43.140 --> 00:28:44.940
How do you do it?

00:28:44.940 --> 00:28:47.940
One, surprise surprise,
AppEngine and Python.

00:28:47.940 --> 00:28:51.320
For the front end, we'll use
the Django web framework and

00:28:51.320 --> 00:28:52.280
the Closure JavaScript Library.

00:28:53.380 --> 00:28:56.800
And we use GData to do calendar
updates, so when a user signs

00:28:56.800 --> 00:28:57.980
up on CloudCourse, we
automatically update

00:28:57.980 --> 00:28:58.360
their calendars.

00:28:59.620 --> 00:29:03.500
All right, now the fun part.

00:29:03.500 --> 00:29:04.806
Our challenges.

00:29:04.960 --> 00:29:08.420
An application like CloudCourse
is inherently very relational.

00:29:08.420 --> 00:29:12.900
How do we deal with the fact
that we don't have joins?

00:29:12.900 --> 00:29:14.120
Second one.

00:29:14.120 --> 00:29:16.200
Long-running computation.

00:29:16.200 --> 00:29:18.680
There's a lot of things
we have to do which are

00:29:18.680 --> 00:29:19.040
going to take some time.

00:29:19.040 --> 00:29:21.078
Say, for example, you
have a session with ten

00:29:21.078 --> 00:29:22.680
people enrolled and ten
people wait-listed.

00:29:23.080 --> 00:29:25.738
Someone is going to drop out
from that particular class.

00:29:25.738 --> 00:29:28.326
We have to reprocess the
wait-listed people, and when

00:29:28.326 --> 00:29:30.920
doing so, we need to send
E-mails, we need to update

00:29:30.920 --> 00:29:34.740
calendars, get user
permissions, and whatnot.

00:29:34.740 --> 00:29:35.660
And this takes time.

00:29:35.660 --> 00:29:38.820
How do we deal with these
long-running computation?

00:29:38.820 --> 00:29:42.118
And finally, we'll go into
details on how we managed to

00:29:42.118 --> 00:29:45.558
build a high-performance
transactional system, and we'll

00:29:45.558 --> 00:29:46.920
look at what we mean exactly.

00:29:46.920 --> 00:29:49.760
So let's start with
the first one.

00:29:49.760 --> 00:29:52.860
No joins.

00:29:52.860 --> 00:29:56.926
This is how a course scheduling
system would look in a

00:29:56.926 --> 00:29:57.220
relational database.

00:29:57.220 --> 00:29:59.840
Your regular sequel stack.

00:29:59.840 --> 00:30:03.740
You have an activity table
and a session table.

00:30:03.740 --> 00:30:06.100
It's a one-to-many relationship
between the activity

00:30:06.100 --> 00:30:08.080
and the sessions.

00:30:08.080 --> 00:30:11.220
Now, when a user goes into the
system and says, all right,

00:30:11.220 --> 00:30:14.298
give me all the Python sessions
you have available in June in

00:30:14.298 --> 00:30:18.180
San Francisco, we need to do
a join between the activity

00:30:18.180 --> 00:30:20.558
table and the session table.

00:30:20.558 --> 00:30:23.860
And this is because of this
name on the activity.

00:30:23.860 --> 00:30:24.220
Now, we don't have joins.

00:30:24.220 --> 00:30:26.520
So how do you deal when
you don't have joins?

00:30:26.520 --> 00:30:30.380
Well, what about we merge
everything in one table so

00:30:30.380 --> 00:30:32.900
there's nothing to join
on, you have one table?

00:30:32.560 --> 00:30:33.460
We can do this.

00:30:34.480 --> 00:30:37.740
We have the name of the
activity, the sessions we're

00:30:37.740 --> 00:30:41.078
going to serialize them in the
list as binary blobs, and then

00:30:41.078 --> 00:30:43.820
we look at the query
we need to do.

00:30:43.820 --> 00:30:46.780
The query is about finding the
sessions of interest for a

00:30:46.780 --> 00:30:47.140
particular date and location.

00:30:47.140 --> 00:30:51.180
So we need to be able to
index on those pairs

00:30:51.180 --> 00:30:53.200
of date and location.

00:30:53.200 --> 00:30:58.920
One easy way to do this is to
put those pairs in the list.

00:30:58.920 --> 00:31:00.680
And this list is going
to be automatically

00:31:00.680 --> 00:31:02.240
indexed by data store.

00:31:02.240 --> 00:31:06.060
So now, when I run a query,
I'm going to be able to do an

00:31:06.060 --> 00:31:09.298
index lookup on this table.

00:31:09.298 --> 00:31:11.420
That works, but that comes
with some limitations.

00:31:11.420 --> 00:31:13.940
If you take this
simple approach.

00:31:13.940 --> 00:31:14.078
One is exploding indices.

00:31:15.060 --> 00:31:20.098
You cannot have more than 1,300
indices in data store, so

00:31:20.098 --> 00:31:23.840
depending on how many pairs of
data and location you have,

00:31:23.840 --> 00:31:25.320
this approach may not work.

00:31:25.320 --> 00:31:29.660
The second issue is one
megabyte limits on every entity

00:31:29.660 --> 00:31:32.460
you store in data store.

00:31:32.460 --> 00:31:34.720
If you have a lot of sessions,
that could be fine, but now, if

00:31:34.720 --> 00:31:36.460
you put a lot of data on each
session, you may run

00:31:36.460 --> 00:31:39.960
into these limits.

00:31:39.960 --> 00:31:42.140
And last but not least,
you a performance issue

00:31:42.140 --> 00:31:43.720
with this approach.

00:31:43.720 --> 00:31:45.880
It's not good, because now,
every time you want to look up

00:31:45.880 --> 00:31:48.040
a particular session, you're
going to have to fetch this

00:31:48.040 --> 00:31:52.640
whole activity into memory to
extract the session

00:31:52.640 --> 00:31:52.680
of interest.

00:31:52.680 --> 00:31:55.400
So even though, when you do
an index look-up it find

00:31:55.400 --> 00:31:56.838
this activity, you are
only interested in a

00:31:56.838 --> 00:31:58.440
particular session.

00:31:58.440 --> 00:32:01.218
And you're going to have to
load this into memory and to

00:32:01.218 --> 00:32:02.978
process it, and it's a
performance issue, and

00:32:02.978 --> 00:32:06.440
eventually it's going to impact
your quota, which is not good.

00:32:06.440 --> 00:32:08.930
So how do we address this?

00:32:09.920 --> 00:32:10.400
Well, we look at the query.

00:32:10.400 --> 00:32:11.920
Why do we join in
the first place?

00:32:11.920 --> 00:32:14.320
We join in the first place
because of this named property.

00:32:14.320 --> 00:32:17.818
So we're going to de-normalize
this, and we're going to

00:32:17.818 --> 00:32:19.100
replicate the named property
at the session level.

00:32:21.300 --> 00:32:25.700
By doing this, we don't have
any exploding indices issue,

00:32:25.700 --> 00:32:28.440
because we don't have a
list we have to index.

00:32:28.440 --> 00:32:30.618
We don't have the one megabyte
limit, because now we can do an

00:32:30.618 --> 00:32:32.578
index look-up on the particular
session of interest.

00:32:33.038 --> 00:32:37.200
This session contains all the
information we can index, which

00:32:37.200 --> 00:32:39.618
is date, location, and name.

00:32:39.618 --> 00:32:42.038
And finally, no performance
issue because we look

00:32:42.038 --> 00:32:44.700
up only one session.

00:32:44.700 --> 00:32:47.040
Now, I can see some eyebrows
raising, and what is it?

00:32:47.040 --> 00:32:49.720
Like, we just de-normalize
data and that's it?

00:32:49.720 --> 00:32:50.580
It's going to work?

00:32:50.580 --> 00:32:51.480
No, it comes with trade-offs.

00:32:51.480 --> 00:32:54.580
And it's not trivial.

00:32:54.580 --> 00:32:59.520
Imagine you have one activity
with a thousand sessions.

00:32:59.520 --> 00:33:02.240
Now, you need to take care of
the relational integrity at the

00:33:02.240 --> 00:33:04.078
application level, because your
back end is not going

00:33:04.078 --> 00:33:06.140
to do it for you.

00:33:06.140 --> 00:33:07.440
This is not straightforward.

00:33:07.440 --> 00:33:11.200
How do you update this name on
a thousand or ten thousand

00:33:11.200 --> 00:33:13.400
entities at the same time?

00:33:13.400 --> 00:33:16.560
It's a long-running process,
and this leads us to

00:33:16.560 --> 00:33:18.360
our second challenge.

00:33:18.360 --> 00:33:19.400
Which is long-running
computation.

00:33:21.980 --> 00:33:24.320
Let's start by describing what
do we put in this long-running

00:33:24.320 --> 00:33:26.000
computation problem?

00:33:26.000 --> 00:33:28.700
Well, definitely, everything
which doesn't fit thirty

00:33:28.700 --> 00:33:32.940
seconds on AppEngine will
fall into that category.

00:33:32.940 --> 00:33:34.220
But we want to put
more than this.

00:33:34.220 --> 00:33:38.500
Everything which is going to
impact the user experience--

00:33:38.500 --> 00:33:41.980
500 miliseconds, one second,
two seconds-- we're going to

00:33:41.980 --> 00:33:43.900
consider this as long-running
computation and we don't want

00:33:43.900 --> 00:33:46.900
the user to see this
happening when they interact

00:33:46.900 --> 00:33:48.440
with our web sites.

00:33:48.440 --> 00:33:50.860
So we're going to push the
burden of the work to back

00:33:50.860 --> 00:33:53.518
end processes, like
calendar updates.

00:33:54.760 --> 00:33:57.120
That's a call to
an external API.

00:33:57.120 --> 00:33:59.280
When you do this in your
enterprise, maybe you want to

00:33:59.280 --> 00:34:00.220
modify Microsoft Outlook.

00:34:00.220 --> 00:34:01.320
Maybe it's going to
take two seconds.

00:34:01.320 --> 00:34:03.900
You want to push this
in the back end.

00:34:03.900 --> 00:34:05.080
How do we push this?

00:34:06.040 --> 00:34:10.218
We use tasks, but we use a
special attribute which is a

00:34:10.218 --> 00:34:15.998
transactional option when
you un-queue a task.

00:34:15.998 --> 00:34:17.878
Say someone signs up on the web
site for a class, Python 101.

00:34:18.758 --> 00:34:20.238
We have to update the calendar,
but we want to update the

00:34:20.238 --> 00:34:22.058
calendar if and only if we're
100% sure that the transaction

00:34:22.058 --> 00:34:28.778
that the user is doing is
going to commit property.

00:34:28.778 --> 00:34:32.318
So the way we do this is we
start the transaction, then we

00:34:32.318 --> 00:34:36.218
un-queue a task with this
transactional flag, and only

00:34:36.218 --> 00:34:39.618
when the transaction commits
will this task be deferred

00:34:39.618 --> 00:34:41.118
in the background.

00:34:41.118 --> 00:34:44.940
And to do this, there's a very
nice API in Python that is not

00:34:44.940 --> 00:34:46.698
very well advertised, and
it's called Deferred API.

00:34:46.698 --> 00:34:51.518
Basically, you can defer any
method call without having to

00:34:51.518 --> 00:34:53.598
write a specific
handler for it.

00:34:53.598 --> 00:34:56.538
So as a developer, this
is very convenient.

00:34:56.538 --> 00:34:58.098
So now you can have all
these tasks running in the

00:34:58.098 --> 00:35:01.338
background, and they may
contend and race for

00:35:01.338 --> 00:35:02.500
the same resources.

00:35:04.958 --> 00:35:08.118
That is going to, maybe slow
the throughput of your system,

00:35:08.118 --> 00:35:09.578
because you're going to have
contention between

00:35:09.578 --> 00:35:10.338
all those tasks.

00:35:10.338 --> 00:35:14.760
So one thing which is very
useful is to chain those tasks.

00:35:14.760 --> 00:35:16.620
And to chain tasks, you can
leverage call jobs very easily.

00:35:16.620 --> 00:35:22.578
Let's look at our
last challenge.

00:35:22.578 --> 00:35:24.458
High performance
transactional work flows.

00:35:24.458 --> 00:35:27.038
Take an example, Google IO.

00:35:27.038 --> 00:35:31.758
We have a limit, 5,000
seats available.

00:35:31.758 --> 00:35:34.380
We send a notification
to millions of people

00:35:34.380 --> 00:35:36.778
at the same time.

00:35:36.778 --> 00:35:39.358
Now, at any given time, dozens
of people are going to try

00:35:39.358 --> 00:35:43.098
to register for Google
IO at the same time.

00:35:44.158 --> 00:35:49.458
How do we make sure that we
have this limit of 5,000, and

00:35:49.458 --> 00:35:50.398
every time someone signs up,
we're going to be able

00:35:50.398 --> 00:35:52.798
to say yes or no?

00:35:52.798 --> 00:35:56.178
The way to do this is by
having a transaction

00:35:56.178 --> 00:35:58.518
on this information.

00:35:58.518 --> 00:36:01.078
On AppEngine, the way you
do this is by leveraging

00:36:01.078 --> 00:36:01.840
entity groups.

00:36:01.840 --> 00:36:06.458
It's basically the way to group
entities so that you can

00:36:06.458 --> 00:36:08.800
leverage a transaction when
you work on those entities.

00:36:08.800 --> 00:36:14.718
In our sample, we have the
activity as a session and the

00:36:14.718 --> 00:36:16.198
fact that the user is signing
up for a particular session

00:36:16.198 --> 00:36:18.498
in the same entity group.

00:36:18.498 --> 00:36:21.858
So when the user goes on the
web site and signs up, we stop

00:36:21.858 --> 00:36:24.218
the transaction on this group,
we look up how many users do we

00:36:24.218 --> 00:36:28.258
have right now, and then we can
give you an answer yes, you are

00:36:28.258 --> 00:36:29.938
below the limit, you are going
to be enrolled, or you're

00:36:29.938 --> 00:36:32.998
going to be wait-listed.

00:36:32.998 --> 00:36:34.998
Now, this is a natural
approach on AppEngine.

00:36:35.840 --> 00:36:40.138
But now, every sign up
becomes a transaction on

00:36:40.138 --> 00:36:41.978
the particular entity.

00:36:41.978 --> 00:36:50.618
And you cannot get a lot of
transactions on the same

00:36:50.618 --> 00:36:51.400
entity at any given time.

00:36:52.198 --> 00:36:55.218
Basically, you're going to get
one to ten, depending on what

00:36:55.218 --> 00:36:58.720
your application does, and one
to ten is just too slow for us.

00:36:58.720 --> 00:37:01.178
Think about it like, twelve
users come at the same time,

00:37:01.178 --> 00:37:03.780
try to sign up, some of them
are going to get timed out,

00:37:03.780 --> 00:37:04.580
so a ten-second delay.

00:37:04.960 --> 00:37:07.838
That's not an acceptable
user experience.

00:37:07.838 --> 00:37:08.558
How do we improve this?

00:37:08.558 --> 00:37:12.018
Well, why do we have this
bottleneck to start with?

00:37:12.018 --> 00:37:15.978
That's because we add the
enrollments in the same

00:37:15.978 --> 00:37:19.598
entity group as the
activity and the session.

00:37:19.598 --> 00:37:21.178
The enrollment is where we have
thousands of users contending

00:37:21.178 --> 00:37:22.638
for the same resources.

00:37:22.638 --> 00:37:24.900
So we're going to
break this apart.

00:37:24.900 --> 00:37:27.578
And we're going to take
the enrollments out

00:37:27.578 --> 00:37:30.358
of the entity group.

00:37:30.358 --> 00:37:33.518
Now, if you're still following,
the reason to be concerned now.

00:37:33.518 --> 00:37:35.118
How do we make sure that we
have these transactional

00:37:35.118 --> 00:37:38.818
semantics, now that we
removed the enrollment

00:37:38.818 --> 00:37:42.678
from this entity group?

00:37:42.678 --> 00:37:46.358
Well, the way we work around
this is by constructing our

00:37:46.358 --> 00:37:50.938
application in a certain way so
that we're going to leverage a

00:37:50.938 --> 00:37:53.860
memcache API that some
of you may know.

00:37:53.860 --> 00:37:56.298
It's called Increment and
Decrement, and what's

00:37:56.298 --> 00:37:59.248
interesting about this
particular API is that it

00:37:59.248 --> 00:37:59.978
has atomic semantics.

00:37:59.978 --> 00:38:05.760
So at any given time, there's
only going to be one process

00:38:05.760 --> 00:38:08.280
which can access this.

00:38:08.280 --> 00:38:09.638
So how do we use this?

00:38:09.638 --> 00:38:13.178
Well, we have a counter in
memcache which is going to keep

00:38:13.178 --> 00:38:15.620
track of how many people do I
have signed up for that

00:38:15.620 --> 00:38:16.640
particular course
at any given time.

00:38:17.880 --> 00:38:19.718
Every time someone signs up,
I increment this counter.

00:38:20.158 --> 00:38:22.838
And I can check, if it's below
the limit it's OK, if it's

00:38:22.838 --> 00:38:24.618
above the limit I'm going
to wait-list the user.

00:38:26.178 --> 00:38:28.458
Now, this is a cache, and like
every other cache, whatever

00:38:28.458 --> 00:38:31.098
you put inside it can be
evicted at any given time.

00:38:31.098 --> 00:38:34.178
And when your counter drops
out from this cache,

00:38:34.178 --> 00:38:36.178
you need to rebuild it.

00:38:36.598 --> 00:38:38.678
And this is where things
get interesting.

00:38:38.678 --> 00:38:39.300
How do you rebuild this cache?

00:38:39.300 --> 00:38:44.300
Well, if you want to be exact,
you need to build this-- you

00:38:44.300 --> 00:38:47.900
need to take this big giant log
on the activities of session

00:38:47.900 --> 00:38:51.738
and the user enrollment
information to be able to count

00:38:51.738 --> 00:38:53.018
the exact number of people who
have signed up at that

00:38:53.018 --> 00:38:56.340
particular moment of time, and
you need to have this log

00:38:56.340 --> 00:38:58.618
because you don't want someone
else to sign up while you're

00:38:58.618 --> 00:39:02.938
counting how many people
have signed up so far.

00:39:02.938 --> 00:39:05.278
But if we take this giant log,
we're back to square one.

00:39:05.278 --> 00:39:08.998
We have these limits of one
to ten per seconds, and we

00:39:08.998 --> 00:39:09.138
don't want these limits.

00:39:10.798 --> 00:39:12.158
So the way we're going to
construct this counter is

00:39:12.158 --> 00:39:15.760
by being conservative.

00:39:15.760 --> 00:39:18.078
When we count the number of
people who are enrolled at

00:39:18.078 --> 00:39:21.138
any given time, we don't
want the exact count.

00:39:21.138 --> 00:39:26.320
Really, what we want is
a conservative count.

00:39:26.320 --> 00:39:29.880
And the way we construct these
counts, now when someone signs

00:39:29.880 --> 00:39:30.978
up, we're going to
say, all right.

00:39:30.978 --> 00:39:34.478
You have a session with ten
people enrolled and your limit

00:39:34.478 --> 00:39:37.498
is ten for this session.

00:39:37.498 --> 00:39:39.578
And we're going to have
to wait-list two berths.

00:39:39.578 --> 00:39:42.858
It could be that we think this
counter is ten, even though

00:39:42.858 --> 00:39:44.260
there's really nine people
enrolled at that time, because

00:39:44.260 --> 00:39:45.780
when we construct it,
we're conservative.

00:39:47.538 --> 00:39:50.578
So in most cases, the user
experience online is

00:39:50.578 --> 00:39:51.760
going to be good.

00:39:51.760 --> 00:39:54.618
We're going to be able to give
approximately a good response

00:39:54.618 --> 00:39:56.200
for the counter, and then the
people are going

00:39:56.200 --> 00:39:56.840
to be enrolled.

00:39:56.840 --> 00:39:59.398
In those very edge cases,
some people are going to

00:39:59.398 --> 00:40:01.598
be wait-listed even though
really they could have been

00:40:01.598 --> 00:40:04.398
enrolled, but that's OK.

00:40:04.398 --> 00:40:07.320
Because we have a back end
process which, offline, is

00:40:07.320 --> 00:40:08.420
going to correct those answers.

00:40:09.158 --> 00:40:14.380
It's going to do an exact count
by taking this big giant log on

00:40:14.380 --> 00:40:18.178
everything, the activities, the
session, and the users, and it

00:40:18.178 --> 00:40:21.278
will either confirm or deny the
response that the

00:40:21.278 --> 00:40:22.198
user got online.

00:40:24.360 --> 00:40:27.048
And this back end process can
proceed at its own pace, one to

00:40:27.048 --> 00:40:28.098
ten per second, that's fine.

00:40:28.098 --> 00:40:30.300
What we care about is the user
experience online, which

00:40:30.300 --> 00:40:32.238
is going to be good.

00:40:32.238 --> 00:40:34.318
So what does this user
experience look like in

00:40:34.318 --> 00:40:35.698
terms of performance?

00:40:35.698 --> 00:40:41.360
This is a profiling of a user
signing up for a class online.

00:40:41.360 --> 00:40:44.300
There's about fifteen RPC calls
here, but the one which is of

00:40:44.300 --> 00:40:46.098
interest is the memcache API:.

00:40:47.218 --> 00:40:51.878
The memcache increment is
taking eight milliseconds.

00:40:51.878 --> 00:40:54.848
And that's a conservative
approach, but let's say-- all

00:40:54.848 --> 00:40:56.398
right, eight, ten milliseconds.

00:40:56.398 --> 00:40:59.298
That's, if you do the math,
about a hundred plus rights

00:40:59.298 --> 00:41:05.678
per second, hundred plus
signed up for an activity.

00:41:05.678 --> 00:41:07.718
Hundred plus signed up
for one single activity,

00:41:07.718 --> 00:41:08.498
like Google IO.

00:41:08.498 --> 00:41:10.598
But you're on AppEngine, right?

00:41:10.598 --> 00:41:12.100
You don't have only
one activity.

00:41:13.238 --> 00:41:16.480
You may have ten, hundred,
thousand, billions.

00:41:16.480 --> 00:41:20.558
The underlying data
store supports it.

00:41:20.538 --> 00:41:23.320
So, think about it.

00:41:23.320 --> 00:41:28.900
A thousand classes, a thousand
courses, hundred plus signed up

00:41:28.900 --> 00:41:33.178
per second for each one of
them, that's a 100,000 signed

00:41:33.178 --> 00:41:37.498
up per second in the
transactional workflow.

00:41:37.498 --> 00:41:39.880
Now, let's take a step back
and see what we just did.

00:41:40.858 --> 00:41:43.738
We took a schema, relational
schema, the one you're very

00:41:43.738 --> 00:41:46.938
familiar with, we analyzed
the type of queries that our

00:41:46.938 --> 00:41:51.078
system does, and we made
a small de-normalization.

00:41:51.078 --> 00:41:52.638
Not too complex.

00:41:52.638 --> 00:41:56.238
And then we leverage an
existing API, which has atomic

00:41:56.238 --> 00:42:00.718
semantics, and we come up with
a system which supports 100,000

00:42:00.718 --> 00:42:03.918
plus transactions per second.

00:42:04.864 --> 00:42:05.838
Now,

00:42:05.838 --> 00:42:07.658
that's pretty good.

00:42:07.658 --> 00:42:11.860
As an application developer, I
don't have to care about tuning

00:42:11.860 --> 00:42:15.438
my JVM, how much memory do I
have, what's my fail-over

00:42:15.438 --> 00:42:17.880
policy, how do I deal
with all those things.

00:42:17.880 --> 00:42:20.378
Usually you spend months
working on those things.

00:42:20.378 --> 00:42:22.320
I didn't have to tune
the application.

00:42:22.320 --> 00:42:23.098
And I get that kind
of scalability.

00:42:24.858 --> 00:42:27.458
Even if that doesn't make you
feel good, it's going to make

00:42:27.458 --> 00:42:31.038
feel good your CIO, because
you don't have to provision

00:42:31.038 --> 00:42:32.678
any missions here.

00:42:32.678 --> 00:42:36.478
This application runs
when it needs to run.

00:42:36.478 --> 00:42:39.980
And yesterday I took a look at
our internal deployment of

00:42:39.980 --> 00:42:44.398
CloudCourse, and we have
20,00 employees in Google.

00:42:45.718 --> 00:42:50.198
We have about 1,000 signs-up
every day on classes on this

00:42:50.198 --> 00:42:57.638
system, and we are still
running below the free quarter.

00:42:57.638 --> 00:43:01.498
So take an application like
this, deploy it on your-- in

00:43:01.498 --> 00:43:03.238
your organization, and
it comes for free.

00:43:03.238 --> 00:43:08.178
No maintenance, no
strings attached.

00:43:08.178 --> 00:43:10.978
So let's see what
we just went over.

00:43:10.978 --> 00:43:13.998
De-normalization trade-offs:
again, don't be afraid of

00:43:13.998 --> 00:43:16.218
de-normalization, don't
de-normalize everything, you

00:43:16.218 --> 00:43:18.160
have to look at the type of
queries that you make, and

00:43:18.160 --> 00:43:19.238
maybe you're not going to
have to de-normalize

00:43:19.238 --> 00:43:19.540
any of your data.

00:43:22.318 --> 00:43:25.498
Asynchronous processing: we
went over this with AppReduce,

00:43:25.498 --> 00:43:26.418
TechStop Online, CloudCourse.

00:43:27.018 --> 00:43:30.038
You want to defer in the
background as much as possible

00:43:30.038 --> 00:43:33.218
when deploying on AppEngine.

00:43:33.218 --> 00:43:37.738
And finally, we've seen how we
can leverage some advanced APIs

00:43:37.738 --> 00:43:41.718
to build a high-performance
transactional system.

00:43:41.718 --> 00:43:43.978
And with that side I'm going
to turn it over to Ben with

00:43:43.978 --> 00:43:44.588
some interesting news.
935
00:43:45,558 --&gt; 00:43:45,53
BEN FRIED:

00:43:45.530 --> 00:43:46.470
All right.

00:43:46.470 --> 00:43:47.412
Thanks, Irwin.

00:43:51.178 --> 00:43:53.718
So, speaking of CloudCourse, we
have an announcement to make,

00:43:53.718 --> 00:43:57.538
which is that CloudCourse is
available as open source

00:43:57.538 --> 00:43:59.340
for you all today.

00:43:59.340 --> 00:44:01.658
There's the URL on the screen,
you can download it, install

00:44:01.658 --> 00:44:04.178
it in AppEngine, run it for
your organization right now.

00:44:04.178 --> 00:44:07.240
It's exactly the same code that
we're running inside Google,

00:44:07.240 --> 00:44:08.460
available to you today.

00:44:08.460 --> 00:44:11.080
There's going to be a posting
on the Google Opensource blog

00:44:11.080 --> 00:44:16.892
about this, theoretically in
about nine minutes, so we can

00:44:16.892 --> 00:44:17.500
share this with the world.

00:44:17.500 --> 00:44:19.120
And, as Irwin said, even a
company the size of Google can

00:44:19.120 --> 00:44:21.200
run this with really, really
little impact on

00:44:21.200 --> 00:44:22.298
the bottom line.

00:44:22.298 --> 00:44:24.078
If you're not a CIO, go back
and tell your CIO, they might

00:44:24.078 --> 00:44:26.540
be kind of happy to
hear about this.

00:44:26.540 --> 00:44:30.800
Now, it is our intent, is our
aspiration to follow exactly

00:44:30.800 --> 00:44:33.110
the same open sourcing policy
with TechStop Online and

00:44:33.110 --> 00:44:36.360
AppReduce, but the reality of
it is that we're not as far

00:44:36.360 --> 00:44:38.618
down the path with those two
apps as we are with this one.

00:44:38.618 --> 00:44:41.198
In the case of AppReduce, we
have the source code and the

00:44:41.198 --> 00:44:44.998
design documents for the demon
that sits in front of SMS or

00:44:44.998 --> 00:44:49.598
SCCM are available right now,
and we've got some general-- oh

00:44:49.598 --> 00:44:54.298
sorry, for TechStop Online, we
have that, and we have-- I was

00:44:54.298 --> 00:44:57.498
right, AppReduce the first
time, coffee gave out on me.

00:44:57.498 --> 00:45:00.778
And then some design docs we
have produced are available as

00:45:00.778 --> 00:45:02.038
well, and hopefully we'll have
some announcements about

00:45:02.038 --> 00:45:04.058
TechStop Online coming soon.

00:45:04.618 --> 00:45:07.238
Finally, you know, we've got
the engineers who built these

00:45:07.238 --> 00:45:10.940
apps are in the AppEngine
sandbox, and they're-- be more

00:45:10.940 --> 00:45:13.040
than happy to demo these or
other applications that we use

00:45:13.040 --> 00:45:15.718
to run Google on Google's
cloud technologies

00:45:15.718 --> 00:45:17.440
for all of you today.

00:45:17.158 --> 00:45:18.400
Or tomorrow.

00:45:18.400 --> 00:45:20.860
So please, stop by, get a demo,
ask us questions if there's

00:45:20.860 --> 00:45:21.400
something you want to
ask us one-on-one.

00:45:21.400 --> 00:45:25.838
And now I think we'll cut over
to Q&amp;A, let's flip over to

00:45:25.838 --> 00:45:29.498
the moderator, and we do have
t-shirts that we're giving out.

00:45:29.498 --> 00:45:31.280
If you want to ask a question
live, you can definitely

00:45:31.280 --> 00:45:32.758
get a t-shirt.

00:45:32.758 --> 00:45:36.718
Let's get the t-shirt
artillery team ready.

00:45:36.718 --> 00:45:37.418
MODERATOR: One thing.

00:45:38.158 --> 00:45:42.198
Please, if you can, make use of
the microphones in the aisles

00:45:42.198 --> 00:45:46.338
so that we'll be able to
capture your questions

00:45:46.338 --> 00:45:48.638
for posterity.

00:45:48.638 --> 00:45:50.558
BEN FRIED: So, I should add
that we have a bunch of our

00:45:50.558 --> 00:45:52.658
friends from the AppEngine team
are here to help answer

00:45:52.658 --> 00:45:54.800
questions, since we anticipated
a bunch of questions.

00:45:54.800 --> 00:45:57.058
It might be more AppEngine or
SDC-ish than just about what

00:45:57.058 --> 00:46:00.340
we do here at Google,
so here we are.

00:46:00.340 --> 00:46:01.138
All right.

00:46:01.138 --> 00:46:04.958
T-shirt number one.
990
00:46:04,958 --&gt; 00:46:04,148
OK.

00:46:04.148 --> 00:46:08.738
How many of the Google teams
have a t-shirt slingshot?

00:46:08.738 --> 00:46:09.058
OK?

00:46:09.058 --> 00:46:13.918
All right, so the first
question-- you all signed a

00:46:13.918 --> 00:46:14.760
release when you joined.

00:46:14.760 --> 00:46:15.400
OK.

00:46:15.400 --> 00:46:19.178
Running a 250GB database for a
well-known association, think

00:46:19.178 --> 00:46:22.238
minty chocolate cookies, not
sure we could entirely get away

00:46:22.238 --> 00:46:23.260
from our sequel back end.

00:46:23.260 --> 00:46:25.618
Do you foresee any ability
to replicate in and out

00:46:25.618 --> 00:46:28.638
of AppEngine with such
a large database?

00:46:28.638 --> 00:46:28.760
Sean.

00:46:28.760 --> 00:46:30.520
SEAN LYNCH: I guess
I'll take this one.

00:46:30.780 --> 00:46:32.340
So there's a couple
of issues on--

00:46:32.340 --> 00:46:34.960
BEN FRIED: Did you
introduce yourself, Sean?
1005
00:46:34,96 --&gt; 00:46:34,73
SEAN LYNCH: Oh yeah.

00:46:34.730 --> 00:46:34.884
Sorry.

00:46:34.884 --> 00:46:36.080
I'm Sean Lynch, I'm the
AppEngine product manager.

00:46:36.080 --> 00:46:39.060
So there's a couple of issues
sort of woven into the

00:46:39.060 --> 00:46:40.940
same question here.

00:46:41.538 --> 00:46:45.078
In terms of size of database,
250GB is fine on data

00:46:45.078 --> 00:46:46.938
stores that exist today.

00:46:46.938 --> 00:46:52.018
We have customers that are
using databases substantially

00:46:52.018 --> 00:46:53.698
larger than that.

00:46:53.698 --> 00:46:55.498
The sequel piece, as you saw in
today's keynote, is something

00:46:55.498 --> 00:46:59.098
that we're excited to announce
and that's coming, so you will

00:46:59.098 --> 00:47:02.438
be able to do-- it wasn't sort
of mentioned in today's talks

00:47:02.438 --> 00:47:05.978
because they're not using it
either yet, but that's

00:47:05.978 --> 00:47:08.118
something that we hope that
people will have available to

00:47:08.118 --> 00:47:10.298
them in the near future.

00:47:10.298 --> 00:47:13.858
The replicated part, that's a
little bit more interesting, I

00:47:13.858 --> 00:47:16.340
think it's one that we have to
talk about, especially if

00:47:16.340 --> 00:47:18.080
there's a lot of interest in
that, but at the moment I don't

00:47:18.080 --> 00:47:22.678
think that's a specific
on the road map.

00:47:22.678 --> 00:47:25.360
BEN FRIED: OK, so let's go to a
live question here in the room.

00:47:25.360 --> 00:47:32.738
SEAN LYNCH: There is, as a
pitch for one of the other tech

00:47:32.738 --> 00:47:33.680
talks we have later today.

00:47:33.680 --> 00:47:39.150
There is the Bulkloader API,
and we have a new version of

00:47:39.150 --> 00:47:42.678
that we released this morning.

00:47:42.678 --> 00:47:46.800
So we'll be going over that
in a later session as well.

00:47:46.800 --> 00:47:46.906
Matt Blaine's actually going to
be teaching that one what can

00:47:46.906 --> 00:47:46.978
be used to accomplish that.

00:47:46.978 --> 00:47:49.038
BEN FRIED: OK, so live
questions in the room.

00:47:49.038 --> 00:47:50.378
Sir.
1034
00:47:50,378 --&gt; 00:47:50,138
AUDIENCE: Yeah.

00:47:50.138 --> 00:47:53.378
Hi.

00:47:53.378 --> 00:47:54.018
I don't know much about the
Secure Data Connector.

00:47:54.018 --> 00:47:56.606
I was wondering if you
could give a little more

00:47:56.606 --> 00:47:56.838
background on that.

00:47:56.838 --> 00:48:00.438
Does that run over HTTPS
as like, a transport?

00:48:00.438 --> 00:48:07.438
And also, is the CloudCourse
actually using Secure

00:48:07.438 --> 00:48:07.958
Data Connector?

00:48:07.958 --> 00:48:09.738
IRWIN BOUTBOUL: So I
start with CloudCourse.

00:48:09.738 --> 00:48:13.368
CloudCourse internally is using
the Secure Data Connector to

00:48:13.368 --> 00:48:13.898
perform services like search.

00:48:13.898 --> 00:48:20.038
We also synchronize CloudCourse
data with some other

00:48:20.038 --> 00:48:20.738
internal databases.

00:48:20.938 --> 00:48:23.860
To do this, yes, internally
we do use CloudCourse.

00:48:24.820 --> 00:48:28.698
And in CloudCOurse, you see on
the open source blog, basically

00:48:28.698 --> 00:48:31.838
we-- you can plug your own
implementation of different

00:48:31.838 --> 00:48:34.618
services like the search
database, the user information

00:48:34.618 --> 00:48:37.824
services, to use in your own
enterprise and you can

00:48:37.824 --> 00:48:38.978
plug it with SDC.

00:48:38.978 --> 00:48:39.998
AUDIENCE: Great, thank you.

00:48:39.998 --> 00:48:42.478
DAVE PRIMER: So, I'll
quickly explain.

00:48:42.478 --> 00:48:44.198
The base--
1056
00:48:44,198 --&gt; 00:48:44,078
BEN FRIED: Introduce
yourself, my friend.

00:48:44.078 --> 00:48:45.060
DAVE PRIMER: Oh, sorry.

00:48:45.060 --> 00:48:47.220
I'm Dave Primer, I was
an engineer on Secure

00:48:47.220 --> 00:48:48.278
Data Connector.

00:48:49.338 --> 00:48:51.760
Secure Data Connector is
basically a technology that

00:48:51.760 --> 00:48:55.280
allows Google to reach inside
of your firewall, and it does

00:48:55.280 --> 00:48:59.758
that by providing an agent that
you run in your network, and

00:48:59.758 --> 00:49:03.038
that agent connects back to
Google and creates a tunnel.

00:49:03.038 --> 00:49:05.558
You don't have to actually open
up any ports on your firewall

00:49:05.558 --> 00:49:10.538
because the initial connection
is outbound by the agent, and

00:49:10.538 --> 00:49:15.280
Google can then use that tunnel
that's been created to make

00:49:15.280 --> 00:49:18.060
requests, and the requests
actually originate as if they

00:49:18.060 --> 00:49:19.920
were on your internal network.

00:49:19.920 --> 00:49:21.138
They use the DNS of the
machine that runs the

00:49:21.138 --> 00:49:24.358
agent, and it's-- yeah.

00:49:24.358 --> 00:49:31.518
It runs over HTTP and HTTPS.

00:49:31.518 --> 00:49:34.458
BEN FRIED: Watch out
for the friendly fire.

00:49:34.458 --> 00:49:35.798
All right, so another live
question and then we'll

00:49:35.798 --> 00:49:37.158
hit the question on the
moderator after that.

00:49:37.158 --> 00:49:38.358
Sir.

00:49:38.358 --> 00:49:39.198
AUDIENCE: Sure.

00:49:39.198 --> 00:49:43.300
We have about 850GB of files
that we store as just files

00:49:43.300 --> 00:49:44.760
in a file system right now.

00:49:44.760 --> 00:49:47.698
Would there be any facility
within AppEngine to store

00:49:47.698 --> 00:49:50.538
things like that, that are
books, just binary data in that

00:49:50.538 --> 00:49:53.492
quantity, or would we use the
Secure Data Connector and host

00:49:53.492 --> 00:49:54.258
it on our own network, or?

00:49:54.258 --> 00:49:56.418
SEAN LYNCH: So one of the
recent additions to the

00:49:56.418 --> 00:49:59.818
AppEngine platform was the Blob
Story PI, and it's more

00:49:59.818 --> 00:50:02.098
designed for hosting things
that are, you know, just

00:50:02.098 --> 00:50:07.770
arbitrary chunks of data, like
books or, you know, anything

00:50:07.770 --> 00:50:08.506
that is bigger than the 1MB
limit so you don't have to

00:50:08.506 --> 00:50:09.060
shard it, things like that.

00:50:09.060 --> 00:50:11.058
AUDIENCE: What kind of size
limits exist for that?

00:50:11.058 --> 00:50:14.118
SEAN LYNCH: So it was 50MB when
we originally launched it,

00:50:14.118 --> 00:50:16.178
today we raised it up to 2GB.

00:50:16.178 --> 00:50:17.860
So--

00:50:17.860 --> 00:50:19.360
AUDIENCE: Total for
the whole index?

00:50:19.360 --> 00:50:21.320
SEAN LYNCH: Oh no,
that's per file is 2GB.
1095
00:50:21,32 --&gt; 00:50:21,058
AUDIENCE: Oh, excellent.

00:50:21.058 --> 00:50:21.138
Thank you.

00:50:21.138 --> 00:50:25.418
BEN FRIED: OK, for those of you
who got t-shirts, by the way, I

00:50:25.418 --> 00:50:28.560
should mention that if it's not
your size, come find Tim in the

00:50:28.560 --> 00:50:30.700
corner afterwards and
he'll swap out for one

00:50:30.700 --> 00:50:31.898
that is your size.

00:50:31.898 --> 00:50:34.878
Now, let's go to a question
that appeared on the moderator.

00:50:34.878 --> 00:50:36.820
I think this is another
one for Sean, actually.

00:50:36.820 --> 00:50:39.260
How does AppEngine address
government data concerns,

00:50:39.260 --> 00:50:41.260
specifically HIPAA compliance
and ownership concerns where

00:50:41.260 --> 00:50:46.438
data is stored in the cloud and
not on government servers?

00:50:46.438 --> 00:50:46.498
GOOGLE ENGINEER: Sure, Ed.

00:50:46.498 --> 00:50:47.360
I'll go ahead and
take this one.

00:50:47.360 --> 00:50:49.260
You know, it's a
tough question.

00:50:49.618 --> 00:50:51.040
There are a lot of different
certifications, and some of

00:50:51.040 --> 00:50:54.158
the certifications are
really stringent ones.

00:50:54.158 --> 00:50:56.820
For AppEngine, for the
AppEngine product as it is

00:50:56.820 --> 00:51:00.498
today and for the AppEngine
business product, we are

00:51:00.498 --> 00:51:01.888
pursuing getting these
certifications for

00:51:01.888 --> 00:51:03.080
our data centers.

00:51:03.080 --> 00:51:06.118
They take a long time to get,
we are working on them, so I

00:51:06.118 --> 00:51:08.980
think the best that I can tell
you right now is we not only

00:51:08.980 --> 00:51:11.198
know about it, but we are
working on it and we're trying

00:51:11.198 --> 00:51:12.980
to get that certification
so you can have that

00:51:12.980 --> 00:51:14.660
level of confidence.

00:51:14.660 --> 00:51:16.120
Or if it's something that's
required by your employer,

00:51:16.120 --> 00:51:18.498
do something for it.

00:51:18.418 --> 00:51:21.218
The other thing I can also tell
you is there is a published

00:51:21.218 --> 00:51:25.038
document that we have, between
Google AppEngine and Google

00:51:25.038 --> 00:51:28.020
Apps, which tells you about
some of the security policies

00:51:28.020 --> 00:51:30.860
and how we run our data centers
and how we protect data.

00:51:30.878 --> 00:51:34.972
I think it's a great sort of--
I think it's four or five pages

00:51:34.972 --> 00:51:37.510
long, but it goes into depth on
just how we run our data

00:51:37.510 --> 00:51:41.178
centers, how we control who has
access to what, and all the

00:51:41.178 --> 00:51:42.118
procedures that we do.

00:51:42.118 --> 00:51:44.980
So I think that's a great thing
to read, or a great thing to

00:51:44.980 --> 00:51:47.678
pass on to other people you
might work if they have

00:51:47.678 --> 00:51:49.958
concerns about Google.

00:51:49.958 --> 00:51:50.678
BEN FRIED: OK, great.

00:51:50.678 --> 00:51:53.478
So I'll just take
another live question.

00:51:53.478 --> 00:51:55.518
AUDIENCE: I couldn't help
notice that your examples

00:51:55.518 --> 00:51:57.460
all use the Python
flavor of the AppEngine.

00:51:57.460 --> 00:52:01.064
Are you guys sending a
secret message to us

00:52:01.064 --> 00:52:01.118
to deploy Java apps?

00:52:01.118 --> 00:52:02.988
BEN FRIED: Oh, no.
1140
00:52:02,988 --&gt; 00:52:02,112
No.

00:52:02.112 --> 00:52:03.098
Oh, great question.

00:52:03.098 --> 00:52:03.778
Absolutely not.

00:52:03.778 --> 00:52:07.198
So, it just so happens that the
goal of the presentation was

00:52:07.198 --> 00:52:10.378
for us to show you all problems
that we thought related as

00:52:10.378 --> 00:52:12.378
closely as possible to problems
you might have as you thought

00:52:12.378 --> 00:52:14.540
about trying to get your
feet wet in AppEngine.

00:52:14.540 --> 00:52:16.960
And a lot of that has to
do with how you talk back

00:52:16.960 --> 00:52:18.280
to services that are
inside your company.

00:52:18.280 --> 00:52:21.760
It just so happens that the
apps that we selected, that we

00:52:21.760 --> 00:52:24.058
thought were great exemplars
of solving that kind of

00:52:24.058 --> 00:52:25.358
problem, were in Python.

00:52:25.760 --> 00:52:28.800
But in fact, I mean, we have an
application that we use for

00:52:28.800 --> 00:52:31.118
doing feedback on interview
candidates called Hire/NoHire,

00:52:31.118 --> 00:52:35.252
which is a Java GWT AppEngine
app that talks back to our--

00:52:35.252 --> 00:52:37.018
inside to our applicant
tracking system, and Matt,

00:52:37.018 --> 00:52:40.358
who's the author of that, is
here today and he'll be in the

00:52:40.358 --> 00:52:42.778
sandbox if you want to talk
about our experience with

00:52:42.778 --> 00:52:45.180
the Java GWT AppEngine
environment as well.

00:52:45.180 --> 00:52:46.566
They're both great.

00:52:46.566 --> 00:52:49.298
I mean, I think it really has
to do with the skills that you

00:52:49.298 --> 00:52:51.598
have and want to have in
your environment, right?

00:52:51.598 --> 00:52:55.878
They're-- you know,
we're big fans of both.

00:52:56.078 --> 00:52:57.698
Another live question?

00:52:57.698 --> 00:53:01.860
AUDIENCE: First there was
Python and then, I guess, Java.

00:53:01.860 --> 00:53:06.038
Are there any plans
for future languages?

00:53:06.038 --> 00:53:12.698
BEN FRIED: I know of no plan
for a COBOL AppEngine, but--

00:53:12.698 --> 00:53:15.618
SEAN LYNCH: So at the moment,
there's nothing official

00:53:15.618 --> 00:53:16.898
that we can say.

00:53:17.738 --> 00:53:19.978
If there's other languages that
you're looking for, definitely

00:53:19.978 --> 00:53:24.680
take a look at some of the
open-source projects out there

00:53:24.680 --> 00:53:25.640
to get other languages
running on the JVM.

00:53:26.320 --> 00:53:29.218
I know that we have some JRuby
guys here today that have been

00:53:29.218 --> 00:53:33.240
really successful, these guys
are-- Closure is actually

00:53:33.240 --> 00:53:34.000
in our sandbox, I believe.

00:53:35.058 --> 00:53:37.258
So there's a lot of people
doing a lot of really cool

00:53:37.258 --> 00:53:44.820
things with other languages
just on top of the JVM.

00:53:44.820 --> 00:53:46.118
BEN FRIED: Why don't we take
another live question.

00:53:46.118 --> 00:53:49.518
Sir.

00:53:49.518 --> 00:53:49.678
AUDIENCE: OK, thanks.

00:53:49.678 --> 00:53:54.918
One of things that's talked
about is, it just works.

00:53:54.918 --> 00:53:56.158
So, people who deploy their
applications typically monitor

00:53:56.158 --> 00:54:00.158
them, IT managers need to
monitor their equipment,

00:54:00.158 --> 00:54:02.018
network storage applications.

00:54:02.018 --> 00:54:06.158
How do you monitor that within
Google for yourself, so that

00:54:06.158 --> 00:54:10.658
you don't get the call
that says it's down and

00:54:10.658 --> 00:54:11.260
nobody else fixed it?

00:54:11.260 --> 00:54:13.198
And what do you provide to
people who use AppEngine, to

00:54:13.198 --> 00:54:16.918
make that possible for them,
or some parts of them?

00:54:16.918 --> 00:54:18.398
BEN FRIED: So, one thing, and
this has to do with the

00:54:18.398 --> 00:54:19.508
question that's up on the
moderator as well that we

00:54:19.508 --> 00:54:23.740
should make clear, is that we
try very hard not to kind of go

00:54:23.740 --> 00:54:25.800
around the back door and take
advantage of the fact that

00:54:25.800 --> 00:54:28.668
we're all in the same company,
but when it comes to how Google

00:54:28.668 --> 00:54:31.620
runs itself, we want to treat
ourselves like a customer.

00:54:31.320 --> 00:54:33.530
Obviously the people who work
on AppEngine and the people who

00:54:33.530 --> 00:54:36.140
work on these apps are
colleagues and have collegial

00:54:36.140 --> 00:54:39.598
relationships and so on, but
it's really important to me for

00:54:39.598 --> 00:54:42.318
my organization, and to Kevin
and David and Vic, that we

00:54:42.318 --> 00:54:45.398
treat this as a model
provider-customer

00:54:45.398 --> 00:54:46.998
relationship, right?

00:54:46.998 --> 00:54:49.118
And that we learn about--
AppEngine for Business is

00:54:49.118 --> 00:54:51.500
brand-new, we just launched it
today, the goal is that we do

00:54:51.500 --> 00:54:53.640
this so we learn about how
to make these business

00:54:53.640 --> 00:54:54.380
offering better, right?

00:54:54.380 --> 00:54:56.540
If we just kind of went behind
the door and took advantage

00:54:56.540 --> 00:54:59.458
of stuff that was only
available to us, we'd be

00:54:59.458 --> 00:55:00.138
in real trouble, right?

00:55:00.138 --> 00:55:01.198
Because we wouldn't be doing
anything to make these

00:55:01.198 --> 00:55:03.098
offerings better.

00:55:03.098 --> 00:55:04.518
So, I don't know if that
answers your question, if the

00:55:04.518 --> 00:55:06.038
question was specifically
about, hey, we use the

00:55:06.038 --> 00:55:07.978
Google dashboard, right?

00:55:07.978 --> 00:55:10.368
So, you know, and we can talk
more about the services that

00:55:10.368 --> 00:55:13.838
are coming online in AppEngine
Business that'll support you

00:55:13.838 --> 00:55:16.474
and all, but we try very hard
to do exactly the same sort of

00:55:16.474 --> 00:55:19.798
things that you all
will do as well.

00:55:19.798 --> 00:55:20.978
You know, it's because the
products are evolving, how

00:55:20.978 --> 00:55:28.578
we do that evolves too, but
the goal is not to cheat.

00:55:28.578 --> 00:55:28.818
Are we about to get the boot?

00:55:28.818 --> 00:55:33.458
But the clock is
going up, not down.

00:55:33.458 --> 00:55:35.778
I thought that meant--
OK, all right.

00:55:36.898 --> 00:55:39.898
So we'll be in the sandbox, if
you've got questions, I think

00:55:39.898 --> 00:55:42.178
we are getting the yank, so
please come by, ask us

00:55:42.178 --> 00:55:47.178
questions, and thank you all.

