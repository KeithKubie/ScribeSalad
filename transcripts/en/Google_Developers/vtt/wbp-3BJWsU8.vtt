WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:09.310
JOSH BLOCH: Hello, and welcome
to code talk with your hosts

00:00:09.310 --> 00:00:10.120
Josh Bloch.

00:00:10.120 --> 00:00:10.940
JEREMY MANSON: And
Jeremy Manson.

00:00:10.940 --> 00:00:15.780
JOSH BLOCH: We're Click and
Hack, the Type-It brothers.

00:00:15.780 --> 00:00:20.630
Now, some people say that
seeing is believing.

00:00:20.630 --> 00:00:21.515
JEREMY MANSON: I don't
believe it.

00:00:21.515 --> 00:00:23.730
JOSH BLOCH: But today we're
going to show you

00:00:23.730 --> 00:00:25.590
that that's not true.

00:00:25.590 --> 00:00:28.780
Now, take a look at this
innocent looking picture.

00:00:28.780 --> 00:00:31.390
And it says Cafe Bay, the magic
number from the Java

00:00:31.390 --> 00:00:32.640
class file.

00:00:32.640 --> 00:00:34.870
Now, do those letters look
straight up and down or

00:00:34.870 --> 00:00:38.490
perhaps tilted, kind
of like that right.

00:00:38.490 --> 00:00:39.410
JEREMY MANSON: Straight.

00:00:39.410 --> 00:00:40.200
JOSH BLOCH: Come on,
shout it out.

00:00:40.200 --> 00:00:40.940
This is participatory.

00:00:40.940 --> 00:00:42.320
JEREMY MANSON: I'll
spill water.

00:00:42.320 --> 00:00:43.530
JOSH BLOCH: That's bad.

00:00:43.530 --> 00:00:44.970
JEREMY MANSON: It's only
a little bit bad.

00:00:44.970 --> 00:00:46.060
JOSH BLOCH: All right.

00:00:46.060 --> 00:00:47.210
JEREMY MANSON: Towels
would be good.

00:00:47.210 --> 00:00:48.395
JOSH BLOCH: Straight tilted?

00:00:48.395 --> 00:00:49.090
JEREMY MANSON: Tilted.

00:00:49.090 --> 00:00:49.470
JOSH BLOCH: Tilted.

00:00:49.470 --> 00:00:52.620
So now what I'm going to do to
prove to you that they're

00:00:52.620 --> 00:00:56.130
straight up and down, is I'm
going to color them in with a

00:00:56.130 --> 00:01:00.260
translucent yellow paint.

00:01:00.260 --> 00:01:04.099
Now do you believe that they're
straight up and down?

00:01:04.099 --> 00:01:05.920
Let's remove the paint.

00:01:05.920 --> 00:01:07.290
Again, they look tilted.

00:01:10.115 --> 00:01:12.770
Well, what about this?

00:01:12.770 --> 00:01:13.340
Qbert.

00:01:13.340 --> 00:01:14.040
You guys know Qbert?

00:01:14.040 --> 00:01:15.315
JEREMY MANSON: They're
too young.

00:01:15.315 --> 00:01:19.240
JOSH BLOCH: So look at the
horizontal faces, dark gray,

00:01:19.240 --> 00:01:22.950
light gray, dark gray
light gray.

00:01:22.950 --> 00:01:25.250
What if I tell you they're
all the same color?

00:01:25.250 --> 00:01:26.596
JEREMY MANSON: Thank you.

00:01:26.596 --> 00:01:28.270
JOSH BLOCH: What
if I prove it?

00:01:28.270 --> 00:01:30.575
I'm going to eliminate
those vertical faces.

00:01:33.310 --> 00:01:36.430
Now you can see it's all
the same shade of gray.

00:01:36.430 --> 00:01:37.560
Sorry about that, by the way.

00:01:37.560 --> 00:01:39.195
I hope I didn't destroy
expensive equipment.

00:01:39.195 --> 00:01:41.355
JEREMY MANSON: Just our
expensive [UNINTELLIGIBLE].

00:01:41.355 --> 00:01:42.540
JOSH BLOCH: Well,
what about this?

00:01:42.540 --> 00:01:44.140
Here we have a flag.

00:01:44.140 --> 00:01:46.970
Does it look straight
orthogonal, perfect?

00:01:46.970 --> 00:01:51.390
or does it look wavy, kind
of blowing in the breeze?

00:01:51.390 --> 00:01:54.670
Wavy, blowing in the breeze, but
you see these little tiny

00:01:54.670 --> 00:01:57.790
boxes inside the big boxes?

00:01:57.790 --> 00:02:00.630
I'm going to gradually remove
them, and for all the Java

00:02:00.630 --> 00:02:02.810
programmers in the house,
that's what

00:02:02.810 --> 00:02:04.060
we call auto unboxing.

00:02:07.900 --> 00:02:10.380
Now, is it straight
up and down?

00:02:10.380 --> 00:02:11.740
It's a checkerboard.

00:02:11.740 --> 00:02:16.860
Bring back the little boxes
and it looks wavy again.

00:02:16.860 --> 00:02:17.430
All right.

00:02:17.430 --> 00:02:18.990
That's enough fun and games.

00:02:18.990 --> 00:02:20.650
Now we're going to, the
whole rest of the talk

00:02:20.650 --> 00:02:21.460
is going to be code.

00:02:21.460 --> 00:02:25.320
I'm going to show you the
same thing in code.

00:02:25.320 --> 00:02:30.320
We're going to have six brand
new Java puzzlers, no repeats,

00:02:30.320 --> 00:02:34.880
nothing ever used
before perhaps.

00:02:34.880 --> 00:02:38.400
Each of them is a short program
that illustrates some

00:02:38.400 --> 00:02:39.820
curious behavior.

00:02:39.820 --> 00:02:42.990
And it's going to be your job
as the audience to tell us

00:02:42.990 --> 00:02:43.960
what the programs do.

00:02:43.960 --> 00:02:45.920
You're going to do it
by show of hands.

00:02:45.920 --> 00:02:49.300
We're going to be polling
the audience and

00:02:49.300 --> 00:02:52.320
participation is mandatory.

00:02:52.320 --> 00:02:55.760
After each problem we will
reveal the mystery, but it's

00:02:55.760 --> 00:02:56.890
not all fun and games.

00:02:56.890 --> 00:02:58.090
There's a point to this.

00:02:58.090 --> 00:03:01.170
Each of the problems carries
with it a moral, a lesson that

00:03:01.170 --> 00:03:04.350
you can learn and take home and
avoid falling into some

00:03:04.350 --> 00:03:05.740
hideous trap.

00:03:05.740 --> 00:03:07.390
So why don't we get this
show on the road?

00:03:07.390 --> 00:03:09.010
JEREMY MANSON: I've got one for
you, in fact, and it's a

00:03:09.010 --> 00:03:11.120
real new one, a brand
new change puzzler.

00:03:11.120 --> 00:03:13.660
It's change you can really
believe in, and it's about

00:03:13.660 --> 00:03:14.650
spare change.

00:03:14.650 --> 00:03:17.750
Now, the question I have for
you is if you pay $2 for a

00:03:17.750 --> 00:03:20.640
gasket that costs $1.10, how
much change do you get?

00:03:20.640 --> 00:03:22.520
Now don't, don't rush it.

00:03:22.520 --> 00:03:23.880
I know it's tough.

00:03:23.880 --> 00:03:26.400
And I know you're a computer guy
and so as a computer guy

00:03:26.400 --> 00:03:27.955
you're going to want
to write a program.

00:03:27.955 --> 00:03:28.585
JOSH BLOCH: A program.

00:03:28.585 --> 00:03:31.450
JEREMY MANSON: So I have a brand
new puzzler right there

00:03:31.450 --> 00:03:32.790
that will allow you to--

00:03:32.790 --> 00:03:33.705
JOSH BLOCH: Wait,
wait a minute.

00:03:33.705 --> 00:03:34.890
JEREMY MANSON: Yes, brand new.

00:03:34.890 --> 00:03:35.640
JOSH BLOCH: I've seen
this one before.

00:03:35.640 --> 00:03:37.300
I saw this one in 2004.

00:03:37.300 --> 00:03:38.030
JEREMY MANSON: No.

00:03:38.030 --> 00:03:38.830
JOSH BLOCH: This is
not a new puzzle.

00:03:38.830 --> 00:03:40.270
This is a very old puzzle.

00:03:40.270 --> 00:03:43.390
This is you're doing the math
using floating point

00:03:43.390 --> 00:03:44.050
arithmetic.

00:03:44.050 --> 00:03:47.190
These are like doubles, and
you can't represent 1.1

00:03:47.190 --> 00:03:48.960
exactly as a double.

00:03:48.960 --> 00:03:54.590
So instead of printing out like
0.90 it'll print 0.8999,

00:03:54.590 --> 00:03:56.955
and you fix it by using
big decimal, right?

00:03:56.955 --> 00:03:58.220
JEREMY MANSON: All right,
you caught me.

00:03:58.220 --> 00:03:58.650
You caught me.

00:03:58.650 --> 00:04:00.720
So let's take a look
at a different one.

00:04:00.720 --> 00:04:03.370
A change I promise you that
is going to come, and I've

00:04:03.370 --> 00:04:05.340
rewritten this program
to use big decimal.

00:04:05.340 --> 00:04:07.910
And now can you tell
me what it does?

00:04:07.910 --> 00:04:10.110
JOSH BLOCH: Well, let's
take a look at it.

00:04:10.110 --> 00:04:11.560
This looks very straightforward.

00:04:11.560 --> 00:04:13.810
In fact, this is a much nicer
program than the previous one.

00:04:13.810 --> 00:04:16.029
You see it has these
local variables.

00:04:16.029 --> 00:04:17.630
They have nice names.

00:04:17.630 --> 00:04:18.149
So big decimal--

00:04:18.149 --> 00:04:18.774
JEREMY MANSON: This
is much clearer.

00:04:18.774 --> 00:04:19.019
Okay?

00:04:19.019 --> 00:04:21.899
I mean, you wouldn't able to
figure out that last one.

00:04:21.899 --> 00:04:24.260
JOSH BLOCH: It's true enough.

00:04:24.260 --> 00:04:27.640
We have big decimal payment
is a new big decimal.

00:04:27.640 --> 00:04:32.010
We're initializing it to 2.00,
$2 is the payment.

00:04:32.010 --> 00:04:36.120
And the cost of that gasket,
how to you get a gasket for

00:04:36.120 --> 00:04:36.830
$1.10 anyway?

00:04:36.830 --> 00:04:37.390
JEREMY MANSON: Junkyard.

00:04:37.390 --> 00:04:39.600
JOSH BLOCH: Yes, you would buy
a gasket at a junkyard.

00:04:39.600 --> 00:04:40.950
JEREMY MANSON: Every
single time.

00:04:40.950 --> 00:04:41.320
JOSH BLOCH: All right.

00:04:41.320 --> 00:04:46.980
Anyway, so $1.10, 1.10 and now
we take the big decimals.

00:04:46.980 --> 00:04:50.610
We say payment dot subtract dot
cost. They're immutable so

00:04:50.610 --> 00:04:55.280
that generates a new big decimal
equal to 0.90, and

00:04:55.280 --> 00:04:56.720
that's exactly what
it prints, right?

00:04:56.720 --> 00:04:58.820
JEREMY MANSON: Well, let's see
if that's one of the answers.

00:04:58.820 --> 00:04:59.960
Oh, that is one of
the answers.

00:04:59.960 --> 00:05:02.650
Excellent So now we come to
the audience participation

00:05:02.650 --> 00:05:06.680
part of the show, and every
single one of you has to guess

00:05:06.680 --> 00:05:07.860
one of these answers.

00:05:07.860 --> 00:05:09.580
And we will be calling people
out individually.

00:05:09.580 --> 00:05:11.450
Participation is mandatory.

00:05:11.450 --> 00:05:15.910
So how many think that
the answer is 0.9?

00:05:15.910 --> 00:05:16.560
Answer A?

00:05:16.560 --> 00:05:17.020
JOSH BLOCH: By show of hands.

00:05:17.020 --> 00:05:18.440
JEREMY MANSON: By show
of hands, yes.

00:05:18.440 --> 00:05:18.930
Raise them.

00:05:18.930 --> 00:05:20.050
JOSH BLOCH: Raise them high.

00:05:20.050 --> 00:05:22.180
JEREMY MANSON: Okay, goodly,
percentage like maybe 10%?

00:05:22.180 --> 00:05:22.820
JOSH BLOCH: 10%.

00:05:22.820 --> 00:05:23.500
JEREMY MANSON: Yes.

00:05:23.500 --> 00:05:25.380
How many of you agree with
Josh and think that

00:05:25.380 --> 00:05:26.660
the answer is 0.90?

00:05:26.660 --> 00:05:28.910
We've we got at least one.

00:05:28.910 --> 00:05:30.320
Okay.

00:05:30.320 --> 00:05:32.760
Not too much enthusiasm
for Josh's answer.

00:05:32.760 --> 00:05:36.480
How many think that this big
decimal version of the problem

00:05:36.480 --> 00:05:38.590
prints out what the original
version of the problem printed

00:05:38.590 --> 00:05:42.050
out, which is 0.8 with lots
of nines after it?

00:05:42.050 --> 00:05:44.600
Oh, okay, well, we've got
some people out there.

00:05:44.600 --> 00:05:46.070
This is a pretty
good selection.

00:05:46.070 --> 00:05:49.460
How many people think that
none of these answers is

00:05:49.460 --> 00:05:51.140
correct and that it does
something completely different

00:05:51.140 --> 00:05:52.530
altogether?

00:05:52.530 --> 00:05:53.460
All right.

00:05:53.460 --> 00:05:56.280
Well, okay, so what do we
think, maybe C then?

00:05:56.280 --> 00:05:58.250
JOSH BLOCH: I would say
10%, and I would say

00:05:58.250 --> 00:05:59.460
people aren't voting.

00:05:59.460 --> 00:06:00.100
JEREMY MANSON: Oh.

00:06:00.100 --> 00:06:00.840
JOSH BLOCH: You may let them
get away with this--

00:06:00.840 --> 00:06:02.100
JEREMY MANSON: No, no no, no.

00:06:02.100 --> 00:06:04.200
JOSH BLOCH: But anyway, I
think your audience has

00:06:04.200 --> 00:06:05.470
chosen answer C.

00:06:05.470 --> 00:06:06.280
Shall we see if it is correct?

00:06:06.280 --> 00:06:09.120
JEREMY MANSON: Let's
if it's correct.

00:06:09.120 --> 00:06:10.997
The answer is none
of the above.

00:06:10.997 --> 00:06:12.247
[laughter]

00:06:14.015 --> 00:06:17.080
JOSH BLOCH: My gosh, that's a
big number you've got there.

00:06:17.080 --> 00:06:18.880
JEREMY MANSON: That's a big
number, but size doesn't

00:06:18.880 --> 00:06:20.270
always matter.

00:06:20.270 --> 00:06:21.740
What's the intuition here?

00:06:21.740 --> 00:06:25.450
The intuition is that we use
the wrong big decimal

00:06:25.450 --> 00:06:25.755
constructor.

00:06:25.755 --> 00:06:26.780
JOSH BLOCH: Let's take
another look at this

00:06:26.780 --> 00:06:27.160
problem, shall we?

00:06:27.160 --> 00:06:28.570
JEREMY MANSON: Let's take
another look at this puzzler.

00:06:28.570 --> 00:06:29.990
So what does the specification
say?

00:06:29.990 --> 00:06:32.970
The specifications for the big
decimal constructor says that

00:06:32.970 --> 00:06:33.640
it takes a double.

00:06:33.640 --> 00:06:36.340
It says that it translates a
double into a big decimal with

00:06:36.340 --> 00:06:39.480
the exact decimal representation
of the double's

00:06:39.480 --> 00:06:41.160
binary floating point value.

00:06:41.160 --> 00:06:44.620
Well, we passed 1.1
to that sucker.

00:06:44.620 --> 00:06:48.090
We know that the exact
representation of that

00:06:48.090 --> 00:06:52.830
double's binary floating point
number is not 1.1 because you

00:06:52.830 --> 00:06:53.800
can't represent 1.1 when--

00:06:53.800 --> 00:06:54.850
JOSH BLOCH: I have
one question you.

00:06:54.850 --> 00:06:55.830
JEREMY MANSON: Go ahead.

00:06:55.830 --> 00:06:58.050
JOSH BLOCH: Why does it print
something out that's even

00:06:58.050 --> 00:07:01.150
longer and uglier than
the last program?

00:07:01.150 --> 00:07:07.140
JEREMY MANSON: Well, the double
print, the two strings

00:07:07.140 --> 00:07:11.230
for double prints only exactly
as many decimal places as you

00:07:11.230 --> 00:07:14.050
need to distinguish the number,
the floating point

00:07:14.050 --> 00:07:16.580
number lower from it, lower
than it, from the floating

00:07:16.580 --> 00:07:18.250
point number higher than it.

00:07:18.250 --> 00:07:18.810
So

00:07:18.810 --> 00:07:19.950
JOSH BLOCH: Is that what
they call the canonical

00:07:19.950 --> 00:07:21.330
JEREMY MANSON: That is what
they call the canonical

00:07:21.330 --> 00:07:22.090
representation--

00:07:22.090 --> 00:07:22.330
JOSH BLOCH: All right.

00:07:22.330 --> 00:07:23.700
JEREMY MANSON: --of that
floating point number.

00:07:23.700 --> 00:07:27.370
In this case, the big decimal
to string method prints out

00:07:27.370 --> 00:07:28.470
all the digits.

00:07:28.470 --> 00:07:32.060
And so you get this enormous,
huge number that's 64 bits.

00:07:32.060 --> 00:07:34.870
I mean you could have looked at
that 0.8999 thing and see

00:07:34.870 --> 00:07:36.230
oh, that was just too short.

00:07:36.230 --> 00:07:36.980
JOSH BLOCH: Well,
that's digits.

00:07:36.980 --> 00:07:37.880
So how do we fix it?

00:07:37.880 --> 00:07:39.460
JEREMY MANSON: Well, okay,
so how do we fix it?

00:07:39.460 --> 00:07:42.000
Well, instead of using the
double constructor we want to

00:07:42.000 --> 00:07:43.540
use the string constructor.

00:07:43.540 --> 00:07:48.040
When you pass a value into
BigDecimal constructor as a

00:07:48.040 --> 00:07:51.310
string, it uses the
exact same scale.

00:07:51.310 --> 00:07:55.765
And it uses the exact number
that you passed in, 2.00 to

00:07:55.765 --> 00:07:59.070
two decimal places, and 1.1
to two decimal places.

00:07:59.070 --> 00:08:02.160
And then when you subtract the
two you're actually going to

00:08:02.160 --> 00:08:04.050
get the value that you wanted,
which is 0.90.

00:08:04.050 --> 00:08:05.175
JOSH BLOCH: Most excellent.

00:08:05.175 --> 00:08:06.090
JEREMY MANSON: Yes,
I think so.

00:08:06.090 --> 00:08:07.220
JOSH BLOCH: And what can
we learn from this?

00:08:07.220 --> 00:08:08.580
JEREMY MANSON: Well, what
can we learn from this?

00:08:08.580 --> 00:08:10.640
Well, there are the lessons to
take away from the first

00:08:10.640 --> 00:08:13.210
version of the problem, which
is that you should really

00:08:13.210 --> 00:08:15.650
avoid floating double where
exact answers are required.

00:08:15.650 --> 00:08:17.200
And all of you probably
know this because you

00:08:17.200 --> 00:08:18.970
all deal with money.

00:08:18.970 --> 00:08:23.140
When you're dealing with money
you don't want 2.00 minus 1.10

00:08:23.140 --> 00:08:26.090
to equal 0.89 because that's
just not a good idea.

00:08:26.090 --> 00:08:27.995
You're going to lose
a lot of cents.

00:08:27.995 --> 00:08:30.190
JOSH BLOCH: Some of us had
no sense to start with.

00:08:30.190 --> 00:08:32.470
JEREMY MANSON: Oh,
that's true.

00:08:32.470 --> 00:08:35.539
You should use BigDecimal, or
if you really need speed you

00:08:35.539 --> 00:08:37.669
should use int or long and
just shift it over by two

00:08:37.669 --> 00:08:39.590
decimal places.

00:08:39.590 --> 00:08:41.750
The new version of this puzzle,
in the new version of

00:08:41.750 --> 00:08:43.820
this puzzler, you should take
away, the takeaway it to use

00:08:43.820 --> 00:08:47.460
BigDecimal in the string and
not BigDecimal of double.

00:08:47.460 --> 00:08:49.400
Because BigDecimal of
double will get you

00:08:49.400 --> 00:08:50.840
into a lot of trouble.

00:08:50.840 --> 00:08:54.070
And sometimes you don't have a
constant string to pass in,

00:08:54.070 --> 00:08:55.340
and that's a complaint
we hear a lot.

00:08:55.340 --> 00:08:59.430
So instead of passing in a
constant string, you can use

00:08:59.430 --> 00:09:02.600
the BigDecimal dot value of
double, which turns the

00:09:02.600 --> 00:09:04.780
BigDecimal, which turns the
double into its canonical

00:09:04.780 --> 00:09:06.050
representation of the
printed string.

00:09:06.050 --> 00:09:06.400
JOSH BLOCH: So wait a minute.

00:09:06.400 --> 00:09:07.060
I have a question for you.

00:09:07.060 --> 00:09:07.560
JEREMY MANSON: Okay.

00:09:07.560 --> 00:09:08.560
JOSH BLOCH: If this one,

00:09:08.560 --> 00:09:09.520
JEREMY MANSON: You
can't give up.

00:09:09.520 --> 00:09:11.150
JOSH BLOCH: BigDecimal
dot value of double--

00:09:11.150 --> 00:09:11.590
JEREMY MANSON:Yes.

00:09:11.590 --> 00:09:14.540
JOSH BLOCH: --is we should be
using more than new BigDecimal

00:09:14.540 --> 00:09:16.980
of double, why doesn't that
have a shorter name?

00:09:16.980 --> 00:09:18.800
Why isn't it easier to call?

00:09:18.800 --> 00:09:19.530
What's with that?

00:09:19.530 --> 00:09:20.770
JEREMY MANSON: Well,
this is really a

00:09:20.770 --> 00:09:22.170
lesson for API designers.

00:09:22.170 --> 00:09:24.580
This is what we're here
to take away actually.

00:09:24.580 --> 00:09:27.950
And the API designer was a
complete bonehead on this one.

00:09:27.950 --> 00:09:29.920
It should not-- complete
loser.

00:09:29.920 --> 00:09:32.010
I don't know where we could find
that guy, but we should

00:09:32.010 --> 00:09:33.510
hunt him down.

00:09:33.510 --> 00:09:37.080
The API designer, what he did is
he made it very easy to do

00:09:37.080 --> 00:09:39.830
something that nobody's ever
really going to want to do.

00:09:39.830 --> 00:09:42.610
And for API designers hey, you
should make it easy to do,

00:09:42.610 --> 00:09:44.800
when you're writing all of your
APIs, you should make it

00:09:44.800 --> 00:09:46.576
easy to do the thing that's
commonly correct, the thing

00:09:46.576 --> 00:09:47.970
that people want to
do all the time.

00:09:47.970 --> 00:09:50.860
And you should make it possible
to do exotic things.

00:09:50.860 --> 00:09:53.710
And so in this case we want to
create some weird static

00:09:53.710 --> 00:09:55.580
factory method to do it instead
of making it really,

00:09:55.580 --> 00:09:56.970
really easy.

00:09:56.970 --> 00:09:58.455
Oh, look, I found the
API designer.

00:09:58.455 --> 00:09:59.460
JOSH BLOCH: All right.

00:09:59.460 --> 00:10:02.700
And the API designer, were he
designing this API today,

00:10:02.700 --> 00:10:06.430
would take the functionality
that he erroneously assigned

00:10:06.430 --> 00:10:09.260
to new BigDecimal of double
and assign it to something

00:10:09.260 --> 00:10:13.160
like BigDecimal dot exact value
of double or something.

00:10:13.160 --> 00:10:14.620
Something that no one would
call by mistake.

00:10:14.620 --> 00:10:15.310
JEREMY MANSON: Do you
have one for me?

00:10:15.310 --> 00:10:16.450
JOSH BLOCH: Ah, well,
you live and learn.

00:10:16.450 --> 00:10:18.148
I do have one for you.

00:10:18.148 --> 00:10:19.820
[slide whistle]

00:10:19.820 --> 00:10:21.800
Oh my.

00:10:21.800 --> 00:10:26.300
So what problem could possibly
live up to that introduction?

00:10:26.300 --> 00:10:28.550
JEREMY MANSON: Absolutely
none.

00:10:28.550 --> 00:10:30.600
Well, if you came up with
it must. I have no idea.

00:10:30.600 --> 00:10:31.260
Could you tell me about?

00:10:31.260 --> 00:10:31.840
JOSH BLOCH: All right.

00:10:31.840 --> 00:10:35.700
So this problem we call
size matters.

00:10:35.700 --> 00:10:36.700
And in this case it does.

00:10:36.700 --> 00:10:40.010
What we do is we make two sets,
one of them's a hash

00:10:40.010 --> 00:10:44.980
set, one of-- sorry-- two maps
a hash map and an EnumMap And

00:10:44.980 --> 00:10:48.420
on each of these maps we call
this method size which

00:10:48.420 --> 00:10:53.140
manipulates the map and then
makes another set based on its

00:10:53.140 --> 00:10:56.770
entry set and returns the size
of the resulting set.

00:10:56.770 --> 00:11:00.410
So it just prints the size of
these two constructed sets.

00:11:00.410 --> 00:11:01.710
And I want you to tell
me what it prints?

00:11:01.710 --> 00:11:02.900
JEREMY MANSON: Well, let
me take a closer look.

00:11:02.900 --> 00:11:03.420
JOSH BLOCH: Please do.

00:11:03.420 --> 00:11:05.350
JEREMY MANSON: So we have this
public class size, and we've

00:11:05.350 --> 00:11:09.220
got this Enum sex, which is male
and female, conventional.

00:11:09.220 --> 00:11:13.030
And we've got a main method that
takes a couple of string

00:11:13.030 --> 00:11:16.510
Varargs And it prints size and
passion for everybody to

00:11:16.510 --> 00:11:19.580
called the size method with a
new hash map from sex to sex.

00:11:19.580 --> 00:11:22.190
And that called this
size method.

00:11:22.190 --> 00:11:26.180
Puts a mapping from male
to female in the map.

00:11:26.180 --> 00:11:29.590
Puts a mapping from female
to male in the map.

00:11:29.590 --> 00:11:32.510
Puts a mapping from male to male
in the map, well, if it's

00:11:32.510 --> 00:11:34.990
San Francisco we have to
encompass all the possible

00:11:34.990 --> 00:11:35.340
combinations.

00:11:35.340 --> 00:11:36.030
JOSH BLOCH: Absolutely.

00:11:36.030 --> 00:11:38.960
JEREMY MANSON: What that one
should do is replace the first

00:11:38.960 --> 00:11:43.210
mapping and the second one
is from female to female.

00:11:43.210 --> 00:11:45.140
And should replace that
second mapping.

00:11:45.140 --> 00:11:48.080
So now we have two mappings in
the set, one for male to male

00:11:48.080 --> 00:11:49.335
and the other from
female to female.

00:11:49.335 --> 00:11:50.220
JOSH BLOCH: Works for me

00:11:50.220 --> 00:11:53.920
JEREMY MANSON: And then we
create a new set consisting of

00:11:53.920 --> 00:11:55.460
all of the entries
in that map.

00:11:55.460 --> 00:11:57.970
And there are two entries so
when we return set dot size

00:11:57.970 --> 00:11:59.970
that should return two.

00:11:59.970 --> 00:12:01.420
Okay, what does the
next line do?

00:12:01.420 --> 00:12:05.750
Well, new EnumMap of sex,
sex with sex class, I

00:12:05.750 --> 00:12:06.880
once took a sex class.

00:12:06.880 --> 00:12:07.485
JOSH BLOCH: You did?

00:12:07.485 --> 00:12:08.680
Did you pass?

00:12:08.680 --> 00:12:10.620
JEREMY MANSON: That's between
me and my teacher.

00:12:10.620 --> 00:12:11.825
JOSH BLOCH: Too much
information.

00:12:11.825 --> 00:12:13.350
JEREMY MANSON: Oh, I'm sorry.

00:12:13.350 --> 00:12:16.570
I withdraw the comment.

00:12:16.570 --> 00:12:18.830
And that should do roughly
exactly the same thing.

00:12:18.830 --> 00:12:21.070
The EnumMap should, yes.

00:12:21.070 --> 00:12:21.790
The EnumMap map creates a
mapping for males and--

00:12:21.790 --> 00:12:23.065
JOSH BLOCH: So what does the
sex class do in there?

00:12:23.065 --> 00:12:25.080
JEREMY MANSON: Oh, the sex class
needs to be in there

00:12:25.080 --> 00:12:27.657
because EnumMap map needs to
be passed the class and the

00:12:27.657 --> 00:12:28.190
constructor.

00:12:28.190 --> 00:12:29.080
And why are you asking me?

00:12:29.080 --> 00:12:31.260
It's your puzzler.

00:12:31.260 --> 00:12:31.610
Okay.

00:12:31.610 --> 00:12:34.230
So that should do exactly
the same thing.

00:12:34.230 --> 00:12:37.280
And that's return two, which is
the size, and so it should

00:12:37.280 --> 00:12:38.985
print out two space and two.

00:12:38.985 --> 00:12:40.670
JOSH BLOCH: Two and two, yes.

00:12:40.670 --> 00:12:42.530
Well, all right.

00:12:42.530 --> 00:12:43.530
That is one of our choices.

00:12:43.530 --> 00:12:46.650
That would be choice B, but
let's poll the audience.

00:12:46.650 --> 00:12:49.510
How many of you think that this
program prints out choice

00:12:49.510 --> 00:12:53.118
A, two followed by one.

00:12:53.118 --> 00:12:54.870
JEREMY MANSON: Three people,
four people.

00:12:54.870 --> 00:12:55.580
JOSH BLOCH: Three people.

00:12:55.580 --> 00:12:56.180
All right.

00:12:56.180 --> 00:13:01.300
How many people think choice
B, two followed by two?

00:13:01.300 --> 00:13:02.710
You're going to have to vote
for something, okay?

00:13:02.710 --> 00:13:03.080
JEREMY MANSON: Hey, come on.

00:13:03.080 --> 00:13:05.330
I put myself on the
line to say two.

00:13:05.330 --> 00:13:06.570
JOSH BLOCH: All right, five
people but they don't really

00:13:06.570 --> 00:13:07.710
have the courage of
their convictions.

00:13:07.710 --> 00:13:08.650
JEREMY MANSON: Come
on, come on.

00:13:08.650 --> 00:13:09.405
Stand up for it.

00:13:09.405 --> 00:13:10.230
JOSH BLOCH: All right.

00:13:10.230 --> 00:13:11.300
Five people.

00:13:11.300 --> 00:13:12.720
How many people think
four four?

00:13:15.440 --> 00:13:17.860
No, maybe 10 people?

00:13:17.860 --> 00:13:18.890
JEREMY MANSON: I'd better see
a lot of none of the above.

00:13:18.890 --> 00:13:20.860
JOSH BLOCH: There's better be
an awful lot of votes for D.

00:13:20.860 --> 00:13:22.630
How many people think
none of the above?

00:13:22.630 --> 00:13:23.285
JEREMY MANSON: Hooray.

00:13:23.285 --> 00:13:25.080
JOSH BLOCH: The great
majority of you.

00:13:25.080 --> 00:13:27.162
JEREMY MANSON: What is the
answer to [UNINTELLIGIBLE]?

00:13:27.162 --> 00:13:29.810
JOSH BLOCH: Sadly, the great
majority of you are not not

00:13:29.810 --> 00:13:31.570
correct this time.

00:13:31.570 --> 00:13:33.460
This puzzle actually,
[slide whistle]

00:13:33.460 --> 00:13:36.715
yes, it prints two
followed by one.

00:13:36.715 --> 00:13:37.270
JEREMY MANSON: One?

00:13:37.270 --> 00:13:38.250
How did that even happen?

00:13:38.250 --> 00:13:38.740
JOSH BLOCH: Yes.

00:13:38.740 --> 00:13:39.460
It's crazy, right?

00:13:39.460 --> 00:13:41.390
We do the same thing to
these two maps, but we

00:13:41.390 --> 00:13:42.730
get different answers.

00:13:42.730 --> 00:13:48.230
And the intuition here is that
enumerating over entry sets

00:13:48.230 --> 00:13:49.740
works better for some map

00:13:49.740 --> 00:13:51.960
implementations than for others.

00:13:51.960 --> 00:13:54.070
Let's take another look.

00:13:54.070 --> 00:13:56.300
So here's the problem.

00:13:56.300 --> 00:14:03.166
The EnumMaps maps entry set
iterator repeatedly returns

00:14:03.166 --> 00:14:06.050
the same entry.

00:14:06.050 --> 00:14:07.380
Why would it do that?

00:14:07.380 --> 00:14:09.990
Well, suppose you've got a hash
map and you're iterating

00:14:09.990 --> 00:14:11.290
over its entry set.

00:14:11.290 --> 00:14:12.320
No problem, right?

00:14:12.320 --> 00:14:16.630
Inside a hash map you have an
entry from key to value for

00:14:16.630 --> 00:14:17.920
every mapping in the map.

00:14:17.920 --> 00:14:21.010
And the iterator simply returns
references to those

00:14:21.010 --> 00:14:23.460
pre-existing entries, which
is really cheap, right?

00:14:23.460 --> 00:14:25.010
You're not creating
any objects.

00:14:25.010 --> 00:14:25.960
No problem.

00:14:25.960 --> 00:14:29.410
But what about an EnumMap
inside an EnumMap

00:14:29.410 --> 00:14:30.720
there are no entries.

00:14:30.720 --> 00:14:34.620
All you have is an array of
values, indexed by ordinals of

00:14:34.620 --> 00:14:37.760
the enums. So when you're
iterating over this thing you

00:14:37.760 --> 00:14:41.590
have to somehow out of thin air
get entries to return to

00:14:41.590 --> 00:14:42.470
the caller.

00:14:42.470 --> 00:14:45.260
Now you could create a separate
entry for every

00:14:45.260 --> 00:14:47.530
mapping in the EnumMap but
EnumMaps are supposed to be

00:14:47.530 --> 00:14:51.280
really fast. So the guy who
wrote that program, who wrote

00:14:51.280 --> 00:14:54.940
EnumMap he decided that it
would be a bad idea to

00:14:54.940 --> 00:14:57.440
actually create an entry
for every single

00:14:57.440 --> 00:14:58.220
mapping in the map.

00:14:58.220 --> 00:14:58.755
Too expensive.

00:14:58.755 --> 00:15:01.485
JEREMY MANSON: Seems
like a bug.

00:15:01.485 --> 00:15:02.690
JOSH BLOCH: Yes.

00:15:02.690 --> 00:15:05.600
It does seem like a bug.

00:15:05.600 --> 00:15:07.460
JEREMY MANSON: Gee, I wonder
who the person made that

00:15:07.460 --> 00:15:07.540
particular one.

00:15:07.540 --> 00:15:10.600
JOSH BLOCH: Well, it's a bug
that's been around since 1997,

00:15:10.600 --> 00:15:12.150
which is kind of funny because
EnumMap hasn't

00:15:12.150 --> 00:15:13.300
been around that long.

00:15:13.300 --> 00:15:15.730
It turns out that we first
introduced this bug in

00:15:15.730 --> 00:15:16.620
identity hash map.

00:15:16.620 --> 00:15:19.710
What that has in common with
EnumMap is it's another map

00:15:19.710 --> 00:15:22.600
that doesn't naturally
have entries, right?

00:15:22.600 --> 00:15:24.980
It basically has an array of
keys, an array of values.

00:15:24.980 --> 00:15:28.755
And at that time it really was
expensive to create objects.

00:15:28.755 --> 00:15:30.470
And we thought we just
can't do it.

00:15:30.470 --> 00:15:31.960
We have this super fast map.

00:15:31.960 --> 00:15:33.570
We can't slow it
down that much.

00:15:33.570 --> 00:15:36.920
In retrospect, it might hot have
been such a good idea.

00:15:36.920 --> 00:15:39.270
JEREMY MANSON: This is Josh's
greatest hits, this talk.

00:15:39.270 --> 00:15:42.560
JOSH BLOCH: Yes, well, anyway,
we did it The spec is

00:15:42.560 --> 00:15:45.250
ambiguous on this point,
at best ambiguous.

00:15:45.250 --> 00:15:47.200
Some people say oh, it's
just completely a bug.

00:15:47.200 --> 00:15:48.000
It's illegal.

00:15:48.000 --> 00:15:51.670
A close reading of the spec
says maybe it's legal.

00:15:51.670 --> 00:15:54.250
Doug Li initially did it for
concurrent hash map, but

00:15:54.250 --> 00:15:56.960
people complained so much, and
Doug was smart enough that he

00:15:56.960 --> 00:15:59.790
fixed it before actually
releasing it.

00:15:59.790 --> 00:16:03.650
And happily Android did not
perpetuate this particular

00:16:03.650 --> 00:16:04.465
piece of bad behavior.

00:16:04.465 --> 00:16:06.290
JEREMY MANSON: These are all
good Android programmers, the

00:16:06.290 --> 00:16:07.370
Google I/O audience.

00:16:07.370 --> 00:16:08.510
JOSH BLOCH: Excellent.

00:16:08.510 --> 00:16:10.910
But anyway so that's
the problem.

00:16:10.910 --> 00:16:12.060
And how do we fix it?

00:16:12.060 --> 00:16:14.520
Well, the fix isn't pretty.

00:16:14.520 --> 00:16:18.970
What you have to do is you can't
use that idiom, new hash

00:16:18.970 --> 00:16:23.570
map of the entry set, sorry new
hash set of the entry set.

00:16:23.570 --> 00:16:26.690
What you have to do is you have
to create an empty hash

00:16:26.690 --> 00:16:31.560
set, then you have to iterate
over all the entries in the

00:16:31.560 --> 00:16:33.210
map's entry set.

00:16:33.210 --> 00:16:36.100
And for each one you have to
effectively clone the entry,

00:16:36.100 --> 00:16:38.890
which we're doing by calling a
new abstract map dot, simple

00:16:38.890 --> 00:16:41.160
immutable entry of E.

00:16:41.160 --> 00:16:44.930
Simply Immutable Entry is like
a little simple entry method

00:16:44.930 --> 00:16:46.790
that you can use whenever you
need to create your own

00:16:46.790 --> 00:16:48.370
entries out of whole cloth.

00:16:48.370 --> 00:16:50.910
So once you do this basically
you end up with a set that has

00:16:50.910 --> 00:16:53.800
a whole set of new entries and
the sizes will both be two,

00:16:53.800 --> 00:16:55.110
and the program will print
out two , two.

00:16:55.110 --> 00:16:56.960
JEREMY MANSON: Well, that all
that seems straightforward

00:16:56.960 --> 00:16:58.365
enough if convoluted.

00:16:58.365 --> 00:16:58.970
JOSH BLOCH: Yes.

00:16:58.970 --> 00:16:59.920
And what can we learn from it?

00:16:59.920 --> 00:17:00.800
JEREMY MANSON: What can
we learn from it?

00:17:00.800 --> 00:17:03.870
JOSH BLOCH: Well, first of all,
iterating over entry sets

00:17:03.870 --> 00:17:05.250
requires care.

00:17:05.250 --> 00:17:08.160
The entry may become
invalid as soon as

00:17:08.160 --> 00:17:09.690
you advance the iterator.

00:17:09.690 --> 00:17:13.690
EnumMap and identity hash map
are the only broken ones in

00:17:13.690 --> 00:17:16.730
standard Java implementation.

00:17:16.730 --> 00:17:20.970
And none of the Android
map implementations

00:17:20.970 --> 00:17:23.020
display this behavior.

00:17:23.020 --> 00:17:27.480
This idiom for copying an entry
set fails in the face of

00:17:27.480 --> 00:17:28.410
this behavior.

00:17:28.410 --> 00:17:29.840
But this another problem that's

00:17:29.840 --> 00:17:31.060
really about API designers.

00:17:31.060 --> 00:17:34.130
So for at API designers, do not
violate the principle of

00:17:34.130 --> 00:17:37.950
least astonishment, that is
always make your APIs do the

00:17:37.950 --> 00:17:39.650
least astonishing thing.

00:17:39.650 --> 00:17:43.950
And never make your APIs
worse in order to make

00:17:43.950 --> 00:17:45.220
them perform better.

00:17:45.220 --> 00:17:49.440
Because in 10 years when things
get faster and better,

00:17:49.440 --> 00:17:52.100
performance will no longer be
a problem, but your API will

00:17:52.100 --> 00:17:54.125
still suck.

00:17:54.125 --> 00:17:55.410
Do you have one for me?

00:17:55.410 --> 00:17:56.910
JEREMY MANSON: Your API
will still suck.

00:17:56.910 --> 00:17:59.680
Yes, that's your motto, right?

00:17:59.680 --> 00:18:00.210
All right.

00:18:00.210 --> 00:18:02.500
so this is a completely
non-API related one.

00:18:02.500 --> 00:18:03.690
You're welcome.

00:18:03.690 --> 00:18:08.000
The match game, all right, so
I've got, what we've got here

00:18:08.000 --> 00:18:10.040
is a pattern that
we're compiling.

00:18:10.040 --> 00:18:12.420
We've got a regular expression
and we want to generate a

00:18:12.420 --> 00:18:15.200
bunch of strings and see if
they match those regular

00:18:15.200 --> 00:18:16.590
expressions.

00:18:16.590 --> 00:18:19.090
Perhaps you could take a look
at this program and let me

00:18:19.090 --> 00:18:20.680
know what you think
it prints out.

00:18:20.680 --> 00:18:21.910
JOSH BLOCH: I'll tell you
what it prints out.

00:18:21.910 --> 00:18:22.430
JEREMY MANSON: Yes, you will.

00:18:22.430 --> 00:18:23.780
JOSH BLOCH: All right.

00:18:23.780 --> 00:18:25.360
This actually looks
very simple.

00:18:25.360 --> 00:18:31.300
So I see that we have a regular
expression, which is

00:18:31.300 --> 00:18:36.950
a, a or a, a optionally
followed by a b, that

00:18:36.950 --> 00:18:39.970
expression repeated
one or more times.

00:18:39.970 --> 00:18:41.960
So clearly this will
match a, a.

00:18:41.960 --> 00:18:46.000
It'll match a, a, a, a a, a, a,
a, a, a, a, a and so forth.

00:18:46.000 --> 00:18:49.810
It'll match any even numbered
string of a's.

00:18:49.810 --> 00:18:53.270
It will match no odd numbered
strings of a's, and it'll also

00:18:53.270 --> 00:18:56.380
match things which have a,
a, b, a, a, b in them.

00:18:56.380 --> 00:18:58.400
But looking at how you're
creating the strings I don't

00:18:58.400 --> 00:19:02.110
see any d's, so I don't even
think that's an issue.

00:19:02.110 --> 00:19:07.090
And I also see that you're
compiling the regular

00:19:07.090 --> 00:19:10.770
expression and saving a pattern,
a complied regular

00:19:10.770 --> 00:19:11.270
expression.

00:19:11.270 --> 00:19:13.500
That's a very good thing to do
because the most expensive

00:19:13.500 --> 00:19:17.210
part of evaluating a regular
expression is compiling it

00:19:17.210 --> 00:19:20.370
into a deterministic finite
automaton, or DFA, as we shall

00:19:20.370 --> 00:19:21.180
call it henceforth.

00:19:21.180 --> 00:19:22.030
JEREMY MANSON: Oh, sure.

00:19:22.030 --> 00:19:22.650
JOSH BLOCH: All right.

00:19:22.650 --> 00:19:26.110
So that's the expensive
part,and And

00:19:26.110 --> 00:19:27.110
we only do it once.

00:19:27.110 --> 00:19:27.600
It's great.

00:19:27.600 --> 00:19:30.550
We do it once and then we use
this compiled regular

00:19:30.550 --> 00:19:33.160
expression 200 times.

00:19:33.160 --> 00:19:35.800
We initially set count to zero,
and we're generating the

00:19:35.800 --> 00:19:38.230
strings by starting with
the empty string.

00:19:38.230 --> 00:19:40.910
We continue as long as the
length is less than 200.

00:19:40.910 --> 00:19:44.320
So the length varies from
zero to 199 inclusive.

00:19:44.320 --> 00:19:46.730
And each time we append a.

00:19:46.730 --> 00:19:51.030
So we've got the empty string
a, a-a, a-a-a and so forth.

00:19:51.030 --> 00:19:55.410
And for each of these strings,
if it matches in its entirety

00:19:55.410 --> 00:19:58.110
that pattern, we increment
count.

00:19:58.110 --> 00:20:02.090
Well, we know that even number
length ones match.

00:20:02.090 --> 00:20:04.890
And the ones with an odd number
length that's like

00:20:04.890 --> 00:20:06.880
barely English but you
know what right?

00:20:06.880 --> 00:20:07.470
Odd lengths--

00:20:07.470 --> 00:20:07.750
JEREMY MANSON: Barely.

00:20:07.750 --> 00:20:09.250
JOSH BLOCH: they don't match.

00:20:09.250 --> 00:20:11.820
And of the 200, half have
an even length,

00:20:11.820 --> 00:20:13.170
half have an odd length.

00:20:13.170 --> 00:20:16.330
So count at the end of the
execution of this program is

00:20:16.330 --> 00:20:18.200
going to be 100.

00:20:18.200 --> 00:20:18.840
JEREMY MANSON: All right

00:20:18.840 --> 00:20:19.790
JOSH BLOCH: So I believe the
program will print 100.

00:20:19.790 --> 00:20:21.836
JEREMY MANSON: Let's see if
that's one of the choices?

00:20:21.836 --> 00:20:23.400
Oh, it is.

00:20:23.400 --> 00:20:26.520
All right How many people think
that this program is

00:20:26.520 --> 00:20:29.420
going to print 99?

00:20:29.420 --> 00:20:30.395
It's like a third.

00:20:30.395 --> 00:20:31.205
JOSH BLOCH: Half of them.

00:20:31.205 --> 00:20:32.420
JEREMY MANSON: Yes,
maybe half.

00:20:32.420 --> 00:20:32.990
JOSH BLOCH: Yeah.

00:20:32.990 --> 00:20:34.110
Raise your hands higher.

00:20:34.110 --> 00:20:34.560
You can't tell.

00:20:34.560 --> 00:20:35.610
JEREMY MANSON: Right, it's kind
of hard to tell, yes.

00:20:35.610 --> 00:20:36.260
Oh, that's golden.

00:20:36.260 --> 00:20:36.800
JOSH BLOCH: That's half.

00:20:36.800 --> 00:20:37.400
JEREMY MANSON: That's
more like half.

00:20:37.400 --> 00:20:38.380
Yes, definitely.

00:20:38.380 --> 00:20:38.910
All right.

00:20:38.910 --> 00:20:42.010
How many you agree with him
and think it's 100?

00:20:42.010 --> 00:20:44.380
And by the way, sometimes we
just try to trick you and

00:20:44.380 --> 00:20:45.410
actually say the right thing.

00:20:45.410 --> 00:20:46.510
JOSH BLOCH: It could happen.

00:20:46.510 --> 00:20:47.070
JEREMY MANSON: Okay.

00:20:47.070 --> 00:20:48.630
We got one, two five or six.

00:20:48.630 --> 00:20:49.990
JOSH BLOCH: I have
three friends.

00:20:49.990 --> 00:20:50.535
Hi, mom.

00:20:50.535 --> 00:20:51.580
JEREMY MANSON: Yes.

00:20:51.580 --> 00:20:53.980
I think that's your brother
out there, isn't it?

00:20:53.980 --> 00:20:55.310
How many people think
that this program

00:20:55.310 --> 00:20:57.690
will throw an exception?

00:20:57.690 --> 00:20:59.730
Oh, that's not a bad number,
maybe a quarter or

00:20:59.730 --> 00:21:01.150
something like that.

00:21:01.150 --> 00:21:04.130
And how many of you lovely
people think that this program

00:21:04.130 --> 00:21:05.770
is going to do absolutely
none of these things?

00:21:05.770 --> 00:21:08.820
That it'll just be completely
different?

00:21:08.820 --> 00:21:09.700
Maybe another Third.

00:21:09.700 --> 00:21:10.940
JOSH BLOCH: A scant quarter.

00:21:10.940 --> 00:21:11.360
All right.

00:21:11.360 --> 00:21:11.676
JEREMY MANSON: All right.

00:21:11.676 --> 00:21:12.320
Let's see what it
actually does.

00:21:12.320 --> 00:21:13.810
JOSH BLOCH: So the winning
answer then is

00:21:13.810 --> 00:21:14.980
clearly choice A, right?

00:21:14.980 --> 00:21:15.350
JEREMY MANSON: Oh, yes.

00:21:15.350 --> 00:21:15.730
Yes.

00:21:15.730 --> 00:21:16.940
Everybody thinks choice
A is the right answer.

00:21:16.940 --> 00:21:19.196
JOSH BLOCH: Let's see
if it does that.

00:21:19.196 --> 00:21:20.830
JEREMY MANSON: Nice
transition.

00:21:20.830 --> 00:21:25.165
Very, very, wrong, sorry.

00:21:25.165 --> 00:21:25.795
JOSH BLOCH: Uh-oh.

00:21:25.795 --> 00:21:28.540
JEREMY MANSON: It turns out that
this program will one run

00:21:28.540 --> 00:21:31.810
for one quadrillion years before
printing anything.

00:21:31.810 --> 00:21:32.880
JOSH BLOCH: One quadrillion
years?

00:21:32.880 --> 00:21:34.660
JEREMY MANSON: The sun is only
going to last billions of

00:21:34.660 --> 00:21:38.030
years, and so this is billions
of billions, billions of sun's

00:21:38.030 --> 00:21:41.090
lifetimes will go by and
this program will

00:21:41.090 --> 00:21:42.320
not print out anything.

00:21:42.320 --> 00:21:44.920
Of course, at Google we can just
run a map produce and run

00:21:44.920 --> 00:21:45.940
it in a trillion years.

00:21:45.940 --> 00:21:47.286
But

00:21:47.286 --> 00:21:48.540
JOSH BLOCH: Yes, I
mean it's just--

00:21:48.540 --> 00:21:50.070
JEREMY MANSON: But it's
still going to take a

00:21:50.070 --> 00:21:51.630
little bit too long.

00:21:51.630 --> 00:21:52.010
All right.

00:21:52.010 --> 00:21:53.630
So what is the intuition here?

00:21:53.630 --> 00:21:55.510
The intuition is that this
regular expression that I

00:21:55.510 --> 00:21:58.060
showed you in the other slide
exhibits what's called

00:21:58.060 --> 00:22:00.160
catastrophic backtracking.

00:22:00.160 --> 00:22:02.165
JOSH BLOCH: Batastrophic
cat tracking?

00:22:02.165 --> 00:22:05.152
JEREMY MANSON: Batastrophic
rat catching.

00:22:05.152 --> 00:22:06.950
JOSH BLOCH: What are
you talking about?

00:22:06.950 --> 00:22:07.710
JEREMY MANSON: I don't
even know.

00:22:07.710 --> 00:22:09.030
Oh, wait, yes I do.

00:22:09.030 --> 00:22:09.510
All right.

00:22:09.510 --> 00:22:13.290
Well, let's see how this regular
expression is matched

00:22:13.290 --> 00:22:16.380
by this DFA that Josh
talked about.

00:22:16.380 --> 00:22:16.760
All right.

00:22:16.760 --> 00:22:20.460
So let's say we pass a string
that doesn't match, a string

00:22:20.460 --> 00:22:21.950
consisting of five a's.

00:22:21.950 --> 00:22:22.720
What is it going to do?

00:22:22.720 --> 00:22:24.620
It's going to look at
the first two a's.

00:22:24.620 --> 00:22:25.830
It's going to say those match.

00:22:25.830 --> 00:22:27.304
It's going to look at the second
two a's and it's going

00:22:27.304 --> 00:22:28.150
to say those match.

00:22:28.150 --> 00:22:30.780
And then it's going to look at
the third two a's and say oh,

00:22:30.780 --> 00:22:31.960
that doesn't match.

00:22:31.960 --> 00:22:35.330
So it has to go backwards,
backtracking and check a, a, b

00:22:35.330 --> 00:22:35.920
question mark.

00:22:35.920 --> 00:22:38.080
Oh, that doesn't match either.

00:22:38.080 --> 00:22:38.480
All right.

00:22:38.480 --> 00:22:39.120
So that failed.

00:22:39.120 --> 00:22:41.490
So it has to go back
another level.

00:22:41.490 --> 00:22:42.470
JOSH BLOCH: So that's
the backtracking.

00:22:42.470 --> 00:22:43.485
What's the catastrophe?

00:22:43.485 --> 00:22:46.290
JEREMY MANSON: The catastrophe
passed here is when it splits

00:22:46.290 --> 00:22:49.150
in half, or yes, when it splits
here it's going to have

00:22:49.150 --> 00:22:51.590
to check to see if a, a, b
question mark matches.

00:22:51.590 --> 00:22:53.850
And a, a, b question
mark does match.

00:22:53.850 --> 00:22:57.650
So it's actually going to have
to traverse this entire full

00:22:57.650 --> 00:23:02.160
binary tree and go through every
single edge to determine

00:23:02.160 --> 00:23:05.080
that this odd numbered
string doesn't match.

00:23:05.080 --> 00:23:06.030
JOSH BLOCH: It's going
to traverse--

00:23:06.030 --> 00:23:06.650
JEREMY MANSON: going

00:23:06.650 --> 00:23:07.450
JOSH BLOCH: Every edge.

00:23:07.450 --> 00:23:09.215
JEREMY MANSON: Going to traverse
every edge, all--

00:23:09.215 --> 00:23:10.480
JOSH BLOCH: A complete
binary tree .

00:23:10.480 --> 00:23:11.070
JEREMY MANSON: All
two to the n

00:23:11.070 --> 00:23:12.680
JOSH BLOCH: From depth
and a half.

00:23:12.680 --> 00:23:14.800
JEREMY MANSON: It's an
exponential blowup It's two to

00:23:14.800 --> 00:23:20.070
the n steps for every single
non-matching binary, for every

00:23:20.070 --> 00:23:21.520
single non-matching string.

00:23:21.520 --> 00:23:24.560
And well, that's two
to the 99th.

00:23:24.560 --> 00:23:27.135
And for the longest binary
string two to the 99th it's a

00:23:27.135 --> 00:23:27.775
really, really big number.

00:23:27.775 --> 00:23:29.630
JOSH BLOCH: Two to the 99th.

00:23:29.630 --> 00:23:31.830
That reminds me of the thing
about putting grains of rice

00:23:31.830 --> 00:23:32.450
on a chessboard.

00:23:32.450 --> 00:23:34.020
JEREMY MANSON: Yes. it's
much like that thing.

00:23:34.020 --> 00:23:34.480
JOSH BLOCH: Yes.

00:23:34.480 --> 00:23:35.020
JEREMY MANSON: All right.

00:23:35.020 --> 00:23:36.120
JOSH BLOCH: So what you're
telling me is

00:23:36.120 --> 00:23:37.290
it just won't finish.

00:23:37.290 --> 00:23:37.900
JEREMY MANSON: It just
won't finish.

00:23:37.900 --> 00:23:38.950
JOSH BLOCH: How can we fix it?

00:23:38.950 --> 00:23:39.930
JEREMY MANSON: So how
can we fix it?

00:23:39.930 --> 00:23:41.910
Well, it's very straightforward
in this.

00:23:41.910 --> 00:23:45.380
You guys might have noticed that
a,a or a,a, b question

00:23:45.380 --> 00:23:47.450
mark, well, all that means is
that the b is optional in the

00:23:47.450 --> 00:23:50.460
second one, which is pretty much
the same thing as saying

00:23:50.460 --> 00:23:51.990
a, a, b question mark.

00:23:51.990 --> 00:23:52.710
So pretty much--

00:23:52.710 --> 00:23:52.922
JOSH BLOCH: Pretty much?

00:23:52.922 --> 00:23:53.230
Yes, it's exaclty that.

00:23:53.230 --> 00:23:54.250
JEREMY MANSON: Exactly the
same thing as saying--

00:23:54.250 --> 00:23:54.740
I'm sorry.

00:23:54.740 --> 00:23:56.520
I tend to understate things.

00:23:56.520 --> 00:23:57.030
All right.

00:23:57.030 --> 00:24:01.300
So what we do is we replace
that regular expression

00:24:01.300 --> 00:24:03.870
grouping with a regular
expression grouping with a, a,

00:24:03.870 --> 00:24:06.400
b question mark alone.

00:24:06.400 --> 00:24:08.480
And that's still not going
to print out 100.

00:24:08.480 --> 00:24:10.600
Even though you thought it would
print out 100, because

00:24:10.600 --> 00:24:12.620
we have that little plus there,
that means you need to

00:24:12.620 --> 00:24:16.610
match at least one of the
regular expressions.

00:24:16.610 --> 00:24:18.240
JOSH BLOCH: So it won't match
the empty string.

00:24:18.240 --> 00:24:19.480
JEREMY MANSON: It's not going
to match the empty string.

00:24:19.480 --> 00:24:21.920
It's only going to match the
second, the fourth and so on

00:24:21.920 --> 00:24:22.820
and so forth and so on.

00:24:22.820 --> 00:24:23.290
JOSH BLOCH: All right.

00:24:23.290 --> 00:24:23.740
JEREMY MANSON: All right.

00:24:23.740 --> 00:24:24.330
JOSH BLOCH: Well,
that's lovely.

00:24:24.330 --> 00:24:24.980
What can we learn from this?

00:24:24.980 --> 00:24:25.710
JEREMY MANSON: What
can we learn here?

00:24:25.710 --> 00:24:29.490
Well, you want to avoid
catastrophic backtracking

00:24:29.490 --> 00:24:30.190
wherever you can.

00:24:30.190 --> 00:24:32.780
You want to make sure that
for all of your regular

00:24:32.780 --> 00:24:36.330
expressions there's only one way
to match each string that

00:24:36.330 --> 00:24:40.200
is to say, with a, a, b question
mark you're only,

00:24:40.200 --> 00:24:43.080
instead of splitting in two
there in that binary tree,

00:24:43.080 --> 00:24:45.090
you're going to march
in a straight line.

00:24:45.090 --> 00:24:47.260
You're going to progress and
it's going to solve the

00:24:47.260 --> 00:24:50.455
problem in linear time instead
of dividing it every step.

00:24:50.455 --> 00:24:52.085
JOSH BLOCH: Linear instead
of exponential.

00:24:52.085 --> 00:24:53.390
JEREMY MANSON: Linear instead
of exponential.

00:24:53.390 --> 00:24:53.810
JOSH BLOCH: What a deal.

00:24:53.810 --> 00:24:54.850
JEREMY MANSON: Much,
much faster.

00:24:54.850 --> 00:24:57.385
Two for the price of one or root
two for the price of one.

00:24:57.385 --> 00:24:57.920
JOSH BLOCH: Two to
the n for one.

00:24:57.920 --> 00:25:00.280
JEREMY MANSON: Two to the
n for the price of one.

00:25:00.280 --> 00:25:01.800
This goes way beyond Java.

00:25:01.800 --> 00:25:03.310
This is not a Java-specific
problem.

00:25:03.310 --> 00:25:05.870
This affects any regular
expression library that does

00:25:05.870 --> 00:25:06.660
backtracking.

00:25:06.660 --> 00:25:11.410
This is the default library in
Perl and Python and PHP and

00:25:11.410 --> 00:25:14.670
Prolog and PL/I and Snowball
and Cobol and--

00:25:14.670 --> 00:25:16.090
JOSH BLOCH: So any language
beginning with a P is--

00:25:16.090 --> 00:25:17.870
JEREMY MANSON: Any language
beginning with a P and some of

00:25:17.870 --> 00:25:18.700
the older ones, too.

00:25:18.700 --> 00:25:19.230
JOSH BLOCH: All right.

00:25:19.230 --> 00:25:21.060
JEREMY MANSON: And
the newer ones.

00:25:21.060 --> 00:25:25.100
So yes, and something else to
remember is that just because

00:25:25.100 --> 00:25:28.330
you can express it short does
not necessarily mean it's

00:25:28.330 --> 00:25:32.220
going to be fast. So you have
to keep performance in mind

00:25:32.220 --> 00:25:33.270
when you're writing
these things.

00:25:33.270 --> 00:25:37.585
You can't just throw it out
there and have it, expect it

00:25:37.585 --> 00:25:39.290
to do exactly what you think
it's going to do.

00:25:39.290 --> 00:25:40.010
JOSH BLOCH: Wise advice.

00:25:40.010 --> 00:25:40.690
JEREMY MANSON: Yes.

00:25:40.690 --> 00:25:41.140
JOSH BLOCH: All right.

00:25:41.140 --> 00:25:42.180
I have one for you now.

00:25:42.180 --> 00:25:42.550
JEREMY MANSON: All right.

00:25:42.550 --> 00:25:47.660
JOSH BLOCH: This one is called
"That Sinking Feeling." And

00:25:47.660 --> 00:25:51.180
this problem concerns a very
simple collection class which

00:25:51.180 --> 00:25:55.070
we call a sync, and all you can
do to a sync is put stuff

00:25:55.070 --> 00:25:57.170
into it and print out
what's in it.

00:25:57.170 --> 00:25:59.410
In particular it has
three methods.

00:25:59.410 --> 00:26:02.030
It has the add method, which
is a Varargs method.

00:26:02.030 --> 00:26:07.230
It takes zero or more elements
and adds them all to the sync.

00:26:07.230 --> 00:26:10.780
It has add unless null,
which is like add

00:26:10.780 --> 00:26:11.935
except it discards null.

00:26:11.935 --> 00:26:14.560
It doesn't put nulls
into the sync.

00:26:14.560 --> 00:26:16.595
My mother always told me not
put nulls into the sync.

00:26:16.595 --> 00:26:17.885
It damages the drain.

00:26:17.885 --> 00:26:18.555
JEREMY MANSON: Oh,
i heard that.

00:26:18.555 --> 00:26:22.550
JOSH BLOCH: And finally it has a
two string method so you can

00:26:22.550 --> 00:26:23.480
print it out.

00:26:23.480 --> 00:26:26.010
You don't see that here
in the abstract.

00:26:26.010 --> 00:26:28.710
The structure of the program,
by the way, is we have one

00:26:28.710 --> 00:26:31.200
sort of abstract skeletal
version of this thing.

00:26:31.200 --> 00:26:32.440
And then a concrete version.

00:26:32.440 --> 00:26:36.290
For strings called string
sync which extends sync.

00:26:36.290 --> 00:26:39.950
And the main programs simply
exercises our string sync.

00:26:39.950 --> 00:26:43.370
It puts some stuff into it,
and then it prints out the

00:26:43.370 --> 00:26:43.840
string sync.

00:26:43.840 --> 00:26:45.120
So I want you to tell
me what it prints?

00:26:45.120 --> 00:26:46.405
JEREMY MANSON: Well, let
me take a closer look.

00:26:46.405 --> 00:26:49.440
JOSH BLOCH: Please.

00:26:49.440 --> 00:26:50.710
JEREMY MANSON: All right.

00:26:50.710 --> 00:26:53.300
So what we have is we have this
abstract class sync that

00:26:53.300 --> 00:26:54.420
you mentioned.

00:26:54.420 --> 00:26:58.760
And it's got an add method and
it takes a Varargs array of t.

00:26:58.760 --> 00:27:00.350
And it's got an add.

00:27:00.350 --> 00:27:02.510
That's abstract so we're going
overload that later or

00:27:02.510 --> 00:27:03.520
override that later.

00:27:03.520 --> 00:27:06.140
And then it also takes
an add unless.

00:27:06.140 --> 00:27:09.330
It also has an add unless null
method, which takes another

00:27:09.330 --> 00:27:10.290
Varargs array of t.

00:27:10.290 --> 00:27:11.690
And it iterates over the t.

00:27:11.690 --> 00:27:12.700
That looks good.

00:27:12.700 --> 00:27:14.710
And if the [? TFC ?]

00:27:14.710 --> 00:27:18.910
is not null, it adds it to the,
it calls the abstract add

00:27:18.910 --> 00:27:20.220
method and adds it to the sync.

00:27:20.220 --> 00:27:20.600
Okay.

00:27:20.600 --> 00:27:22.090
That seems all right.

00:27:22.090 --> 00:27:26.150
Now we've got a string sync
version of this abstract sync,

00:27:26.150 --> 00:27:29.070
and what that does is it has
a list, which I guess is to

00:27:29.070 --> 00:27:31.090
contain all of those lovely
strings we're going to be

00:27:31.090 --> 00:27:31.860
adding to it.

00:27:31.860 --> 00:27:32.310
JOSH BLOCH: Indeed.

00:27:32.310 --> 00:27:34.470
JEREMY MANSON: And we add
an array of strings.

00:27:34.470 --> 00:27:38.660
We add a list strings here, a
Varargs list and list dot add

00:27:38.660 --> 00:27:42.090
all of arrays dot as
list of elements.

00:27:42.090 --> 00:27:45.210
So what it's going to do is it's
going to take the string.

00:27:45.210 --> 00:27:47.380
It's being passed.

00:27:47.380 --> 00:27:49.280
And it's going to add
it to the list.

00:27:49.280 --> 00:27:50.515
JOSH BLOCH: The string array.

00:27:50.515 --> 00:27:51.105
JEREMY MANSON: I'm sorry?

00:27:51.105 --> 00:27:52.210
JOSH BLOCH: The string array.

00:27:52.210 --> 00:27:52.640
JEREMY MANSON: The string
array, yes.

00:27:52.640 --> 00:27:52.740
Pardon me.

00:27:52.740 --> 00:27:54.960
And it's going to add the
contents of the string array

00:27:54.960 --> 00:27:56.770
to the list. All right.

00:27:56.770 --> 00:27:58.570
So now we go down to
the main method.

00:27:58.570 --> 00:28:00.210
We see we create
a string sync.

00:28:00.210 --> 00:28:03.460
We do add unless null
of the string null

00:28:03.460 --> 00:28:05.450
and the value null.

00:28:05.450 --> 00:28:08.410
Okay, add unless null is going
to call this, this method

00:28:08.410 --> 00:28:10.130
here, this add unless
null method.

00:28:10.130 --> 00:28:12.980
The add unless null method going
to go through that array

00:28:12.980 --> 00:28:16.310
of strings, and the first one
is the null, is the string

00:28:16.310 --> 00:28:19.620
containing the word null, and
that's going to be added.

00:28:19.620 --> 00:28:20.780
And then it's going
to iterate again.

00:28:20.780 --> 00:28:22.440
It's going to come to
the value null.

00:28:22.440 --> 00:28:24.930
This time element is going to
be equal to null, so that's

00:28:24.930 --> 00:28:26.340
not going to be added.

00:28:26.340 --> 00:28:28.710
So when you do system dot out
dot print all and at the end

00:28:28.710 --> 00:28:32.720
here that should print out a
list containing the word null.

00:28:32.720 --> 00:28:35.930
JOSH BLOCH: A list containing
the word null.

00:28:35.930 --> 00:28:39.050
All right Let's see that's
one of your choices.

00:28:39.050 --> 00:28:41.150
My gosh, it is.

00:28:41.150 --> 00:28:45.380
So your choices are choice A,
a list containing the word

00:28:45.380 --> 00:28:48.350
null, B, null, null,
so somehow it let

00:28:48.350 --> 00:28:49.330
both of them in.

00:28:49.330 --> 00:28:53.180
And I know that it is true that
Java will print out the

00:28:53.180 --> 00:28:57.580
null object reference or the
string N-U-L-L as null.

00:28:57.580 --> 00:29:00.410
It prints them the same way.

00:29:00.410 --> 00:29:03.870
It might throw a null pointer
exception or it might do none

00:29:03.870 --> 00:29:05.180
of the above.

00:29:05.180 --> 00:29:05.895
Those are the choices.

00:29:05.895 --> 00:29:07.780
JEREMY MANSON: All right Let's
ask them what they think.

00:29:07.780 --> 00:29:08.430
JOSH BLOCH: All right.

00:29:08.430 --> 00:29:10.050
Audience, what do you think?

00:29:10.050 --> 00:29:15.320
How many people believe that
this program prints simply the

00:29:15.320 --> 00:29:16.490
list containing null?

00:29:16.490 --> 00:29:17.240
JEREMY MANSON: I do.

00:29:17.240 --> 00:29:18.190
I do.

00:29:18.190 --> 00:29:20.420
JOSH BLOCH: What else
could it do, right?

00:29:20.420 --> 00:29:21.760
A quarter of them actually
agree with you

00:29:21.760 --> 00:29:22.850
JEREMY MANSON: Better
than that.

00:29:22.850 --> 00:29:25.240
JOSH BLOCH: How many people
believe it prints null, null,

00:29:25.240 --> 00:29:27.260
prints both of them?

00:29:27.260 --> 00:29:28.095
JEREMY MANSON: A smattering.

00:29:28.095 --> 00:29:29.700
JOSH BLOCH: A smattering,
well, I see one.

00:29:29.700 --> 00:29:30.790
JEREMY MANSON: I see two.

00:29:30.790 --> 00:29:31.250
JOSH BLOCH: I see two.

00:29:31.250 --> 00:29:32.180
All right, two people.

00:29:32.180 --> 00:29:34.850
How many people believe it
throws in a pointer exception?

00:29:34.850 --> 00:29:36.300
JEREMY MANSON: Lots of
people think so.

00:29:36.300 --> 00:29:37.675
JOSH BLOCH: That
a half of you.

00:29:37.675 --> 00:29:42.295
And how many people believe
none of the above?

00:29:42.295 --> 00:29:44.970
JEREMY MANSON: A quarter, yes.,
maybe a little less.

00:29:44.970 --> 00:29:46.010
JOSH BLOCH: A quarter of you.

00:29:46.010 --> 00:29:51.450
Well, it turns out that those
of you who said none of the

00:29:51.450 --> 00:29:53.580
above are indeed correct.

00:29:53.580 --> 00:29:59.180
And the intuition here is that
Varargs and generics don't get

00:29:59.180 --> 00:30:02.590
along very well and when you mix
them they have a tendency

00:30:02.590 --> 00:30:05.140
to throw class cast
exceptions.

00:30:05.140 --> 00:30:06.660
So shall we take another look
at the problem there?

00:30:06.660 --> 00:30:08.090
JEREMY MANSON: I would love to
take another look at that

00:30:08.090 --> 00:30:09.330
because that makes no sense
to me whatsoever.

00:30:09.330 --> 00:30:11.190
JOSH BLOCH: No, it doesn't
make a lot of sense to me

00:30:11.190 --> 00:30:12.270
either, but that's
what it does.

00:30:12.270 --> 00:30:12.788
JEREMY MANSON: Okay.

00:30:12.788 --> 00:30:13.115
Well, we'll see.

00:30:13.115 --> 00:30:13.800
JOSH BLOCH: All right.

00:30:13.800 --> 00:30:18.270
So the stack trace is
extraordinarily confusing.

00:30:18.270 --> 00:30:22.100
The class cast exception
it turns out is thrown

00:30:22.100 --> 00:30:24.090
from this line here.

00:30:24.090 --> 00:30:24.900
There's no code here.

00:30:24.900 --> 00:30:25.420
JEREMY MANSON: There's
no code there.

00:30:25.420 --> 00:30:26.310
JOSH BLOCH: It just says public

00:30:26.310 --> 00:30:28.365
class string sync extends--

00:30:28.365 --> 00:30:29.835
JEREMY MANSON: It's a VM bug.

00:30:29.835 --> 00:30:32.360
JOSH BLOCH: And that
is the line that

00:30:32.360 --> 00:30:33.350
actually throws the exception.

00:30:33.350 --> 00:30:34.410
How could that be?

00:30:34.410 --> 00:30:35.290
JEREMY MANSON: It's a VM bug.

00:30:35.290 --> 00:30:37.660
JOSH BLOCH: And if the rest of
the stack trace looks like

00:30:37.660 --> 00:30:38.870
this, that was called--

00:30:38.870 --> 00:30:39.570
JEREMY MANSON: I'd say
it doesn't happen on

00:30:39.570 --> 00:30:39.770
[UNINTELLIGIBLE].

00:30:39.770 --> 00:30:41.930
JOSH BLOCH: by add element.

00:30:41.930 --> 00:30:43.030
Okay?

00:30:43.030 --> 00:30:45.990
And add element was called
by add unless null.

00:30:45.990 --> 00:30:50.810
So basically we tried to put in
these two things and that

00:30:50.810 --> 00:30:59.840
in turn called add unless null,
which called add on the

00:30:59.840 --> 00:31:01.320
first element.

00:31:01.320 --> 00:31:04.370
And then it blew up here.

00:31:04.370 --> 00:31:06.110
What's going on?

00:31:06.110 --> 00:31:13.100
Well, what's going on is
briefings Varargs , erasure,

00:31:13.100 --> 00:31:14.595
and a bridge method.

00:31:14.595 --> 00:31:17.700
And the bridge method is the
most mysterious of the lot.

00:31:17.700 --> 00:31:21.040
So first of all, Varargs mean
that when you think you're

00:31:21.040 --> 00:31:23.970
passing like one or more
elements, they are packaged up

00:31:23.970 --> 00:31:27.350
into an array for you
automatically.

00:31:27.350 --> 00:31:28.540
And what about erasure?

00:31:28.540 --> 00:31:32.250
Erasure means that we're
passing one or more

00:31:32.250 --> 00:31:34.050
things of type t.

00:31:34.050 --> 00:31:36.880
What kind of array are they
packaged up into?

00:31:36.880 --> 00:31:39.340
You'd love it to be an array
of t's wouldn't you?

00:31:39.340 --> 00:31:40.920
So if you were calling
it on strings, you've

00:31:40.920 --> 00:31:42.400
got on array of string.

00:31:42.400 --> 00:31:44.120
If you were calling it on
integers you've got an array

00:31:44.120 --> 00:31:44.510
of integers.

00:31:44.510 --> 00:31:45.310
But you don't.

00:31:45.310 --> 00:31:47.760
You get the erasure that
is the lower bound

00:31:47.760 --> 00:31:49.290
of t, which is object.

00:31:49.290 --> 00:31:52.730
So it's always creates
an array of objects.

00:31:52.730 --> 00:31:56.530
And the same thing happens, by
the way, down here when we are

00:31:56.530 --> 00:32:01.060
adding, when we're calling
add from add unless null.

00:32:01.060 --> 00:32:04.060
The type of add is
t dot, dot, dot.

00:32:04.060 --> 00:32:08.410
And we have to create an array
to bundle up all of these one

00:32:08.410 --> 00:32:11.040
elements, even when you're only
passing one you've got to

00:32:11.040 --> 00:32:11.660
create an array.

00:32:11.660 --> 00:32:13.030
That's the way Varargs
work, right?

00:32:13.030 --> 00:32:15.470
And that array is
an object array.

00:32:15.470 --> 00:32:17.160
So far so bad.

00:32:17.160 --> 00:32:19.610
Now, what about the
bridge method?

00:32:19.610 --> 00:32:24.200
Well, if you look at sync from
a VM perspective, the method

00:32:24.200 --> 00:32:30.100
that you have to override here,
add is of type t dot,

00:32:30.100 --> 00:32:32.190
dot, dot, which is object
dot, dot, dot.

00:32:32.190 --> 00:32:34.370
You need a method that
takes an array of

00:32:34.370 --> 00:32:36.620
objects for the VM right?

00:32:36.620 --> 00:32:39.830
But the method that we are
writing here, our add method,

00:32:39.830 --> 00:32:43.080
takes an array of
strings, right?

00:32:43.080 --> 00:32:44.690
String dot, dot, dot element.

00:32:44.690 --> 00:32:48.280
But the compiler in its infinite
wisdom and mercy,

00:32:48.280 --> 00:32:50.190
makes for us an automatically
generated

00:32:50.190 --> 00:32:52.940
synthetic bridge method.

00:32:52.940 --> 00:32:55.040
It's not present in the source,
but it is present

00:32:55.040 --> 00:32:59.590
class file, and its job is to
create a bridge between the

00:32:59.590 --> 00:33:01.540
string array method and the
object array method.

00:33:01.540 --> 00:33:05.395
So all it does is takes the
object array and casts it to a

00:33:05.395 --> 00:33:07.820
string array, because it has to
be a string array, right?

00:33:07.820 --> 00:33:10.750
That's what you're passing
in, one more strings.

00:33:10.750 --> 00:33:15.625
Well, sadly, it doesn't
necessarily have to be a

00:33:15.625 --> 00:33:16.380
string array.

00:33:16.380 --> 00:33:20.390
Suppose you're calling it
from here, add element.

00:33:20.390 --> 00:33:23.050
We already said it creates an
object array, which gets

00:33:23.050 --> 00:33:26.570
passed into here, which gets
cast to a string array.

00:33:26.570 --> 00:33:28.210
And the cast fails
at run time.

00:33:28.210 --> 00:33:30.850
The compiler generated a cast,
and it fails at run time.

00:33:30.850 --> 00:33:31.740
JEREMY MANSON: That
should be illegal.

00:33:31.740 --> 00:33:33.740
Isn't there some sort of,
isn't this something the

00:33:33.740 --> 00:33:34.930
compiler should tell
you about?

00:33:34.930 --> 00:33:37.490
JOSH BLOCH: Yes, the compiler
tried to warn you, and you

00:33:37.490 --> 00:33:38.040
wouldn't listen.

00:33:38.040 --> 00:33:38.780
You ignored it.

00:33:38.780 --> 00:33:39.870
JEREMY MANSON: I thought
this was your puzzler!

00:33:39.870 --> 00:33:41.830
JOSH BLOCH: But they never
ignore it, right?

00:33:41.830 --> 00:33:42.280
JEREMY MANSON: No.

00:33:42.280 --> 00:33:44.105
Nobody ever here ever ignores
compiler warnings.

00:33:44.105 --> 00:33:45.610
JOSH BLOCH: You pay attention
to all of them.

00:33:45.610 --> 00:33:46.300
JEREMY MANSON: Every
single one.

00:33:46.300 --> 00:33:49.060
JOSH BLOCH: In fact, when it
says uses unchecked or unsafe

00:33:49.060 --> 00:33:52.620
operation, you compile again
with a dash x link unchecked

00:33:52.620 --> 00:33:55.690
flag, and then it tells you
exactly what went wrong.

00:33:55.690 --> 00:33:58.790
It says uncheck the generic
recreation for type t array

00:33:58.790 --> 00:33:59.880
for Varargs parameter.

00:33:59.880 --> 00:34:01.470
So it actually shows
you the line where

00:34:01.470 --> 00:34:03.180
the bad thing happens.

00:34:03.180 --> 00:34:05.320
So how do we fix it?

00:34:05.320 --> 00:34:09.989
Well the easiest way to fix it
is if it hurts when you go

00:34:09.989 --> 00:34:11.600
like that, don't go like that.

00:34:11.600 --> 00:34:15.239
The problem is mixing the
arrays, in this case varargs

00:34:15.239 --> 00:34:17.070
and collections, so don't
use a varargs.

00:34:17.070 --> 00:34:21.190
Instead, just take in a
collection of elements.

00:34:21.190 --> 00:34:23.290
And now when you're
doing add we can't

00:34:23.290 --> 00:34:23.940
just pass the element.

00:34:23.940 --> 00:34:25.560
We have to turn it into a
collection, so we just call

00:34:25.560 --> 00:34:28.780
collections dot single,
no big deal.

00:34:28.780 --> 00:34:32.020
This add takes a collection of
strings, and now notice we

00:34:32.020 --> 00:34:34.659
don't even have to say arrays
dot as list. So it's like

00:34:34.659 --> 00:34:37.010
longer in one place and shorter
in another, because we

00:34:37.010 --> 00:34:38.190
already have a collection.

00:34:38.190 --> 00:34:41.739
And we can call add all with
a collection argument.

00:34:41.739 --> 00:34:44.520
And when we call it from the
main method once again, we

00:34:44.520 --> 00:34:46.489
don't have varargs at our
disposal, so we have say

00:34:46.489 --> 00:34:48.154
arrays dot as list, but
not so bad really.

00:34:48.154 --> 00:34:50.010
JEREMY MANSON: No bridge
methods to nowhere.

00:34:50.010 --> 00:34:52.440
JOSH BLOCH: No bridge methods
to nowhere, absolutely.

00:34:52.440 --> 00:34:54.699
It all just works and the
compiler doesn't warn you

00:34:54.699 --> 00:34:55.690
because it doesn't have to.

00:34:55.690 --> 00:34:57.690
It type checks and it works.

00:34:57.690 --> 00:35:01.095
So the moral here is Varargs
provide a leaky abstraction.

00:35:01.095 --> 00:35:02.450
JEREMY MANSON: That
was a leaky sync.

00:35:02.450 --> 00:35:04.240
JOSH BLOCH: Yes, that
was a leaky sync

00:35:04.240 --> 00:35:04.530
JEREMY MANSON: All right.

00:35:04.530 --> 00:35:05.440
That was a very weak joke.

00:35:05.440 --> 00:35:06.110
JOSH BLOCH: It was awful.

00:35:06.110 --> 00:35:06.950
You should be ashamed
of yourself.

00:35:06.950 --> 00:35:07.180
JEREMY MANSON: I am.

00:35:07.180 --> 00:35:09.875
JOSH BLOCH: Anyway, so the
idea is that it's a thin

00:35:09.875 --> 00:35:10.960
veneer over arrays.

00:35:10.960 --> 00:35:13.370
The arrays do show their ugly
heads, and the arrays don't

00:35:13.370 --> 00:35:15.120
get along very well
with generics.

00:35:15.120 --> 00:35:18.380
And since you can't mix them,
prefer collections to arrays.

00:35:18.380 --> 00:35:21.820
And finally, perhaps the most
important warning of this

00:35:21.820 --> 00:35:24.320
particular puzzle, don't ignore
compiler warnings.

00:35:24.320 --> 00:35:26.330
They are trying to tell
you something.

00:35:26.330 --> 00:35:30.020
Pretty much every compiler
warning is something that

00:35:30.020 --> 00:35:34.060
could be an outright
error at run time.

00:35:34.060 --> 00:35:34.970
Okay?

00:35:34.970 --> 00:35:36.210
So fix them.

00:35:36.210 --> 00:35:39.110
Ideally eliminate the warning
from your code.

00:35:39.110 --> 00:35:41.580
If you can't do that, prove,
and I do mean prove to

00:35:41.580 --> 00:35:45.140
yourself, that there is no real
problem, that nothing bad

00:35:45.140 --> 00:35:46.120
can happen at run time.

00:35:46.120 --> 00:35:50.110
And then write your proof into
the code as a comment.

00:35:50.110 --> 00:35:53.130
And finally use at suppress
warnings in the tightest

00:35:53.130 --> 00:35:55.700
possible scope so that the
compiler does not print that

00:35:55.700 --> 00:35:56.610
warning anymore.

00:35:56.610 --> 00:35:59.780
So that any warnings that the
compiler do print represent

00:35:59.780 --> 00:36:01.685
real problems that must
be addressed.

00:36:01.685 --> 00:36:03.780
JEREMY MANSON: All right Well,
I've got one for you.

00:36:03.780 --> 00:36:04.495
JOSH BLOCH: All right.

00:36:04.495 --> 00:36:06.450
JEREMY MANSON: Golly, sarge.

00:36:06.450 --> 00:36:09.740
What I've got for you today is
what we call a glommer, and

00:36:09.740 --> 00:36:15.350
the purpose of this class is
to glom objects and scalars

00:36:15.350 --> 00:36:17.400
together in various ways.

00:36:17.400 --> 00:36:20.850
We've got a glommer that
gloms strings together.

00:36:20.850 --> 00:36:23.650
And we've got a glommer that
gloms ints together.

00:36:23.650 --> 00:36:26.930
And I'm calling my main method
down there, and I'm calling

00:36:26.930 --> 00:36:30.060
glommer, and I want you to tell
me what this program is

00:36:30.060 --> 00:36:31.035
going to print out?

00:36:31.035 --> 00:36:31.555
JOSH BLOCH: All right.

00:36:31.555 --> 00:36:32.882
JEREMY MANSON: All right.

00:36:32.882 --> 00:36:37.470
JOSH BLOCH: So I see that we
have two glom methods.

00:36:37.470 --> 00:36:39.040
It's an overloaded method.

00:36:39.040 --> 00:36:41.360
The first one take a collection
of objects, and the

00:36:41.360 --> 00:36:44.100
second takes a list
of integers.

00:36:44.100 --> 00:36:47.350
So if you pass just any
collection of objects that's

00:36:47.350 --> 00:36:49.790
not a list of integers
it returns a string.

00:36:49.790 --> 00:36:51.360
And how does it build
that string?

00:36:51.360 --> 00:36:52.920
It starts with the
empty string.

00:36:52.920 --> 00:36:55.920
It iterates over all the
objects, appends them all to

00:36:55.920 --> 00:36:57.890
the string and returns
the results.

00:36:57.890 --> 00:36:59.730
In essence it concatenates
them all.

00:36:59.730 --> 00:37:03.030
If you passed in cat, dog, mouse
it would return cat,

00:37:03.030 --> 00:37:05.270
dog, mouse all jammed
together.

00:37:05.270 --> 00:37:07.960
What about if you're passing
a list of integers?

00:37:07.960 --> 00:37:09.250
Well, here we're going
to return an int.

00:37:09.250 --> 00:37:12.070
We initialize it to zero.

00:37:12.070 --> 00:37:14.350
Now, I see we're using
auto unboxing.

00:37:14.350 --> 00:37:17.140
You're iterating over these
integers as ints, and you're

00:37:17.140 --> 00:37:19.760
adding each of the int values
into the results.

00:37:19.760 --> 00:37:21.980
And finally you're returning
the sum.

00:37:21.980 --> 00:37:24.090
So this one returns
the catenation.

00:37:24.090 --> 00:37:25.770
This one returns the sum.

00:37:25.770 --> 00:37:28.750
And our main program we've
got a list of strings.

00:37:28.750 --> 00:37:30.500
certainly not a list
of integers.

00:37:30.500 --> 00:37:32.110
But it is a collection
of objects.

00:37:32.110 --> 00:37:35.930
A list of strings consisting
of one, two and three.

00:37:35.930 --> 00:37:39.730
We create a glommer, and
we glom those strings.

00:37:39.730 --> 00:37:43.290
And we print out the result
of the glomming.

00:37:43.290 --> 00:37:46.120
That would be this overloading,
and it would

00:37:46.120 --> 00:37:48.320
print one, two, three with
no spaces in between.

00:37:48.320 --> 00:37:48.890
JEREMY MANSON: All right.

00:37:48.890 --> 00:37:50.260
Let's see if that's one
of the possibilities.

00:37:50.260 --> 00:37:51.560
Oh, there it is.

00:37:51.560 --> 00:37:52.720
It's one of the possibilities.

00:37:52.720 --> 00:37:55.500
All right so we've got six.

00:37:55.500 --> 00:37:57.950
That's for people who think
that the integer method is

00:37:57.950 --> 00:38:00.140
being called, I guess. this has
got one, two, three for

00:38:00.140 --> 00:38:02.070
people who agree with
Josh over there.

00:38:02.070 --> 00:38:03.955
We've got the idea that it
might throw an exception.

00:38:03.955 --> 00:38:06.070
And we've got D, none
of the above.

00:38:06.070 --> 00:38:07.200
All right.

00:38:07.200 --> 00:38:10.050
So your turn, how many do you
think this program is going to

00:38:10.050 --> 00:38:11.300
print out six?

00:38:14.160 --> 00:38:17.500
About five, maybe something
like that?

00:38:17.500 --> 00:38:18.630
Five people something
like that?

00:38:18.630 --> 00:38:19.120
How many of you think--

00:38:19.120 --> 00:38:21.505
JOSH BLOCH: I think there were
six people actually.

00:38:21.505 --> 00:38:23.810
JEREMY MANSON: Well, you can
count better than I can, and

00:38:23.810 --> 00:38:25.170
we proved that earlier.

00:38:25.170 --> 00:38:28.400
All right how many people think
that this program prints

00:38:28.400 --> 00:38:29.720
out one, two, three,
agree with Josh.

00:38:29.720 --> 00:38:31.320
And again, sometimes
we trick you.

00:38:31.320 --> 00:38:31.940
JOSH BLOCH: What else
could it do, right?

00:38:31.940 --> 00:38:35.070
JEREMY MANSON: It could
be actually be right.

00:38:35.070 --> 00:38:36.820
Six, seven, eight people,
something like that.

00:38:36.820 --> 00:38:37.940
More people than thought six.

00:38:37.940 --> 00:38:39.250
How many people think
that this program

00:38:39.250 --> 00:38:41.970
will throw an exception?

00:38:41.970 --> 00:38:46.430
Got a good chunk of them,
maybe a third, half?

00:38:46.430 --> 00:38:47.340
JOSH BLOCH: Raise your
hands higher.

00:38:47.340 --> 00:38:48.590
We want to count.

00:38:48.590 --> 00:38:50.100
All right It's a third
of them, yes.

00:38:50.100 --> 00:38:51.200
JEREMY MANSON: It's a
pretty good number.

00:38:51.200 --> 00:38:52.880
And how many people think that
this program going to do

00:38:52.880 --> 00:38:55.900
something completely different,
none of the above?

00:38:55.900 --> 00:38:57.280
Oh, okay, well that's about--

00:38:57.280 --> 00:38:58.170
JOSH BLOCH: That's got
to be another third.

00:38:58.170 --> 00:38:58.660
JEREMY MANSON: Another
third, yes.

00:38:58.660 --> 00:38:59.060
All right.

00:38:59.060 --> 00:38:59.970
JOSH BLOCH: It's a tie
then between--

00:38:59.970 --> 00:39:00.730
JEREMY MANSON: Yes,
I think C and D.

00:39:00.730 --> 00:39:01.310
JOSH BLOCH: All right.

00:39:01.310 --> 00:39:01.510
Let's see what it does.

00:39:01.510 --> 00:39:03.060
JEREMY MANSON: Let's see
what it actually does.

00:39:03.060 --> 00:39:03.715
[da-da-da-dun]

00:39:03.715 --> 00:39:04.390
JOSH BLOCH: Oh, my.

00:39:04.390 --> 00:39:06.100
JEREMY MANSON: It throws
an exception.

00:39:06.100 --> 00:39:07.470
It throws a class
cast exception.

00:39:07.470 --> 00:39:08.120
JOSH BLOCH: Another class
cast exception.

00:39:08.120 --> 00:39:09.350
JEREMY MANSON: Another
class cast exception.

00:39:09.350 --> 00:39:10.710
I mean you can't get away
from these things.

00:39:10.710 --> 00:39:11.870
JOSH BLOCH: So what's
going on here?

00:39:11.870 --> 00:39:12.540
JEREMY MANSON: What's
going on?

00:39:12.540 --> 00:39:14.590
Well, the intuition is that
raw types are dangerous.

00:39:14.590 --> 00:39:16.340
And you might not have seen
a raw type in there.

00:39:16.340 --> 00:39:17.620
JOSH BLOCH: I didn't
see a raw type.

00:39:17.620 --> 00:39:18.200
JEREMY MANSON: Because
you weren't

00:39:18.200 --> 00:39:19.560
looking closely enough.

00:39:19.560 --> 00:39:23.830
You may not have seen that
glommer is a class that takes

00:39:23.830 --> 00:39:25.790
a parameterized type
of t here.

00:39:25.790 --> 00:39:26.900
JOSH BLOCH: And what's
it do with the t?

00:39:26.900 --> 00:39:29.380
JEREMY MANSON: And it does
absolutely nothing with the t,

00:39:29.380 --> 00:39:32.080
but it does require the t.

00:39:32.080 --> 00:39:35.500
And you may have noticed down
here, when we created a new

00:39:35.500 --> 00:39:38.670
glommer, we did not
pass that t.

00:39:38.670 --> 00:39:41.590
So what happens when you
create a new class that

00:39:41.590 --> 00:39:44.710
requires a parameterized type
and that you do not pass in a

00:39:44.710 --> 00:39:46.450
parameterized type?

00:39:46.450 --> 00:39:50.530
Well, excuse me, what
happens is that the

00:39:50.530 --> 00:39:51.700
compilation will discard.

00:39:51.700 --> 00:39:54.310
It will treat it as a raw type,
and it will discard all

00:39:54.310 --> 00:39:56.090
the generic type information
in that class.

00:39:56.090 --> 00:39:57.440
JOSH BLOCH: All the generic
type information?

00:39:57.440 --> 00:39:58.710
JEREMY MANSON: All
the generic type.

00:39:58.710 --> 00:40:02.060
The question mark over there
goes away, the integer over

00:40:02.060 --> 00:40:02.670
there goes away.

00:40:02.670 --> 00:40:04.380
The string over there
goes away.

00:40:04.380 --> 00:40:05.570
And so what are you left with?

00:40:05.570 --> 00:40:06.830
You're left with raw types.

00:40:06.830 --> 00:40:10.910
You're left with calling glom
on a list of strings.

00:40:10.910 --> 00:40:11.660
Well, we've two--

00:40:11.660 --> 00:40:12.175
JOSH BLOCH: Just a list.

00:40:12.175 --> 00:40:14.630
JEREMY MANSON: just a list.
We've got two possible methods

00:40:14.630 --> 00:40:15.910
that we could resolve that to.

00:40:15.910 --> 00:40:19.290
One of them takes a list and the
other takes a collection.

00:40:19.290 --> 00:40:20.900
The list one is more specific.

00:40:20.900 --> 00:40:23.930
It's the most specific type that
you can resolve it to.

00:40:23.930 --> 00:40:26.480
And so it picks the list type.

00:40:26.480 --> 00:40:28.490
Well, what happens if it picks
the list type, those of you

00:40:28.490 --> 00:40:31.090
who are clever enough to see,
well it's look what it's

00:40:31.090 --> 00:40:31.800
trying to do there.

00:40:31.800 --> 00:40:33.640
It's expecting an int
and you're passing

00:40:33.640 --> 00:40:34.390
it a bunch of strings.

00:40:34.390 --> 00:40:37.390
JOSH BLOCH: So when it tries to
auto unbox the string as an

00:40:37.390 --> 00:40:39.640
int it throws a class
cast exception.

00:40:39.640 --> 00:40:40.872
JEREMY MANSON: It does indeed.

00:40:40.872 --> 00:40:41.640
JOSH BLOCH: All right.

00:40:41.640 --> 00:40:43.100
Well, that's pretty ugly.

00:40:43.100 --> 00:40:44.500
So how do we fix that?

00:40:44.500 --> 00:40:46.400
JEREMY MANSON: Well,
we fix it by paying

00:40:46.400 --> 00:40:47.280
attention to the compiler.

00:40:47.280 --> 00:40:48.130
JOSH BLOCH: All right.

00:40:48.130 --> 00:40:49.380
And what did the compiler us?

00:40:49.380 --> 00:40:52.040
JEREMY MANSON: Well, the
compiler told us something

00:40:52.040 --> 00:40:55.240
that, again, if you'd read it,
you would have seen the exact

00:40:55.240 --> 00:40:58.365
problem, an unchecked call to
glom of list as a member of

00:40:58.365 --> 00:40:59.090
raw type glommer.

00:40:59.090 --> 00:40:59.870
JOSH BLOCH: Ouch.

00:40:59.870 --> 00:41:01.420
All right, so how do
we really fix that?

00:41:01.420 --> 00:41:03.130
JEREMY MANSON: Very, very fast
and very straightforward.

00:41:03.130 --> 00:41:06.960
Well, the easiest thing to do is
to specify a type parameter

00:41:06.960 --> 00:41:09.230
for glommer, a type parameter
for glommer.

00:41:09.230 --> 00:41:10.400
And it doesn't matter what type

00:41:10.400 --> 00:41:11.410
parameter you specify here.

00:41:11.410 --> 00:41:12.750
It could be random.

00:41:12.750 --> 00:41:13.290
It could be system--

00:41:13.290 --> 00:41:14.450
JOSH BLOCH: Any random
you're saying?

00:41:14.450 --> 00:41:15.500
JEREMY MANSON: Any random
type at all.

00:41:15.500 --> 00:41:16.400
JOSH BLOCH: Okay,
but that's ugly.

00:41:16.400 --> 00:41:17.520
Is there a better
way to fix it?

00:41:17.520 --> 00:41:18.250
JEREMY MANSON: Well, yes.

00:41:18.250 --> 00:41:19.920
You don't have to have a
type parameter there.

00:41:19.920 --> 00:41:20.680
We weren't using it.

00:41:20.680 --> 00:41:22.600
Why have it in the first
place, Right?

00:41:22.600 --> 00:41:24.550
So just get rid of the
darn parameter.

00:41:24.550 --> 00:41:26.230
And I should probably
be careful where

00:41:26.230 --> 00:41:26.920
I point this thing.

00:41:26.920 --> 00:41:27.940
Get rid of the data.

00:41:27.940 --> 00:41:29.060
JOSH BLOCH: Put that darn
thing somewhere else.

00:41:29.060 --> 00:41:29.940
JEREMY MANSON: Yes.

00:41:29.940 --> 00:41:30.720
I'm going to get
us all killed.

00:41:30.720 --> 00:41:31.070
JOSH BLOCH: Okay.

00:41:31.070 --> 00:41:33.020
This is so beautiful it couldn't
possibly be made any

00:41:33.020 --> 00:41:33.760
more beautiful.

00:41:33.760 --> 00:41:35.190
JEREMY MANSON: And yet I argue
that you could make it

00:41:35.190 --> 00:41:36.040
slightly more beautiful.

00:41:36.040 --> 00:41:36.420
JOSH BLOCH: Prove it.

00:41:36.420 --> 00:41:37.790
JEREMY MANSON: I will show
you on the next slide.

00:41:37.790 --> 00:41:39.300
Oh, here's the next slide.

00:41:39.300 --> 00:41:44.800
Well, those glom methods, they
didn't actually use any states

00:41:44.800 --> 00:41:45.570
for the glommer.

00:41:45.570 --> 00:41:46.850
They could be static methods.

00:41:46.850 --> 00:41:48.930
They're just tiny little
static utility methods.

00:41:48.930 --> 00:41:51.620
Now, I know all of you good
Java programmers have been

00:41:51.620 --> 00:41:54.910
trained to recoil at
the word static.

00:41:54.910 --> 00:41:56.400
And this can't be mocked.

00:41:56.400 --> 00:41:57.270
It's not testable.

00:41:57.270 --> 00:41:58.750
Well, I don't care
what you think.

00:41:58.750 --> 00:42:00.820
JOSH BLOCH: Who in their right
mind would want to mock that?

00:42:00.820 --> 00:42:01.670
I think it mocks itself,
frankly.

00:42:01.670 --> 00:42:03.060
JEREMY MANSON: It's
already a mockery.

00:42:03.060 --> 00:42:03.690
JOSH BLOCH: Yes.

00:42:03.690 --> 00:42:05.620
JEREMY MANSON: So in
this case you just

00:42:05.620 --> 00:42:06.560
call glom the strings.

00:42:06.560 --> 00:42:07.680
You don't need to create
a new object.

00:42:07.680 --> 00:42:10.950
I'm all about not creating new
objects, in sane ways, unlike

00:42:10.950 --> 00:42:12.950
like the EnumMap example
earlier.

00:42:12.950 --> 00:42:13.610
JOSH BLOCH: Exactly.

00:42:13.610 --> 00:42:16.390
JEREMY MANSON: And you get the
right answer, and it prints

00:42:16.390 --> 00:42:16.660
one, two, three.

00:42:16.660 --> 00:42:17.200
JOSH BLOCH: Love it.

00:42:17.200 --> 00:42:17.860
What can we learn that?

00:42:17.860 --> 00:42:19.440
JEREMY MANSON: Well, waht we can
learn from that is never

00:42:19.440 --> 00:42:22.370
use raw types of new code.

00:42:22.370 --> 00:42:25.070
It's okay if you're maintaining
that Java 1.4

00:42:25.070 --> 00:42:26.370
program and you know
what it did.

00:42:26.370 --> 00:42:30.340
But if you've got new code just
avoid it at all costs.

00:42:30.340 --> 00:42:32.490
They lose all your generics
information.

00:42:32.490 --> 00:42:34.350
It's going to break your
overload resolution like it

00:42:34.350 --> 00:42:35.440
did in this example.

00:42:35.440 --> 00:42:39.680
And again, as with the last
example, don't ignore the

00:42:39.680 --> 00:42:42.600
compiler warnings even when
they're, even when they're

00:42:42.600 --> 00:42:43.155
indecipherable.

00:42:43.155 --> 00:42:44.030
JOSH BLOCH: Which is
most of the time.

00:42:44.030 --> 00:42:45.490
JEREMY MANSON: Which is most
of the time with these

00:42:45.490 --> 00:42:46.240
generics warnings.

00:42:46.240 --> 00:42:47.730
I'm sure you've all seen these
generics warnings.

00:42:47.730 --> 00:42:50.960
I don't understand them.

00:42:50.960 --> 00:42:54.090
They have the tendency to turn
those little yellow squiggly

00:42:54.090 --> 00:42:58.120
lines that you see in your
eclipse screen at compile time

00:42:58.120 --> 00:43:00.670
into red squiggly lines
at run time.

00:43:00.670 --> 00:43:01.305
JOSH BLOCH: All right.

00:43:01.305 --> 00:43:03.320
JEREMY MANSON: So that's
our moral.

00:43:03.320 --> 00:43:04.470
Do you have one for me?

00:43:04.470 --> 00:43:04.875
JOSH BLOCH: I do.

00:43:04.875 --> 00:43:05.550
JEREMY MANSON: Okay.

00:43:05.550 --> 00:43:07.190
JOSH BLOCH: This is
the last problem.

00:43:07.190 --> 00:43:08.160
JEREMY MANSON: Oh,
that's so sad.

00:43:08.160 --> 00:43:11.120
JOSH BLOCH: The last problem of
the day This one is called

00:43:11.120 --> 00:43:14.640
"It's Elementary," and
this one, it's not a

00:43:14.640 --> 00:43:15.745
completely new problem.

00:43:15.745 --> 00:43:17.205
JEREMY MANSON: I think I've
seen this one before.

00:43:17.205 --> 00:43:20.670
JOSH BLOCH: Gave it in 2004,
but this one is new and

00:43:20.670 --> 00:43:23.450
improved and we mix
it up a little.

00:43:23.450 --> 00:43:24.560
JEREMY MANSON: It looks
exactly the same.

00:43:24.560 --> 00:43:26.190
JOSH BLOCH: It's a
great problem.

00:43:26.190 --> 00:43:28.620
It's all about addition.

00:43:28.620 --> 00:43:30.100
And addition is pretty
easy stuff.

00:43:30.100 --> 00:43:33.530
You guys learned that what,
in seventh grade?

00:43:33.530 --> 00:43:34.225
JEREMY MANSON: I
was in college.

00:43:34.225 --> 00:43:35.660
JOSH BLOCH: College, something
like that.

00:43:35.660 --> 00:43:37.540
So you should have no trouble
with this one.

00:43:37.540 --> 00:43:38.480
What does this program print?

00:43:38.480 --> 00:43:39.790
JEREMY MANSON: Well,
I have no idea.

00:43:39.790 --> 00:43:40.390
Well, first of all--

00:43:40.390 --> 00:43:41.140
JOSH BLOCH: Can you what--

00:43:41.140 --> 00:43:41.910
JEREMY MANSON: I don't
know what this is.

00:43:41.910 --> 00:43:42.420
What is this?

00:43:42.420 --> 00:43:44.300
Is this some sort of a weird
bio-hazard symbol?

00:43:44.300 --> 00:43:45.580
JOSH BLOCH: Well, okay.

00:43:45.580 --> 00:43:47.590
See, if you were a little
older you would

00:43:47.590 --> 00:43:48.090
know what that was.

00:43:48.090 --> 00:43:50.780
How many people know what
that symbol is?

00:43:50.780 --> 00:43:51.630
JEREMY MANSON: Old people.

00:43:51.630 --> 00:43:52.160
JOSH BLOCH: My gosh.

00:43:52.160 --> 00:43:52.580
JEREMY MANSON: Look at
all these old people.

00:43:52.580 --> 00:43:53.660
JOSH BLOCH: Very, very
few of them.

00:43:53.660 --> 00:43:57.470
So it used to be that single
records called 45s had these

00:43:57.470 --> 00:43:59.440
big holes in the middle and you
put one of those suckers

00:43:59.440 --> 00:44:01.030
in them before you put
them on your VDU.

00:44:01.030 --> 00:44:03.370
VDU is a vinyl decoding unit.

00:44:03.370 --> 00:44:04.240
JEREMY MANSON: You had a VDU?

00:44:04.240 --> 00:44:05.290
JOSH BLOCH: Turntable?

00:44:05.290 --> 00:44:06.070
Yes.

00:44:06.070 --> 00:44:07.390
Anyway, never mind.

00:44:07.390 --> 00:44:07.830
JEREMY MANSON: All right.

00:44:07.830 --> 00:44:08.080
Okay.

00:44:08.080 --> 00:44:08.720
Let's see what this
prints out.

00:44:08.720 --> 00:44:09.570
Yes, I'm sorry.

00:44:09.570 --> 00:44:11.480
One, two, three, four, five plus
five, four, three, two

00:44:11.480 --> 00:44:13.440
one, well, that looks like
it would print out six,

00:44:13.440 --> 00:44:14.320
six, six, six, six.

00:44:14.320 --> 00:44:15.970
Six, six, six, six
six, six, yes.

00:44:15.970 --> 00:44:17.760
That's the right number, six,
six, six, six, six.

00:44:17.760 --> 00:44:18.560
Yes, right?

00:44:18.560 --> 00:44:21.580
And then we print out a space,
very straightforward, and then

00:44:21.580 --> 00:44:24.270
zero, one, two, three,
four plus four,

00:44:24.270 --> 00:44:25.290
three, two, one, zero.

00:44:25.290 --> 00:44:28.850
That looks like it would put a
zero plus four, one plus three

00:44:28.850 --> 00:44:30.810
four, four, four, four, four.

00:44:30.810 --> 00:44:35.520
So five fours, five sixes
followed by five fours, right?

00:44:35.520 --> 00:44:38.050
JOSH BLOCH: Five sixes followed
by five fours.

00:44:38.050 --> 00:44:39.180
JEREMY MANSON: Yes, that's
got to be the answer.

00:44:39.180 --> 00:44:40.440
There's no possible other
answer there.

00:44:40.440 --> 00:44:42.380
JOSH BLOCH: Let us see that.

00:44:42.380 --> 00:44:43.730
All right.

00:44:43.730 --> 00:44:45.400
That actually is one
of your choices.

00:44:45.400 --> 00:44:47.750
It's choice C, and I must remind
you, by the way, when a

00:44:47.750 --> 00:44:49.090
program is simple enough--

00:44:49.090 --> 00:44:49.980
JEREMY MANSON: That's right.

00:44:49.980 --> 00:44:50.550
How could it be?

00:44:50.550 --> 00:44:51.790
How could I possibly
have gone wrong?

00:44:51.790 --> 00:44:52.870
JOSH BLOCH: How could
he have gone wrong?

00:44:52.870 --> 00:44:53.310
JEREMY MANSON: Exactyl.

00:44:53.310 --> 00:44:55.020
JOSH BLOCH: Take a look.

00:44:55.020 --> 00:44:56.270
Think, if you will.

00:45:00.540 --> 00:45:01.920
All right.

00:45:01.920 --> 00:45:04.496
The time for thinking
has passed.

00:45:04.496 --> 00:45:06.830
JEREMY MANSON: I say that at
the beginning of the talk.

00:45:06.830 --> 00:45:07.950
JOSH BLOCH: Good point.

00:45:07.950 --> 00:45:10.980
How many of you believe, and by
the way, I'm not going to

00:45:10.980 --> 00:45:13.010
read out these five digit
numbers because it feels very

00:45:13.010 --> 00:45:16.800
silly to read out eight five
digit numbers, but how many of

00:45:16.800 --> 00:45:20.630
you believe it would be choice
A, 17,000 and change followed

00:45:20.630 --> 00:45:23.070
by all the fours.

00:45:23.070 --> 00:45:23.290
Choice A?

00:45:23.290 --> 00:45:24.100
JEREMY MANSON: A
couple people.

00:45:24.100 --> 00:45:24.390
JOSH BLOCH: people?

00:45:24.390 --> 00:45:24.850
JEREMY MANSON: Two, three

00:45:24.850 --> 00:45:26.030
JOSH BLOCH: Three?

00:45:26.030 --> 00:45:26.650
Three of you.

00:45:26.650 --> 00:45:30.550
How many people go for choice B,
17,000 and change and then

00:45:30.550 --> 00:45:31.610
43,000 and change?

00:45:31.610 --> 00:45:34.070
JEREMY MANSON: That's like
four, five, six.

00:45:34.070 --> 00:45:34.995
Six, something like that.

00:45:34.995 --> 00:45:36.090
JOSH BLOCH: A smattering.

00:45:36.090 --> 00:45:38.971
How many people go
for choice C?

00:45:38.971 --> 00:45:39.830
JEREMY MANSON: Yes.

00:45:39.830 --> 00:45:41.160
That's the only possible
answer, right?

00:45:41.160 --> 00:45:42.640
JOSH BLOCH: About 10 of you.

00:45:42.640 --> 00:45:44.570
You guys better be going for
choice D because that's all

00:45:44.570 --> 00:45:45.140
that's left.

00:45:45.140 --> 00:45:46.520
How many people believe
choice D?

00:45:46.520 --> 00:45:47.390
JEREMY MANSON: Lots of people
believe choice D.

00:45:47.390 --> 00:45:49.310
JOSH BLOCH: All right, lots
of you, two thirds of you.

00:45:49.310 --> 00:45:53.060
Some of you weren't voting, but
choice D, choice D wins by

00:45:53.060 --> 00:45:53.550
a landslide.

00:45:53.550 --> 00:45:54.780
JEREMY MANSON: So what
is the actual answer?

00:45:54.780 --> 00:45:56.280
JOSH BLOCH: Well, that's
a very good question.

00:45:56.280 --> 00:45:59.660
It turns out that the actual
answer, believe it or

00:45:59.660 --> 00:46:01.760
not, is choice B.

00:46:01.760 --> 00:46:03.020
JEREMY MANSON: Choice B?

00:46:03.020 --> 00:46:03.440
[slide whistle]

00:46:03.440 --> 00:46:04.310
JOSH BLOCH: Yes, sometimes
it happens.

00:46:04.310 --> 00:46:06.580
JEREMY MANSON: I don't even see
how that-- those are like

00:46:06.580 --> 00:46:07.320
random numbers.

00:46:07.320 --> 00:46:08.535
I've never seen those
numbers before.

00:46:08.535 --> 00:46:10.375
Well, I've seen them before
on the slide, but--

00:46:10.375 --> 00:46:12.960
JOSH BLOCH: So the intuition
here, it's a two part problem,

00:46:12.960 --> 00:46:14.570
and it's got two parts
of intuition.

00:46:14.570 --> 00:46:17.050
First of all, that program
doesn't say what

00:46:17.050 --> 00:46:18.570
you think it does.

00:46:18.570 --> 00:46:23.000
And second of all leading zeroes
can cause trouble.

00:46:23.000 --> 00:46:25.650
So let's take a look here.

00:46:25.650 --> 00:46:31.570
Now, if you look at this green
character, you'll see that it

00:46:31.570 --> 00:46:36.070
has an acute angle, and that
makes it the digit one.

00:46:39.500 --> 00:46:43.210
Well, wait, wait, wait,
wait, [laughter]

00:46:43.210 --> 00:46:44.996
You can boo all you like.

00:46:44.996 --> 00:46:45.925
JEREMY MANSON: It's
still true.

00:46:45.925 --> 00:46:48.950
JOSH BLOCH: But first of all,
it's true and you could have

00:46:48.950 --> 00:46:50.775
seen it, but second of all,
and more importantly,

00:46:50.775 --> 00:46:51.950
JEREMY MANSON: You
didn't see it.

00:46:51.950 --> 00:46:55.050
JOSH BLOCH: More importantly,
this is a problem with a very

00:46:55.050 --> 00:46:55.870
important lesson.

00:46:55.870 --> 00:46:58.040
We'll get to the lesson
in a moment.

00:46:58.040 --> 00:47:02.110
And that lesson alone I aver
is worth the price of

00:47:02.110 --> 00:47:03.240
admission to this talk.

00:47:03.240 --> 00:47:06.240
Not necessarily to the
conference, but to this talk.

00:47:06.240 --> 00:47:06.970
All right.

00:47:06.970 --> 00:47:11.230
So we're adding this integer
one, two, three, four, five,

00:47:11.230 --> 00:47:18.655
to 5,432 long, and of course
we end up with 17,777 long.

00:47:18.655 --> 00:47:20.530
But it doesn't print out
that it's a long.

00:47:20.530 --> 00:47:22.070
That's kind of nasty.

00:47:22.070 --> 00:47:24.370
And what about the second one?

00:47:24.370 --> 00:47:26.230
Well, here's what's
happening there.

00:47:26.230 --> 00:47:31.180
This leading zero indicates an
octal that is base eight.

00:47:31.180 --> 00:47:31.710
JEREMY MANSON: An octal?

00:47:31.710 --> 00:47:32.180
What is that?

00:47:32.180 --> 00:47:33.470
Some old person's
number system?

00:47:33.470 --> 00:47:34.430
JOSH BLOCH: It is, well--

00:47:34.430 --> 00:47:35.250
JEREMY MANSON: What is this?

00:47:35.250 --> 00:47:38.310
What are we programming mini
computers in 1965?

00:47:38.310 --> 00:47:39.700
JOSH BLOCH: Back in my day--

00:47:39.700 --> 00:47:40.370
JEREMY MANSON: You had a day?

00:47:40.370 --> 00:47:40.840
JOSH BLOCH:There
were machines.

00:47:40.840 --> 00:47:41.940
JEREMY MANSON: There
were machines?

00:47:41.940 --> 00:47:42.100
Oh, my God.

00:47:42.100 --> 00:47:42.920
JOSH BLOCH: There
were machines--

00:47:42.920 --> 00:47:43.390
JEREMY MANSON: I though
you just had rocks.

00:47:43.390 --> 00:47:45.530
JOSH BLOCH: That had
36 bit words.

00:47:45.530 --> 00:47:46.620
JEREMY MANSON: Thirty-six
bit words.

00:47:46.620 --> 00:47:48.030
JOSH BLOCH: That's a multiple of
three and they were called

00:47:48.030 --> 00:47:50.030
DEC ssytem 10s and they were
actually pretty darned good.

00:47:50.030 --> 00:47:51.250
JEREMY MANSON: And that's
what most Java

00:47:51.250 --> 00:47:51.590
programmers need, right?

00:47:51.590 --> 00:47:52.090
JOSH BLOCH: Yes, right.

00:47:52.090 --> 00:47:55.260
When you have like, they would
have like six, six bit bytes

00:47:55.260 --> 00:47:56.110
and stuff like that.

00:47:56.110 --> 00:47:58.980
When you are dealing with things
like that, octal is not

00:47:58.980 --> 00:48:01.610
such a stupid base to use.

00:48:01.610 --> 00:48:04.910
But moreover, this existed in
the C programming language,

00:48:04.910 --> 00:48:07.910
and in general the rule in
Java was when C does

00:48:07.910 --> 00:48:08.840
it we do it, too.

00:48:08.840 --> 00:48:09.250
JEREMY MANSON: It's true.

00:48:09.250 --> 00:48:11.546
JOSH BLOCH: And that's why--

00:48:11.546 --> 00:48:13.930
JEREMY MANSON: That's
my motto.

00:48:13.930 --> 00:48:16.250
JOSH BLOCH: And that's
why it does this.

00:48:16.250 --> 00:48:22.290
And 1,234 octal was equal to 668
decimal, hence that other

00:48:22.290 --> 00:48:24.090
random looking number.

00:48:24.090 --> 00:48:24.790
So how do we fix it?

00:48:24.790 --> 00:48:25.980
JEREMY MANSON: So how
do we fix it?

00:48:25.980 --> 00:48:26.965
JOSH BLOCH: Well, duh.

00:48:26.965 --> 00:48:27.745
JEREMY MANSON: Yes.

00:48:27.745 --> 00:48:28.770
That one's easy.

00:48:28.770 --> 00:48:34.070
JOSH BLOCH: We turn the L into a
one and we omit that leading

00:48:34.070 --> 00:48:34.600
zero, right?

00:48:34.600 --> 00:48:37.480
And then it prints six, six,
six, six, six and four, four,

00:48:37.480 --> 00:48:38.990
four, four, four, just
as it should.

00:48:38.990 --> 00:48:40.970
JEREMY MANSON: But you promised
everybody something

00:48:40.970 --> 00:48:41.960
slightly deeper in this?

00:48:41.960 --> 00:48:43.300
JOSH BLOCH: Yes, all right,
deeper things.

00:48:43.300 --> 00:48:44.240
JEREMY MANSON: I don't
really believe that.

00:48:44.240 --> 00:48:45.440
JOSH BLOCH: The deeper things
are the morals.

00:48:45.440 --> 00:48:46.020
No, there really are.

00:48:46.020 --> 00:48:46.530
This is important.

00:48:46.530 --> 00:48:46.940
JEREMY MANSON: Okay.

00:48:46.940 --> 00:48:50.200
JOSH BLOCH: Listen guys, and
women, listen everyone.

00:48:50.200 --> 00:48:50.510
Never--

00:48:50.510 --> 00:48:51.735
JEREMY MANSON: Guys in the
gender neutral sense.

00:48:51.735 --> 00:48:55.810
JOSH BLOCH: use a lower case L
to indicate a long literal.

00:48:55.810 --> 00:48:57.740
Always use an upper case L.

00:48:57.740 --> 00:48:58.580
This is clear.

00:48:58.580 --> 00:49:02.180
If you see five, four, three,
two upper case L we know we're

00:49:02.180 --> 00:49:04.970
talking about a long literal
in the 5,000s.

00:49:04.970 --> 00:49:08.720
If you use a lower case L,
which sadly is common in

00:49:08.720 --> 00:49:11.140
certain other programming
languages ending in plus plus

00:49:11.140 --> 00:49:15.950
that we won't talk about,
it's unreadable.

00:49:15.950 --> 00:49:18.050
So that's the big moral.

00:49:18.050 --> 00:49:20.490
And there's a second related
moral, which is don't use a

00:49:20.490 --> 00:49:23.540
lone lower case L as
a variable name.

00:49:23.540 --> 00:49:25.480
Because once again, when people
do something with it,

00:49:25.480 --> 00:49:28.010
like print it, it'll look like
they're printing one not L.

00:49:28.010 --> 00:49:31.570
I used to always say list of
string L equals blah, blah.

00:49:31.570 --> 00:49:33.260
But now if you look at
my code I always say

00:49:33.260 --> 00:49:34.940
list rather than L.

00:49:34.940 --> 00:49:38.210
And then for the second part of
that, never precede an int

00:49:38.210 --> 00:49:40.390
with a zero just to pad it.

00:49:40.390 --> 00:49:42.930
If it happens to be seven or
less it won't change the

00:49:42.930 --> 00:49:44.840
value, but my God, your program

00:49:44.840 --> 00:49:46.930
becomes very, very fragile.

00:49:46.930 --> 00:49:50.000
Only precede an integer
with zero if you

00:49:50.000 --> 00:49:51.210
want it to be octal.

00:49:51.210 --> 00:49:54.200
And if you're going to do that,
always add a comment

00:49:54.200 --> 00:49:56.340
saying this is an
octal literal.

00:49:56.340 --> 00:49:58.840
Because otherwise some helpful
person who is re-factoring

00:49:58.840 --> 00:50:00.425
your code, cleaning
it up perhaps,

00:50:00.425 --> 00:50:00.970
JEREMY MANSON: Yes.

00:50:00.970 --> 00:50:02.500
JOSH BLOCH: Well, like,
remove the leading

00:50:02.500 --> 00:50:03.050
zero and change it.

00:50:03.050 --> 00:50:04.990
JEREMY MANSON: These things
should be compiler warnings.

00:50:04.990 --> 00:50:06.120
JOSH BLOCH: They should
be compiler

00:50:06.120 --> 00:50:08.330
warnings, but they aren't.

00:50:08.330 --> 00:50:11.700
So in the meantime,
warn yourself.

00:50:11.700 --> 00:50:12.760
All right.

00:50:12.760 --> 00:50:13.455
JEREMY MANSON: All right.

00:50:13.455 --> 00:50:15.030
JOSH BLOCH: So a summary then
of the traps that we

00:50:15.030 --> 00:50:15.880
presented for you.

00:50:15.880 --> 00:50:17.940
JEREMY MANSON: Well, first of
all you always want to use

00:50:17.940 --> 00:50:20.120
BigDecimal string and not
new BigDecimal double.

00:50:20.120 --> 00:50:23.930
Always read that Java doc and
make sure what you're doing is

00:50:23.930 --> 00:50:25.150
what you expect to be doing.

00:50:25.150 --> 00:50:25.910
JOSH BLOCH: Excellent.

00:50:25.910 --> 00:50:28.620
And then for the second problem
do not assume when

00:50:28.620 --> 00:50:31.840
you're iterating over a map that
the map dot entry objects

00:50:31.840 --> 00:50:32.770
are stable.

00:50:32.770 --> 00:50:34.700
If you happen to be using
one of those broken map

00:50:34.700 --> 00:50:38.040
implementations, EnumMap
and identity hash

00:50:38.040 --> 00:50:39.120
map, they aren't stable.

00:50:39.120 --> 00:50:40.030
They'll change.

00:50:40.030 --> 00:50:42.350
You will return the same one
repeatedly and mutate it

00:50:42.350 --> 00:50:43.240
between iterations.

00:50:43.240 --> 00:50:45.750
JEREMY MANSON: Beware of
batastrophic cat tracking when

00:50:45.750 --> 00:50:46.910
writing regular expressions.

00:50:46.910 --> 00:50:50.060
Always make sure that your
regular expression doesn't

00:50:50.060 --> 00:50:53.610
experience this or that maybe
you use a different regular

00:50:53.610 --> 00:50:54.605
expression library.

00:50:54.605 --> 00:50:55.490
JOSH BLOCH: All right.

00:50:55.490 --> 00:51:01.090
And for problem four, generics
and arrays do not mix.

00:51:01.090 --> 00:51:05.460
So prefer generics to arrays
and also Varargs when mixed

00:51:05.460 --> 00:51:06.690
with generics become
dangerous.

00:51:06.690 --> 00:51:09.120
JEREMY MANSON: Never use
raw type in new code.

00:51:09.120 --> 00:51:11.130
You're going to lose all of your
generic type information.

00:51:11.130 --> 00:51:13.350
And again, don't make
the mistake

00:51:13.350 --> 00:51:14.880
about compiler warnings.

00:51:14.880 --> 00:51:17.200
JOSH BLOCH: So you're not one of
those raw, raw, raw, that's

00:51:17.200 --> 00:51:18.160
the spirit people then?

00:51:18.160 --> 00:51:20.030
JEREMY MANSON: No, no,
I'm very, very

00:51:20.030 --> 00:51:20.840
anti- school spirit.

00:51:20.840 --> 00:51:21.640
JOSH BLOCH: All right.

00:51:21.640 --> 00:51:22.000
All right.

00:51:22.000 --> 00:51:26.300
And finally always use an upper
case L to indicate your

00:51:26.300 --> 00:51:27.190
long [? consents ?],

00:51:27.190 --> 00:51:31.380
and never use zero to pad
your int literals.

00:51:31.380 --> 00:51:33.730
And the lessons for
API designers?

00:51:33.730 --> 00:51:35.620
JEREMY MANSON: Well, think
should make it easy to do the

00:51:35.620 --> 00:51:37.960
commonly correct thing and
impossible to do exotic

00:51:37.960 --> 00:51:39.890
things, like in that Big
Decimal example.

00:51:39.890 --> 00:51:42.650
JOSH BLOCH: And you should not
violate the principle of least

00:51:42.650 --> 00:51:42.930
astonishment.

00:51:42.930 --> 00:51:45.666
You should always make your
APIs do what people expect

00:51:45.666 --> 00:51:46.340
them to do.

00:51:46.340 --> 00:51:46.795
And finally?

00:51:46.795 --> 00:51:49.110
JEREMY MANSON: And never worsen
your API to improve

00:51:49.110 --> 00:51:51.824
performance unless you have no
choice and you barely know

00:51:51.824 --> 00:51:52.050
what you're doing.

00:51:52.050 --> 00:51:53.610
JOSH BLOCH: All right.

00:51:53.610 --> 00:51:58.130
In conclusion, the Java platform
is still reasonably

00:51:58.130 --> 00:51:59.180
simple and elegant.

00:51:59.180 --> 00:52:00.420
JEREMY MANSON: And they're
making it simpler and more

00:52:00.420 --> 00:52:01.330
elegant, more elegant
every day.

00:52:01.330 --> 00:52:02.010
JOSH BLOCH: No.

00:52:02.010 --> 00:52:05.830
Sadly, sadly no, but we
won't discuss that.

00:52:05.830 --> 00:52:07.460
It has a few sharp corners.

00:52:07.460 --> 00:52:10.460
So learn to recognize them
and learn to avoid them.

00:52:10.460 --> 00:52:13.510
The easiest way to do that is
to keep your programs short

00:52:13.510 --> 00:52:15.380
and clear, because if you don't
understand what your

00:52:15.380 --> 00:52:17.120
program does it probably
doesn't do what

00:52:17.120 --> 00:52:17.710
you want it to do.

00:52:17.710 --> 00:52:19.680
JEREMY MANSON: But sometimes
short and clear isn't actually

00:52:19.680 --> 00:52:21.070
the right way to do it.

00:52:21.070 --> 00:52:21.450
All right.

00:52:21.450 --> 00:52:23.820
And you should always
use Find Bugs.

00:52:23.820 --> 00:52:26.410
My graduate adviser, he's dear
to my heart, my graduate

00:52:26.410 --> 00:52:28.250
adviser is Bill Pugh the
father of Find Bugs.

00:52:28.250 --> 00:52:29.940
He wrote it with Dave Hovemeyer,
a fellow graduate

00:52:29.940 --> 00:52:30.570
student of mine.

00:52:30.570 --> 00:52:31.700
It's a beautiful program.

00:52:31.700 --> 00:52:34.110
It has caught innumerable
problems of mine.

00:52:34.110 --> 00:52:34.860
JOSH BLOCH: How much
does it cost?

00:52:34.860 --> 00:52:35.270
It must be expensive.

00:52:35.270 --> 00:52:37.040
JEREMY MANSON: It
costs nothing.

00:52:37.040 --> 00:52:37.400
You can--

00:52:37.400 --> 00:52:37.670
JOSH BLOCH: It's free?

00:52:37.670 --> 00:52:39.760
JEREMY MANSON: download it right
now from University of

00:52:39.760 --> 00:52:41.390
Maryland or from SourceForge.

00:52:41.390 --> 00:52:44.340
And run it on all of your code
and fix all of those terrible

00:52:44.340 --> 00:52:46.820
problems. And you should use
a good IDE that puts those

00:52:46.820 --> 00:52:49.020
yellow squiggly lines in because
you really don't want

00:52:49.020 --> 00:52:49.710
those yellow squiggly lines.

00:52:49.710 --> 00:52:50.600
JOSH BLOCH: It's such a deal.

00:52:50.600 --> 00:52:53.240
It finds bugs for free,
and do you know what?

00:52:53.240 --> 00:52:55.000
It does it on class files.

00:52:55.000 --> 00:52:57.090
So you can take like program
that you paid for--

00:52:57.090 --> 00:52:57.740
JEREMY MANSON: Other
pepole's code.

00:52:57.740 --> 00:52:58.980
JOSH BLOCH: Other people's
programs where you don't even

00:52:58.980 --> 00:52:59.690
have the source,

00:52:59.690 --> 00:53:00.280
JEREMY MANSON: Find bugs.

00:53:00.280 --> 00:53:03.090
JOSH BLOCH: You can find bugs
and you can say on line 63 of

00:53:03.090 --> 00:53:06.110
the class called Froobie,
you have this bug.

00:53:06.110 --> 00:53:07.200
It really freaks people out.

00:53:07.200 --> 00:53:08.830
JEREMY MANSON: Give
it a whirl.

00:53:08.830 --> 00:53:11.000
JOSH BLOCH: All right,
and finally, don't

00:53:11.000 --> 00:53:12.260
code like my brother.

00:53:12.260 --> 00:53:14.540
JEREMY MANSON: And whatever you
do, under no circumstances

00:53:14.540 --> 00:53:16.610
should you ever code
like my brother.

00:53:16.610 --> 00:53:20.280
JOSH BLOCH: And now a word
from our sponsor.

00:53:20.280 --> 00:53:26.270
If you did not like this talk,
you will certainly detest this

00:53:26.270 --> 00:53:31.420
book here, which contains 95
more puzzles, 52 illusions and

00:53:31.420 --> 00:53:32.275
tons of fun.

00:53:32.275 --> 00:53:34.480
JEREMY MANSON: What's that
yellow thing in the corner?

00:53:34.480 --> 00:53:35.480
JOSH BLOCH: Why that?

00:53:35.480 --> 00:53:37.940
That is a shameless plug.

00:53:37.940 --> 00:53:38.940
All right.

00:53:38.940 --> 00:53:45.140
So if you enjoyed this talk I
want you to tweet, attaching

00:53:45.140 --> 00:53:48.970
these hash tags and say
my God, Jeremy and

00:53:48.970 --> 00:53:50.320
Josh were just amazing.

00:53:50.320 --> 00:53:52.270
I want to marry both of them.

00:53:52.270 --> 00:53:52.920
Name my children after them.

00:53:52.920 --> 00:53:53.090
JEREMY MANSON:This is San
Francisco after all.

00:53:53.090 --> 00:53:57.060
JOSH BLOCH: Children after them
even if they're girls.

00:53:57.060 --> 00:53:58.980
And you can go to
the web here.

00:53:58.980 --> 00:54:01.790
There's a page that like
automatically generates rave

00:54:01.790 --> 00:54:02.830
tweets for you.

00:54:02.830 --> 00:54:06.060
If you think that the talk was
perhaps lacking in some way,

00:54:06.060 --> 00:54:09.300
we provided another address
here which you can use.

00:54:09.300 --> 00:54:09.900
Thanks a lot for coming.

00:54:09.900 --> 00:54:10.340
JEREMY MANSON: Thank you all.

00:54:10.340 --> 00:54:14.260
JOSH BLOCH: And enjoy the rest
your Google I/O experience.

