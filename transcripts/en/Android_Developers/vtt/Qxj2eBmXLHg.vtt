WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.265
[MUSIC PLAYING]

00:00:04.020 --> 00:00:05.770
YIGIT BOYAR: Hello and
welcome, everybody.

00:00:05.770 --> 00:00:08.250
My name is Yigit Boyar,
and I'm the technical lead

00:00:08.250 --> 00:00:09.750
for Architecture Components.

00:00:15.320 --> 00:00:16.210
Thank you.

00:00:16.210 --> 00:00:18.400
So today, we are going
to talk about what is

00:00:18.400 --> 00:00:19.930
new in Architecture Components.

00:00:19.930 --> 00:00:22.210
But before we start
with them, let's

00:00:22.210 --> 00:00:27.290
look at what we have been doing
in the last two, three years.

00:00:27.290 --> 00:00:30.310
So three years ago, we
were talking to developers.

00:00:30.310 --> 00:00:32.350
And they were saying,
oh, Android development

00:00:32.350 --> 00:00:34.060
is so hard, so hard.

00:00:34.060 --> 00:00:37.540
We're like, what is hard
about Android development?

00:00:37.540 --> 00:00:42.430
And they started listing things
like Lifecycles, Persistence.

00:00:42.430 --> 00:00:45.490
Like, a lot of things
were just hot, you know?

00:00:45.490 --> 00:00:46.870
So we needed to pick something.

00:00:46.870 --> 00:00:49.480
We said, OK, we're going to
first create an architecture

00:00:49.480 --> 00:00:50.080
guidance.

00:00:50.080 --> 00:00:53.050
And we're going to tackle
some of the major problems we

00:00:53.050 --> 00:00:54.170
think are important.

00:00:54.170 --> 00:00:58.000
So we started with
Lifecycles and Persistence.

00:00:58.000 --> 00:01:00.820
Two years ago at I/O,
we announced them.

00:01:00.820 --> 00:01:02.560
Soon after, we
have added Paging,

00:01:02.560 --> 00:01:04.660
because we realized
people struggle with that,

00:01:04.660 --> 00:01:06.280
making it efficient.

00:01:06.280 --> 00:01:09.370
And then in last year's I/O,
we have added WorkManager

00:01:09.370 --> 00:01:11.770
and Navigation to the flock.

00:01:11.770 --> 00:01:14.560
All these five
libraries together

00:01:14.560 --> 00:01:18.120
had more than 150
releases in two years.

00:01:18.120 --> 00:01:22.030
That's like a release
every five days.

00:01:22.030 --> 00:01:26.230
And based on the latest survey,
70% of professional developers

00:01:26.230 --> 00:01:30.320
use one of those libraries
in their applications.

00:01:30.320 --> 00:01:32.804
So thank you.

00:01:32.804 --> 00:01:35.708
[APPLAUSE]

00:01:37.650 --> 00:01:41.230
This is, like, a really
amazing adoption number for us.

00:01:41.230 --> 00:01:43.380
And let's look at
how we're doing it.

00:01:43.380 --> 00:01:45.150
So every project
starts this life

00:01:45.150 --> 00:01:46.780
with an early access program.

00:01:46.780 --> 00:01:48.660
So once we know what
we are planning to do,

00:01:48.660 --> 00:01:52.500
we send it to some
developers, ask for feedback.

00:01:52.500 --> 00:01:54.960
After we are comfortable
with that feedback,

00:01:54.960 --> 00:01:57.450
we release a public alpha,
which is when we are still

00:01:57.450 --> 00:02:02.220
developing it actively, but
it is ready to show everyone.

00:02:02.220 --> 00:02:05.100
After some time, we become
happy with the functionality

00:02:05.100 --> 00:02:07.470
and the APIs, and
we call it beta.

00:02:07.470 --> 00:02:09.060
When we call
something beta, that

00:02:09.060 --> 00:02:11.580
means the API will
not change anymore.

00:02:11.580 --> 00:02:15.480
So you can write code, and that
code will still keep compiling.

00:02:15.480 --> 00:02:18.030
And eventually, the
library becomes stable.

00:02:18.030 --> 00:02:20.160
And soon after the
library becomes stable,

00:02:20.160 --> 00:02:22.630
we always go back to
alpha and then beta.

00:02:22.630 --> 00:02:25.190
So the cycle keeps turning.

00:02:25.190 --> 00:02:28.140
We heard that, like, many people
are unhappy because everything

00:02:28.140 --> 00:02:30.063
is in alpha all the time.

00:02:30.063 --> 00:02:30.980
This is because of it.

00:02:30.980 --> 00:02:33.600
You can happily use the
latest stable version.

00:02:33.600 --> 00:02:35.420
But we want to
develop in the open,

00:02:35.420 --> 00:02:38.580
and we want this
rapid iteration cycle.

00:02:38.580 --> 00:02:42.210
And all of this is possible
thanks to the community.

00:02:42.210 --> 00:02:44.530
So we do a lot of User
Experience Research.

00:02:44.530 --> 00:02:46.530
We talk to developers.

00:02:46.530 --> 00:02:49.530
They keep these Developer
Diaries while they work.

00:02:49.530 --> 00:02:52.290
They do real regular
work at work.

00:02:52.290 --> 00:02:55.590
They log what they are doing,
and tell us how it is going.

00:02:55.590 --> 00:02:57.330
We do a lot of
one-on-one interviews

00:02:57.330 --> 00:03:00.510
with developers to better
understand the problems.

00:03:00.510 --> 00:03:03.240
We do Early Access Programs
so that before showing it

00:03:03.240 --> 00:03:07.290
to everybody, we can talk to
a closer group, more in-depth,

00:03:07.290 --> 00:03:09.610
and get initial feedback.

00:03:09.610 --> 00:03:13.020
Issue Tracker, where you report
your bugs and feature requests,

00:03:13.020 --> 00:03:14.430
is very important for us.

00:03:14.430 --> 00:03:18.720
This is what we use to
prioritize features and bugs.

00:03:18.720 --> 00:03:21.210
Last but not least,
we closely follow

00:03:21.210 --> 00:03:22.990
things like Reddit,
StackOverflow,

00:03:22.990 --> 00:03:26.790
to see what the
community is thinking.

00:03:26.790 --> 00:03:29.460
So yesterday we have
announced that it's going

00:03:29.460 --> 00:03:32.880
to be Kotlin first for Android.

00:03:32.880 --> 00:03:36.600
So this means we are not going
to just release ktx libraries.

00:03:36.600 --> 00:03:39.480
We are going to release more
Kotlin-focused libraries.

00:03:39.480 --> 00:03:42.060
Maybe some of them will
be written in Kotlin

00:03:42.060 --> 00:03:45.850
to take advantage of the
better language features.

00:03:45.850 --> 00:03:49.260
So it means some of the APIs
will first target Kotlin,

00:03:49.260 --> 00:03:53.260
and then will also support
the Java programming language.

00:03:53.260 --> 00:03:57.990
So during today, when I talk
about these new features,

00:03:57.990 --> 00:04:00.930
you will see a lot of Kotlin.

00:04:00.930 --> 00:04:02.850
OK, so let's start
the libraries.

00:04:02.850 --> 00:04:05.460
And we will start with the
oldest library we have,

00:04:05.460 --> 00:04:07.223
Data Binding.

00:04:07.223 --> 00:04:08.640
So if you don't
know Data Binding,

00:04:08.640 --> 00:04:12.360
Data Binding is our
declarative UIs inside XML.

00:04:12.360 --> 00:04:16.860
It tries to bridge the gap
between your code and your XML.

00:04:16.860 --> 00:04:18.709
So if you have a
layout like this,

00:04:18.709 --> 00:04:20.790
if you put these
layout tags around it,

00:04:20.790 --> 00:04:22.800
you'll get a Binding class.

00:04:22.800 --> 00:04:25.610
If you add variables as
inputs to that layout,

00:04:25.610 --> 00:04:28.740
they become setters and
getters in this Binding class.

00:04:28.740 --> 00:04:31.740
And then you can use these
variables in your layout

00:04:31.740 --> 00:04:33.720
and declare what
you want to show.

00:04:33.720 --> 00:04:37.470
And Data Binding takes
care of showing it.

00:04:37.470 --> 00:04:40.950
This last one year, we've been
heavily focused on the tooling

00:04:40.950 --> 00:04:42.840
part of Data Binding.

00:04:42.840 --> 00:04:45.570
So we have significantly
improved the compilation speed.

00:04:45.570 --> 00:04:49.980
It's now 20% faster while we
run the annotation processor.

00:04:49.980 --> 00:04:52.560
We added support for
distributed grade of cache,

00:04:52.560 --> 00:04:54.930
so that if you're
using in your company,

00:04:54.930 --> 00:04:59.070
you benefit from your peers
compiling the projects.

00:04:59.070 --> 00:05:01.800
Last but not least,
in 3.5, now we

00:05:01.800 --> 00:05:05.550
have an incremental annotation
processor for Data Binding.

00:05:05.550 --> 00:05:09.210
It's experimental, so you need
to turn it on with this flag.

00:05:09.210 --> 00:05:13.840
So please give it a try, and
let us know how it works.

00:05:13.840 --> 00:05:16.350
So other part of Data
Binding is tooling

00:05:16.350 --> 00:05:19.560
integration, which is Studio.

00:05:19.560 --> 00:05:21.252
So we did a lot of work here.

00:05:21.252 --> 00:05:22.710
So one of the things
we've improved

00:05:22.710 --> 00:05:25.200
is how the live class
generation works.

00:05:25.200 --> 00:05:28.380
So on the left here, I have
this Binding class associated

00:05:28.380 --> 00:05:30.580
with the layout on the right.

00:05:30.580 --> 00:05:32.780
And if I want to
access the stacks view,

00:05:32.780 --> 00:05:35.460
I can just go ahead
and give it an ID.

00:05:35.460 --> 00:05:37.380
So when my view has
an ID, it becomes

00:05:37.380 --> 00:05:39.400
a field in the Binding class.

00:05:39.400 --> 00:05:42.780
And here, immediately,
without compiling the project,

00:05:42.780 --> 00:05:45.470
I have that field in
that Binding object.

00:05:45.470 --> 00:05:46.590
So we don't need to wait.

00:05:46.590 --> 00:05:50.946
[APPLAUSE]

00:05:52.890 --> 00:05:54.810
So if you're using
Data Binding, this

00:05:54.810 --> 00:05:56.850
is not how we update
the views, right?

00:05:56.850 --> 00:05:59.250
You can also do it
with a variable.

00:05:59.250 --> 00:06:01.800
That's actually how you
will do it in Data Binding.

00:06:01.800 --> 00:06:03.420
So we go ahead, change it.

00:06:03.420 --> 00:06:06.210
We add this header as a
variable to the layout.

00:06:06.210 --> 00:06:08.430
As you can see,
autocomplete works.

00:06:08.430 --> 00:06:11.280
We get rid of the ID,
because we don't need it.

00:06:11.280 --> 00:06:14.610
Instead, we are just going
to say text is header.

00:06:14.610 --> 00:06:17.520
As you can see, code
completion works here, too.

00:06:17.520 --> 00:06:20.340
On the left, it
immediately turned red.

00:06:20.340 --> 00:06:22.240
So just go ahead and fix it.

00:06:22.240 --> 00:06:25.850
So all of this works without
waiting for compilation.

00:06:25.850 --> 00:06:29.850
[APPLAUSE]

00:06:31.850 --> 00:06:34.240
So another important
thing is refactoring.

00:06:34.240 --> 00:06:36.760
So I have a user object
here on the left, which

00:06:36.760 --> 00:06:38.680
is a variable on the right.

00:06:38.680 --> 00:06:40.890
And in one of the
expressions, I accessed that

00:06:40.890 --> 00:06:43.365
and call a function
on that user object.

00:06:43.365 --> 00:06:45.457
But if I go to the
class and say I'm

00:06:45.457 --> 00:06:47.290
going to rename this
function, and I'm going

00:06:47.290 --> 00:06:50.800
to call it, say, CombinedName.

00:06:50.800 --> 00:06:54.640
So as soon as I make this
change and it entered,

00:06:54.640 --> 00:06:57.490
Android Studio updates
my binding [INAUDIBLE]

00:06:57.490 --> 00:06:59.670
automatically for me.

00:06:59.670 --> 00:07:02.410
And you can do the
same thing from XML,

00:07:02.410 --> 00:07:05.530
and it will update your code.

00:07:05.530 --> 00:07:08.680
Last but not least, we know
Data Binding error messages

00:07:08.680 --> 00:07:10.120
has been a huge problem.

00:07:10.120 --> 00:07:12.620
That, like, you will have any
problem in your compilation,

00:07:12.620 --> 00:07:14.450
you will get 1,000 errors.

00:07:14.450 --> 00:07:16.190
So we fixed that problem.

00:07:16.190 --> 00:07:19.140
We have also added a
section in your output

00:07:19.140 --> 00:07:21.020
that is specific to
Data Binding errors,

00:07:21.020 --> 00:07:22.610
so you can easily discover them.

00:07:25.150 --> 00:07:27.700
So similar to Data
Binding, like,

00:07:27.700 --> 00:07:29.800
how do we access
views on Androids?

00:07:29.800 --> 00:07:32.638
Let's look at all
the options we have.

00:07:32.638 --> 00:07:34.180
We're going to
evaluate them in terms

00:07:34.180 --> 00:07:36.850
of elegance, the
compile time safety,

00:07:36.850 --> 00:07:39.070
and the build speed impact.

00:07:39.070 --> 00:07:42.880
So first, we have the
good old findViewById.

00:07:42.880 --> 00:07:45.100
It's not elegant,
it's very verbose.

00:07:45.100 --> 00:07:47.170
Doesn't provide any
compile time safety.

00:07:47.170 --> 00:07:49.240
You don't know what
type you're receiving.

00:07:49.240 --> 00:07:52.630
But it doesn't have any build
speed impact, so that's good.

00:07:52.630 --> 00:07:55.840
You could use DataBinding,
which provides a really nice API

00:07:55.840 --> 00:07:57.910
with the compile time safety.

00:07:57.910 --> 00:08:00.040
But it draws an
annotation processor,

00:08:00.040 --> 00:08:02.290
so it does slow down your build.

00:08:02.290 --> 00:08:04.390
You could be using
Butterknife similarly.

00:08:04.390 --> 00:08:06.430
It's another
annotation processor,

00:08:06.430 --> 00:08:08.850
so it's going to
slow down your build.

00:08:08.850 --> 00:08:10.450
Now if you're in
Kotlin, you could

00:08:10.450 --> 00:08:12.610
use Kotlin Synthetic accesses.

00:08:12.610 --> 00:08:14.950
It provides partial
compile time safety,

00:08:14.950 --> 00:08:17.860
is a really beautiful
API, and also it

00:08:17.860 --> 00:08:19.990
doesn't have any
build speed impact.

00:08:19.990 --> 00:08:21.340
But we are looking for this.

00:08:21.340 --> 00:08:23.770
Like something that
has a green checkmark

00:08:23.770 --> 00:08:24.980
in all of these things.

00:08:24.980 --> 00:08:27.490
It should be possible.

00:08:27.490 --> 00:08:30.100
And we don't need to look
far to discover this.

00:08:30.100 --> 00:08:31.600
So if you look at
this Data Binding,

00:08:31.600 --> 00:08:34.960
we see a lot of people using
Data Binding like this.

00:08:34.960 --> 00:08:38.497
They put IDs through the Views,
just to get this binding class

00:08:38.497 --> 00:08:39.039
on the right.

00:08:39.039 --> 00:08:40.970
No variables, no expressions.

00:08:40.970 --> 00:08:45.820
So why don't we just
call this View Binding?

00:08:45.820 --> 00:08:47.800
So View Binding is
a new feature that's

00:08:47.800 --> 00:08:51.220
going to be available
in Android Studio 3.6.

00:08:51.220 --> 00:08:53.184
That's the next version.

00:08:53.184 --> 00:08:58.376
[APPLAUSE]

00:09:00.280 --> 00:09:03.220
So now let's go back to
the previous example.

00:09:03.220 --> 00:09:04.470
We had these Layout texts.

00:09:04.470 --> 00:09:05.470
They're not necessary.

00:09:05.470 --> 00:09:06.470
We don't have variables.

00:09:06.470 --> 00:09:08.010
So we can get rid of it.

00:09:08.010 --> 00:09:11.320
This is just a
regular layout XML.

00:09:11.320 --> 00:09:13.880
So if you're headed
for more activity,

00:09:13.880 --> 00:09:15.210
we will access it like this.

00:09:15.210 --> 00:09:17.670
But you don't want
this findViewById.

00:09:17.670 --> 00:09:19.590
So control F it out.

00:09:19.590 --> 00:09:22.230
And instead, we can use
the generated Binding

00:09:22.230 --> 00:09:26.280
class inflated, and
then setContentView.

00:09:26.280 --> 00:09:28.920
And now we are going to
have all of the Views

00:09:28.920 --> 00:09:33.100
with IDs as public final
fields in that object.

00:09:33.100 --> 00:09:35.010
So you get perfect
compile time safety,

00:09:35.010 --> 00:09:38.370
because if the idea with the
correct type doesn't exist,

00:09:38.370 --> 00:09:41.230
your code will just not compile.

00:09:41.230 --> 00:09:44.550
And you can also
use it from Java.

00:09:44.550 --> 00:09:48.395
[APPLAUSE]

00:09:51.290 --> 00:09:52.110
So thank you.

00:09:52.110 --> 00:09:55.740
All of these Binding classes are
generated by the Android Gradle

00:09:55.740 --> 00:09:56.340
plug-in.

00:09:56.340 --> 00:09:59.580
So it doesn't need to do
any extra work unless you

00:09:59.580 --> 00:10:00.790
change a layout file.

00:10:00.790 --> 00:10:03.430
And if you change a layout
file, only that file gets

00:10:03.430 --> 00:10:04.160
invalidated.

00:10:04.160 --> 00:10:08.300
So it's very fast doing
incremental compilation.

00:10:08.300 --> 00:10:11.430
It's 100% compile time safe,
so if your code compiles,

00:10:11.430 --> 00:10:15.040
you know those views exist
in the right layouts.

00:10:15.040 --> 00:10:17.520
It has full Studio integration,
similar to what I have

00:10:17.520 --> 00:10:19.740
shown for Data Binding earlier.

00:10:19.740 --> 00:10:22.830
And speaking of Data
Binding, it is completely

00:10:22.830 --> 00:10:24.600
compatible with Data Binding.

00:10:24.600 --> 00:10:28.680
In fact, if you're using Data
Binding just to access Views,

00:10:28.680 --> 00:10:30.980
you can turn it off and
turn on View Binding.

00:10:30.980 --> 00:10:34.310
And your code will
compile as is.

00:10:34.310 --> 00:10:35.910
OK.

00:10:35.910 --> 00:10:37.470
Now we're going to
move to Lifecycle.

00:10:37.470 --> 00:10:40.650
And I'm going to invite Sergey
to tell us more about it.

00:10:40.650 --> 00:10:41.508
Thank you.

00:10:41.508 --> 00:10:44.854
[APPLAUSE]

00:10:46.766 --> 00:10:48.672
SERGEY VASILINETS: Thanks Yigit.

00:10:48.672 --> 00:10:49.630
Good morning, everyone.

00:10:49.630 --> 00:10:52.560
My name is Sergey, and I
will give a quick update

00:10:52.560 --> 00:10:54.190
on Lifecycles.

00:10:54.190 --> 00:10:57.120
So what we did two
years ago is, first

00:10:57.120 --> 00:11:00.240
of all, introduced a
way to observe events

00:11:00.240 --> 00:11:01.750
from your Fragments
or Activities,

00:11:01.750 --> 00:11:05.690
so you know where it started
or resumed, and so on.

00:11:05.690 --> 00:11:07.500
We introduced
ViewModels, that is,

00:11:07.500 --> 00:11:10.260
retained state across
configuration changes.

00:11:10.260 --> 00:11:14.160
Kind of a starting point
for your non-UI pod.

00:11:14.160 --> 00:11:16.440
And lastly, LiveData
is just observable

00:11:16.440 --> 00:11:20.230
that have a good
default behavior

00:11:20.230 --> 00:11:22.590
to observe with Lifecycle.

00:11:22.590 --> 00:11:24.870
But before proceeding
to new stuff,

00:11:24.870 --> 00:11:27.690
we have to talk about that.

00:11:27.690 --> 00:11:31.040
After I/O, I read on
the internet this.

00:11:31.040 --> 00:11:34.020
And I was like, what's going on?

00:11:34.020 --> 00:11:36.630
I don't agree with that at all.

00:11:36.630 --> 00:11:40.980
And I have to explain now
why this confusion exists,

00:11:40.980 --> 00:11:42.340
and why it's not true.

00:11:42.340 --> 00:11:45.870
So the picture is
kind of like that.

00:11:45.870 --> 00:11:48.630
So it was going to be a full
explanation at the beginning.

00:11:48.630 --> 00:11:50.040
So you have your stuff.

00:11:50.040 --> 00:11:53.460
You put your stuff into
ViewModel or a SavedState.

00:11:53.460 --> 00:11:55.470
Configuration Change happens.

00:11:55.470 --> 00:11:57.980
You go to your
ViewModel or SavedState

00:11:57.980 --> 00:12:00.690
and grab your
stuff out of there.

00:12:00.690 --> 00:12:02.860
Is it the similar mechanisms?

00:12:02.860 --> 00:12:04.740
Well, actually, no.

00:12:04.740 --> 00:12:09.240
So let's take a closer look
only on SavedState part.

00:12:09.240 --> 00:12:10.770
Same set up.

00:12:10.770 --> 00:12:13.230
You put your stuff
into the SavedState.

00:12:13.230 --> 00:12:18.000
When we talked about
Configuration Change, well,

00:12:18.000 --> 00:12:22.500
actual purpose of SavedState
is not Configuration Changes.

00:12:22.500 --> 00:12:26.550
It is created to help
you with process depth.

00:12:26.550 --> 00:12:30.120
Because the system manager's
application in the background

00:12:30.120 --> 00:12:33.660
may decide, well, we need this
memory for some other task,

00:12:33.660 --> 00:12:35.350
and kill your application.

00:12:35.350 --> 00:12:39.370
But because Android wants to
provide nice user experience,

00:12:39.370 --> 00:12:42.390
what we do is, once the
application has restarted,

00:12:42.390 --> 00:12:43.870
we give you hints.

00:12:43.870 --> 00:12:46.350
The SavedState
gives us hints here.

00:12:46.350 --> 00:12:50.340
How to create the state that
you had before, and the user's

00:12:50.340 --> 00:12:51.810
seen before.

00:12:51.810 --> 00:12:54.330
So how does it actually work?

00:12:54.330 --> 00:12:56.130
And then one step deeper.

00:12:56.130 --> 00:12:58.570
So once you put
your SavedState--

00:12:58.570 --> 00:13:01.240
[INAUDIBLE] a SavedState,
what actually happens,

00:13:01.240 --> 00:13:03.840
SavedState travels
to the system server.

00:13:03.840 --> 00:13:05.560
System server is a
separate process.

00:13:05.560 --> 00:13:10.810
So there is, like, this travel
across process boundaries.

00:13:10.810 --> 00:13:14.010
And this gives us very
specific restrictions

00:13:14.010 --> 00:13:15.220
on what is a SavedState.

00:13:15.220 --> 00:13:16.380
It's not the stuff.

00:13:16.380 --> 00:13:17.520
It's the data.

00:13:17.520 --> 00:13:18.870
It's parcelable data.

00:13:18.870 --> 00:13:22.190
It's just what we call
a serializable Android.

00:13:22.190 --> 00:13:24.120
Or primitive types.

00:13:24.120 --> 00:13:27.730
And also we have this data
limit on the size of it,

00:13:27.730 --> 00:13:31.980
because otherwise system
can't keep, like, gigabytes

00:13:31.980 --> 00:13:34.170
of data for every application.

00:13:34.170 --> 00:13:37.930
And serialization actually
takes time as well.

00:13:37.930 --> 00:13:40.150
So it just won't work.

00:13:40.150 --> 00:13:41.680
So this is a SavedState.

00:13:41.680 --> 00:13:44.160
So let's take a look
on our ViewModels.

00:13:44.160 --> 00:13:46.260
Well in a contrast
to SavedState,

00:13:46.260 --> 00:13:49.590
ViewModel always lives
in the process memory.

00:13:49.590 --> 00:13:51.570
Then it never leaves it.

00:13:51.570 --> 00:13:55.280
So Configuration Change doesn't
affect it anyhow at all.

00:13:55.280 --> 00:13:57.330
It just-- memory is continuous.

00:13:57.330 --> 00:13:58.800
Your ViewModel is still there.

00:13:58.800 --> 00:14:03.510
Process doesn't die,
so your stuff is there.

00:14:03.510 --> 00:14:08.970
So however when
processes are restarted--

00:14:08.970 --> 00:14:11.490
well, it's in process memory.

00:14:11.490 --> 00:14:13.050
Process dies.

00:14:13.050 --> 00:14:15.610
Everything there goes away.

00:14:15.610 --> 00:14:17.700
And then the application
is restarted.

00:14:17.700 --> 00:14:20.890
From a ViewModel perspective,
you have nothing.

00:14:20.890 --> 00:14:24.450
So you can see they handle
different situations.

00:14:24.450 --> 00:14:27.900
And ViewModel are for
keeping references

00:14:27.900 --> 00:14:32.580
to your non-serializable
things, like network requests

00:14:32.580 --> 00:14:36.235
in-flight, or database queries.

00:14:36.235 --> 00:14:37.860
Well, it doesn't mean
that you actually

00:14:37.860 --> 00:14:39.640
to write these things there.

00:14:39.640 --> 00:14:42.090
But it kind of provides
the scope for them.

00:14:42.090 --> 00:14:44.760
And other things that
you can keep there

00:14:44.760 --> 00:14:48.340
is big objects like
a long list of data

00:14:48.340 --> 00:14:50.790
you queried from database and
you need to keep somewhere.

00:14:50.790 --> 00:14:54.540
Or images that are relevant only
for that fragment specifically.

00:14:54.540 --> 00:14:59.280
While SavedState is this UI-bits
like selection and scroll

00:14:59.280 --> 00:15:00.060
state.

00:15:00.060 --> 00:15:01.810
And navigation state.

00:15:01.810 --> 00:15:04.080
This is, like, more
interesting for us.

00:15:04.080 --> 00:15:05.040
What does this mean?

00:15:05.040 --> 00:15:09.810
So once you show, let's say,
a screen with user profile,

00:15:09.810 --> 00:15:13.500
you want to know what
user you showed last time.

00:15:13.500 --> 00:15:16.140
So you need to keep user ID
in this navigation state.

00:15:16.140 --> 00:15:19.420
So we'll see this
example in a second.

00:15:19.420 --> 00:15:24.600
So as you see, ViewModel and
SavedState work together.

00:15:24.600 --> 00:15:27.930
They shouldn't be opposed.

00:15:27.930 --> 00:15:32.070
So let's see on
this user example.

00:15:32.070 --> 00:15:34.360
So your ViewModel
will look like this.

00:15:34.360 --> 00:15:35.830
You have a user.

00:15:35.830 --> 00:15:39.630
And then you have a LiveData
of this information.

00:15:39.630 --> 00:15:42.380
How you would do this
ViewModel plus SavedState

00:15:42.380 --> 00:15:43.540
and all the way?

00:15:43.540 --> 00:15:46.570
Well, this is fairly
boilerplate-ish.

00:15:46.570 --> 00:15:49.640
In onCreate, you go to
bundle, parse the information

00:15:49.640 --> 00:15:51.950
from the bundle.

00:15:51.950 --> 00:15:53.360
Plus the ViewModel.

00:15:53.360 --> 00:15:56.030
In SavedState,
you go in reverse.

00:15:56.030 --> 00:15:57.380
Filler, boilerplate.

00:15:57.380 --> 00:16:01.160
And what we did,
we introduced a way

00:16:01.160 --> 00:16:04.350
to contribute the SavedState
from ViewModel right away.

00:16:04.350 --> 00:16:08.150
So now you can receive this
SavedStateHandle object right

00:16:08.150 --> 00:16:10.970
in your ViewModel constructor.

00:16:10.970 --> 00:16:14.570
And this object will allow
you to access SavedState right

00:16:14.570 --> 00:16:15.900
into your ViewModel.

00:16:15.900 --> 00:16:17.870
So what is this?

00:16:17.870 --> 00:16:18.710
It's very simple.

00:16:18.710 --> 00:16:20.780
It's map-like object,
meaning that it

00:16:20.780 --> 00:16:23.150
has very straightforward API.

00:16:23.150 --> 00:16:28.320
You just put stuff, and
get it once you put it--

00:16:28.320 --> 00:16:30.560
later when your
application is recreated,

00:16:30.560 --> 00:16:32.480
ViewModel is created.

00:16:32.480 --> 00:16:34.550
It receives the
SavedState handle.

00:16:34.550 --> 00:16:37.550
The information that
you put by the key

00:16:37.550 --> 00:16:39.530
will be available
to you again, so you

00:16:39.530 --> 00:16:42.410
can query by the same key.

00:16:42.410 --> 00:16:45.920
We also give you
nice convenience API.

00:16:45.920 --> 00:16:47.810
If you use LiveData, you can--

00:16:47.810 --> 00:16:52.280
instead of just .getData you
can observe it in a usual way.

00:16:52.280 --> 00:16:57.352
And because SavedState is
mutable, because otherwise

00:16:57.352 --> 00:16:58.310
it would be a constant.

00:16:58.310 --> 00:17:00.240
No need to save it.

00:17:00.240 --> 00:17:02.710
We can give you a
mutable LiveData

00:17:02.710 --> 00:17:06.200
and you can write as
you would do usually.

00:17:06.200 --> 00:17:09.740
So last slide on this theme
is provided by my manager,

00:17:09.740 --> 00:17:11.089
actually.

00:17:11.089 --> 00:17:14.369
SavedState is not your database.

00:17:14.369 --> 00:17:18.490
No matter which API you
use, old uncreate and unsave

00:17:18.490 --> 00:17:19.640
in SavedState.

00:17:19.640 --> 00:17:22.010
Or this new convenience API.

00:17:22.010 --> 00:17:24.410
Or fragment arguments.

00:17:24.410 --> 00:17:27.240
Underlying mechanisms
are the same.

00:17:27.240 --> 00:17:29.900
So you still have
this restrictions

00:17:29.900 --> 00:17:33.650
about what you can put
there on the size limit.

00:17:33.650 --> 00:17:36.110
So it won't just work.

00:17:36.110 --> 00:17:39.440
And we go to the other thing.

00:17:39.440 --> 00:17:45.140
So continues everywhere,
Lifecycle aren't exceptions.

00:17:45.140 --> 00:17:48.170
Yesterday, we had a talk
about Coroutines in Lifecycle.

00:17:48.170 --> 00:17:52.490
If you missed it, you can
find it on the internet.

00:17:52.490 --> 00:17:57.920
We introduced a bunch of new
APIs, looking for feedback.

00:17:57.920 --> 00:18:05.220
And we kind of paid our debts
in other fields of Lifecycles.

00:18:05.220 --> 00:18:07.730
For example, some
conversions were broken

00:18:07.730 --> 00:18:11.040
for a long time for LiveData.

00:18:11.040 --> 00:18:15.320
So you can see it doesn't
look like natural Kotlin code.

00:18:15.320 --> 00:18:16.670
And now it does.

00:18:16.670 --> 00:18:21.320
You can have this land
after observe all.

00:18:21.320 --> 00:18:24.720
Similar transformations
looked very unnatural,

00:18:24.720 --> 00:18:27.410
because we had this static
method on transformations.

00:18:27.410 --> 00:18:31.520
And you know, it's just not
the way you do that in Kotlin.

00:18:31.520 --> 00:18:34.280
Instead of that, you
have extension functions.

00:18:34.280 --> 00:18:35.930
We did that.

00:18:35.930 --> 00:18:38.640
And last thing is the
ViewModels initialization.

00:18:38.640 --> 00:18:42.590
We kind of forced it to
have this lateinit var.

00:18:42.590 --> 00:18:44.818
And it's a bit of a [INAUDIBLE].

00:18:44.818 --> 00:18:46.610
People are getting
worried when you see it.

00:18:46.610 --> 00:18:48.530
It's for a reason.

00:18:48.530 --> 00:18:49.820
Or now the ViewModels.

00:18:49.820 --> 00:18:54.110
Models So now it's
with [INAUDIBLE],,

00:18:54.110 --> 00:18:56.120
you have very concise index.

00:18:56.120 --> 00:19:01.397
You just initialize your
ViewModel, and that is it.

00:19:01.397 --> 00:19:05.133
[APPLAUSE]

00:19:06.540 --> 00:19:08.640
And actually that is
it for Lifecycles.

00:19:08.640 --> 00:19:14.330
And I hand out for Sumir, who
is going to present WorkManager

00:19:14.330 --> 00:19:15.120
and a [INAUDIBLE].

00:19:15.120 --> 00:19:20.246
[APPLAUSE]

00:19:20.683 --> 00:19:21.850
SUMIR KATARIA: Hi, everyone.

00:19:21.850 --> 00:19:24.300
My name is Sumir Kataria,
and I am an engineer

00:19:24.300 --> 00:19:25.590
on the Android team.

00:19:25.590 --> 00:19:28.470
I want to talk to you a little
bit about WorkManager today.

00:19:28.470 --> 00:19:30.630
For those of you who
don't know, WorkManager

00:19:30.630 --> 00:19:33.840
is a background processing
library for work

00:19:33.840 --> 00:19:36.750
that is specifically deferrable,
meaning that it doesn't

00:19:36.750 --> 00:19:39.420
have to be executed right away.

00:19:39.420 --> 00:19:41.100
This is also work
that's persistent.

00:19:41.100 --> 00:19:43.840
So it can go across
app restarts.

00:19:43.840 --> 00:19:46.260
It can go across
device restarts.

00:19:46.260 --> 00:19:48.768
So it needs to be persistent.

00:19:48.768 --> 00:19:50.310
This is work that's
constraint-based,

00:19:50.310 --> 00:19:53.060
so you can have work
that only triggers

00:19:53.060 --> 00:19:55.060
when you have a network
connection, for example.

00:19:55.060 --> 00:19:57.120
Or other constraints.

00:19:57.120 --> 00:19:59.640
And finally, this is work
that's backwards compatible.

00:19:59.640 --> 00:20:02.760
So it goes all the way back
to Ice Cream Sandwich, API 14.

00:20:05.370 --> 00:20:07.230
Before I go to,
actually, top priorities,

00:20:07.230 --> 00:20:11.372
we released a stable
version of WorkManager 1.0

00:20:11.372 --> 00:20:12.330
a couple of months ago.

00:20:12.330 --> 00:20:15.060
So I want to thank everybody
who participated in the alpha,

00:20:15.060 --> 00:20:16.800
beta, Early Access Program.

00:20:16.800 --> 00:20:18.182
Thank you very much.

00:20:18.182 --> 00:20:20.640
So our top priorities moving
forward, there's three of them

00:20:20.640 --> 00:20:22.180
that I'm going to
talk about today.

00:20:22.180 --> 00:20:24.870
One is performance
and compatibility.

00:20:24.870 --> 00:20:26.320
The next is testing.

00:20:26.320 --> 00:20:28.260
And finally, building
for the future.

00:20:28.260 --> 00:20:30.970
So things that are
more forward-looking.

00:20:30.970 --> 00:20:33.842
So let's talk about
performance and compatibility.

00:20:33.842 --> 00:20:35.550
The first thing that
I want to talk about

00:20:35.550 --> 00:20:37.710
is on-demand initialization.

00:20:37.710 --> 00:20:40.840
It's available now in alpha,
so please check it out.

00:20:40.840 --> 00:20:43.980
So one of the things that
you might have noticed

00:20:43.980 --> 00:20:45.480
with WorkManager
is that it needs

00:20:45.480 --> 00:20:47.700
to be initialized when
your app starts up.

00:20:47.700 --> 00:20:50.850
This is, more or less, a
hard requirement currently.

00:20:50.850 --> 00:20:53.370
And this on-demand
initialization

00:20:53.370 --> 00:20:55.200
will allow you to
start WorkManager only

00:20:55.200 --> 00:20:56.940
when you need it,
which is really

00:20:56.940 --> 00:21:00.662
good for avoiding critical
hot paths like app startup.

00:21:00.662 --> 00:21:03.120
This is not something that you
need to worry about anymore.

00:21:03.120 --> 00:21:06.610
You can just use it when
you actually need it.

00:21:06.610 --> 00:21:08.110
Let's take a look
at how this looks.

00:21:08.110 --> 00:21:10.277
So right now, you might
have your Application class.

00:21:10.277 --> 00:21:12.960
So you might have customized
it so you have a MyApp.

00:21:12.960 --> 00:21:17.880
And in WorkManager 2.1
alpha, you can extend--

00:21:17.880 --> 00:21:21.660
or actually implement--
Configuration.Provider,

00:21:21.660 --> 00:21:23.570
override this method,
and this returns

00:21:23.570 --> 00:21:25.540
a WorkManager configuration.

00:21:25.540 --> 00:21:28.050
So this is all
WorkManager needs to know

00:21:28.050 --> 00:21:30.300
on where to get this data.

00:21:30.300 --> 00:21:33.630
Now, currently in
WorkManager 2.0,

00:21:33.630 --> 00:21:36.660
you get
WorkManager.getInstance, and you

00:21:36.660 --> 00:21:38.510
don't provide any arguments.

00:21:38.510 --> 00:21:41.250
And starting in 2.1, if you
provide this context argument,

00:21:41.250 --> 00:21:44.940
this is WorkManager's signal,
OK, if I'm not initialized,

00:21:44.940 --> 00:21:48.180
I can go to the application
object, get the configuration,

00:21:48.180 --> 00:21:50.477
and do a lazy initialization
when I'm needed.

00:21:50.477 --> 00:21:51.310
So that's all it is.

00:21:51.310 --> 00:21:53.030
It's very simple.

00:21:53.030 --> 00:21:54.780
The second thing I
want to talk about here

00:21:54.780 --> 00:21:56.680
is Google Play
Services integration.

00:21:56.680 --> 00:21:58.630
And this is coming soon.

00:21:58.630 --> 00:22:01.200
So this basically will allow
you to have better performance

00:22:01.200 --> 00:22:03.540
on pre-Marshmallow devices.

00:22:03.540 --> 00:22:04.630
And it's totally optional.

00:22:04.630 --> 00:22:06.280
You don't really
need to integrate it

00:22:06.280 --> 00:22:06.930
if you don't want it.

00:22:06.930 --> 00:22:08.070
And if you do want
to integrate it,

00:22:08.070 --> 00:22:10.470
it's just a simple Gradle
dependency that you add.

00:22:10.470 --> 00:22:13.470
Nothing else, because
there's no API changes.

00:22:13.470 --> 00:22:16.260
Under the hood, it'll see
if you have Play Services.

00:22:16.260 --> 00:22:21.780
If you're using it, it'll use
it on pre-Marshmallow devices.

00:22:21.780 --> 00:22:23.170
And compatibility improvements.

00:22:23.170 --> 00:22:25.228
This is an ongoing
project for us.

00:22:25.228 --> 00:22:27.270
And this is not something
that you'll necessarily

00:22:27.270 --> 00:22:30.147
see in our code base
or in our releases,

00:22:30.147 --> 00:22:31.980
but it's stuff that we
do behind the scenes.

00:22:31.980 --> 00:22:34.270
And I want to talk a
little bit about it.

00:22:34.270 --> 00:22:37.620
So we've noticed that there are
a few differences in devices

00:22:37.620 --> 00:22:38.680
and manufacturers.

00:22:38.680 --> 00:22:43.590
For example, if you go to the
Recents of your device, and you

00:22:43.590 --> 00:22:44.820
swipe away an app.

00:22:44.820 --> 00:22:47.228
On a stock Android device
or on a Pixel device,

00:22:47.228 --> 00:22:49.020
you'll notice that the
process gets killed.

00:22:49.020 --> 00:22:51.210
But on some devices, you
might see that the app

00:22:51.210 --> 00:22:52.260
gets force-stopped.

00:22:52.260 --> 00:22:54.870
And force stop is a
really destructive action.

00:22:54.870 --> 00:22:59.110
In the case of force stop, your
jobs get stopped and wiped out,

00:22:59.110 --> 00:22:59.610
actually.

00:22:59.610 --> 00:23:00.750
Your alarms got wiped out.

00:23:00.750 --> 00:23:02.760
You no longer receive FCMs.

00:23:02.760 --> 00:23:05.365
Force stop is a very
destructive action.

00:23:05.365 --> 00:23:07.740
So we're working with OEMs to
have a consistent app close

00:23:07.740 --> 00:23:08.400
behavior here.

00:23:08.400 --> 00:23:11.010
We want to make sure that
everybody has the same app

00:23:11.010 --> 00:23:13.410
close behavior, which is
really good for libraries

00:23:13.410 --> 00:23:18.060
like WorkManager, which
operate in the background.

00:23:18.060 --> 00:23:20.940
The next thing I want to
talk about is testing.

00:23:20.940 --> 00:23:23.650
When we launched WorkManager
a couple of months ago,

00:23:23.650 --> 00:23:27.420
we kind of had a problem
with roboelectric support,

00:23:27.420 --> 00:23:28.990
in that it didn't work.

00:23:28.990 --> 00:23:29.550
We fixed it.

00:23:29.550 --> 00:23:33.270
It's out and stable,
sorry about that.

00:23:33.270 --> 00:23:37.573
And also, now we have an alpha
unit testing for workers.

00:23:37.573 --> 00:23:39.240
So basically you can
create your workers

00:23:39.240 --> 00:23:41.310
using one of these two
classes, TestWorkerBuilder

00:23:41.310 --> 00:23:43.740
or TestListenableWorkerBuilder.

00:23:43.740 --> 00:23:46.620
And you can just use them by
using the doWork or startWork

00:23:46.620 --> 00:23:48.245
method as is appropriate.

00:23:48.245 --> 00:23:49.870
So let's take a look
at that in action.

00:23:49.870 --> 00:23:52.410
So let's say you
have a WorkRequest.

00:23:52.410 --> 00:23:55.290
You can use a TestWorkerBuilder,
and you can say,

00:23:55.290 --> 00:23:59.010
create that WorkRequest from
a given context and a given

00:23:59.010 --> 00:24:01.290
executor on which it will run.

00:24:01.290 --> 00:24:02.800
You just build it.

00:24:02.800 --> 00:24:04.590
So this gives you a
worker class back.

00:24:04.590 --> 00:24:06.507
And then you can call
the doWork method, which

00:24:06.507 --> 00:24:09.060
is a method you've
already overwritten,

00:24:09.060 --> 00:24:11.190
and get its result. You
can assert a result.

00:24:11.190 --> 00:24:12.690
You can check the
state of your app,

00:24:12.690 --> 00:24:13.857
make sure everything's fine.

00:24:13.857 --> 00:24:16.780
So that's how you would
unit test a worker.

00:24:16.780 --> 00:24:18.780
If you're using a listenable
worker, same thing.

00:24:18.780 --> 00:24:21.620
You start with a WorkRequest.

00:24:21.620 --> 00:24:24.140
And you use a
TestListenableWorkerBuilder,

00:24:24.140 --> 00:24:28.870
and you can say, create a
worker using that request.

00:24:28.870 --> 00:24:30.605
You build it.

00:24:30.605 --> 00:24:31.230
And same thing.

00:24:31.230 --> 00:24:33.860
Instead of calling doWork in
this case, you call startWork.

00:24:33.860 --> 00:24:38.120
Remember that listenable
workers are asynchronous

00:24:38.120 --> 00:24:40.400
and control their own execution.

00:24:40.400 --> 00:24:43.040
So you don't need to
specify an executor here.

00:24:43.040 --> 00:24:45.410
And startWork returns
a listenable future,

00:24:45.410 --> 00:24:48.035
so you just call a blocking
get-on in this case.

00:24:48.035 --> 00:24:52.100
And you assert that everything
is the way you want it to be.

00:24:52.100 --> 00:24:54.170
You can even provide
more arguments.

00:24:54.170 --> 00:24:56.940
So you can say something like,
here's the input data for it.

00:24:56.940 --> 00:24:59.720
Here's the runAttemptCount
that you're currently on.

00:24:59.720 --> 00:25:03.255
Here's the tags that you
have for this worker.

00:25:03.255 --> 00:25:04.880
And the last thing
I want to talk about

00:25:04.880 --> 00:25:07.230
is building for the future.

00:25:07.230 --> 00:25:09.260
And this is-- in
particular, we want

00:25:09.260 --> 00:25:11.400
to have foreground service
support in WorkManager.

00:25:11.400 --> 00:25:13.005
And this is very
much in progress.

00:25:13.005 --> 00:25:13.880
So this is not ready.

00:25:13.880 --> 00:25:15.920
This is-- later in the
year, you'll probably

00:25:15.920 --> 00:25:17.820
see something about this.

00:25:17.820 --> 00:25:19.730
But the basic idea
is, what if you

00:25:19.730 --> 00:25:23.447
could do work in the foreground
using the WorkManager API?

00:25:23.447 --> 00:25:24.780
And this is particularly useful.

00:25:24.780 --> 00:25:26.480
I was talking to
someone this morning.

00:25:26.480 --> 00:25:28.220
They wanted to do a
long-running upload.

00:25:28.220 --> 00:25:30.800
WorkManager and
JobScheduler both give you

00:25:30.800 --> 00:25:33.920
a 10-minute slice of
time to do an upload

00:25:33.920 --> 00:25:35.480
or whatever work you have.

00:25:35.480 --> 00:25:37.040
But what if it goes
longer than that?

00:25:37.040 --> 00:25:38.750
You can use a program
service for that,

00:25:38.750 --> 00:25:41.520
and WorkManager can
make it easier for you.

00:25:41.520 --> 00:25:43.430
So because this is a
foreground service,

00:25:43.430 --> 00:25:46.017
your app will show
a notification.

00:25:46.017 --> 00:25:48.350
Talk to us about it in the
sandbox if you're interested.

00:25:48.350 --> 00:25:50.270
We want to hear
what everybody has

00:25:50.270 --> 00:25:55.290
to contribute to this, what use
cases you have, and so forth.

00:25:55.290 --> 00:25:58.790
And now I'd like to turn
it over to Danny, for Room.

00:25:58.790 --> 00:26:02.150
[APPLAUSE]

00:26:03.110 --> 00:26:04.760
DANIEL SANTIAGO:
Thank you, Samir.

00:26:04.760 --> 00:26:06.770
Hey, my name is Daniel
Santiago, and I'll

00:26:06.770 --> 00:26:08.910
be talking a little
bit about Room.

00:26:08.910 --> 00:26:13.250
But before we get to what's
new at Room, what is Room?

00:26:13.250 --> 00:26:17.150
Well, Room is our SQLite
object mapping library.

00:26:17.150 --> 00:26:19.850
And it basically creates
a bunch of code for you,

00:26:19.850 --> 00:26:23.180
based on some annotation,
so that you can easily

00:26:23.180 --> 00:26:28.100
access your data objects
with a SQLite database.

00:26:28.100 --> 00:26:31.310
Let's do a quick recap
on how this looks.

00:26:31.310 --> 00:26:33.570
Imagine we're making
a music application.

00:26:33.570 --> 00:26:36.560
We're going to be saving
some songs on a database.

00:26:36.560 --> 00:26:38.180
We start by having a data class.

00:26:38.180 --> 00:26:39.400
We call it Song.

00:26:39.400 --> 00:26:41.810
It has some ID, a URL.

00:26:41.810 --> 00:26:43.630
For Room, to let
know that you want

00:26:43.630 --> 00:26:46.430
to have a table for this
Entity, you annotate it

00:26:46.430 --> 00:26:49.010
with the Entity annotation.

00:26:49.010 --> 00:26:52.140
You let it know of
its unique identifier.

00:26:52.140 --> 00:26:55.580
Now in a database, if you want
to get the data out of it,

00:26:55.580 --> 00:26:57.890
you write a normal SQL query.

00:26:57.890 --> 00:26:59.720
SELECT star FROM Song.

00:26:59.720 --> 00:27:01.520
But to let Room
know that you want

00:27:01.520 --> 00:27:03.230
to link this query
with that data class,

00:27:03.230 --> 00:27:04.730
you actually put it on a method.

00:27:04.730 --> 00:27:06.600
That returns a list
of songs, and it's

00:27:06.600 --> 00:27:08.162
annotated with a Query.

00:27:08.162 --> 00:27:10.370
Now you don't throw these
methods all over the place.

00:27:10.370 --> 00:27:14.030
You actually put them on what
we call a data access subject.

00:27:14.030 --> 00:27:16.700
And if this is just an
interface or an abstract class,

00:27:16.700 --> 00:27:18.630
annotate it with @Dao.

00:27:18.630 --> 00:27:21.680
Now to link these together,
you have your MusicDatabase,

00:27:21.680 --> 00:27:23.780
it extends RoomDatabase.

00:27:23.780 --> 00:27:25.880
It has a @Database annotation.

00:27:25.880 --> 00:27:28.700
And then you let it know of its
entities, which in this case

00:27:28.700 --> 00:27:29.840
will be the song.

00:27:29.840 --> 00:27:33.470
And the Daos are
just getter method.

00:27:33.470 --> 00:27:35.820
In a nutshell, it kind
of looks like this.

00:27:35.820 --> 00:27:38.060
You have your database, your
Daos, and your entities.

00:27:38.060 --> 00:27:42.110
And your application interacts
with all of these things.

00:27:42.110 --> 00:27:43.640
Now let's get to the good stuff.

00:27:43.640 --> 00:27:50.420
So something new that's in
Room 2.1 is Coroutine support.

00:27:50.420 --> 00:27:56.090
In Room 2.0, if you tried to add
a suspend method to your Dao,

00:27:56.090 --> 00:27:58.640
because you have a Kotlin
app, you're using Coroutines,

00:27:58.640 --> 00:28:01.550
and you probably want to do
your heavy work asynchronously,

00:28:01.550 --> 00:28:04.040
you usually add
your suspend method.

00:28:04.040 --> 00:28:05.660
Room would freak out.

00:28:05.660 --> 00:28:07.340
He wouldn't know what to do.

00:28:07.340 --> 00:28:10.380
He would, nope, can't do that.

00:28:10.380 --> 00:28:14.000
And this might lead you to
create wrapper methods, that

00:28:14.000 --> 00:28:16.520
are suspend functions
that actually then call

00:28:16.520 --> 00:28:18.060
the actual Dao function.

00:28:18.060 --> 00:28:21.330
But you can imagine this
doesn't scale very well.

00:28:21.330 --> 00:28:22.220
But no worries.

00:28:22.220 --> 00:28:25.215
In Room 2.1, you can
actually have Dao methods

00:28:25.215 --> 00:28:27.200
that are suspending methods.

00:28:27.200 --> 00:28:30.110
Room will generate the
correct code, including

00:28:30.110 --> 00:28:33.260
using a background dispatcher.

00:28:33.260 --> 00:28:35.960
You can also have suspend
methods with insert,

00:28:35.960 --> 00:28:37.190
object, and delete.

00:28:37.190 --> 00:28:42.350
And even more so, you can have
suspend implemented methods

00:28:42.350 --> 00:28:45.830
that do multiple database
operations, that are annotated

00:28:45.830 --> 00:28:49.280
with @Transactions, so that
these database operations are

00:28:49.280 --> 00:28:51.830
done automatically.

00:28:51.830 --> 00:28:54.080
Even more so, there's
also an extension function

00:28:54.080 --> 00:28:57.910
on Room database that will allow
you to start a transaction.

00:28:57.910 --> 00:28:59.930
It creates a special
Coroutine context

00:28:59.930 --> 00:29:05.540
that you can use to also perform
multiple database operations.

00:29:05.540 --> 00:29:09.450
Now another new feature we added
in Room is Full Text Search.

00:29:09.450 --> 00:29:13.100
Full Text Search is
an extension in SQLite

00:29:13.100 --> 00:29:18.600
to be able to create tables to
efficiently search for data.

00:29:18.600 --> 00:29:20.630
Thinking back on our
music app, imagine

00:29:20.630 --> 00:29:22.640
we're trying to create
a search functionality.

00:29:22.640 --> 00:29:25.570
We want to search for
songs, given a phrase.

00:29:25.570 --> 00:29:27.800
If we were to do
this in Room 2.0,

00:29:27.800 --> 00:29:30.140
we would have to
write a Dao method.

00:29:30.140 --> 00:29:31.490
Kind of like this.

00:29:31.490 --> 00:29:34.670
Doesn't look great, you
have this huge WHERE clause.

00:29:34.670 --> 00:29:36.670
It has all the columns, like.

00:29:36.670 --> 00:29:38.110
It's not great.

00:29:38.110 --> 00:29:39.020
But no worries.

00:29:39.020 --> 00:29:43.310
In Room 2.1, if
you want an Entity

00:29:43.310 --> 00:29:45.410
to be able to be
backed by an Fts table,

00:29:45.410 --> 00:29:48.290
you simply use the
Fts annotation.

00:29:48.290 --> 00:29:50.900
And now this greatly
simplifies your query,

00:29:50.900 --> 00:29:54.470
because you can start using
the MATCH expression, which

00:29:54.470 --> 00:29:58.410
is way more efficient.

00:29:58.410 --> 00:29:59.060
Speaking of--

00:29:59.060 --> 00:30:01.540
[APPLAUSE]

00:30:01.540 --> 00:30:02.780
Yeah.

00:30:02.780 --> 00:30:03.790
Thanks.

00:30:03.790 --> 00:30:06.520
Speaking of simplifying
things, Database Views

00:30:06.520 --> 00:30:09.790
is another way to simplify
your database operation.

00:30:09.790 --> 00:30:12.730
So Database Views are
kind of like tables,

00:30:12.730 --> 00:30:15.190
where everywhere you
reference a table,

00:30:15.190 --> 00:30:16.390
you can reference a view.

00:30:16.390 --> 00:30:18.980
But they're different because
you cannot insert data

00:30:18.980 --> 00:30:20.380
into views.

00:30:20.380 --> 00:30:22.640
To put it differently,
they're kind of like queries

00:30:22.640 --> 00:30:25.330
with a given name.

00:30:25.330 --> 00:30:28.660
Let's think, again, back
to our music application.

00:30:28.660 --> 00:30:31.210
This time, we want to
show a list of albums.

00:30:31.210 --> 00:30:34.540
And these albums have some
aggregated information.

00:30:34.540 --> 00:30:39.340
The total number of songs, and
the total time in the album.

00:30:39.340 --> 00:30:41.830
And thinking back, how
we started using Room,

00:30:41.830 --> 00:30:46.340
we have a simple data class with
the information that we need.

00:30:46.340 --> 00:30:54.180
Now, in Room 2.1, instead
of having a BigQuery,

00:30:54.180 --> 00:30:57.310
you can actually annotate your
data class with @DatabaseView.

00:30:57.310 --> 00:31:00.410
And instead of making a table,
you'll create a view out of it.

00:31:00.410 --> 00:31:03.190
And then to specify how
we get this information,

00:31:03.190 --> 00:31:06.490
you put your BigQuery
in the annotation.

00:31:06.490 --> 00:31:08.610
And you can see,
it's a BigQuery.

00:31:08.610 --> 00:31:10.090
It has segregating information.

00:31:10.090 --> 00:31:11.830
But the important
thing is that now you

00:31:11.830 --> 00:31:18.130
can use this view or entity
as if it was another table.

00:31:18.130 --> 00:31:19.660
And you can see
here, we also have

00:31:19.660 --> 00:31:21.700
another ORDER BY,
which you know,

00:31:21.700 --> 00:31:23.602
makes your operations easier.

00:31:23.602 --> 00:31:29.014
[APPLAUSE]

00:31:30.000 --> 00:31:31.420
Nice.

00:31:31.420 --> 00:31:34.270
We've been also adding more
support for Rx in Room,

00:31:34.270 --> 00:31:38.610
since we know people like Rx.

00:31:38.610 --> 00:31:41.680
In Room 2.1, you can
have insert, update,

00:31:41.680 --> 00:31:46.590
and delete method that return
Completable, Maybe, and Single.

00:31:46.590 --> 00:31:49.560
And even more newer,
we also added support

00:31:49.560 --> 00:31:54.030
for returning Rx tag
on Query-annotated Dao

00:31:54.030 --> 00:31:56.990
methods that perform
write statements,

00:31:56.990 --> 00:31:59.490
such as update,
insert, and delete.

00:31:59.490 --> 00:32:02.310
So for those queries that
are more complicated,

00:32:02.310 --> 00:32:06.510
but you still want to
use Rx, you can do that.

00:32:06.510 --> 00:32:08.730
Now, that's some of
the new things in Room.

00:32:08.730 --> 00:32:10.863
But we still have a
lot more work to do.

00:32:10.863 --> 00:32:12.780
One of the most immediate
things we want to do

00:32:12.780 --> 00:32:16.020
is have an incremental
annotation processor.

00:32:16.020 --> 00:32:18.780
This will greatly improve
the build performance

00:32:18.780 --> 00:32:22.080
for those of you using Room,
or for those of you who

00:32:22.080 --> 00:32:25.230
might start to use Room.

00:32:25.230 --> 00:32:28.710
We also know that relationship
is another area of improvement.

00:32:28.710 --> 00:32:32.340
We only have a single
annotation for @Relation.

00:32:32.340 --> 00:32:35.440
And it helps you
with one to many,

00:32:35.440 --> 00:32:37.230
but we feel like we
can do many to many.

00:32:37.230 --> 00:32:38.810
Even maybe using a jump table.

00:32:38.810 --> 00:32:42.300
So that's one area we
are trying to explore.

00:32:42.300 --> 00:32:45.390
We also know that
migrations are not so great.

00:32:45.390 --> 00:32:47.770
Like, when you use Room, it
creates the tables for you.

00:32:47.770 --> 00:32:49.228
But then when you
migrate, you also

00:32:49.228 --> 00:32:51.780
have to call the
CREATE statement.

00:32:51.780 --> 00:32:54.420
We feel like most of
the migration operations

00:32:54.420 --> 00:32:57.960
can be done with
some code generation,

00:32:57.960 --> 00:33:01.530
such as adding a new table
or renaming a column.

00:33:01.530 --> 00:33:02.880
Things like that.

00:33:02.880 --> 00:33:07.350
Last but not least, as we take
a look at Kotlin and Coroutines,

00:33:07.350 --> 00:33:09.810
we are keeping our
eye on their APIs.

00:33:09.810 --> 00:33:14.630
And we'll be able to add
support for Channels and Flow.

00:33:14.630 --> 00:33:15.270
Thanks.

00:33:15.270 --> 00:33:20.149
So back to Yigit, who will be
talking to you about Paging.

00:33:20.149 --> 00:33:24.640
[APPLAUSE]

00:33:25.640 --> 00:33:26.960
YIGIT BOYAR: Thanks, Danny.

00:33:26.960 --> 00:33:29.470
OK, let's talk about Paging.

00:33:29.470 --> 00:33:31.360
So if you don't
know Paging, Paging

00:33:31.360 --> 00:33:37.180
is our library to load large
lists into RecyclerView lazily.

00:33:37.180 --> 00:33:39.100
And it works with
multiple data source.

00:33:39.100 --> 00:33:41.460
It works with Room,
Realm, Retrofit,

00:33:41.460 --> 00:33:45.530
whatever kind of place where
you can pull the data from.

00:33:45.530 --> 00:33:48.440
For the next version
of Paging, our focus

00:33:48.440 --> 00:33:51.400
is on networking
and error handling.

00:33:51.400 --> 00:33:53.140
So we heard this loud
and clear, that it

00:33:53.140 --> 00:33:57.820
is kind of hard to channel
your errors from your network

00:33:57.820 --> 00:33:59.300
back into your UI.

00:33:59.300 --> 00:34:03.020
So we are working on a new
pipeline to enable this,

00:34:03.020 --> 00:34:05.980
We'll also add support to change
those pages as you pull them,

00:34:05.980 --> 00:34:10.219
so you can inject headers
and footers or filter them.

00:34:10.219 --> 00:34:12.130
Last but not least, we
are going to improve

00:34:12.130 --> 00:34:16.270
the support for RxJava and
add support for Coroutines.

00:34:16.270 --> 00:34:19.250
So these are all in the
next version of Paging.

00:34:19.250 --> 00:34:22.570
We are about to start an
Early Access Program for it.

00:34:22.570 --> 00:34:24.250
So we are doing an
Early Access Program

00:34:24.250 --> 00:34:26.699
because we significantly
changed the API, so we

00:34:26.699 --> 00:34:28.420
want to get good feedback.

00:34:28.420 --> 00:34:32.980
And later in the summer, you
should expect an alpha version.

00:34:32.980 --> 00:34:35.230
All right, Navigation.

00:34:35.230 --> 00:34:39.280
Navigation is a library we
released in a previous I/O.

00:34:39.280 --> 00:34:42.280
It helps you with
your in app UI flows.

00:34:42.280 --> 00:34:46.000
So you can easily show a graph,
control how the user should

00:34:46.000 --> 00:34:48.179
navigate, et cetera.

00:34:48.179 --> 00:34:52.060
So a couple months ago,
Navigation became stable.

00:34:52.060 --> 00:34:55.690
And we already started working
on the next version, which

00:34:55.690 --> 00:34:56.969
is already out.

00:34:56.969 --> 00:34:59.770
And in this next version,
we have a new feature

00:34:59.770 --> 00:35:02.380
for ViewModels where
you can scope them

00:35:02.380 --> 00:35:03.970
to a Navigation Graph.

00:35:03.970 --> 00:35:04.720
This is amazing.

00:35:04.720 --> 00:35:06.420
Where you have things
like sign-up flows

00:35:06.420 --> 00:35:08.560
that's composed of
multiple screens,

00:35:08.560 --> 00:35:13.698
you can just have one
ViewModel for that whole scope.

00:35:13.698 --> 00:35:18.857
[APPLAUSE]

00:35:19.800 --> 00:35:22.380
And other features, you
can now navigate by URI,

00:35:22.380 --> 00:35:26.160
so you don't need
to have the IDs.

00:35:26.160 --> 00:35:31.238
And you can finally use dialogs
as navigation destinations.

00:35:31.238 --> 00:35:34.654
[APPLAUSE]

00:35:35.630 --> 00:35:38.080
So these are all in 2.1.

00:35:38.080 --> 00:35:41.650
But another big upcoming
feature for Navigation

00:35:41.650 --> 00:35:45.200
is support for dynamically
delivered modules.

00:35:45.200 --> 00:35:46.215
Now it's not ready yet.

00:35:46.215 --> 00:35:48.830
This is going to take a
couple of months to implement.

00:35:48.830 --> 00:35:51.130
But it's going to be
available in Navigation

00:35:51.130 --> 00:35:54.070
so that you can just
navigate as if everything

00:35:54.070 --> 00:35:56.170
is inside the application,
without thinking

00:35:56.170 --> 00:35:57.370
about dynamic features.

00:36:00.640 --> 00:36:02.980
So to learn more
about all of these,

00:36:02.980 --> 00:36:06.810
join us later today at 1:30 in
the Jetpack Navigation talk.

00:36:09.950 --> 00:36:15.010
OK, so if you're, like, maybe
new to these things, or trying

00:36:15.010 --> 00:36:16.690
to get started
with Kotlin, trying

00:36:16.690 --> 00:36:19.240
to get started with
Architecture Components,

00:36:19.240 --> 00:36:22.240
we just released a
new course on Udacity.

00:36:22.240 --> 00:36:25.640
This is, like, a 10-course
session, completely online,

00:36:25.640 --> 00:36:27.910
that teaches you how to
write a modern Android

00:36:27.910 --> 00:36:31.810
application using Kotlin
and Architecture Components.

00:36:31.810 --> 00:36:34.420
So this is a great
resource to get started

00:36:34.420 --> 00:36:36.640
with these technologies.

00:36:36.640 --> 00:36:40.890
You can always find detailed
documentation on our website.

00:36:40.890 --> 00:36:44.110
And if you want to be involved
further in our process,

00:36:44.110 --> 00:36:47.530
you can go to this URL and
see how you can participate

00:36:47.530 --> 00:36:50.690
in our development flow.

00:36:50.690 --> 00:36:52.730
Thank you.

00:36:52.730 --> 00:36:55.480
[MUSIC PLAYING]

