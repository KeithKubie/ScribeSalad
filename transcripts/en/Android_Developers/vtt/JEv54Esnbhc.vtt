WEBVTT
Kind: captions
Language: en

00:00:07.990 --> 00:00:08.930
ANKUR KOTWAL: Hi everyone.

00:00:08.930 --> 00:00:12.430
Welcome to another Android
Developer Lab+.

00:00:12.430 --> 00:00:14.660
We're in a different day
of the week today.

00:00:14.660 --> 00:00:16.740
It's obviously not a Thursday.

00:00:16.740 --> 00:00:18.600
Unless of course you're watching
on YouTube, in which

00:00:18.600 --> 00:00:19.360
case it might be.

00:00:19.360 --> 00:00:22.120
You might be in the future.

00:00:22.120 --> 00:00:24.130
Anyway, so welcome.

00:00:24.130 --> 00:00:26.300
We are actually coming to you
today from Hong Kong.

00:00:26.300 --> 00:00:29.430
So even though Tony and I are
on different screens, we are

00:00:29.430 --> 00:00:31.460
actually right opposite
one another.

00:00:31.460 --> 00:00:34.000
I'll let Tony introduce
himself.

00:00:34.000 --> 00:00:35.680
TONY CHAN: All right.

00:00:35.680 --> 00:00:36.782
Hi, everyone.

00:00:36.782 --> 00:00:38.210
My name's Tony.

00:00:38.210 --> 00:00:42.030
So Ankur and I today
are in Hong Kong.

00:00:42.030 --> 00:00:44.900
So cool.

00:00:44.900 --> 00:00:45.590
ANIRUDH DEWANI: All right.

00:00:45.590 --> 00:00:47.940
I'm Anirudh, and
I'm [INAUDIBLE]

00:00:47.940 --> 00:00:48.966
joining from Hyderabad.

00:00:48.966 --> 00:00:50.415
And [INAUDIBLE]

00:00:50.415 --> 00:00:51.665
here, I guess.

00:00:54.080 --> 00:00:55.570
ANKUR KOTWAL: Anyway, so
thanks for joining us.

00:00:55.570 --> 00:00:57.430
I'm Ankur Kotwal.

00:00:57.430 --> 00:01:02.400
Normally from the Sydney office,
but I'm glad to be

00:01:02.400 --> 00:01:04.330
here with Tony for once.

00:01:04.330 --> 00:01:07.630
So today's topic of the week
is actually the native

00:01:07.630 --> 00:01:08.470
development kit.

00:01:08.470 --> 00:01:12.390
And we have our resident expert
Anirudh who's going to

00:01:12.390 --> 00:01:13.510
present that to us.

00:01:13.510 --> 00:01:15.324
So take it away, Anirudh.

00:01:15.324 --> 00:01:15.701
ANIRUDH DEWANI: All right.

00:01:15.701 --> 00:01:16.570
Thanks, Ankur.

00:01:16.570 --> 00:01:17.820
Let me share my slides.

00:01:27.148 --> 00:01:27.639
OK.

00:01:27.639 --> 00:01:30.820
Can you all see the slides?

00:01:30.820 --> 00:01:32.600
ANKUR KOTWAL: Yeah.

00:01:32.600 --> 00:01:32.810
All right.

00:01:32.810 --> 00:01:39.170
ANIRUDH DEWANI: So the topic
for today is NDK.

00:01:39.170 --> 00:01:42.340
I'm going to introduce
to you what is NDK.

00:01:42.340 --> 00:01:43.540
ANKUR KOTWAL: Anirudh,
sorry to disturb you.

00:01:43.540 --> 00:01:44.970
We can see Keynote.

00:01:44.970 --> 00:01:47.430
We don't see the presentation
itself.

00:01:53.260 --> 00:01:55.190
I think you might have screen
shared only Keynote.

00:01:55.190 --> 00:01:58.450
You need to screen share your
desktop in order for the

00:01:58.450 --> 00:02:01.140
actual presentation to show.

00:02:01.140 --> 00:02:01.560
ANIRUDH DEWANI: OK.

00:02:01.560 --> 00:02:03.045
I'm going to do it
another way.

00:02:03.045 --> 00:02:04.295
ANKUR KOTWAL: All right.

00:02:12.760 --> 00:02:16.040
So while Anirudh does that--

00:02:16.040 --> 00:02:21.960
the NDK is obviously an
alternative to using Eclipse

00:02:21.960 --> 00:02:24.100
and doing Java programming.

00:02:24.100 --> 00:02:25.030
And--

00:02:25.030 --> 00:02:26.620
well, I don't want to steal
Anirudh's thunder.

00:02:26.620 --> 00:02:28.960
So go ahead, Anirudh.

00:02:28.960 --> 00:02:29.350
ANIRUDH DEWANI: All right.

00:02:29.350 --> 00:02:30.730
So everything's fine now?

00:02:30.730 --> 00:02:31.890
ANKUR KOTWAL: Yeah.

00:02:31.890 --> 00:02:32.250
ANIRUDH DEWANI: All right.

00:02:32.250 --> 00:02:33.970
Thanks.

00:02:33.970 --> 00:02:34.990
So first, what is NDK?

00:02:34.990 --> 00:02:38.180
It's the Native Development Kit,
which basically means it

00:02:38.180 --> 00:02:42.710
allows you to build and publish
native applications--

00:02:42.710 --> 00:02:46.080
build and deploy,
I should say.

00:02:46.080 --> 00:02:49.280
So it's actually a tool set, a
collection of tools, which

00:02:49.280 --> 00:02:51.610
includes cross toolchains like
the compiler, linker, and

00:02:51.610 --> 00:02:54.990
build system for native
libraries, which you use to

00:02:54.990 --> 00:02:58.590
write your C/C++ code, link
them against the libraries

00:02:58.590 --> 00:03:00.670
available as part
of the system--

00:03:00.670 --> 00:03:04.250
ABI, binary interface, as well
as the other libraries--

00:03:04.250 --> 00:03:08.010
and include them as part of the
Android build system so

00:03:08.010 --> 00:03:11.650
that they get packaged
into your APKs.

00:03:11.650 --> 00:03:14.680
And we also have a build system
which uses Android.mk,

00:03:14.680 --> 00:03:16.410
the Android make files.

00:03:16.410 --> 00:03:22.310
And this is what you use to
build your native libraries.

00:03:22.310 --> 00:03:24.880
Then, like I mentioned, there
are packaging tools available.

00:03:24.880 --> 00:03:28.650
So that when you actually add
a native library to your

00:03:28.650 --> 00:03:32.050
project, which also contains
Java code and Android

00:03:32.050 --> 00:03:34.520
manifests and other
activities.

00:03:34.520 --> 00:03:36.970
It allows you to bundle
your native libraries

00:03:36.970 --> 00:03:39.120
along with your APK.

00:03:39.120 --> 00:03:42.510
So that you can deploy them
to the [? cluster. ?]

00:03:42.510 --> 00:03:46.850
And the part that I mentioned
about ABI, which is the binary

00:03:46.850 --> 00:03:49.290
interface or the headers,
these are basically the

00:03:49.290 --> 00:03:51.680
headers available from the--

00:03:51.680 --> 00:03:55.270
C/C++ headers and libraries
available from the Android

00:03:55.270 --> 00:03:57.200
framework to you to
code against.

00:03:57.200 --> 00:04:00.910
And there are a lot of things
about these libraries that you

00:04:00.910 --> 00:04:01.320
should know.

00:04:01.320 --> 00:04:03.800
And we're going to look at some
of the basic architecture

00:04:03.800 --> 00:04:06.910
of how all these components are
deployed, so you better

00:04:06.910 --> 00:04:09.800
understand what these libraries
are and why these

00:04:09.800 --> 00:04:13.790
are the only libraries
you should use.

00:04:13.790 --> 00:04:16.740
So before we begin looking
into the libraries and

00:04:16.740 --> 00:04:20.029
architecture, I want to
cover what NDK is not.

00:04:20.029 --> 00:04:22.150
And this is very important.

00:04:22.150 --> 00:04:23.170
There are some--

00:04:23.170 --> 00:04:24.230
people have asked
us questions.

00:04:24.230 --> 00:04:26.660
Is NDK a replacement for SDK?

00:04:26.660 --> 00:04:29.910
Or can I just write my
code in C/C++ because

00:04:29.910 --> 00:04:31.860
I'm better at it?

00:04:31.860 --> 00:04:34.950
So NDK is not a replacement
for SDK.

00:04:34.950 --> 00:04:39.030
SDK always will be the primary
choice of development platform

00:04:39.030 --> 00:04:39.400
for Android.

00:04:39.400 --> 00:04:41.945
And it offers you tons of
libraries through the Dalvik.

00:04:44.780 --> 00:04:47.880
The SDK is the primary platform
for development.

00:04:47.880 --> 00:04:50.360
NDK is only targeted
for special cases.

00:04:50.360 --> 00:04:54.540
And we're going to discuss
what those cases are.

00:04:54.540 --> 00:04:57.060
NDK is not the solution for
performance issues.

00:04:57.060 --> 00:05:00.600
So if you have performance
issues in your app, do not

00:05:00.600 --> 00:05:03.810
think that if I use C/C++
code with NDK, my app

00:05:03.810 --> 00:05:05.370
is going to be faster.

00:05:05.370 --> 00:05:08.270
For most applications, NDK will
not make a difference.

00:05:08.270 --> 00:05:11.990
And Dalvik is actually very
optimized and employs you with

00:05:11.990 --> 00:05:12.430
all the many--

00:05:12.430 --> 00:05:15.050
garbage collection stuff,
which you'll have to do

00:05:15.050 --> 00:05:16.840
manually when writing
native code.

00:05:16.840 --> 00:05:19.440
So it's not always a solution
for performance issues.

00:05:21.970 --> 00:05:23.810
It's not meant for typical
applications.

00:05:23.810 --> 00:05:28.110
So if you have a regular UI,
list view kind of application

00:05:28.110 --> 00:05:30.355
where you're pulling data from
the internet and storing them

00:05:30.355 --> 00:05:32.000
on data store and showing
them on UI and

00:05:32.000 --> 00:05:33.570
letting the user interact--

00:05:33.570 --> 00:05:36.240
these are your typical
applications.

00:05:36.240 --> 00:05:38.800
NDK is not meant for those.

00:05:38.800 --> 00:05:42.500
And it's not an alternative
programming language option,

00:05:42.500 --> 00:05:45.700
which means that you cannot
choose NDK just because you're

00:05:45.700 --> 00:05:48.370
comfortable with C/C++.

00:05:48.370 --> 00:05:52.040
But you have to be comfortable
if you choose NDK for specific

00:05:52.040 --> 00:05:55.085
needs of your project because
all the code is done in C and

00:05:55.085 --> 00:05:58.280
C++ and [INAUDIBLE].

00:05:58.280 --> 00:06:01.140
So now, when to use NDK?

00:06:01.140 --> 00:06:03.350
So if you have a lot of
libraries that you've written

00:06:03.350 --> 00:06:06.820
as part of your projects or open
source libraries that you

00:06:06.820 --> 00:06:08.360
would like to use--

00:06:08.360 --> 00:06:10.070
we use these native
libraries--

00:06:10.070 --> 00:06:11.510
you should use NDK.

00:06:11.510 --> 00:06:14.490
So while you can still write
your application code in Java,

00:06:14.490 --> 00:06:16.740
you can actually include these
libraries and make those

00:06:16.740 --> 00:06:17.420
[? generate ?]

00:06:17.420 --> 00:06:21.480
codes across from Dalvik to
the native [? world. ?]

00:06:21.480 --> 00:06:23.600
And in that sense, use
these libraries

00:06:23.600 --> 00:06:25.780
that you already have.

00:06:25.780 --> 00:06:27.300
Also, if you are writing
something that is

00:06:27.300 --> 00:06:29.660
computationally intensive--

00:06:29.660 --> 00:06:33.280
for example, a lot of
math is involved--

00:06:33.280 --> 00:06:36.080
you can look at the option
of using NDK.

00:06:36.080 --> 00:06:38.370
Because with NDK you can
leverage some of the CP

00:06:38.370 --> 00:06:41.600
specific extensions for
performance, like vector

00:06:41.600 --> 00:06:44.560
floating point instructions
and NEON instructions.

00:06:44.560 --> 00:06:47.690
And these are really fast
routines that you can access

00:06:47.690 --> 00:06:49.000
directly from NDK.

00:06:49.000 --> 00:06:53.300
So this may be a case where you
can look to use NDK if you

00:06:53.300 --> 00:06:56.105
feel that that last bit of
performance, you need to

00:06:56.105 --> 00:06:58.110
squeeze out from the platform.

00:07:02.850 --> 00:07:05.520
So we're going to look at
some of the supported

00:07:05.520 --> 00:07:06.370
platforms right now.

00:07:06.370 --> 00:07:10.520
So we support the ARMv5
instructions set, ARMv7 with

00:07:10.520 --> 00:07:12.480
the hardware floating point
unit, Thumb-2, and Neon

00:07:12.480 --> 00:07:13.650
instructions.

00:07:13.650 --> 00:07:17.670
Then we also support x86
architecture and MPS.

00:07:17.670 --> 00:07:21.580
So what this means is basically
you can use NDK to

00:07:21.580 --> 00:07:24.030
build libraries or shared
objects for

00:07:24.030 --> 00:07:25.110
these platforms only.

00:07:25.110 --> 00:07:27.900
So your code has to run on one
of these platforms because the

00:07:27.900 --> 00:07:28.330
[? binary's ?]

00:07:28.330 --> 00:07:29.725
generated and kept
in a folder.

00:07:29.725 --> 00:07:35.050
And all of these specific
platforms are available to you

00:07:35.050 --> 00:07:36.300
right now to generate
those libraries.

00:07:39.280 --> 00:07:43.200
So let's look at an
architectural overview where

00:07:43.200 --> 00:07:47.250
NDK and where the different
components sit in the system.

00:07:47.250 --> 00:07:49.890
So if you're a Java developer,
you've actually

00:07:49.890 --> 00:07:52.800
used Java SDK before.

00:07:52.800 --> 00:07:54.890
You can see, there is a
Linux kernel there.

00:07:54.890 --> 00:07:58.420
And then we have a Runtime,
the Dalvik VM.

00:07:58.420 --> 00:08:01.280
And then you have all these
framework classes and APIs and

00:08:01.280 --> 00:08:02.490
stuff available to you
that's [INAUDIBLE]

00:08:02.490 --> 00:08:04.350
on top of the Runtime.

00:08:04.350 --> 00:08:08.950
And these are activity managers
of the entire Android

00:08:08.950 --> 00:08:11.640
framework that's available
in the SDK.

00:08:11.640 --> 00:08:13.560
And then you write your
applications on top of this.

00:08:13.560 --> 00:08:18.700
So the Runtime is talking to the
kernel using JNI, which is

00:08:18.700 --> 00:08:19.750
Java Native Interface.

00:08:19.750 --> 00:08:25.420
So you can call C/C++ native
code from Java Runtime.

00:08:25.420 --> 00:08:26.500
But--

00:08:26.500 --> 00:08:30.910
so what happens is that there
are certain systems that are

00:08:30.910 --> 00:08:32.970
really sitting on top
of Linux kernel.

00:08:32.970 --> 00:08:36.669
And that's where what I
mentioned about a certain set

00:08:36.669 --> 00:08:39.539
of headers and libraries
available to you as an NDK

00:08:39.539 --> 00:08:40.830
programmer.

00:08:40.830 --> 00:08:44.350
The reason why that is so is
because a lot of the system

00:08:44.350 --> 00:08:46.190
libraries that we have
that are running

00:08:46.190 --> 00:08:47.580
on top of the kernel--

00:08:47.580 --> 00:08:49.060
these are not very stable.

00:08:49.060 --> 00:08:51.550
And there's no reason for
them to be stable.

00:08:51.550 --> 00:08:54.060
We change them across versions
as we see fit.

00:08:54.060 --> 00:08:57.130
And we cannot really guarantee
a stable interface on top of

00:08:57.130 --> 00:08:59.670
this because this is something
that only Android uses.

00:08:59.670 --> 00:09:02.390
And it's meant for only Android
framework and Runtime.

00:09:02.390 --> 00:09:04.710
So why release different
versions?

00:09:04.710 --> 00:09:07.050
We can make sure our Runtime
adapts to these changes in the

00:09:07.050 --> 00:09:07.890
system libraries.

00:09:07.890 --> 00:09:10.690
But that's not something
we'd like to tell

00:09:10.690 --> 00:09:11.510
you with your apps.

00:09:11.510 --> 00:09:15.730
Because then if you have a new
release of the framework, a

00:09:15.730 --> 00:09:18.730
new API SDK release, your apps
will start breaking if you're

00:09:18.730 --> 00:09:20.990
using any of those system
libraries that have changed

00:09:20.990 --> 00:09:22.560
over the version.

00:09:22.560 --> 00:09:25.640
So what we try to do is provide
you a stable ABI, the

00:09:25.640 --> 00:09:27.110
Application Binary Interface.

00:09:27.110 --> 00:09:30.020
And this is a set of headers
and libraries that are

00:09:30.020 --> 00:09:31.570
available to you to
code against.

00:09:31.570 --> 00:09:33.040
So we make sure that
these are stable.

00:09:33.040 --> 00:09:36.490
These remain the same over
different versions of NDK.

00:09:36.490 --> 00:09:38.770
So you can always rely on--

00:09:38.770 --> 00:09:41.990
it's kind of guaranteed that
they will work across.

00:09:41.990 --> 00:09:44.530
And the box that you see that
says Libraries, these are your

00:09:44.530 --> 00:09:47.415
libraries, the libraries that
you write on top of these

00:09:47.415 --> 00:09:48.920
stable ABIs.

00:09:48.920 --> 00:09:51.190
And then again you can
use JNIWrapper.

00:09:51.190 --> 00:09:54.260
And your applications can have
Java code that can directly

00:09:54.260 --> 00:09:56.520
talk to your libraries
that are talking to

00:09:56.520 --> 00:09:58.950
stable ABIs using JNI.

00:09:58.950 --> 00:10:02.650
So this is an alternative code
execution environment that

00:10:02.650 --> 00:10:04.080
basically is what
NDK provides.

00:10:07.640 --> 00:10:09.740
So some of the headers that
are available to you--

00:10:12.550 --> 00:10:13.850
I guess this is pretty
much all the headers

00:10:13.850 --> 00:10:14.880
available to you.

00:10:14.880 --> 00:10:17.070
And this is what you
should be using.

00:10:17.070 --> 00:10:18.190
So the first one is libc.

00:10:18.190 --> 00:10:20.150
I think I have a mistake
there saying lib.

00:10:20.150 --> 00:10:21.990
It's libc, the standard
C library.

00:10:21.990 --> 00:10:24.890
And there's a lib math, the
lib compression library;

00:10:24.890 --> 00:10:26.110
liblog, it's [? just the ?]

00:10:26.110 --> 00:10:28.700
Android log system, if you want
to interact with that;

00:10:28.700 --> 00:10:31.270
the libdl, dynamic
linking library.

00:10:31.270 --> 00:10:35.130
And then we have graphics native
libraries like OpenGL,

00:10:35.130 --> 00:10:40.200
ES1.1, 2.0 spec libraries, and
libjnigraphics that can talk

00:10:40.200 --> 00:10:44.740
directly to the rendering system
like bitmaps and stuff

00:10:44.740 --> 00:10:47.280
and also to the OpenGL stuff.

00:10:47.280 --> 00:10:50.340
So these are the libraries
available to you.

00:10:50.340 --> 00:10:52.120
And recently, with
Gingerbread--

00:10:52.120 --> 00:10:53.280
well, not so recently.

00:10:53.280 --> 00:10:56.160
With Gingerbread we added
support for more libraries to

00:10:56.160 --> 00:10:59.730
basically cater to the needs
of game developers.

00:10:59.730 --> 00:11:02.790
And so there is OpenGL ES
Audio available to you.

00:11:02.790 --> 00:11:04.570
There is libegl available
to you.

00:11:04.570 --> 00:11:07.660
And also a standard C++ library
is available to you.

00:11:07.660 --> 00:11:10.350
So these are the only headers
and libraries you should use

00:11:10.350 --> 00:11:13.370
in your program from the system
and not rely on any

00:11:13.370 --> 00:11:17.320
other system libraries available
because they may not

00:11:17.320 --> 00:11:19.460
remain the same.

00:11:19.460 --> 00:11:21.865
So it's very important to note
that if you want to support

00:11:21.865 --> 00:11:24.205
your application across
versions, just stick to this

00:11:24.205 --> 00:11:25.455
set of libraries.

00:11:29.120 --> 00:11:33.530
So how do you write
a simple app?

00:11:33.530 --> 00:11:35.930
So in terms of project
structure, it's pretty much

00:11:35.930 --> 00:11:37.930
the same when you create
a project.

00:11:37.930 --> 00:11:41.775
And you can do that by using
either Android create project

00:11:41.775 --> 00:11:44.160
script that is available
or use [INAUDIBLE]

00:11:44.160 --> 00:11:45.240
project.

00:11:45.240 --> 00:11:48.330
And you have a folder called
JNI that [INAUDIBLE]

00:11:48.330 --> 00:11:50.650
to your source and to
your libs folder.

00:11:50.650 --> 00:11:55.050
This JNI folder is actually
written in the NDK code or

00:11:55.050 --> 00:11:56.920
your native code.

00:11:56.920 --> 00:12:00.380
So you write your C/C++
library source files.

00:12:00.380 --> 00:12:03.705
And these may actually be
another project that you

00:12:03.705 --> 00:12:04.220
already have.

00:12:04.220 --> 00:12:07.170
And you can just place all that
C/C++ code inside this

00:12:07.170 --> 00:12:09.410
JNI folder.

00:12:09.410 --> 00:12:12.620
And then you write a bare
file, Android.mk file.

00:12:12.620 --> 00:12:16.330
And the syntax is pretty easy,
and it's very flexible.

00:12:16.330 --> 00:12:19.875
So this is-- what you need to
do to build your NDK code is

00:12:19.875 --> 00:12:22.210
write the Android.mk file.

00:12:22.210 --> 00:12:24.655
In this file you basically
describe where are your source

00:12:24.655 --> 00:12:26.880
files, what source files you
need to build, what are the

00:12:26.880 --> 00:12:30.100
libraries these source files
should link against, and the

00:12:30.100 --> 00:12:33.290
output of the library.

00:12:33.290 --> 00:12:34.860
This is for modules.

00:12:34.860 --> 00:12:37.160
If in your project you're going
to have more than a

00:12:37.160 --> 00:12:41.890
couple of modules or native
libraries that you're

00:12:41.890 --> 00:12:44.350
building, you will have
an Android.mk

00:12:44.350 --> 00:12:46.600
file for each of those.

00:12:46.600 --> 00:12:49.240
And then on top of that, you'll
have an Application.mk

00:12:49.240 --> 00:12:52.330
which is basically a wrap,
something that is going to

00:12:52.330 --> 00:12:54.140
dedicate the module building
for each of

00:12:54.140 --> 00:12:55.170
these Android.mk files.

00:12:55.170 --> 00:13:00.860
So use the Application.mk
to build all of

00:13:00.860 --> 00:13:02.860
these Android.mk files.

00:13:02.860 --> 00:13:07.500
Optionally, you can use javah
or Eclipse tools, IDE tools,

00:13:07.500 --> 00:13:09.850
to generate C headers
from Java files.

00:13:09.850 --> 00:13:12.470
So if you're--

00:13:12.470 --> 00:13:14.790
which in general, we introduce
something [INAUDIBLE]

00:13:14.790 --> 00:13:16.420
and we'll get over there.

00:13:16.420 --> 00:13:18.530
But before that if you're
writing code for all the

00:13:18.530 --> 00:13:26.220
platforms, what you want to do
is-- in your Java code, your

00:13:26.220 --> 00:13:29.560
application code, you have some
methods incremented there

00:13:29.560 --> 00:13:32.940
and some methods or something
that you want to use in the

00:13:32.940 --> 00:13:34.000
other platform.

00:13:34.000 --> 00:13:36.250
So you're going to prefix the
keyword method in front of

00:13:36.250 --> 00:13:38.220
those methods in Java.

00:13:38.220 --> 00:13:41.930
And then you can use javah to
generate the headers for these

00:13:41.930 --> 00:13:46.210
Java files, which actually
generates a [INAUDIBLE] code,

00:13:46.210 --> 00:13:50.485
which you can use to interact
between Java and the Dalvik at

00:13:50.485 --> 00:13:53.290
the native [? world. ?]

00:13:53.290 --> 00:13:56.720
So once you do this step-- and
this is optional, depending on

00:13:56.720 --> 00:13:58.480
your use case--

00:13:58.480 --> 00:14:00.940
you would run the NDK build
script which is available.

00:14:00.940 --> 00:14:03.030
And this is the entire toolchain
available to you.

00:14:03.030 --> 00:14:06.440
So you would run this NDK
[? tools ?] to generate new

00:14:06.440 --> 00:14:08.630
native, share object,
or library.

00:14:08.630 --> 00:14:11.180
And in your Java code, you can
load this library by saying

00:14:11.180 --> 00:14:14.060
system.loadLibrary, native.so
or whatever the name

00:14:14.060 --> 00:14:16.360
for your module is.

00:14:16.360 --> 00:14:22.520
And NDK build is part of the
entire NDK platform, which is

00:14:22.520 --> 00:14:23.760
available for you to download.

00:14:23.760 --> 00:14:26.710
And it's platform specific.

00:14:26.710 --> 00:14:29.070
So this is something you can
go and download from

00:14:29.070 --> 00:14:31.060
developers.google.com.

00:14:31.060 --> 00:14:32.940
Just along with the SDK,
you can find the

00:14:32.940 --> 00:14:34.550
NDK links to that.

00:14:34.550 --> 00:14:37.390
So once you've generated the
shared object libraries, and

00:14:37.390 --> 00:14:40.480
system.loadLibrary will make
these libraries available to

00:14:40.480 --> 00:14:43.955
you loaded dynamically against
the running application.

00:14:48.140 --> 00:14:51.340
So with Gingerbread, we
introduced something called

00:14:51.340 --> 00:14:52.960
NativeActivity.

00:14:52.960 --> 00:14:57.130
So before Gingerbread, you would
always need to have some

00:14:57.130 --> 00:15:00.420
Java code in your application
and some specific methods

00:15:00.420 --> 00:15:01.730
implemented in native code.

00:15:01.730 --> 00:15:02.620
So you would--

00:15:02.620 --> 00:15:05.020
like I said, you would put the
native prefix in front of

00:15:05.020 --> 00:15:05.910
those methods.

00:15:05.910 --> 00:15:09.240
So you would say private,
native, and do this, something

00:15:09.240 --> 00:15:11.020
in [? past ?] parameters.

00:15:11.020 --> 00:15:14.150
So with Gingerbread,
you can actually

00:15:14.150 --> 00:15:15.570
write Java-less classes.

00:15:15.570 --> 00:15:18.750
And you can-- still my entire
activity is a NativeActivity,

00:15:18.750 --> 00:15:21.260
so you don't have to write
any application code.

00:15:21.260 --> 00:15:23.590
And this is something
useful for game

00:15:23.590 --> 00:15:24.630
developers and something.

00:15:24.630 --> 00:15:28.565
So if you're a game developer,
and you have all your input

00:15:28.565 --> 00:15:31.850
and your UI and everything
written in native code, you

00:15:31.850 --> 00:15:34.150
really don't need any Java
interface to it.

00:15:34.150 --> 00:15:36.980
So what you can do is write
a NativeActivity.

00:15:42.990 --> 00:15:46.440
So like I mentioned, it
implements a complete activity

00:15:46.440 --> 00:15:48.140
in native code.

00:15:48.140 --> 00:15:50.940
So we'll just look at the
manifest of how you declare a

00:15:50.940 --> 00:15:52.690
NativeActicity.

00:15:52.690 --> 00:15:56.270
So if you see, in this slide
there is an activity by the

00:15:56.270 --> 00:15:58.570
name of
android.app.nativeactivity.

00:15:58.570 --> 00:16:04.140
And this is the activity tag,
which has an element called

00:16:04.140 --> 00:16:06.520
metadata, which specifies
the name of a library.

00:16:06.520 --> 00:16:09.270
And this is the native library
we are going to be using.

00:16:09.270 --> 00:16:11.950
And the value is the
activity name, the

00:16:11.950 --> 00:16:13.480
NativeActivity available.

00:16:13.480 --> 00:16:16.400
So this will actually make
sure that your activity--

00:16:16.400 --> 00:16:20.670
this will tell the Android
Runtime that there is no Java

00:16:20.670 --> 00:16:23.170
class for this activity.

00:16:23.170 --> 00:16:25.930
The entire activity is
implemented natively.

00:16:25.930 --> 00:16:30.460
And if your application is
completely Java-less, you

00:16:30.460 --> 00:16:32.360
would see that in the
application path we have

00:16:32.360 --> 00:16:35.160
something called
Android:hasCode="false", which

00:16:35.160 --> 00:16:36.910
means that there is
no Java code.

00:16:36.910 --> 00:16:41.110
And all the components inside
this APK are native.

00:16:43.990 --> 00:16:46.720
So the entry point for
a NativeActivity--

00:16:46.720 --> 00:16:49.720
if you're writing a native app
activity completely Java-less,

00:16:49.720 --> 00:16:51.910
the entry point is
android_main.

00:16:51.910 --> 00:16:56.140
So in your C/C++ you should
have this entry point.

00:16:56.140 --> 00:17:03.090
And this is where the Runtime
starts interacting with your

00:17:03.090 --> 00:17:04.510
application.

00:17:04.510 --> 00:17:05.530
[INAUDIBLE]

00:17:05.530 --> 00:17:09.670
and this is kind of similar to
the Android activity style.

00:17:09.670 --> 00:17:15.000
This is implemented as part
of Android native [? gu ?]

00:17:15.000 --> 00:17:15.260
library.

00:17:15.260 --> 00:17:19.470
And this is something you will
have to link against when

00:17:19.470 --> 00:17:20.859
you're building your
native code.

00:17:20.859 --> 00:17:24.380
So when I mentioned Android.mk
files where you define your

00:17:24.380 --> 00:17:27.430
dependencies in the libraries,
you would also have to include

00:17:27.430 --> 00:17:28.680
this library.

00:17:31.190 --> 00:17:35.210
So before we discuss tools and
IDEs, there are some important

00:17:35.210 --> 00:17:39.290
performance considerations
with the NDK.

00:17:39.290 --> 00:17:41.780
So when you're actually--

00:17:41.780 --> 00:17:46.240
the first thing is the threads
that are created in your

00:17:46.240 --> 00:17:48.850
applications are tied
to the process.

00:17:48.850 --> 00:17:54.200
So sometimes your activity may
stop or may pause, but your

00:17:54.200 --> 00:17:55.700
thread and your process
is still alive.

00:17:55.700 --> 00:17:57.280
That's actually hosting
these activities.

00:17:57.280 --> 00:18:01.510
That's your application, which
sponsor Dalvik VM.

00:18:01.510 --> 00:18:04.960
So this process must
still be alive.

00:18:04.960 --> 00:18:07.815
So because the process may be
alive, you're using threads in

00:18:07.815 --> 00:18:10.520
your NDK code, your threads will
also continue running.

00:18:10.520 --> 00:18:12.970
So it's something important you
should know when you're

00:18:12.970 --> 00:18:13.930
writing your application.

00:18:13.930 --> 00:18:17.570
Although the activity may be out
of the screen or may have

00:18:17.570 --> 00:18:20.785
been paused because some dialog
popped up in front,

00:18:20.785 --> 00:18:22.410
your threads will still
be running.

00:18:22.410 --> 00:18:25.060
Sometimes you want to choose
which threads you should stop

00:18:25.060 --> 00:18:26.980
at that point of time
or which threads

00:18:26.980 --> 00:18:28.650
you should keep running.

00:18:28.650 --> 00:18:31.960
So if you're doing some kind of
sound, maybe something you

00:18:31.960 --> 00:18:32.990
want to stop there.

00:18:32.990 --> 00:18:37.820
Because once your activities
are stopped or paused, you

00:18:37.820 --> 00:18:40.080
don't want to hear any sound
from your application.

00:18:40.080 --> 00:18:41.240
But there are other things
that you may

00:18:41.240 --> 00:18:42.280
need to keep running.

00:18:42.280 --> 00:18:44.880
So that's an important
consideration when writing NDK

00:18:44.880 --> 00:18:47.840
code, native code.

00:18:47.840 --> 00:18:50.570
The other thing is because
the process is only

00:18:50.570 --> 00:18:51.100
[? brought live ?]

00:18:51.100 --> 00:18:53.930
once, there may be some static
initializers in your code and

00:18:53.930 --> 00:18:55.720
they will all be getting
initialized once.

00:18:55.720 --> 00:18:59.920
So the activity stops and
then again resumes.

00:18:59.920 --> 00:19:03.580
These static initializers will
not be loaded again, so you

00:19:03.580 --> 00:19:06.070
may want to avoid the static
initializers and take care of

00:19:06.070 --> 00:19:08.680
initializing these variables
yourself.

00:19:08.680 --> 00:19:13.170
So as an NDK developer, also
there are other performance

00:19:13.170 --> 00:19:15.970
considerations and tools and
stuff available for you

00:19:15.970 --> 00:19:17.790
because it can get tricky.

00:19:17.790 --> 00:19:21.290
And it's not easy to manage
memory when you're writing the

00:19:21.290 --> 00:19:23.200
memory, handling things
yourself.

00:19:23.200 --> 00:19:25.320
So you need to be
extra careful.

00:19:25.320 --> 00:19:28.700
So what we have as part
of tools and IDEs--

00:19:28.700 --> 00:19:32.365
the ADT 20 IDE now supports
NDK building and debugging

00:19:32.365 --> 00:19:36.120
directly from using
the ADT plug-in.

00:19:36.120 --> 00:19:39.330
And this actually uses a
multi-threaded GDB, so you

00:19:39.330 --> 00:19:41.850
don't have to write all the
codings like main thread to be

00:19:41.850 --> 00:19:44.000
able to debug that.

00:19:44.000 --> 00:19:46.790
There's a link to that,
tools.android.co

00:19:46.790 --> 00:19:51.660
m/recent/usingthendkplugin, and
this is where you can see

00:19:51.660 --> 00:19:56.180
notes about the support and
how to configure it.

00:19:56.180 --> 00:19:58.980
There are also plug-ins
available, Eclipse plug-ins

00:19:58.980 --> 00:20:00.260
available from [? Nmedia ?]

00:20:00.260 --> 00:20:01.810
that can help you do performance
and memory

00:20:01.810 --> 00:20:06.050
analysis for your application.

00:20:06.050 --> 00:20:10.840
We also support the NDK GDB,
which is the GNU debugger that

00:20:10.840 --> 00:20:11.150
you can use.

00:20:11.150 --> 00:20:13.260
And you can use any GDB.

00:20:13.260 --> 00:20:16.500
So this actually starts a GDB
server on your device and then

00:20:16.500 --> 00:20:19.480
uses a name [? byte ?] to talk
to your machine that you're

00:20:19.480 --> 00:20:20.650
debugging it from.

00:20:20.650 --> 00:20:22.740
So these are some of the
tools available.

00:20:22.740 --> 00:20:25.660
There are a lot more available
from community.

00:20:25.660 --> 00:20:28.580
There are a number of us who
have come up with complete

00:20:28.580 --> 00:20:30.330
project generation kits.

00:20:30.330 --> 00:20:33.040
And so the companies like
[? Nmedia ?] have come up with

00:20:33.040 --> 00:20:35.380
advanced memory analysis
tools and stuff.

00:20:35.380 --> 00:20:37.450
So this is some of the things
you can explore.

00:20:37.450 --> 00:20:40.750
And each time you use this, you
should always debug your

00:20:40.750 --> 00:20:42.990
applications using Gingerbread
because you can debug a

00:20:42.990 --> 00:20:45.690
NativeActivity, find out new
[? polls ?], find out memory

00:20:45.690 --> 00:20:48.662
leaks and fix them.

00:20:48.662 --> 00:20:50.400
So yeah.

00:20:50.400 --> 00:20:53.730
That brings us to the end
of the presentation.

00:20:53.730 --> 00:20:58.340
We will now move on to Q and
A. Ankur, do you want

00:20:58.340 --> 00:20:59.792
to take that up?

00:20:59.792 --> 00:21:00.190
ANKUR KOTWAL: Yeah.

00:21:00.190 --> 00:21:02.330
Thanks, Anirudh.

00:21:02.330 --> 00:21:08.150
So we have Anatoliy live.

00:21:08.150 --> 00:21:09.618
Hi, there.

00:21:09.618 --> 00:21:10.022
ANATOLIY KAVERIN: Yeah.

00:21:10.022 --> 00:21:10.830
Hi.

00:21:10.830 --> 00:21:11.920
Do you hear me well?

00:21:11.920 --> 00:21:13.410
ANKUR KOTWAL: Yeah,
we can hear you.

00:21:13.410 --> 00:21:14.080
ANATOLIY KAVERIN: OK.

00:21:14.080 --> 00:21:15.365
Great.

00:21:15.365 --> 00:21:16.600
ANKUR KOTWAL: Do you have
any questions that you

00:21:16.600 --> 00:21:18.030
wanted to ask us?

00:21:18.030 --> 00:21:19.090
ANATOLIY KAVERIN: Yeah.

00:21:19.090 --> 00:21:21.160
Just a question regarding NDK.

00:21:21.160 --> 00:21:23.070
I'm glad that you're
in the session.

00:21:23.070 --> 00:21:27.200
Actually, as a topic, this
is the first Hangout I'm

00:21:27.200 --> 00:21:28.100
attending to.

00:21:28.100 --> 00:21:30.510
And I was not aware
of the topic.

00:21:30.510 --> 00:21:34.760
But NDK is actually right
now one of my projects.

00:21:34.760 --> 00:21:37.190
I'm working closely with it.

00:21:37.190 --> 00:21:38.380
So the first question is--

00:21:38.380 --> 00:21:42.970
you said that there are some
header files we each provide

00:21:42.970 --> 00:21:44.120
to NDK developers.

00:21:44.120 --> 00:21:45.860
What about STL?

00:21:45.860 --> 00:21:47.550
Something related to more
language, I would say.

00:21:47.550 --> 00:21:49.570
Are they stable?

00:21:49.570 --> 00:21:51.865
I know that there are
three alternatives.

00:21:51.865 --> 00:21:53.220
No, not three but two.

00:21:53.220 --> 00:21:54.270
It's [INAUDIBLE]

00:21:54.270 --> 00:21:56.920
and [INAUDIBLE], which we
can use in our projects.

00:21:56.920 --> 00:21:59.860
But are they stable or not?

00:21:59.860 --> 00:22:01.400
Because it mentions them
in the list of

00:22:01.400 --> 00:22:04.190
the available headers.

00:22:04.190 --> 00:22:05.880
ANIRUDH DEWANI: So the libraries
that I've mentioned

00:22:05.880 --> 00:22:08.310
in the list of available
headers, these are more stable

00:22:08.310 --> 00:22:13.035
ones and guaranteed to work
across each of the releases.

00:22:13.035 --> 00:22:14.480
So these are the ones
[INAUDIBLE]

00:22:14.480 --> 00:22:16.645
as far as Android [INAUDIBLE]
is concerned.

00:22:16.645 --> 00:22:19.580
Or the Android system library
set is concerned, you can

00:22:19.580 --> 00:22:21.950
always have your third party
libraries there.

00:22:21.950 --> 00:22:23.080
But from the [? systemic ?]

00:22:23.080 --> 00:22:24.660
perspective, the ones
[INAUDIBLE].

00:22:24.660 --> 00:22:27.360
And you can always find the
updated list on the

00:22:27.360 --> 00:22:32.090
developer.google.com NDK.

00:22:32.090 --> 00:22:33.930
Actually, we have a list
of libraries there.

00:22:33.930 --> 00:22:37.340
And you should always
stick to that.

00:22:37.340 --> 00:22:39.670
ANATOLIY KAVERIN: But as far as
I know, some STL libraries

00:22:39.670 --> 00:22:41.030
are shipped with NDK.

00:22:41.030 --> 00:22:43.860
But they are not
stable, right?

00:22:43.860 --> 00:22:46.432
ANKUR KOTWAL: Anirudh, just
before you answer the next

00:22:46.432 --> 00:22:47.660
question-- we can't
see you, actually.

00:22:47.660 --> 00:22:49.836
Your screen share is still on.

00:22:52.980 --> 00:22:53.500
There you go.

00:22:53.500 --> 00:22:54.240
Thank you.

00:22:54.240 --> 00:22:56.300
ANIRUDH DEWANI: Thanks.

00:22:56.300 --> 00:22:56.720
I'm sorry.

00:22:56.720 --> 00:22:58.170
You said, some libraries--

00:22:58.170 --> 00:23:00.274
I didn't catch which libraries.

00:23:00.274 --> 00:23:01.230
Some?

00:23:01.230 --> 00:23:04.110
ANATOLIY KAVERIN: I mean that
STL is a part of NDK.

00:23:07.860 --> 00:23:11.100
But it is not listed in
the stable libraries.

00:23:11.100 --> 00:23:14.730
So they ship together, but they
are not still stable?

00:23:14.730 --> 00:23:15.130
Right?

00:23:15.130 --> 00:23:18.256
They are subject to change.

00:23:18.256 --> 00:23:20.410
ANIRUDH DEWANI: I think
there's a [INAUDIBLE]

00:23:20.410 --> 00:23:22.470
string that we had.

00:23:22.470 --> 00:23:24.900
I can check and get back to you
whether we want to call it

00:23:24.900 --> 00:23:27.320
stable and make it available
and really want to call it

00:23:27.320 --> 00:23:28.320
stable officially.

00:23:28.320 --> 00:23:29.680
So that you can go
ahead and use it.

00:23:29.680 --> 00:23:32.340
I know it's available
as far as the NDK.

00:23:32.340 --> 00:23:34.590
Maybe I'll get back on
this [INAUDIBLE]

00:23:34.590 --> 00:23:36.710
this Hangout and post
an answer there.

00:23:36.710 --> 00:23:36.985
ANATOLIY KAVERIN: OK.

00:23:36.985 --> 00:23:40.010
And Just a second question
regarding NativeActivity.

00:23:40.010 --> 00:23:43.860
Imagine that I'm developing
some application where I'm

00:23:43.860 --> 00:23:46.620
going to have audio and
video streaming.

00:23:46.620 --> 00:23:50.860
For example, this will be
something similar to what

00:23:50.860 --> 00:23:53.310
we're doing now, Hangout,
targeted on

00:23:53.310 --> 00:23:54.900
primary full tablets.

00:23:54.900 --> 00:23:58.320
And for example, in one part
of the screen I'm going to

00:23:58.320 --> 00:24:01.970
have, for example,
some video frame.

00:24:01.970 --> 00:24:04.580
In another part, I'm going to
have some chat and of course

00:24:04.580 --> 00:24:06.230
audio conversation.

00:24:06.230 --> 00:24:10.580
Will NativeActivity benefit
me somehow?

00:24:10.580 --> 00:24:16.560
Because as I see it now, I was
planning to use, I would say,

00:24:16.560 --> 00:24:24.250
a classic Java activity with
some framing with video

00:24:24.250 --> 00:24:26.080
output, for example.

00:24:26.080 --> 00:24:30.900
But my audio/video compression
code already is a part of NDK

00:24:30.900 --> 00:24:33.250
library, which I'm shipping
with my application.

00:24:33.250 --> 00:24:38.330
So do I have any benefits if I
will stick to NativeActivity?

00:24:38.330 --> 00:24:42.430
Will it benefit me in the
performance of this, I would

00:24:42.430 --> 00:24:45.163
say, video showing,
video output?

00:24:45.163 --> 00:24:47.570
Can you comment?

00:24:47.570 --> 00:24:50.290
ANIRUDH DEWANI: So if you are
using any of those specific

00:24:50.290 --> 00:24:51.495
instructions--

00:24:51.495 --> 00:24:53.710
the Neon instruction
set, et cetera--

00:24:53.710 --> 00:24:57.010
for your compression routines
and stuff, you may have some

00:24:57.010 --> 00:24:59.400
benefits in performance there.

00:24:59.400 --> 00:25:03.090
But otherwise, largely,
it's part of--

00:25:03.090 --> 00:25:05.100
as far as rendering and stuff
is concerned on the

00:25:05.100 --> 00:25:06.050
screen, there is--

00:25:06.050 --> 00:25:08.290
I really wouldn't say that
there's any benefit in using

00:25:08.290 --> 00:25:09.680
the NDK for that stuff.

00:25:09.680 --> 00:25:10.900
So yeah.

00:25:10.900 --> 00:25:12.310
It's really up to the
compression and all that

00:25:12.310 --> 00:25:15.550
routines, plus computationally
intensive routines.

00:25:15.550 --> 00:25:17.630
And if you want to take some
benefit there using the

00:25:17.630 --> 00:25:19.770
instruction set [INAUDIBLE]

00:25:19.770 --> 00:25:22.140
available on the [INAUDIBLE],
that's where [INAUDIBLE].

00:25:25.400 --> 00:25:25.890
ANATOLIY KAVERIN: OK.

00:25:25.890 --> 00:25:26.280
OK.

00:25:26.280 --> 00:25:26.850
Thank you.

00:25:26.850 --> 00:25:28.200
So far I've got no
more questions.

00:25:45.432 --> 00:25:49.910
ANIRUDH DEWANI: Ankur,
we cannot hear you.

00:25:49.910 --> 00:25:50.710
ANKUR KOTWAL: Well, that's
embarrassing.

00:25:50.710 --> 00:25:55.950
I was talking for good 30
seconds then on mute.

00:25:55.950 --> 00:25:59.470
In terms of moderator, we have
one question on there.

00:25:59.470 --> 00:26:02.680
Which basically says, "How do
I send search terms to the

00:26:02.680 --> 00:26:07.789
Google search app built into
Android?" I mean, the answer

00:26:07.789 --> 00:26:09.930
to this is typically--

00:26:09.930 --> 00:26:15.810
what you do is you'd just call
a URL, like doing a normal

00:26:15.810 --> 00:26:17.400
Google search.

00:26:17.400 --> 00:26:19.900
You will actually not go through
the Google search app.

00:26:19.900 --> 00:26:22.210
It'll basically fire
up your browser.

00:26:22.210 --> 00:26:26.110
And you'll get search results
through the webpage, the

00:26:26.110 --> 00:26:27.560
mobile site.

00:26:27.560 --> 00:26:30.390
So I guess my follow-up question
to this would be, is

00:26:30.390 --> 00:26:36.240
there anything in particular
that you are after in that

00:26:36.240 --> 00:26:38.010
built in Google search app?

00:26:38.010 --> 00:26:40.820
Because in general, that
Google search app is

00:26:40.820 --> 00:26:41.570
basically--

00:26:41.570 --> 00:26:46.000
all it is is a user interface
for doing searches.

00:26:46.000 --> 00:26:51.015
On Jellybean, we added Google
Now, which actually handles

00:26:51.015 --> 00:26:53.800
some Google searches there and
presents them slightly

00:26:53.800 --> 00:26:55.000
differently.

00:26:55.000 --> 00:26:58.180
But if you do the same search
through your mobile browser,

00:26:58.180 --> 00:27:02.590
you do get the same knowledge
cards and the usual results.

00:27:02.590 --> 00:27:05.840
And they're kind of formatted to
match your screen size, and

00:27:05.840 --> 00:27:07.510
it goes through the browser.

00:27:07.510 --> 00:27:08.640
The browser is there.

00:27:08.640 --> 00:27:11.290
You don't need to go directly
to the Google search app.

00:27:11.290 --> 00:27:13.820
So in terms of your results,
it should be the same.

00:27:13.820 --> 00:27:17.380
But I'll be interested to know
what else you might be after,

00:27:17.380 --> 00:27:20.600
why specifically you want the
integration with the Google

00:27:20.600 --> 00:27:21.850
search app itself.

00:27:24.720 --> 00:27:31.140
So JJ from Cambridge, if you're
able to respond back in

00:27:31.140 --> 00:27:34.290
a future moderator, that
would be great.

00:27:34.290 --> 00:27:37.600
Just let us know.

00:27:37.600 --> 00:27:44.250
Let me just see if there's
anything else from the thread

00:27:44.250 --> 00:27:46.010
where we've got the
Hangout running.

00:27:46.010 --> 00:27:46.970
And there isn't.

00:27:46.970 --> 00:27:50.020
So we're done, I guess.

00:27:50.020 --> 00:27:52.740
There is nothing
more for today.

00:27:52.740 --> 00:27:56.490
Thanks Anirudh for the
presentation on NDK.

00:27:56.490 --> 00:27:59.640
I'm sure you'll get quite a few
questions from developers.

00:27:59.640 --> 00:28:02.810
It's a fairly common and popular
topic about coding

00:28:02.810 --> 00:28:06.030
using C++ for Android.

00:28:06.030 --> 00:28:07.280
So thanks very much.

00:28:07.280 --> 00:28:08.550
And yeah.

00:28:08.550 --> 00:28:09.370
We'll be back next week.

00:28:09.370 --> 00:28:13.160
And next week we'll be back to
our regularly scheduled time,

00:28:13.160 --> 00:28:15.040
which is on Thursdays.

00:28:15.040 --> 00:28:16.650
So yeah.

00:28:16.650 --> 00:28:17.940
Thanks for joining us.

00:28:17.940 --> 00:28:20.860
And we'll see you next week.

00:28:20.860 --> 00:28:21.690
ANATOLIY KAVERIN:
Looking forward.

00:28:21.690 --> 00:28:23.590
Bye.

00:28:23.590 --> 00:28:24.360
ANKUR KOTWAL: Thanks.

00:28:24.360 --> 00:28:25.610
Bye bye.

