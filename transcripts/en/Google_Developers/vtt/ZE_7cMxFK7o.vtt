WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:02.970
[MUSIC PLAYING]

00:00:10.410 --> 00:00:11.270
Hi.

00:00:11.270 --> 00:00:13.990
Do you have a great cast
app that plays media back?

00:00:13.990 --> 00:00:17.280
Well, I bet you'd love to know
how to engage your users more.

00:00:17.280 --> 00:00:20.460
If I told you you could spend
a tiny bit more time coding

00:00:20.460 --> 00:00:24.650
and get 20% more attention for
your users, would you do it?

00:00:24.650 --> 00:00:26.280
Of course you would.

00:00:26.280 --> 00:00:29.000
That's why you need
Autoplay and Queuing.

00:00:29.000 --> 00:00:30.770
Autoplay takes
advantage of a feature

00:00:30.770 --> 00:00:32.970
we've included in the
media playback library

00:00:32.970 --> 00:00:34.970
called MPL preload.

00:00:34.970 --> 00:00:37.470
You can get MPL to send
events back to your JavaScript

00:00:37.470 --> 00:00:39.690
while media playback
is happening.

00:00:39.690 --> 00:00:42.470
You can hook into those events
to gain more insight into media

00:00:42.470 --> 00:00:45.140
while it's playing
back on a cast device.

00:00:45.140 --> 00:00:46.950
For example, you
can get an event

00:00:46.950 --> 00:00:49.400
when the entire media
has finished buffering.

00:00:49.400 --> 00:00:51.930
But I'll bet you're asking why.

00:00:51.930 --> 00:00:54.670
Well, if you're streaming
media over the network,

00:00:54.670 --> 00:00:57.130
that event could trigger,
say, within 20 seconds

00:00:57.130 --> 00:00:59.310
a video is still ready
to be played by the cast

00:00:59.310 --> 00:01:02.400
device, which gives you time to
set up the next piece of media

00:01:02.400 --> 00:01:05.900
to play so you can have seamless
playback of multiple media

00:01:05.900 --> 00:01:08.300
streams one after the other.

00:01:08.300 --> 00:01:10.650
Using MPL preload
can give your users

00:01:10.650 --> 00:01:12.680
a great uninterrupted
media consumption

00:01:12.680 --> 00:01:15.410
experience that they won't be
able to tear themselves away

00:01:15.410 --> 00:01:16.660
from.

00:01:16.660 --> 00:01:19.490
Now writing code to manage all
that can be time consuming,

00:01:19.490 --> 00:01:22.660
so that's why we also
have Queuing APIs.

00:01:22.660 --> 00:01:24.820
The queuing APIs let you
maintain a list of media

00:01:24.820 --> 00:01:26.792
to play one after
the other, and take

00:01:26.792 --> 00:01:29.000
care of setting up the
Autoplay buffering, et cetera,

00:01:29.000 --> 00:01:30.780
so you don't have to.

00:01:30.780 --> 00:01:33.780
The Queuing APIs also provide
dynamic playlist management

00:01:33.780 --> 00:01:35.840
to make it easy to
display the queued meteor

00:01:35.840 --> 00:01:38.860
items to your user, insert
or delete media items,

00:01:38.860 --> 00:01:40.860
or change their playback order.

00:01:40.860 --> 00:01:44.540
You can even show history for
media that's finished playing.

00:01:44.540 --> 00:01:47.020
To help make a playlist
enabled experience enjoyable,

00:01:47.020 --> 00:01:49.740
we provide [INAUDIBLE] about
how to inform your users when

00:01:49.740 --> 00:01:51.890
another item is about
to start playing

00:01:51.890 --> 00:01:54.660
with up next notifications
and countdown timers

00:01:54.660 --> 00:01:58.470
to give your user a chance
to skip or cancel playback.

00:01:58.470 --> 00:02:00.720
For reference, we've
added Autoplay and Queuing

00:02:00.720 --> 00:02:03.620
to the example cast video apps
for Android, iOS, and web,

00:02:03.620 --> 00:02:05.940
so you can see it in action.

00:02:05.940 --> 00:02:08.300
Using Autoplay and Queuing
will engage your users

00:02:08.300 --> 00:02:11.180
and give you much,
much better retention.

00:02:11.180 --> 00:02:12.700
I'm Alex [? Deller, ?]
and I can't

00:02:12.700 --> 00:02:15.080
wait to sit back and
enjoy your app delivering

00:02:15.080 --> 00:02:18.090
me a seamless media experience.

