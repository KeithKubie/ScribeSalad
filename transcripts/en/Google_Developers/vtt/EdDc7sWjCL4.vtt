WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:44.340
&gt;&gt; NEUBERG: Today, I'm going to talk about
HTML5, but kind of in the larger sense. It's

00:00:44.340 --> 00:00:49.559
not going to just be strictly the HTML5, those
standard; we're talking about CSS3, will be

00:00:49.559 --> 00:00:55.270
talking about some of the new JavaScripts,
APIs; there'll be a little smidgen of WebGL

00:00:55.270 --> 00:01:02.750
and SVG, just to kind of throw things in.
And the structure of this presentation is

00:01:02.750 --> 00:01:07.270
there's a lot going on, and I wanted to kind
of give a sense of a lot of the different

00:01:07.270 --> 00:01:13.090
things that are happening. In this slide deck,
it's actually built using HTML5 and CSS3,

00:01:13.090 --> 00:01:18.080
and a lot of it--there'll be interactive portions
in the slide that will show you in effect

00:01:18.080 --> 00:01:22.360
some of these things. And thee slides are
actually have been created collaboratively

00:01:22.360 --> 00:01:26.430
by an open-source community. So, it's been
an ongoing open-source project to kind of

00:01:26.430 --> 00:01:32.270
create this educational slide deck. So, let's
get started. Where do widgets come from? So

00:01:32.270 --> 00:01:38.430
in the '90s, there was sort of a lot of progress
on the web with a lot of exciting things.

00:01:38.430 --> 00:01:42.280
And then the last 10 years, things kind of
slow down for a little bit. Big thing and

00:01:42.280 --> 00:01:49.530
sort of--2001--2002, was throw away tables,
use CSS; people embrace that. And in 2005,

00:01:49.530 --> 00:01:53.650
Ajax started taking off. the web kind of--sort
of coming back to life. The last few years,

00:01:53.650 --> 00:01:59.210
has been kind of the age of JavaScript toolkits.
Things like jQuery, prototype, Dojo, script.aculo.us.

00:01:59.210 --> 00:02:04.880
Who here uses jQuery, for example? It has
really take in world by storm and people really

00:02:04.880 --> 00:02:09.560
using that. And a lot of those were attempts
to kind of make the web an easier place to

00:02:09.560 --> 00:02:14.400
develop for and kind of--sort of iron over
its issues. And what's really exciting is

00:02:14.400 --> 00:02:19.359
starting in about 2009; we're starting to
really see the browsers themselves catch backup.

00:02:19.359 --> 00:02:23.349
So the development of HTML5, browsers are
actually starting to implement things like

00:02:23.349 --> 00:02:29.629
SVG. We're seeing new experiments in CSS3
and WebGL, so it's an exciting time. It's

00:02:29.629 --> 00:02:34.450
a great time to be a web developer. So the
next five years is going to be very exciting.

00:02:34.450 --> 00:02:37.459
And like I said, strictly, we're going to
be talking about things that are a little

00:02:37.459 --> 00:02:42.909
larger than just the HTML5 standard. We'll
be talking about CSS, which you need to get

00:02:42.909 --> 00:02:48.489
your job done, especially CSS3. And a lot
of this new JavaScript APIs that come along

00:02:48.489 --> 00:02:56.819
in HTML5, like geolocation. So let's start
with the JavaScript APIs. One of the things

00:02:56.819 --> 00:03:03.540
that is coming along is everyone uses sort
of "getElementById" and "getElementByTagname."

00:03:03.540 --> 00:03:08.470
But we--a new method is coming along called
"getElementsByClassName." And jQuery, again,

00:03:08.470 --> 00:03:14.249
really showed how powerful it is when you
can use CSS selectors in order to grab things

00:03:14.249 --> 00:03:20.230
from your page. So now, you could add the
class name business cards or events and get

00:03:20.230 --> 00:03:24.260
all of the elements on the page with this
new method. But you can go beyond this, a

00:03:24.260 --> 00:03:28.779
new method is coming along called "querySelectorAll."
And, again, a sort of like what jQuery gives

00:03:28.779 --> 00:03:35.180
you. And you can put an arbitrary CSS selector
in there. So right here, for example, we're

00:03:35.180 --> 00:03:41.560
saying, I've got an unordered list. Grab me
each of the list items. And then the nth-child,

00:03:41.560 --> 00:03:46.129
just give me the odd ones. So, you might imagine
using that to make a strapping pattern on

00:03:46.129 --> 00:03:50.909
a table for example or in a list. Here, we
have another one "querySelectorAll." We're

00:03:50.909 --> 00:03:57.819
saying, give me the table that has the class
name test, then give me its immediate table

00:03:57.819 --> 00:04:03.629
row, and then it's immediate, all of the table
elements. So, that one line will return you

00:04:03.629 --> 00:04:08.430
back a lot of things that in the old style
of having to use the document object model

00:04:08.430 --> 00:04:13.129
would have taken a lot of code. So, another
cool thing coming along is something called

00:04:13.129 --> 00:04:19.570
web storage. And let me show you the demo
first. So in this form--this form is being

00:04:19.570 --> 00:04:25.920
tied in the local storage. It's storing little
bits of data in your browser. If we restart,

00:04:25.920 --> 00:04:30.850
you saw that it stayed there. And if I restarted
the browser or the browser crashed it would

00:04:30.850 --> 00:04:35.071
still be there. So, the first thing you get
is you get a new thing called local storage,

00:04:35.071 --> 00:04:40.750
"window.localStorage." So, right here we say,
add an event listener when you've taken your

00:04:40.750 --> 00:04:46.220
hands off the keyboard in the text area. The
localStorage object is just like a hash table.

00:04:46.220 --> 00:04:51.730
You put key value pairs into it. So there
we are, we use value and we set it to the

00:04:51.730 --> 00:04:56.340
value of the text area. And on the next line
localStorage timestamp--there we are giving

00:04:56.340 --> 00:05:00.750
a timestamp. So, it was really easy to use
and it just persists. In getting the value

00:05:00.750 --> 00:05:07.340
it's just a straightforward, "window.localStorage",
give me my value. Now, when simple key value

00:05:07.340 --> 00:05:14.290
pair isn't enough, another part of HTML5 is
a real SQL database. Now, gears had this,

00:05:14.290 --> 00:05:20.600
and it was really fun--offline Gmail, for
example, uses the SQL storage inside of gears.

00:05:20.600 --> 00:05:25.850
And the HTML5 SQL storage is very similar,
it was inspired by it. And once you have a

00:05:25.850 --> 00:05:30.800
real SQL engine on the client side, you can
do all sorts of interesting things. Like sorting

00:05:30.800 --> 00:05:37.090
on a complex table that has a lot of data
or searching along different things. Let's

00:05:37.090 --> 00:05:43.390
look at the demo first. This is like a simple
little to do list. Well, throw me some to

00:05:43.390 --> 00:05:51.620
do lists like some items, like, you know,
shave yaks, learn HTML5. Anyone else have

00:05:51.620 --> 00:05:58.811
a task? It doesn't have to make any sense.
&gt;&gt; More pizza.

00:05:58.811 --> 00:06:11.080
&gt;&gt; NEUBERG: More pizza, good one. One more.
More chairs. More beer, we'll have that one

00:06:11.080 --> 00:06:19.780
too. So the cool thing is in Safari and in
Chrome, you can actually go into a new view

00:06:19.780 --> 00:06:25.390
where you can actually see all of your--what's
stored. And you can actually give SQL expressions

00:06:25.390 --> 00:06:32.430
against what's in your data which is really
powerful. And here is some code that shows

00:06:32.430 --> 00:06:37.670
how to use this. The first thing you do is
you open your database and you give your database

00:06:37.670 --> 00:06:41.750
a name and you give it a version. Why do you
think you want a version of these client-side

00:06:41.750 --> 00:06:50.250
databases? Synchronization, uh-huh, and migration,
people may go out of date. See, I might want

00:06:50.250 --> 00:06:54.920
to push some JavaScript that would update
a Schema, for example. When you open your

00:06:54.920 --> 00:06:59.400
database, it's on it. The next thing you want
to do is you want to do everything inside

00:06:59.400 --> 00:07:04.900
of a transaction. And HTML5 had you do all
your calls in a database inside of a transaction

00:07:04.900 --> 00:07:08.420
because the web is a very unforgiving environment
and it wants to make sure that all of your

00:07:08.420 --> 00:07:13.460
calls went through or they didn't in a solid
way. You know, browsers crash, users leave

00:07:13.460 --> 00:07:19.150
the page. So, the first thing you do, is you
say, give me your transaction, "tx", and once

00:07:19.150 --> 00:07:23.190
you have that you could execute your SQL.
And there we are executing some SQL there,

00:07:23.190 --> 00:07:29.170
select star from our test table. And then
you can provide arguments which we don't have.

00:07:29.170 --> 00:07:33.670
And actually results come back in another
callback, a successCallback and an errorCallback.

00:07:33.670 --> 00:07:40.520
Why do you think you would want to have your
results come back asynchronously? What's that?

00:07:40.520 --> 00:07:43.080
&gt;&gt; Non-blocking.
&gt;&gt; NEUBERG: Exactly. So it's non-blocking.

00:07:43.080 --> 00:07:49.170
What if you're querying a monstrous SQL table,
the browser will freeze. So if that doesn't

00:07:49.170 --> 00:07:54.280
happen, all results come back asynchronously
so it wouldn't be blocking the browser. So

00:07:54.280 --> 00:07:59.220
these different kinds of storage go hand-in-hand
with an application cache so you can take

00:07:59.220 --> 00:08:06.531
your browsers offline. To use this, the first
thing is you add a new attribute to your HTML

00:08:06.531 --> 00:08:14.120
tag, "manifest=", and then you give it a file
name, and in that file name, you provide a

00:08:14.120 --> 00:08:20.120
pointer to a file. And we have an example
file right down here. The first line of this

00:08:20.120 --> 00:08:25.490
file--you always say the word "cache-manifest."
Another important thing is this file needs

00:08:25.490 --> 00:08:29.860
to be served up with a special mind type.
So you have to configure your server. If you're

00:08:29.860 --> 00:08:34.200
running into weird stuff, that's an important
little thing to look for. You can give all

00:08:34.200 --> 00:08:38.500
sorts of options in here, we're going to keep
it simple. You can say what you want to cache.

00:08:38.500 --> 00:08:42.310
When you say "cache:" and then it'll provide
a list of resources. We're grabbing some ping

00:08:42.310 --> 00:08:47.340
files, some JavaScripts, some CSS. You can
actually give other kinds of things; you can

00:08:47.340 --> 00:08:51.579
kind of give whitelists of things that you
don't want to cache. Maybe when you're online,

00:08:51.579 --> 00:08:57.430
you had a server-side PHP script, but you
obviously want to do something else when you're

00:08:57.430 --> 00:09:04.740
offline. Two important things, one is that,
the way that the browser works with this is

00:09:04.740 --> 00:09:10.339
the browser grabs the cache manifest file
and it sees if anything--it sees if the file

00:09:10.339 --> 00:09:15.920
itself ever changed. If the file itself is
changed, it goes and downloads each of the

00:09:15.920 --> 00:09:22.120
files inside of it. And it only succeeds if
every single file successfully is downloaded.

00:09:22.120 --> 00:09:25.279
So that you're not in a weird in between state,
right? So you don't have half of what you

00:09:25.279 --> 00:09:31.930
need offline. So it's all works or all fails.
So the one thing to note is that the browser

00:09:31.930 --> 00:09:36.470
doesn't check to see whether the individual
files have changed, it only looks if the manifest

00:09:36.470 --> 00:09:43.140
file has changed. So, as a trick, if you want
to version your resources, you can just give

00:09:43.140 --> 00:09:47.709
a comment, like version one, and as soon as
you change that to, like, version two, the

00:09:47.709 --> 00:09:54.639
file signature will change and the browser
goes, "oh, okay, I need to download more resources."

00:09:54.639 --> 00:09:58.270
There's a whole slew of events that you can
subscribe to in order to give a nice user

00:09:58.270 --> 00:10:05.430
interface. So, you see up there "addEventListener('checking'"
so that you can provide some UI. And there's

00:10:05.430 --> 00:10:12.339
a whole bunch of these events that you can
subscribe to. Web Workers. Web Workers allow

00:10:12.339 --> 00:10:17.779
you to run code that won't that won't block
the browser. They're not threads but they

00:10:17.779 --> 00:10:23.199
kind of act like them. Let me show you a demo
first. So right here we have sort of Google

00:10:23.199 --> 00:10:28.040
Maps, and let's say, we want to find routes
between a bunch of different cities. Something

00:10:28.040 --> 00:10:34.569
that's really computationally intensive. If
we don't use workers and we try to drag--notice

00:10:34.569 --> 00:10:42.120
how it froze up there. I'm running my mouse;
it doesn't do anything--bad user experience.

00:10:42.120 --> 00:10:52.870
If we use workers, while it's thinking, the
browser can stay responsive. So, why would

00:10:52.870 --> 00:11:01.519
you want that? Well, there are demos showing,
you know, workers doing real-time image analysis

00:11:01.519 --> 00:11:07.529
of video in order to do, sort of tracking,
real time OCR, all sorts of interesting things

00:11:07.529 --> 00:11:12.019
moving to the client side to take advantage
of these machines. And let's look at some

00:11:12.019 --> 00:11:17.422
code using these. The first thing is you get
a new object called worker. So, you say, new

00:11:17.422 --> 00:11:21.290
worker, and you put the JavaScript that you
want to run inside that worker in another

00:11:21.290 --> 00:11:26.420
file. So, we say, "extra_work.js," and workers
communicate back with the page that called

00:11:26.420 --> 00:11:31.180
them by using messaging, right. So you, you
know, you send it a message, it sends you

00:11:31.180 --> 00:11:35.810
back a message. By the way, that's one of
the patterns, if you look to an HTML5 in a

00:11:35.810 --> 00:11:42.149
lot of the JavaScript APIs, they choose asynchronous
type calling most of the time. And they choose

00:11:42.149 --> 00:11:48.129
kind of a message style most of the time,
if you're looking for a common pattern. So,

00:11:48.129 --> 00:11:53.259
once we make our worker, in order to get results
back, we say "worker.onmessage." You give

00:11:53.259 --> 00:11:58.459
it a function that will get called and here
we are, we say, "{ alert(event.data); }." That

00:11:58.459 --> 00:12:02.300
would be the data that the worker has sent
me, right. You could imagine the workers calculating

00:12:02.300 --> 00:12:08.649
prime numbers for example. Inside of the "extra_work.js"
file, you could imagine we're doing some work.

00:12:08.649 --> 00:12:13.249
You have a new magic method called post message.
And you can post message with some data. It

00:12:13.249 --> 00:12:19.089
could be arbitrary JavaScript, so JavaScript
can get sent back and forth like JSON. I want

00:12:19.089 --> 00:12:25.060
to briefly talk about notifications. This
is actually not formally a part of HTML5.

00:12:25.060 --> 00:12:32.980
It's an experimental part of Chrome. It's
one of the things being proposed. And it allows

00:12:32.980 --> 00:12:39.980
you to do a little pop-up style, tossed messages.
So at first you have to give a site permission,

00:12:39.980 --> 00:12:57.311
we don't want sites being all annoying, so
we're allowing. And... [PAUSE] Yeah, there

00:12:57.311 --> 00:13:03.200
we go. So we have nice little notification
that appeared. To use this, again, lets look

00:13:03.200 --> 00:13:08.550
at some sample code. The first thing, you
get a new object called "window.webkitNotifications."

00:13:08.550 --> 00:13:15.329
You want to make sure that object is there.
And you call "checkPermission" and "checkPermission"

00:13:15.329 --> 00:13:21.589
will return zero if it's been allowed permission.
It's actually constant, if the user has allowed

00:13:21.589 --> 00:13:27.339
it before. If they have, we create a notification.
We say, "webkitNotifications.createNotification."

00:13:27.339 --> 00:13:32.350
And you'll see up here, we can pass a picture
in. So we pass a URL to an image. We can pass

00:13:32.350 --> 00:13:39.209
a title in. We can pass text and so on. You
can get pretty fancy. And then finally, if

00:13:39.209 --> 00:13:46.660
the users never given it, we say "webkitNotifications.requestPermission
 ()" and that will do that little gold bar

00:13:46.660 --> 00:13:51.879
you saw at the top. You know, asking, "Hey,
can the site do this?" Are there any quick

00:13:51.879 --> 00:13:57.730
questions before we continue? So the question
is what happens to the method get on us by

00:13:57.730 --> 00:14:01.399
name? Most people didn't about this, there's
an older method where you can enumerate things

00:14:01.399 --> 00:14:07.069
by name. It's an older method. It's predated
even having IDs on elements. It doesn't always

00:14:07.069 --> 00:14:14.889
were consistently across everything on a page.
It's essentially deprecated. So it's dangerous

00:14:14.889 --> 00:14:16.539
to use unless you really know what you're
doing, maybe a weird JavaScript hacker.

00:14:16.539 --> 00:14:21.699
&gt;&gt; How do we get the collections for radio
boxes and check boxes?

00:14:21.699 --> 00:14:25.480
&gt;&gt; NEUBERG: So you would give a query--how
do you get collections for radio boxes and

00:14:25.480 --> 00:14:30.559
check boxes? One of the things you'll see
when I go into see CSS3 is you can get pretty

00:14:30.559 --> 00:14:35.220
fancy with your CSS selectors. So you could
say, "Give me now the input of a check." And

00:14:35.220 --> 00:14:39.780
so you would pass into "querySelectorAll"
to get all the check radio buttons. So let's

00:14:39.780 --> 00:14:44.990
move on unfortunately, because we have a fair
amount of material left. One of the things

00:14:44.990 --> 00:14:50.589
about HTML5 is drag and drop. And, again,
we could spend the whole talk just talking

00:14:50.589 --> 00:14:56.930
about drag and drop. There's a lot of stuff
in here. But just to show you some sample

00:14:56.930 --> 00:15:02.360
code and some demos, the first thing you do
is you say, "document.addEventListener" and

00:15:02.360 --> 00:15:08.100
you subscribe to the "dragstart" event. Tell
me when dragging has started. Inside of there,

00:15:08.100 --> 00:15:14.740
you get an event object with a special data
transfer member, so you can say, "event.dataTransfer.setData"

00:15:14.740 --> 00:15:19.240
so you could override the data that's actually
being, you know, you could clean it up, you

00:15:19.240 --> 00:15:23.300
could do some special things to it, and then
you can actually do what's called an effect.

00:15:23.300 --> 00:15:28.171
So you could say--actually copy the data rather
than have a reference. We're actually going

00:15:28.171 --> 00:15:31.559
to control how things are shown to the user.
And there's a lot of different options, a

00:15:31.559 --> 00:15:35.600
lot of configuration. It's a little bit of
a hard API to use unfortunately but it's fairly

00:15:35.600 --> 00:15:42.290
powerful. As an example, I'm dragging this
image. If I drop it into the drop area, over

00:15:42.290 --> 00:15:48.989
here you see what some code would get. You
can get your results and essentially different

00:15:48.989 --> 00:15:53.730
kinds of flavors. So here we are grabbing
a URI list and here we are grabbing a URL

00:15:53.730 --> 00:15:59.569
which is just the reference to the image.
Here I am selecting some text and I'm dragging

00:15:59.569 --> 00:16:04.699
out over here. And in this, we're making the
original text so it's actually--it's exactly

00:16:04.699 --> 00:16:09.730
the same text that was dragged. But you could
get fancy. Let's say I grab this text and

00:16:09.730 --> 00:16:17.589
drag it. What is on the--but drag and drop
is different. So we've added some HTML into

00:16:17.589 --> 00:16:23.649
it. I know people can see that so it's a strong
overwritten consent and strong. So basically,

00:16:23.649 --> 00:16:29.329
you can kind of hook in a different levels
and do some very powerful things. The last

00:16:29.329 --> 00:16:34.680
of our JavaScript APIs for now is geolocation.
This is one of my favorite ones because I

00:16:34.680 --> 00:16:38.439
find it really easy to use and I think that
it opens up something that you couldn't do

00:16:38.439 --> 00:16:43.209
on the web before. Let's start with the demo.
So we have a Google Map and I drop the little

00:16:43.209 --> 00:16:50.780
location here showing us on Market Street.
To do that, the first thing is you look for

00:16:50.780 --> 00:16:56.690
the "navigator.geolocation" object. If it's
there, there's a great method, it's a simple

00:16:56.690 --> 00:17:01.740
method, "getCurrentPosition" which you give
it a callback and you get back a position

00:17:01.740 --> 00:17:05.380
object and it's really straightforward. Once
you have that, you can grab the latitude and

00:17:05.380 --> 00:17:12.360
the longitude and you could pass those two
numbers into an API for maps because those

00:17:12.360 --> 00:17:17.569
generally take those as an input. You could
pass that into a social networking App. You

00:17:17.569 --> 00:17:21.610
could do all sorts of interesting things.
One thing to mention is the first time you

00:17:21.610 --> 00:17:26.429
do this the browser will prompt the user saying,
"Hey, this site wants to know your position.

00:17:26.429 --> 00:17:30.470
Do you give them permission?" Because obviously,
again, we want the user to be in control of

00:17:30.470 --> 00:17:35.179
this; so the question is the fact that you're
being asked for geolocation that are built

00:17:35.179 --> 00:17:40.470
in the browser. Yes, that's totally built
into the browser. And, you know, actually,

00:17:40.470 --> 00:17:46.440
the iPhone will prompt you if a website uses
it. Different--Chrome or Firefox will prompt

00:17:46.440 --> 00:17:52.899
you as well because we don't want sites being
able to know your location without your permission.

00:17:52.899 --> 00:17:57.330
So that rounds out the JavaScript APIs. Obviously,
a lot of really cool new things, being able

00:17:57.330 --> 00:18:02.570
to build the desktop experience with things
like notifications, drag and drop; client-side

00:18:02.570 --> 00:18:07.730
storage let's you actually get better performance
by actually using these computers. I like

00:18:07.730 --> 00:18:13.200
to say the old web treated our machines like
they are Commodore 64s. We've got these amazing

00:18:13.200 --> 00:18:19.500
machines now with so much storage and power.
And HTML5 really uses the CPU on these machines

00:18:19.500 --> 00:18:24.450
with things like workers. Really uses the
hard drives on these things. I mean, we have

00:18:24.450 --> 00:18:29.519
100 of gigabytes and the web has not been
able to use this with a user's permission.

00:18:29.519 --> 00:18:37.309
So really expanding what the client site can
do. Let's look at some of the new tags that

00:18:37.309 --> 00:18:45.200
come along. It's like Christmas time. There's
all these nice new tags. Again, I'm just going

00:18:45.200 --> 00:18:51.399
to briefly touch on them, but you get some
new semantic tags. One of them is a header

00:18:51.399 --> 00:18:56.080
that just says, "Hey, this is a header at
the top of my page." Age group lets you have

00:18:56.080 --> 00:19:01.370
different little portions of that header.
You've got "nav" which is what it sounds like.

00:19:01.370 --> 00:19:07.590
It says, "Hey, this is a navigation section."
We've got a section element which just says--when

00:19:07.590 --> 00:19:11.750
you look at a page, you can say, "Hey, these
are different sections, right?" So now you

00:19:11.750 --> 00:19:17.049
can tell the browser, "Hey, this is the section
where my ads are. This is the section where

00:19:17.049 --> 00:19:22.649
my articles are and so on." There's an article
tag. And then inside of these, you can actually

00:19:22.649 --> 00:19:32.740
group these. So an article could itself have
a header and a footer. A side is actually

00:19:32.740 --> 00:19:36.580
for things that are not part of the normal
flow. So you've never read an article and

00:19:36.580 --> 00:19:40.779
you seem like a little blow out, right, with
a quote, that would be in the side. Or maybe

00:19:40.779 --> 00:19:44.769
you're reading an article on scientific American
and there's an info graphic; that would be

00:19:44.769 --> 00:19:49.640
in a side. What's nice about these--these
don't give you necessarily anything that you

00:19:49.640 --> 00:19:54.290
couldn't do by setting a CSS class name. But
the nice thing is it keeps your markup, it's

00:19:54.290 --> 00:20:00.000
more semantic. It helps search engines. If
you want your page to be screen scraped especially

00:20:00.000 --> 00:20:04.919
when we get to micro data, which I'll talk
about, you are helping other machines understand

00:20:04.919 --> 00:20:11.470
your page in a better way and you're also
making your page more maintainable. One of

00:20:11.470 --> 00:20:15.870
the things an HTML5, one of the big philosophies
is to codify what people are already doing.

00:20:15.870 --> 00:20:22.470
One of the ideas is called, you know, pave
the cow paths. There's a famous story of a

00:20:22.470 --> 00:20:25.929
cow. They didn't know where they wanted to
make the paths so they made everything grass.

00:20:25.929 --> 00:20:30.000
And they saw where the grass was, you know,
was sort of lower because everyone walk there

00:20:30.000 --> 00:20:33.820
and then that's why they made the sidewalks.
That's especially true with things like this

00:20:33.820 --> 00:20:39.210
link relations. These have all existed. HTML5
just says, "Hey, it's okay to use them. You

00:20:39.210 --> 00:20:46.019
don't have to feel guilty about using them."
So I'm not going to explain them all, but

00:20:46.019 --> 00:20:51.990
like "rel=icon" gives you a little "favicon,"
you know, over in the browser bar. Pingback

00:20:51.990 --> 00:20:59.120
is interesting. Pingback--a page can say,
"Here's a URL if another page links to me,

00:20:59.120 --> 00:21:04.820
whether it's a comment. Ping this URL and
tell me," and then that page can maintain

00:21:04.820 --> 00:21:12.230
all of the links that point in. Wordpress,
for example, does this. Prefetch, I think

00:21:12.230 --> 00:21:15.730
Firefox innovated this one. Prefetch says,
tells the browser, "Hey, it might be a really

00:21:15.730 --> 00:21:19.850
good idea to grab this page or these collection
of pages because it will improve the user

00:21:19.850 --> 00:21:24.910
performance, because they'll probably click
on IT." Son on things like archives points

00:21:24.910 --> 00:21:35.130
to archives and so on. Microdata, I'm really
excited about this one. Microdata gives you

00:21:35.130 --> 00:21:41.409
a way to sprinkle a little bit of extra information
in your page or metadata to help, again, search

00:21:41.409 --> 00:21:46.450
engines, third party tools. And the thing
I love about it is it doesn't try to boil

00:21:46.450 --> 00:21:52.650
the ocean, it's not trying to be, you know,
artificial intelligence markup language. And

00:21:52.650 --> 00:21:57.630
it's learning from a lot of the lessons of
the last 15 years from things like micro formats,

00:21:57.630 --> 00:22:01.561
which showed, hey, you want to mix your data
into your HTML because people are actually

00:22:01.561 --> 00:22:05.190
going to do things there, you want to keep
it simple. It learned some of the lessons

00:22:05.190 --> 00:22:09.770
you've already have, you know, a little bit
of a sophisticated but it doesn't go overboard.

00:22:09.770 --> 00:22:18.850
And--first of all, I'll give the benefit.
Right now, Google will actually see some microdata

00:22:18.850 --> 00:22:24.340
markups for like events, reviews in order
to give better search results. So down here,

00:22:24.340 --> 00:22:29.389
there's a rich snippets testing tool. We're
giving like a URL to let's say, like a pizza

00:22:29.389 --> 00:22:34.580
shop. And down here you'll see a result where
it knows, for example, the name of the pizza

00:22:34.580 --> 00:22:39.649
place, the location. It has ratings because
there were some microdata that said, "Hey,

00:22:39.649 --> 00:22:47.340
here's how many stars that was given and so
on." Let's quickly look our example, microdata.

00:22:47.340 --> 00:22:52.600
The first thing is that you should know is,
again, you mix this in your HTML. Let's say

00:22:52.600 --> 00:22:56.830
we have an event, you would mix it into the
HTML, and generally it should be things that

00:22:56.830 --> 00:23:03.929
are visible to the user. Like a review, or
in this case, information about a band. The

00:23:03.929 --> 00:23:09.020
first thing you do is you say, "itemtype"
and you give the URL that's arbitrary, that

00:23:09.020 --> 00:23:14.809
just says, that points to your--whatever you're--it
doesn't actually point to anything it can.

00:23:14.809 --> 00:23:19.899
But it can be, you know, anything that starts
with this "itemtype" will be event or will

00:23:19.899 --> 00:23:26.260
in events, or will be a resume. And then you
give "itemscope", so you say, this is where

00:23:26.260 --> 00:23:32.200
my band information starts. This is where
my event information starts. And then you

00:23:32.200 --> 00:23:37.760
give each of the item properties. So, there,
we say, "itemprop='name'". So we're giving

00:23:37.760 --> 00:23:43.240
the name of one of the members of the band,
Neil. We're giving "itemprop='band'". The

00:23:43.240 --> 00:23:47.730
name is Four Parts Water and then we're giving
the nationality for example of the band, which

00:23:47.730 --> 00:23:54.539
is British. So, really straightforward and
you can--there's already a number of these

00:23:54.539 --> 00:24:01.600
sorts of very simple markups that you can
annotate your pages with. So, ARIA is actually

00:24:01.600 --> 00:24:06.889
again, not necessarily part of HTML file but
some thing is finally arriving. How many of

00:24:06.889 --> 00:24:14.120
you use like jQuery UI or Dojo UI? Right,
you might use these JavaScript widgets that

00:24:14.120 --> 00:24:19.830
give you a "tree" or give you sort of like
a data control, things like that. One problem

00:24:19.830 --> 00:24:25.450
with those is screen readers can't work with
it. So ARIA, which I'm really impressed by,

00:24:25.450 --> 00:24:29.769
is a way to kind of overlay a little bit of
extra information. So screen readers know

00:24:29.769 --> 00:24:35.611
that, that jQuery UI component that was a
"tree"--is a "tree," right? And most of these

00:24:35.611 --> 00:24:41.649
widgets produce HTML. So they just annotate
the HTML that they produce which the screen

00:24:41.649 --> 00:24:47.029
readers can see. Which accessibility tool
can see? So, here's an example, here's let's

00:24:47.029 --> 00:24:54.420
say, some of the HTML of a "tree." We have
an unordered list, and we say, "role=tree".

00:24:54.420 --> 00:24:57.941
So were saying, this one in unordered list,
it's not an unordered list. It's actually

00:24:57.941 --> 00:25:03.409
a tree control. And then we can give special
thing "aria-labelledby" which gives a nice

00:25:03.409 --> 00:25:09.799
label to maybe present or say, or showed magnified
so that a user can know what it is. And then

00:25:09.799 --> 00:25:14.100
on each of the little list items we give the
"role". So we're saying that first list item,

00:25:14.100 --> 00:25:20.919
that's actually a tree item. And we're seeing
"aria-expanded='true'". So, you could imagine

00:25:20.919 --> 00:25:27.260
that if your JavaScript widgets says, "aria-expanded='false'"
the screen reader will know that and be able

00:25:27.260 --> 00:25:33.059
to interact with it. And then, here we have
a group. So we say, "role=group" we give them

00:25:33.059 --> 00:25:37.220
a tree items. So it's a pretty straightforward
standard. It gives you a lot of bang for the

00:25:37.220 --> 00:25:42.940
buck. Again, but the basic idea is you give
the role of things and you kind of say, what

00:25:42.940 --> 00:25:49.559
things are a little bit to help the screen
readers. Another part of HTML which is just

00:25:49.559 --> 00:25:56.470
arriving, which I think is going really make
an impact, is this new form field types. So,

00:25:56.470 --> 00:26:02.149
right here for example, here's a range. We
didn't have to make that with JavaScripts.

00:26:02.149 --> 00:26:07.820
We just have a new input type, "type='range.'"
We give the minimum, the maximum and the defaults

00:26:07.820 --> 00:26:13.960
and the browser gave it to us. There's a nice
new attribute on input controls called "autofocus"

00:26:13.960 --> 00:26:18.409
which just says, "Hey, when the page loads,
give that field "autofocus"". Probably like,

00:26:18.409 --> 00:26:26.090
90% of the JavaScript out there is to do that.
So, a lot of HTML5 is, again, pave the cow

00:26:26.090 --> 00:26:30.370
paths, get things out of JavaScript that don't
really belong there, get them back in the

00:26:30.370 --> 00:26:35.110
browser so we can have a more reliable web
and continue moving forward. Another simple

00:26:35.110 --> 00:26:40.759
one, we have a new attribute called "placeholder".
So here I've input "side=text" at text field

00:26:40.759 --> 00:26:47.120
and "placeholder" will give you some nice
fancy little grayed out text when I go inside.

00:26:47.120 --> 00:26:50.310
Little things, but things like this if you
are a web developer is a pain in the butt,

00:26:50.310 --> 00:26:55.220
you have to do it yourself. Now, you get an
attribute to do it. Like I said there's all

00:26:55.220 --> 00:26:59.360
sorts of other cool input controls that are
not widely implemented yet. Opera gets a gold

00:26:59.360 --> 00:27:03.539
star. They actually implement most of them
I think. Things like menu for a menu, progress

00:27:03.539 --> 00:27:10.420
bar. So you can show progress, time and so
what. Those are going to be nice if they start

00:27:10.420 --> 00:27:17.520
showing up. So I think HTML5 video has gotten
a lot of press lately. Let's start with audio.

00:27:17.520 --> 00:27:34.379
Let me show you the demos first. Let's start
with the French's national anthem. And of

00:27:34.379 --> 00:27:41.370
course, this control right here is all given
by the browser and JavaScript can interact

00:27:41.370 --> 00:27:47.889
with it. Audio, it's pretty simple, we seen
audio tag. Control just says, "Hey, let the

00:27:47.889 --> 00:27:51.559
browser to give me controls." You could not
do that and do your own custom funky controls

00:27:51.559 --> 00:27:56.691
if you want to. And, of course, we get a JavaScript
API, so there we are. We grab the audio tag

00:27:56.691 --> 00:28:01.320
and we said ".muted='false'" which mutes it.
Again, there's a whole bunch of options here.

00:28:01.320 --> 00:28:13.259
You can nest multiple content types and so
on. Let's look at the video.

00:28:13.259 --> 00:28:19.450
So, again, when I hover over I get--the browser
gives me a control, and this is really a part

00:28:19.450 --> 00:28:24.140
of the browser. So we're adding CSS reflection.
That's one of the interesting things. It gets

00:28:24.140 --> 00:28:33.000
this out of a black box, and you can actually
start applying. Think of all--that's what's

00:28:33.000 --> 00:28:38.210
so cool about HTML5, they're like little tools,
like many little pieces that you can hook

00:28:38.210 --> 00:28:43.221
together in interesting ways. You can, you
know, style SVG with CSS3. So, you can do

00:28:43.221 --> 00:28:49.240
vector graphics that uses cascading style
sheets. You can add animations on top of HTML5

00:28:49.240 --> 00:28:53.080
video. So there's this cool interlocking pieces,
they get us outside of a little box on the

00:28:53.080 --> 00:29:02.250
page. And again, very similar of the audio
tag, we have a video tag. When we say auto-play

00:29:02.250 --> 00:29:07.110
which means, "Hey, start this when page is,
you know, loaded." Controls, we'll give you

00:29:07.110 --> 00:29:11.580
those controls. And we have, you know, simple
methods like play. And again, for both of

00:29:11.580 --> 00:29:15.669
these there's a whole slew of events you can
listen to, to know where, you know, is it

00:29:15.669 --> 00:29:22.620
buffering, is it done, if you want those hooks
to give a nice interface to your users. So

00:29:22.620 --> 00:29:29.639
canvas; canvas is like an easy way to draw
on the page. It gives you a really straight

00:29:29.639 --> 00:29:34.450
forward JavaScript API. Right down there is
actually the results of the code that you

00:29:34.450 --> 00:29:37.889
see up there. And the first thing you have
is you set--you have a canvas tag, you give

00:29:37.889 --> 00:29:42.290
it an ID. Think of it like a little paintable
area, give it a width and height. And then

00:29:42.290 --> 00:29:47.840
inside your JavaScript, you grab a reference
to the canvas, you say, "getContext("2D")"

00:29:47.840 --> 00:29:53.830
and I'll show you the hooks, that opens up
having a 3D context which we'll see with WebGL.

00:29:53.830 --> 00:29:56.389
And then once you have that you make calls
on it. So there we are, we'll make a fill

00:29:56.389 --> 00:30:03.019
rectangle, there's our black rectangle, we
begin a path, we make an arc, we set a width,

00:30:03.019 --> 00:30:07.890
we make the ends rounded, we set the stroke
style. And I'll be talking about this. You

00:30:07.890 --> 00:30:14.220
may have seen RGB, but one of the new things
is RGBA, which just allows you to give opacity

00:30:14.220 --> 00:30:18.419
on colors. You can do nice effects with that.
And then finally we say ".stroke" to actually

00:30:18.419 --> 00:30:28.610
draw the thing. Here's a canvas example to
interact with things. Canvas is--the way--people

00:30:28.610 --> 00:30:33.309
always ask me how should I think of canvas
in SVJ? Canvas is really good essentially

00:30:33.309 --> 00:30:38.360
as sort of bitmap operations. If you want
to make something that's like Photoshop, then

00:30:38.360 --> 00:30:44.399
you would be using canvas they're pixels.
So, look, I just exported this to JPEG, it

00:30:44.399 --> 00:30:47.690
was one of the things that you can do with
canvas. I exported this to ping what you see

00:30:47.690 --> 00:30:56.279
here. SVG is vectors. If you were doing something
like illustrator, which is type illustration,

00:30:56.279 --> 00:31:00.890
that's when you would use that technology.
So, pixels or vectors, and they both have

00:31:00.890 --> 00:31:08.429
different uses in your tool kit. One of the
cool things in HTML5 is it says that you can

00:31:08.429 --> 00:31:14.279
now natively use SVG. People ask what is SVG?
SVG, just like HTML it gives you bunch of

00:31:14.279 --> 00:31:20.070
tags like form and table. SVG just gives you
bunch of extra new tags like circle, rectangle,

00:31:20.070 --> 00:31:27.389
that you can mix in. And HTML5 says you can
now drop this tags into normal HTML. The people

00:31:27.389 --> 00:31:31.249
had followed this in the past. You had used
something called XHTML, you had to jump there

00:31:31.249 --> 00:31:36.440
some hoops, so it kind of streamlines SVG
a little bit. Here we are in some HTML, we

00:31:36.440 --> 00:31:41.250
just say this SVG, and we're doing a couple
of different things in the circle. The nice

00:31:41.250 --> 00:31:47.440
thing about this is it's just like HTML. We
can give them IDs, we can give them classes

00:31:47.440 --> 00:31:53.210
so we can have common styles. Here I am putting
the center of the circle right here, 50% of

00:31:53.210 --> 00:32:03.399
the way in the page and then down 25%, I'm
putting a radius. One of the cool things is

00:32:03.399 --> 00:32:07.259
you could do gradient fills. So, here I am
referencing a fill that I've defined which

00:32:07.259 --> 00:32:12.720
is not on the page here. And then again, you
can use all your JavaScript skills. So, on

00:32:12.720 --> 00:32:20.870
mouse down, says, hello. Here's a nice SVG
example to show. Here we have the tiger; a

00:32:20.870 --> 00:32:33.490
classic illustrated tiger. And as we zoom
in, things still stay nice. Canvas 3D, or

00:32:33.490 --> 00:32:40.210
WebGL; now, this is still kind of being baked
but it's a very exciting thing. What you're

00:32:40.210 --> 00:32:44.409
seeing down there is being rendered right
now, that's not a movie. Those are 3D graphics

00:32:44.409 --> 00:32:51.300
being drawn by JavaScript. And WebGL looks
and feels like the standard HTML5 canvas.

00:32:51.300 --> 00:32:56.509
You have a canvas tag up there, you get it.
When you do something magically you say, "getContext",

00:32:56.509 --> 00:33:02.220
and from now you say, "("experimental-webgl")",
and that hands you back an object that is

00:33:02.220 --> 00:33:08.340
a simply open GL with the JavaScript wrapper.
And then we are making a viewport which just

00:33:08.340 --> 00:33:14.220
says, we're in the 3D space, you know, it
kind of--where's my sizing. Now these things

00:33:14.220 --> 00:33:19.850
all start coming together. With workers in
faster JavaScript and web browsers, you can

00:33:19.850 --> 00:33:24.919
imagine doing lots of scene graph protection
and powerful things on a worker not to block

00:33:24.919 --> 00:33:31.279
the browser, passing messages back over, that's
drawing to a WebGL context, that's maybe showing

00:33:31.279 --> 00:33:37.159
like cool readouts on your game with canvas
that might be bringing in graphical resources

00:33:37.159 --> 00:33:43.289
as SVG. So, again, remember, think about this,
you know, many pieces that work together.

00:33:43.289 --> 00:33:53.700
So, the final thing is CSS3. One of the first
thing that CSS3 brings you are more of these

00:33:53.700 --> 00:34:00.429
selectors, so what are these selectors? CSS
binds on to the thing on your page using selectors,

00:34:00.429 --> 00:34:06.900
and CSS3 gives you more of them based on what
people have asked for. The first one, we say,

00:34:06.900 --> 00:34:13.090
".row:nth-child(even)" will give me the even
version of the list, and then you could do

00:34:13.090 --> 00:34:17.869
the odd. And why would you want to do that?
Well, it used to be so hard to have a list

00:34:17.869 --> 00:34:21.369
of data, and to make something more readable
you generally want to make it, you know, every

00:34:21.369 --> 00:34:25.800
other color right, the eye can follow it like
that little row there. That was really hard

00:34:25.800 --> 00:34:30.480
to do. You had to do like server-side processing
to write out different classes. Now, you can

00:34:30.480 --> 00:34:37.970
do it with just a little bit of CSS. Something
called "inline-block." This one's hard to

00:34:37.970 --> 00:34:43.750
describe but it's really cool. How many of
you have ever tried to use CSS trying to replace

00:34:43.750 --> 00:34:48.790
tables? And you want like some images to go
right next to each other, you want them to

00:34:48.790 --> 00:34:57.250
line up, and when the width of the page changes,
you wanted to kind of go down. Yeah, basically,

00:34:57.250 --> 00:35:02.109
something that you really need to kind of
replace tables. Inline block kind of gives

00:35:02.109 --> 00:35:06.579
you a midway between a block level elements
and an inline level element; it kind of gives

00:35:06.579 --> 00:35:10.530
you qualities of both. And I encourage you
to take a look more at it, we don't have time

00:35:10.530 --> 00:35:17.809
to go deep into it. But it's one of these
CSS properties that allows you to do tasks

00:35:17.809 --> 00:35:21.900
that really use to require tables in a straightforward
way. You'll see that when we get to columns,

00:35:21.900 --> 00:35:27.410
by the way, as well. Someone had asked about
specific attributes; well, now, you can actually

00:35:27.410 --> 00:35:34.240
match "[type="text"]" for example, so you
can actually match on attributes. Well, you

00:35:34.240 --> 00:35:39.060
could imagine putting this with microdata,
saying this is an event, or some of these

00:35:39.060 --> 00:35:49.660
new semantic tags. So, you might say article,
bracket, item type or sort of item prop equals

00:35:49.660 --> 00:35:55.660
importance. You know, you could start working
at higher level in your CSS and that' where

00:35:55.660 --> 00:36:00.410
those attributes start coming in. Negation;
this is interesting. You had ":not." So we're

00:36:00.410 --> 00:36:05.310
saying ":not" if you have something as the
class name box, or saying if something is

00:36:05.310 --> 00:36:11.160
not a span, so you kind of do an inverse.
And finally, we can do more specific targeting.

00:36:11.160 --> 00:36:16.650
We get like that ":first-child," which we
get--let's say, we've got a header element.

00:36:16.650 --> 00:36:20.490
And let's say we've got a nice image as the
first thing, well, that will grab us the first

00:36:20.490 --> 00:36:26.339
child and when we can do fancy stuff on it.
And then, other ones--look what was in the

00:36:26.339 --> 00:36:33.770
bracket, the "+" is adjacency. So it says
if I have an h2 element right next 2 a header

00:36:33.770 --> 00:36:38.520
element, then do this. So these selectors
might seem kind of drive but they allow you

00:36:38.520 --> 00:36:45.079
to do a lot of common tasks and grab things
on your page. One of the cool things--this

00:36:45.079 --> 00:36:49.609
is actually CSS 2.1, but it's finally arriving.
It's taking my 10, 15 years for web fonts

00:36:49.609 --> 00:36:57.340
to arrive and they're finally arriving. To
use them you say, "@font-face," you give your

00:36:57.340 --> 00:37:03.460
font a name like we have "font-family: 'Leaguegothic',"
and you point it to a font file. There's a

00:37:03.460 --> 00:37:11.030
lot and discussions about which font files--personally,
I believe, that open type has sort of arrive

00:37:11.030 --> 00:37:15.490
as the de facto thing that folks can use,
but other browsers have other standards which

00:37:15.490 --> 00:37:21.770
you can kind to patch over. But there, we've
got a grabbing "LeagueGothic.otf." And then,

00:37:21.770 --> 00:37:26.569
you can use it like any other font. So we
say, header, "font-family: 'LeagueGothic',"

00:37:26.569 --> 00:37:31.250
and here's a little font down here and it's
not an image. So you can treat it as little

00:37:31.250 --> 00:37:35.960
text. I can print it. A search engine can
work of it better. If I change the size of

00:37:35.960 --> 00:37:42.760
the browser, if I zoom in because I need accessibility,
it still stays a font. Here's another one

00:37:42.760 --> 00:37:46.280
with those nice little things that you don't
know you want it until you need it. Something

00:37:46.280 --> 00:37:49.390
called the ellipsis, it's something like a
bunch of texts and it doesn't know how to

00:37:49.390 --> 00:37:54.950
squeeze in the page. I want to be able to
add three little dots if the size changes.

00:37:54.950 --> 00:37:58.300
You have no idea how many people--how much
pain people have gone through having to do

00:37:58.300 --> 00:38:04.240
server-side solutions to calculate these things.
Make it a nice "text-overflow: ellipsis."

00:38:04.240 --> 00:38:08.460
We see up here, it doesn't have it but right
here it does. So, as we change the width,

00:38:08.460 --> 00:38:14.630
you see those three little dots, it gives
the ellipsis. You'll see this with the boarder

00:38:14.630 --> 00:38:18.589
like the rounded corners too; people used
stuff to go through for these things. Here

00:38:18.589 --> 00:38:23.520
we are with columns; again, some of it was
used to be a pain in the butt to do. We say,

00:38:23.520 --> 00:38:30.580
give me two columns, here we do--making a
little rule and we put a gap and we are changing

00:38:30.580 --> 00:38:39.030
the number of columns. People [INDISTINCT].
So to do this in the past, you had to make

00:38:39.030 --> 00:38:44.270
like weird wrappers and do funky stuff in
your markup and like do negative margins and,

00:38:44.270 --> 00:38:49.270
we're like, you know, a lot of us in the community,
we say that you shouldn't have to be a wizard

00:38:49.270 --> 00:38:53.710
with HTML or JavaScript or CSS to do things
that everyone needs to do. So a lot of the

00:38:53.710 --> 00:38:57.900
stuff is about--you don't have to be a wizard,
you can just get your job done. Text stroke

00:38:57.900 --> 00:39:03.030
is a pretty simple. Here I am changing the
width. You have more control now over stroking.

00:39:03.030 --> 00:39:09.040
So here we are, saying photos are black, make
the stroke, which is the outside red, and

00:39:09.040 --> 00:39:15.130
then change the width. I talked about RGBA.
It's a little letter but it makes a big difference.

00:39:15.130 --> 00:39:18.740
In the past, you could just get red, green,
blue. Now, you can give fourth channel which

00:39:18.740 --> 00:39:22.490
is opacity, letting you do some nice effects.
So here we have red, green, blue and then

00:39:22.490 --> 00:39:28.811
the opacity, so we're saying 75%; and if I'll
change that, there's the text and then on

00:39:28.811 --> 00:39:35.220
my background it has one of these two. This
used to require--you'd have to like custom-make

00:39:35.220 --> 00:39:42.530
images for every single permutation and push
them down to the client. Now, you can just--again,

00:39:42.530 --> 00:39:47.200
this go--this could be a web font. There could
be SVG and, yeah, these things go together.

00:39:47.200 --> 00:39:54.150
So now, you can use the client like it's more
than a Commodore 64. This has kind of settle--there's

00:39:54.150 --> 00:40:01.580
a whole another color model called hue/saturation/luminance,
HSL. And the reason that matters is humans

00:40:01.580 --> 00:40:06.380
don't think of colors in terms of how RGB
asks you to think of colors. Artists, graphic

00:40:06.380 --> 00:40:10.760
designers think of colors in terms of hue,
which is like the color of something, saturation

00:40:10.760 --> 00:40:15.170
which is like how grey it is, luminance which
how bright it is. So, this allows graphic

00:40:15.170 --> 00:40:20.500
designers and so on to make colors the way
that people more naturally think about colors.

00:40:20.500 --> 00:40:25.780
So here we are changing these different things.
This is one of things showing up in more browsers,

00:40:25.780 --> 00:40:35.760
then, of course, we have the opacity. Rounded
corners, I know. I love it, it's great; easy,

00:40:35.760 --> 00:40:40.560
a pain in the butt to make the rounded corners.
It's amazing how just the common things used

00:40:40.560 --> 00:40:51.260
to be so hard. We had now a border-radius;
you look at the outside, changes it.

00:40:51.260 --> 00:40:54.800
Gradients; again, this could be a deep subject.
I'm not going to go into all of them. But

00:40:54.800 --> 00:41:00.099
CSS3 gives you gradients. We have linear gradient
at the top. We just say, start at the top,

00:41:00.099 --> 00:41:04.730
go down to the bottom, and then we get stops,
so you can give multiple stops. There we are

00:41:04.730 --> 00:41:08.920
going between two different colors. And we
have radial gradients, which obviously gives

00:41:08.920 --> 00:41:14.369
you a radial and you give like an arc and
you give a radius. Here we are just changing

00:41:14.369 --> 00:41:20.340
that. And again, you can have again have an
opacity channel so there could be on top or

00:41:20.340 --> 00:41:28.661
something. With great power comes great responsibility.
Shadows, again, text-shadows there we are

00:41:28.661 --> 00:41:36.270
controlling the horizontal, the vertical,
they offset. Unfortunately, box-shadows not

00:41:36.270 --> 00:41:41.560
working right now, I can't show that one.
So I love this one. Instant Web 2.0--so, here's

00:41:41.560 --> 00:41:50.540
our logo. We add a text-shadow first and then
we add a linear gradient. And we put some

00:41:50.540 --> 00:42:00.020
little round on the sides and then we add
the reflection.

00:42:00.020 --> 00:42:04.750
Simple things around CSS3 give you background
enhancements. So it used to be in a lot of

00:42:04.750 --> 00:42:09.240
control, if you made a background image. Now,
you have a new background-size. So you can

00:42:09.240 --> 00:42:14.580
say, "always make sure if something's in a
box that contains it." You can say, "It's

00:42:14.580 --> 00:42:19.630
okay if you clip the corners of me, or always
cut the corners of me." And then, you could

00:42:19.630 --> 00:42:24.020
say, always, you know, "Scale me, 100%." So
just more control and you can now have multiple

00:42:24.020 --> 00:42:31.970
backgrounds. Again, so you don't have to spend
all your time at Photoshop. Here we have--thanks.

00:42:31.970 --> 00:42:37.809
Here we have two backgrounds. A little toggle
here and some nice little... So transitions,

00:42:37.809 --> 00:42:41.030
again, a deep subject. We could spend a lot
of time talking about this, but now you have

00:42:41.030 --> 00:42:49.160
the CSS3 animations. So here we have, you
know, here's the old school left and right.

00:42:49.160 --> 00:42:54.950
We're just changing the class name of this
little box and nothing quite happens. But

00:42:54.950 --> 00:42:58.990
now, we change--we've got a Webkit transition
where we're saying change the margin over

00:42:58.990 --> 00:43:03.990
one second ease-in and then ease-out, and
you'll see what I mean. So we say, "Oh." It's

00:43:03.990 --> 00:43:12.780
all kind of accelerated and stacks are ease-in
and ease-out and it's changing the margin.

00:43:12.780 --> 00:43:17.750
And it's going against this, we changed the
margin left right here. So we're saying go

00:43:17.750 --> 00:43:22.799
to what its definition should be over one
second, so a really simple, straightforward

00:43:22.799 --> 00:43:29.820
animation. Transition this can go together.
Here we have using a colon hover which is

00:43:29.820 --> 00:43:35.500
a great pseudo-class which is--it can replace
a lot of JavaScript, were you just say, you

00:43:35.500 --> 00:43:42.020
know, when I'm hovered over apply this rule
and here we are applying this simple transform

00:43:42.020 --> 00:43:51.960
to rotate and scale and, its also 3D. So we
can actually rotate across the Z axis. Doing

00:43:51.960 --> 00:43:59.579
fancy. That would [INDISTINCT] kind of iTune
style, sort of shuffle type of things. CSS

00:43:59.579 --> 00:44:03.000
animations, again, it could be a deep subject
but from a high level you define your keyframes,

00:44:03.000 --> 00:44:07.910
you say "This should be here and then this
should be here" and then you can define new

00:44:07.910 --> 00:44:15.460
animations over certain amount of time and
we're getting this. So you could remake the

00:44:15.460 --> 00:44:23.380
blink tag if you want. So were these things
supported? That can be a complicated subject

00:44:23.380 --> 00:44:31.520
because it's really fast changing these days,
you know, Firefox 3.0, 3.5, 3.6, Chrome, IE8

00:44:31.520 --> 00:44:37.339
actually has a number of HTML5 things in it;
IE9, congrats to them, it has a lot of really

00:44:37.339 --> 00:44:41.850
cool stuff in it. You know, new versions of
Chrome are always kind of being pushed to

00:44:41.850 --> 00:44:48.410
you that have new things implemented. One
just got sent pretty recently, Safari. So,

00:44:48.410 --> 00:44:53.300
a lot of this thing to be use today, I'll
briefly mentioned Chrome frame, one thing

00:44:53.300 --> 00:44:58.490
that's interesting about it is this page itself
is actually could be viewed in IE6, 7 and

00:44:58.490 --> 00:45:06.770
8 if Chrome frame is present. And you just
drop a simple metatag and--I don't have my

00:45:06.770 --> 00:45:10.569
virtual machine set up, unfortunately. But
this whole presentation would run exactly

00:45:10.569 --> 00:45:15.700
as you see it inside of Internet Explorer.
So, that can be a good sort of a temporary

00:45:15.700 --> 00:45:23.079
way to help you deploy what you're doing.
So we have time for a few questions. Just

00:45:23.079 --> 00:45:27.990
about five minutes? Is that right? So the
question is, are there any limits on workers?

00:45:27.990 --> 00:45:33.380
And are we seeing--basically, how are we seeing
people use--oh, distribute to workers? So

00:45:33.380 --> 00:45:36.460
the first question, to be honest, I'm not
completely sure. I know that Gears used to

00:45:36.460 --> 00:45:43.190
have a 256 worker limit. I'm not sure what
the browsers themselves are doing. By the

00:45:43.190 --> 00:45:48.360
way, a lot of parts of HTML5 sort of Gears,
sort of got re-factored in so workers was

00:45:48.360 --> 00:45:51.849
one of those. And the second question is,
I've always had--would have been--it'd be

00:45:51.849 --> 00:45:56.870
really cool, you know if someone had a bit
of JavaScript that they, you know, have a

00:45:56.870 --> 00:46:03.040
distributed network, you know, steady at home
using workers, it'll be kind of crazy. Yes.

00:46:03.040 --> 00:46:08.390
So the question is can you inject ads into
an HTML5 video like you can do with Flash?

00:46:08.390 --> 00:46:16.140
I'm not going to--so HTML5 video gives you
a number of events. So you could imagine reusing

00:46:16.140 --> 00:46:22.520
the video surface to queue up and have control
and have a number of video resources that

00:46:22.520 --> 00:46:27.069
you've queued up. That you're just--just like
you dynamically changed the source of an image,

00:46:27.069 --> 00:46:31.930
you could say you get timeline events, so
I could say five seconds in or at the very

00:46:31.930 --> 00:46:37.450
beginning, you know. Say, the source equals
my ad and then when that's done, you say the

00:46:37.450 --> 00:46:42.560
source equals, you know, the content. That
would be one way to do it. So yes, you can

00:46:42.560 --> 00:46:49.750
do it. Yeah, but not with action script. What
about development tools? That's a great question.

00:46:49.750 --> 00:46:54.470
Someone could make a lot of money making great
development tools for the stuff. Go do it

00:46:54.470 --> 00:47:00.920
now before someone else does it. Hopefully,
Adobe will because they make great tools,

00:47:00.920 --> 00:47:06.589
they make great tools. I actually worked at
Flash as well and I--the tools are amazing.

00:47:06.589 --> 00:47:10.491
So I'd love to see it. Yeah. So the question
is I mentioned two features that asked for

00:47:10.491 --> 00:47:16.290
permission geolocation and notifications and
what other features use this and is there

00:47:16.290 --> 00:47:26.190
a common wave that they ask? Yeah. Other things
do ask, offline will ask, local storage, SQL

00:47:26.190 --> 00:47:34.210
storage will ask--I might be missing some
others. They all tend to do the butter bar

00:47:34.210 --> 00:47:39.800
approach which is you get a little butter
bar at the top. Browsers can choose to determine

00:47:39.800 --> 00:47:43.599
how they want to ask you, but most I believe
have been doing the butter bar approach like--since

00:47:43.599 --> 00:47:50.020
IE8, they've been doing a similar to butter
bar approach. So that's the level of consistency.

00:47:50.020 --> 00:47:58.039
So the question is do you have the ability
to style the browser's native or default controls?

00:47:58.039 --> 00:48:02.339
I don't believe that there's anything in the
spec that says that you can do that and I

00:48:02.339 --> 00:48:05.750
don't believe any browsers necessarily expose
that. I could be wrong if someone knows about

00:48:05.750 --> 00:48:12.250
that. I think it's an all or nothing type
of situation. So if you--you would just leave

00:48:12.250 --> 00:48:17.240
the controls tag off. And, again, you can
imagine just say on mouse hover, then you

00:48:17.240 --> 00:48:21.890
could use these different things to use that,
you know, the opacity now. Get a little CSS3

00:48:21.890 --> 00:48:29.450
animation, you know, say, you know, show dev,
position it, and you can, you know, relatively

00:48:29.450 --> 00:48:34.299
absolute over the video or down. So you could--you
just have to recreate it yourself. But, again,

00:48:34.299 --> 00:48:38.010
you use these pieces together. That why, again,
I like to say if a browser just chooses to

00:48:38.010 --> 00:48:44.060
implement HTML5 video the stuff goes together
and then your buttons, for example, would

00:48:44.060 --> 00:48:50.160
be a little less 3G resources. So they look
good on a giant media screen or on a small--so

00:48:50.160 --> 00:48:55.230
the resolution is independent. And so the
question is, for text at the slider tag which

00:48:55.230 --> 00:49:02.190
has no representation older browsers, how
do you handle degradation? So degradation

00:49:02.190 --> 00:49:07.820
can be done in a variety of ways. Most browsers
will keep those customs tags in the markup.

00:49:07.820 --> 00:49:15.060
And there are tricks for IE to force it to
see unknown tags and then you could do capabilities

00:49:15.060 --> 00:49:21.930
detection and then shim in some JavaScript.
You know, I mean we're doing--I mean I'm doing

00:49:21.930 --> 00:49:26.589
crazy shimming on for SVG and SVG Web. We
have the browser natively supports SVG, it's,

00:49:26.589 --> 00:49:32.010
you know, its beautiful. But if its not I'm
doing crazy JavaScript tricks. I'm shimming

00:49:32.010 --> 00:49:37.060
in Flash. So it depends on what you're trying
to do with an emulation that it brings it

00:49:37.060 --> 00:49:43.619
in and stuff. So you'd have to shim. All right;
well, thank you, everyone.

