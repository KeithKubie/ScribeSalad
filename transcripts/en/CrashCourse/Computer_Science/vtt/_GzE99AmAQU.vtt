WEBVTT
Kind: captions
Language: en

00:00:03.040 --> 00:00:05.800
Hi, I’m Carrie Anne, and welcome to CrashCourse
Computer Science!

00:00:05.809 --> 00:00:10.210
Last episode, we talked about the basics of
computer security, principles and techniques

00:00:10.210 --> 00:00:12.440
used to keep computer systems safe and sound.

00:00:12.440 --> 00:00:15.830
But, despite our best efforts, the news is
full of stories of individuals, companies

00:00:15.830 --> 00:00:20.390
and governments getting cyberattacked by hackers,
people who, with their technical knowledge,

00:00:20.390 --> 00:00:21.960
break into computer systems.

00:00:21.960 --> 00:00:23.420
Not all hackers are bad though.

00:00:23.420 --> 00:00:27.259
There are hackers who hunt for bugs and try
to close security holes in software to make

00:00:27.259 --> 00:00:28.980
systems safer and more resilient.

00:00:28.980 --> 00:00:33.250
They’re often hired by companies and governments
to perform security evaluations.

00:00:33.250 --> 00:00:35.930
These hackers are called White Hats, they’re
the good guys.

00:00:35.930 --> 00:00:40.450
On the flip side, there are Black Hats, malicious
hackers with intentions to steal, exploit

00:00:40.450 --> 00:00:42.610
and sell computer vulnerabilities and data.

00:00:42.610 --> 00:00:45.080
Hackers’ motivations also differ wildly.

00:00:45.080 --> 00:00:49.250
Some hack for amusement and curiosity, while
cybercriminals hack most often for monetary

00:00:49.250 --> 00:00:50.000
gain.

00:00:50.000 --> 00:00:53.860
And then there are hacktivists, who use their
skills to promote a social or political goal.

00:00:53.860 --> 00:00:55.720
And that’s just the tip of the iceberg.

00:00:55.720 --> 00:00:59.880
Basically, the stereotypical view of a hacker
as some unpopular kid sitting in a dark room

00:00:59.920 --> 00:01:05.220
full of discarded pizza boxes probably better describes John Green in college than it does hackers.

00:01:05.220 --> 00:01:07.200
Today, we’re not going to teach you how
to be a hacker.

00:01:07.210 --> 00:01:11.660
Instead, we’ll discuss some classic examples
of how hackers break into computer systems

00:01:11.660 --> 00:01:13.680
to give you an idea of how it’s done.

00:01:13.680 --> 00:01:22.500
INTRO

00:01:22.500 --> 00:01:26.740
The most common way hackers get into computer
systems isn’t by hacking at all; it’s

00:01:26.740 --> 00:01:28.890
by tricking users into letting them in.

00:01:28.890 --> 00:01:33.470
This is called social engineering, where a
person is manipulated into divulging confidential

00:01:33.470 --> 00:01:38.160
information, or configuring a computer system
so that it permits entry by attackers.

00:01:38.160 --> 00:01:42.229
The most common type of attack is phishing,
which you most often encounter as an email

00:01:42.229 --> 00:01:45.250
asking you to login to an account on a website,
say your bank.

00:01:45.250 --> 00:01:49.530
You’ll be asked to click a link in the email,
which takes you to a site that looks legit

00:01:49.530 --> 00:01:52.729
to the casual observer, but is really an evil
clone.

00:01:52.729 --> 00:01:56.520
When you enter your username and password,
that information goes straight to the hackers,

00:01:56.540 --> 00:01:59.280
who then can login to the real website as
you.

00:01:59.280 --> 00:02:00.120
Bad news!

00:02:00.120 --> 00:02:04.520
Even with a 1/10th of one percent success
rate, a million phishing emails might yield

00:02:04.530 --> 00:02:06.460
a thousand compromised accounts.

00:02:06.479 --> 00:02:11.120
Another social engineering attack is pretexting,
where attackers call up, let's say a company,

00:02:11.120 --> 00:02:14.260
and then confidently pretend to be from their
IT department.

00:02:14.260 --> 00:02:18.340
Often attackers will call a first number,
and then ask to be transferred to a second,

00:02:18.370 --> 00:02:20.900
so that the phone number appears to be internal
to the company.

00:02:20.900 --> 00:02:25.310
Then, the attacker can instruct an unwitting
user to configure their computer in a compromising

00:02:25.320 --> 00:02:29.160
way, or get them to reveal confidential details,
like passwords or network configurations.

00:02:29.160 --> 00:02:32.020
Sorry, one sec…

00:02:32.020 --> 00:02:38.660
Oh. Hey, it's Susan from It. We’re having some network issues down here, can you go ahead and check a setting for me?”

00:02:38.660 --> 00:02:40.040
... and it begins.

00:02:40.040 --> 00:02:44.060
Attackers can be very convincing, especially
with a little bit of research beforehand to

00:02:44.069 --> 00:02:46.100
find things like key employees’ names.

00:02:46.100 --> 00:02:50.470
It might take ten phone calls to find an victim,
but you only need one to get in.

00:02:50.470 --> 00:02:54.980
Emails are also a common delivery mechanism
for trojan horses, programs that masquerade

00:02:54.980 --> 00:03:00.620
as harmless attachments, like a photo or invoice, but actually contain malicious software, called malware.

00:03:00.620 --> 00:03:02.380
Malware can take many forms.

00:03:02.380 --> 00:03:05.240
Some might steal your data, like your banking
credentials.

00:03:05.240 --> 00:03:08.900
Others might encrypt your files and demand
a ransom, what's known as ransomware.

00:03:08.940 --> 00:03:12.950
If they can’t run malware or get a user
to let them in, attackers have to force their

00:03:12.950 --> 00:03:14.300
way in through other means.

00:03:14.300 --> 00:03:19.050
One method, which we briefly discussed last
episode, is to brute force a password, try

00:03:19.050 --> 00:03:22.180
every combination of password until you gain entry.

00:03:22.180 --> 00:03:26.280
Most modern systems defend against this type
of attack by having you wait incrementally

00:03:26.280 --> 00:03:31.160
longer periods of time following each failed
attempt, or even lock you out entirely after

00:03:31.160 --> 00:03:32.340
a certain number of tries.

00:03:32.340 --> 00:03:36.140
One recent hack to get around this is called
NAND Mirroring, where if you have physical

00:03:36.140 --> 00:03:40.500
access to the computer, you can attach wires
to the device's memory chip and make a perfect

00:03:40.500 --> 00:03:41.830
copy of its contents.

00:03:41.830 --> 00:03:46.490
With this setup, you can try a series of passwords,
until the device starts making you wait.

00:03:46.490 --> 00:03:50.400
When this happens, you just reflash the memory
with the original copy you made, essentially

00:03:50.400 --> 00:03:55.129
resetting it, allowing you to try more passwords
immediately, with no waiting.

00:03:55.129 --> 00:03:59.830
This technique was shown to be successful
on an iPhone 5C, but many newer devices include

00:03:59.830 --> 00:04:01.879
mechanisms to thwart this type of attack.

00:04:01.879 --> 00:04:06.440
If you don’t have physical access to a device,
you have to find a way to hack it remotely,

00:04:06.440 --> 00:04:07.700
like over the internet.

00:04:07.700 --> 00:04:12.129
In general, this requires an attacker to find
and take advantage of a bug in a system, and

00:04:12.129 --> 00:04:16.500
successfully utilizing a bug to gain capabilities
or access is called an exploit.

00:04:16.520 --> 00:04:19.440
One common type of exploit is a buffer overflow.

00:04:19.440 --> 00:04:23.320
Buffers are a general term for a block of
memory reserved for storing data.

00:04:23.330 --> 00:04:27.460
We talked about video buffers for storing
pixel data in Episode 23.

00:04:27.460 --> 00:04:31.780
As a simple example, we can imagine an operating
system’s login prompt, which has fields

00:04:31.780 --> 00:04:33.530
for a username and password.

00:04:33.540 --> 00:04:38.400
Behind the scenes, this operating system uses buffers for storing the text values that are entered.

00:04:38.400 --> 00:04:42.620
For illustration, let's say these buffers
were specified to be of size ten.

00:04:42.630 --> 00:04:45.520
In memory, the two text buffers would look
something like this:

00:04:45.530 --> 00:04:48.979
Of course, the operating system is keeping
track of a lot more than just a username and

00:04:48.979 --> 00:04:52.940
password, so there’s going to be data stored
both before and after in memory.

00:04:52.940 --> 00:04:57.230
When a user enters a username and password,
the values are copied into the buffers, where

00:04:57.230 --> 00:04:58.280
they can be verified.

00:04:58.280 --> 00:05:02.850
A buffer overflow attack does exactly what
the name suggests: overflows the buffer.

00:05:02.850 --> 00:05:07.540
In this case, any password longer than ten
characters will overwrite adjacent data in

00:05:07.540 --> 00:05:08.080
memory.

00:05:08.080 --> 00:05:12.160
Sometimes this will just cause a program or
operating system to crash, because important

00:05:12.160 --> 00:05:14.400
values are overwritten with gobbledygook.

00:05:14.400 --> 00:05:18.520
Crashing a system is bad, and maybe that’s
all that a mischievous hacker wants to do,

00:05:18.520 --> 00:05:19.520
be a nuisance.

00:05:19.520 --> 00:05:24.350
But attackers can also exploit this bug more
cleverly by injecting purposeful new values

00:05:24.350 --> 00:05:29.169
into a program’s memory, for example, setting
an “is admin” variable to true.

00:05:29.169 --> 00:05:33.580
With the ability to arbitrarily manipulate
a program’s memory, hackers can bypass things

00:05:33.580 --> 00:05:37.920
like login prompts, and sometimes even use
that program to hijack the whole system.

00:05:37.920 --> 00:05:40.980
There are many methods to combat buffer overflow
attacks.

00:05:41.009 --> 00:05:45.080
The easiest is to always test the length of
input before copying it into a buffer, called

00:05:45.080 --> 00:05:46.420
bounds checking.

00:05:46.420 --> 00:05:49.780
Many modern programming languages implement
bounds checking automatically.

00:05:49.780 --> 00:05:54.780
Programs can also randomize the memory location
of variables, like our hypothetical “is

00:05:54.780 --> 00:05:59.180
admin” flag, so that hackers don’t know
what memory location to overwrite, and are

00:05:59.180 --> 00:06:01.820
more likely to crash the program than gain
access.

00:06:01.820 --> 00:06:05.720
Programs can also leave unused space after
buffers, and keep an eye on those values to

00:06:05.720 --> 00:06:10.300
see if they change; if they do, they know
an attacker is monkeying around with memory.

00:06:10.300 --> 00:06:14.980
These regions are called canaries, named after
the small birds miners used to take underground

00:06:14.980 --> 00:06:16.740
to warn them of dangerous conditions.

00:06:16.740 --> 00:06:19.140
Another classic hack is code injection.

00:06:19.140 --> 00:06:23.199
It’s most commonly used to attack websites
that use databases, which pretty much all

00:06:23.199 --> 00:06:24.740
big websites do.

00:06:24.740 --> 00:06:28.800
We won’t be covering databases in this series,
so here’s a simple example to illustrate

00:06:28.800 --> 00:06:29.889
this type of attack.

00:06:29.889 --> 00:06:35.520
We’ll use Structured Query Language, S-Q-L,
also called sequel, a popular database API.

00:06:35.520 --> 00:06:38.990
Let’s imagine our login prompt is now running
on a webpage.

00:06:38.990 --> 00:06:43.449
When a user clicks “login”, the text values
are sent to a server, which executes code

00:06:43.449 --> 00:06:47.880
that checks if that username exists, and if
it does, verifies the password matches.

00:06:47.880 --> 00:06:52.389
To do this, the server will execute code,
known as a SQL query, that looks something

00:06:52.389 --> 00:06:53.220
like this.

00:06:53.220 --> 00:06:56.700
First, it needs to specify what data we’re
retrieving from the database.

00:06:56.700 --> 00:06:59.260
In this case, we want to fetch the password.

00:06:59.260 --> 00:07:03.060
The server also needs to specify from what
place in the database to retrieve the value

00:07:03.060 --> 00:07:03.840
from.

00:07:03.840 --> 00:07:07.720
In this case, let’s imagine all the users’
data is stored in a data structure called

00:07:07.720 --> 00:07:09.520
a table labeled “users”.

00:07:09.520 --> 00:07:13.770
Finally, the server doesn’t want to get
back a giant list of passwords for every user

00:07:13.770 --> 00:07:17.979
in the database, so it specifies that it only
wants data for the account whose username

00:07:17.980 --> 00:07:19.340
equals a certain value.

00:07:19.340 --> 00:07:24.220
That value is copied into the SQL query by
the server, based on what the user typed in,

00:07:24.230 --> 00:07:27.860
so the actual command that’s sent to the
SQL database would look something like this,

00:07:27.860 --> 00:07:29.760
where username equals philbin.

00:07:29.760 --> 00:07:32.680
Note also that SQL commands end with a semicolon.

00:07:32.700 --> 00:07:34.650
So how does someone hack this?

00:07:34.650 --> 00:07:38.169
By sending in a malicious username, with embedded
SQL commands!

00:07:38.169 --> 00:07:40.880
Like, we could send the server this funky
username:

00:07:40.880 --> 00:07:44.990
When the server copies this text into the
SQL Query, it ends up looking like this:

00:07:44.990 --> 00:07:49.069
As I mentioned before, semicolons are used
to separate commands, so the first command

00:07:49.069 --> 00:07:53.039
that gets executed is this:
If there is a user named ‘whatever’, the

00:07:53.039 --> 00:07:55.110
database will return the password.

00:07:55.110 --> 00:07:59.110
Of course, we have no idea what ‘whatever’s’
password is, so we’ll get it wrong and the

00:07:59.110 --> 00:08:00.630
server will reject us.

00:08:00.630 --> 00:08:04.960
If there’s no user named ‘whatever’,
the database will return no password or provide

00:08:04.960 --> 00:08:07.720
an error, and the server will again reject
us.

00:08:07.720 --> 00:08:11.700
Either way, we don’t care, because it’s
the next SQL command we’re interested in:

00:08:11.700 --> 00:08:16.340
“drop table users” – a command that
we injected by manipulating the username field.

00:08:16.349 --> 00:08:21.080
This command instructs the SQL database to
delete the table containing all user data.

00:08:21.080 --> 00:08:22.080
Wiped clean!

00:08:22.080 --> 00:08:25.319
Which would cause a lot of headaches at a
place like a bank... or really anywhere.

00:08:25.319 --> 00:08:28.539
And notice that we didn’t even break into
the system – it’s not like we correctly

00:08:28.540 --> 00:08:30.400
guessed a username and password.

00:08:30.400 --> 00:08:34.680
Even with no formal access, we were able to
create mayhem by exploiting a bug.

00:08:34.700 --> 00:08:39.169
This is a very simple example of code injection,
which almost all servers today have defenses

00:08:39.169 --> 00:08:39.740
against.

00:08:39.740 --> 00:08:43.660
With more sophisticated attacks, it’s possible
to add records to the database – like a

00:08:43.660 --> 00:08:48.120
new administrator account – or even get
the database to reveal data, allowing hackers

00:08:48.120 --> 00:08:52.630
to steal things like credit card numbers,
social security numbers and all sorts of nefarious

00:08:52.630 --> 00:08:53.180
goodies.

00:08:53.180 --> 00:08:55.200
But we’re not going to teach you how to do that.

00:08:55.209 --> 00:08:59.399
As with buffer overflows, programmers should
always assume input coming from the outside

00:08:59.399 --> 00:09:02.250
to be potentially dangerous, and examine it
carefully.

00:09:02.250 --> 00:09:06.209
Most username and password forms on the web
don’t let you include special symbols like

00:09:06.209 --> 00:09:09.550
semicolons or quotes as a first level of defense.

00:09:09.550 --> 00:09:14.300
Good servers also sanitize input by removing
or modifying special characters before running

00:09:14.300 --> 00:09:15.420
database queries.

00:09:15.420 --> 00:09:17.920
Working exploits are often sold or shared
online.

00:09:17.930 --> 00:09:22.060
The more prevalent the bug, or the more damaging
the exploit, the higher the price or prestige

00:09:22.060 --> 00:09:23.060
it commands.

00:09:23.060 --> 00:09:28.180
Even governments sometimes buy exploits, which
allow them to compromise computers for purposes

00:09:28.180 --> 00:09:29.020
like spying.

00:09:29.020 --> 00:09:32.840
When a new exploitable bug is discovered that
the software creators weren’t aware of,

00:09:32.840 --> 00:09:35.110
it’s called a zero day vulnerability.

00:09:35.110 --> 00:09:39.820
Black Hat Hackers rush to use the exploit
for maximum benefit before white hat programmers

00:09:39.820 --> 00:09:41.329
release a patch for the bug.

00:09:41.329 --> 00:09:44.830
This is why it’s so important to keep your
computer’s software up to date; a lot of

00:09:44.830 --> 00:09:47.089
those downloads are security patches.

00:09:47.089 --> 00:09:51.059
If bugs are left open on enough systems, it
allows hackers to write a program that jump

00:09:51.059 --> 00:09:54.449
from computer to computer automatically which
are called worms.

00:09:54.449 --> 00:09:58.509
If a hacker can take over a large number of
computers, they can be used together, to form

00:09:58.509 --> 00:10:00.239
what’s called a botnet.

00:10:00.239 --> 00:10:04.639
This can have many purposes, like sending
huge volumes of spam, mining bitcoins using

00:10:04.639 --> 00:10:09.300
other people's computing power and electricity,
and launching Distributed Denial of Service

00:10:09.300 --> 00:10:11.370
or DDoS attacks against servers.

00:10:11.370 --> 00:10:15.579
DDoS is where all the computers in the botnet
send a flood of dummy messages.

00:10:15.579 --> 00:10:19.379
This can knock services offline, either to
force owners to pay a ransom or just to be

00:10:19.380 --> 00:10:20.180
evil.

00:10:20.180 --> 00:10:24.460
Despite all of the hard working white hats,
exploits documented online, and software engineering

00:10:24.489 --> 00:10:28.320
best practices, cyberattacks happen on a daily
basis.

00:10:28.329 --> 00:10:32.600
They cost the global economy roughly half
a trillion dollars annually, and that figure

00:10:32.600 --> 00:10:35.840
will only increase as we become more reliant
on computing systems.

00:10:35.840 --> 00:10:40.399
This is especially worrying to governments,
as infrastructure is increasingly computer-driven,

00:10:40.399 --> 00:10:44.879
like powerplants, the electrical grid, traffic
lights, water treatment plants, oil refineries,

00:10:44.879 --> 00:10:48.100
air traffic control, and lots of other key
systems.

00:10:48.100 --> 00:10:52.279
Many experts predict that the next major war
will be fought in cyberspace, where nations

00:10:52.279 --> 00:10:56.439
are brought to their knees not by physical
attack, but rather crippled economically and

00:10:56.440 --> 00:10:58.720
infrastructurally through cyberwarfare.

00:10:58.720 --> 00:11:03.269
There may not be any bullets fired, but the
potential for lives lost is still very high...

00:11:03.269 --> 00:11:05.350
maybe even higher than conventional warfare.

00:11:05.350 --> 00:11:08.259
So, we should all adopt good cybersecurity
practices.

00:11:08.259 --> 00:11:12.670
And, as a community interconnected over the
internet, we should ensure our computers are

00:11:12.670 --> 00:11:16.379
secured against those who wish to use their
great potential for harm.

00:11:16.380 --> 00:11:19.080
So maybe stop ignoring that update notification?

00:11:19.080 --> 00:11:19.920
I’ll see you next week.

