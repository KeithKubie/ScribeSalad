WEBVTT
Kind: captions
Language: en

00:00:05.990 --> 00:00:07.448
ROMAIN GUY: Good
morning, everyone.

00:00:07.448 --> 00:00:11.192
[APPLAUSE]

00:00:11.192 --> 00:00:13.460
Wait, don't cheer us.

00:00:13.460 --> 00:00:15.040
Cheer the next speakers.

00:00:15.040 --> 00:00:18.210
So I'm Romain Guy, representing
the Platform team on Android,

00:00:18.210 --> 00:00:20.880
and this is Tor Norbye
representing the Tools team.

00:00:20.880 --> 00:00:22.205
But you're not here for us.

00:00:22.205 --> 00:00:23.830
You are here for very
special speakers.

00:00:23.830 --> 00:00:25.204
TOR NORBYE: Yeah,
so Romain and I

00:00:25.204 --> 00:00:27.992
have been incredibly
excited about this official

00:00:27.992 --> 00:00:28.950
announcement of Kotlin.

00:00:28.950 --> 00:00:31.650
We both love Kotlin, in case
you hadn't noticed already.

00:00:31.650 --> 00:00:35.060
And we don't take any more time
from the speakers of honor.

00:00:35.060 --> 00:00:37.096
So without further
ado, here they are.

00:00:37.096 --> 00:00:51.500
[APPLAUSE]

00:00:51.500 --> 00:00:54.070
HADI HARIRI: Hello, everyone.

00:00:54.070 --> 00:00:56.220
Aw, that's nice.

00:00:56.220 --> 00:00:59.040
So I was thinking the other
day, the first time that I ever

00:00:59.040 --> 00:01:03.330
did a talk on Kotlin, it was
like 4 and 1/2 years ago.

00:01:03.330 --> 00:01:08.580
And they gave me a room for 900
people and 7 people showed up.

00:01:08.580 --> 00:01:11.240
So it's kind of nice to see
more of you show up today.

00:01:11.240 --> 00:01:12.218
Thank you.

00:01:12.218 --> 00:01:16.430
[APPLAUSE]

00:01:16.430 --> 00:01:20.010
Anyway I've got roughly
around 30 minutes.

00:01:20.010 --> 00:01:22.930
Actually, a little bit less.

00:01:22.930 --> 00:01:25.844
28 minutes to give you a
whirlwind tour of Kotlin,

00:01:25.844 --> 00:01:27.760
so I'm not going to cover
the entire language.

00:01:27.760 --> 00:01:31.790
I'm going to try show you
as much as I possibly can

00:01:31.790 --> 00:01:34.220
and how you can use it
and where it provides you

00:01:34.220 --> 00:01:35.410
with some benefits, OK?

00:01:35.410 --> 00:01:37.890
So I'm going to try and do
it all with live coding,

00:01:37.890 --> 00:01:41.710
so if it all goes terribly
wrong, there's a Google video--

00:01:41.710 --> 00:01:44.290
I mean there's a YouTube video
of this somewhere as well.

00:01:44.290 --> 00:01:45.950
So you can watch that.

00:01:45.950 --> 00:01:48.200
OK, so we're going to start
with something very simple

00:01:48.200 --> 00:01:50.580
that you've already
seen, data class.

00:01:50.580 --> 00:01:54.480
And I'm in a file called main.

00:01:54.480 --> 00:01:57.250
So data class, I'm going to
create a new type called money,

00:01:57.250 --> 00:01:59.830
and it's going to happen
amounts which is of type Int.

00:01:59.830 --> 00:02:01.710
I know, don't say
anything for now.

00:02:01.710 --> 00:02:03.870
And it's going to have a
currency of type string.

00:02:03.870 --> 00:02:04.370
OK?

00:02:06.880 --> 00:02:09.180
And this is both
properties, and they're

00:02:09.180 --> 00:02:10.860
going to be read
only properties.

00:02:10.860 --> 00:02:13.530
So this is something that
you're already familiar with.

00:02:13.530 --> 00:02:14.920
It's essentially a data class.

00:02:14.920 --> 00:02:17.260
Let's go ahead and
compare that to a Java one

00:02:17.260 --> 00:02:20.740
that I have done earlier.

00:02:20.740 --> 00:02:23.040
So split vertically.

00:02:23.040 --> 00:02:25.400
And let's get the Java
money up-- actually,

00:02:25.400 --> 00:02:28.600
let's go down this side.

00:02:28.600 --> 00:02:31.480
Java money-- so there you go.

00:02:31.480 --> 00:02:35.450
That's kind of the equivalent of
what I've just written, right.

00:02:35.450 --> 00:02:37.340
A JavaBean essentially,
a data class

00:02:37.340 --> 00:02:39.010
that provides two getters.

00:02:39.010 --> 00:02:41.870
They're immutable,
so they're read only.

00:02:41.870 --> 00:02:44.300
And this data modifier over
here, what that's doing

00:02:44.300 --> 00:02:46.341
is essentially giving me
a whole bunch of things,

00:02:46.341 --> 00:02:49.460
like the to string, it's
giving me the clone,

00:02:49.460 --> 00:02:53.340
which in Kotlin it's called
copy, it's doing the equals,

00:02:53.340 --> 00:02:54.470
it's doing the hashCode.

00:02:54.470 --> 00:02:56.164
Now you say, OK,
well that's great.

00:02:56.164 --> 00:02:57.580
Brilliant, but why
do I need that?

00:02:57.580 --> 00:03:00.960
Because any good IDE is going
to generate that for me.

00:03:00.960 --> 00:03:01.794
It is true, it does.

00:03:01.794 --> 00:03:03.543
But the problem is
that that's code you're

00:03:03.543 --> 00:03:04.630
going to have to maintain.

00:03:04.630 --> 00:03:06.010
And every time you
add a new property,

00:03:06.010 --> 00:03:08.080
you're going to have to go
back and change that code.

00:03:08.080 --> 00:03:10.246
And the other issue that
you're going to have is you

00:03:10.246 --> 00:03:11.950
don't know, in fact,
if that code is

00:03:11.950 --> 00:03:14.920
the standard stuff that Kotl--

00:03:14.920 --> 00:03:17.850
that IDE has generated
for you, or you've

00:03:17.850 --> 00:03:18.850
tweaked it a little bit.

00:03:18.850 --> 00:03:19.820
OK?

00:03:19.820 --> 00:03:23.220
So it's not just about saving
on typing on the first line.

00:03:23.220 --> 00:03:24.250
Right.

00:03:24.250 --> 00:03:25.750
Now what I'm going
to do is go ahead

00:03:25.750 --> 00:03:27.180
and create a function main.

00:03:27.180 --> 00:03:29.370
Let's close this guy over here.

00:03:29.370 --> 00:03:31.360
And this is the top
entry point of Kotlin,

00:03:31.360 --> 00:03:35.880
so you have a public static
void main in a class.

00:03:35.880 --> 00:03:37.280
You don't need that in Kotlin.

00:03:37.280 --> 00:03:39.730
So in Kotlin, you can put
everything in the top level.

00:03:39.730 --> 00:03:42.360
It's kind of like
JavaScript in a good way.

00:03:42.360 --> 00:03:46.825
And so you don't have to--

00:03:46.825 --> 00:03:49.630
and I want to reiterate,
every function and everything

00:03:49.630 --> 00:03:51.840
that I'll show you today,
I'm going to just add it

00:03:51.840 --> 00:03:53.920
in the file as a
top level thing,

00:03:53.920 --> 00:03:56.700
but that doesn't mean that
you don't have any more member

00:03:56.700 --> 00:03:57.300
functions.

00:03:57.300 --> 00:03:59.420
Anything, any class,
even a data class

00:03:59.420 --> 00:04:00.900
can have member functions.

00:04:00.900 --> 00:04:02.460
But for brevity
and for the purpose

00:04:02.460 --> 00:04:03.890
of what I'm showing
you, I'm just

00:04:03.890 --> 00:04:06.490
going to put it
as top level, OK?

00:04:06.490 --> 00:04:08.920
So I'm going to create
a new instance of money.

00:04:08.920 --> 00:04:11.430
We're going to call it,
for example, tickets.

00:04:11.430 --> 00:04:16.579
And I'll say Money 100, and
it's going to be dollars, right?

00:04:16.579 --> 00:04:20.240
And I'll get into the
explicit type here,

00:04:20.240 --> 00:04:22.610
but essentially here what
I'm doing is type inference.

00:04:22.610 --> 00:04:24.550
So Kotlin is very strong
in type inference,

00:04:24.550 --> 00:04:26.820
and as much as it can
infer, it will for you.

00:04:26.820 --> 00:04:29.350
So you don't have to
explicitly tell the type.

00:04:29.350 --> 00:04:32.940
And then I'll say,
for example, popcorn.

00:04:32.940 --> 00:04:37.695
Let's say tickets, copy, right?

00:04:37.695 --> 00:04:39.320
So what that's going
to do is basically

00:04:39.320 --> 00:04:44.550
copy the previous one for me,
and all of the properties.

00:04:44.550 --> 00:04:47.530
So if I don't pass
any parameters in,

00:04:47.530 --> 00:04:50.570
it's going to just take the same
values as it has before, OK.

00:04:50.570 --> 00:04:52.420
So I can pass in a
new parameter and say,

00:04:52.420 --> 00:04:54.670
you know, in Spain,
for example, popcorn

00:04:54.670 --> 00:04:57.450
is seven times the price
of the entry of the cinema,

00:04:57.450 --> 00:04:59.720
so that's going to
be like 500 euros.

00:04:59.720 --> 00:05:01.650
Right?

00:05:01.650 --> 00:05:04.900
And now I can do things
like, for instance,

00:05:04.900 --> 00:05:11.240
if tickets is not
equal to popcorn,

00:05:11.240 --> 00:05:17.040
then println "they
are different!"

00:05:17.040 --> 00:05:20.247
So what this is doing is a
property comparison one by one.

00:05:20.247 --> 00:05:21.830
It is not doing a
point of comparison.

00:05:21.830 --> 00:05:25.670
For point of comparisons, we
have the triple equal, right?

00:05:25.670 --> 00:05:27.370
Different to
JavaScript, there isn't

00:05:27.370 --> 00:05:31.120
a chart of 600 different
positions you have to remember.

00:05:31.120 --> 00:05:33.552
And this, by the way,
is font ligature,

00:05:33.552 --> 00:05:35.010
so don't get confused
with that, we

00:05:35.010 --> 00:05:36.910
didn't introduce a new symbol.

00:05:36.910 --> 00:05:38.190
OK.

00:05:38.190 --> 00:05:42.710
So I can go ahead
and just run this,

00:05:42.710 --> 00:05:44.410
and I get they are different.

00:05:44.410 --> 00:05:48.890
And if I change this to 100
and I put this as dollars

00:05:48.890 --> 00:05:52.500
and I run this, it's going
to say to you that nothing,

00:05:52.500 --> 00:05:53.690
because they are the same.

00:05:53.690 --> 00:05:54.604
OK?

00:05:54.604 --> 00:05:56.520
Now one of the features
we keep boosting about

00:05:56.520 --> 00:05:58.940
is the interop between
Java and Kotlin.

00:05:58.940 --> 00:06:02.360
So we have this Java
money one over here,

00:06:02.360 --> 00:06:05.100
so I'm going to go ahead and
create an instance of it.

00:06:05.100 --> 00:06:11.260
I'll say javaMoney equals
javaMoney, and it will be 100

00:06:11.260 --> 00:06:13.130
and it'll be dollars.

00:06:13.130 --> 00:06:16.420
And then if I do
javaMoney, you can see

00:06:16.420 --> 00:06:18.920
that I don't have any getters.

00:06:18.920 --> 00:06:22.690
Well, I do have, actually, a
getter, so I can do get amount,

00:06:22.690 --> 00:06:25.450
but if I write
getAmount, complete it,

00:06:25.450 --> 00:06:28.040
the IDE's already going to
replace that for property,

00:06:28.040 --> 00:06:30.550
because we don't have really
like getters and setters,

00:06:30.550 --> 00:06:32.790
we just have properties.

00:06:32.790 --> 00:06:36.270
So that's consuming
Java from Kotlin.

00:06:36.270 --> 00:06:39.420
And if I go over to the
Java over here, and let's

00:06:39.420 --> 00:06:41.490
go ahead and create a
public statics void main,

00:06:41.490 --> 00:06:42.389
and I'll do--

00:06:42.389 --> 00:06:44.180
so let's see, I've got
to declare the type.

00:06:44.180 --> 00:06:53.410
Money equals new money,
100, and dollars, and--

00:06:53.410 --> 00:06:54.060
OK.

00:06:54.060 --> 00:06:57.250
That's the other thing.

00:06:57.250 --> 00:06:59.910
Semicolons in
Kotlin are optional.

00:06:59.910 --> 00:07:01.510
And the reason
they're optional is

00:07:01.510 --> 00:07:03.572
so that you can have
endless arguments over

00:07:03.572 --> 00:07:05.030
whether you should
use them or not.

00:07:07.692 --> 00:07:09.650
We are trying to compete
with JavaScript there.

00:07:09.650 --> 00:07:11.920
OK, so money.getAmount.

00:07:11.920 --> 00:07:15.047
So now I'm using a Java type--
sorry, a Kotlin type from Java,

00:07:15.047 --> 00:07:17.130
so I'm getting the getters
and the setters, right?

00:07:17.130 --> 00:07:22.110
So idiomatic depending
on how you are using it.

00:07:22.110 --> 00:07:25.050
And that's just different Java
files, different Kotlin files

00:07:25.050 --> 00:07:28.880
in a single project, working
seamlessly without any issues.

00:07:28.880 --> 00:07:32.760
Right, so now let's go ahead
and create some functions.

00:07:32.760 --> 00:07:35.210
So I'm going to create a
function called sendPayment.

00:07:35.210 --> 00:07:36.930
That takes a money--

00:07:36.930 --> 00:07:41.879
and Money-- and it's going
to println the money out.

00:07:41.879 --> 00:07:43.670
And of course we have
string interpolation,

00:07:43.670 --> 00:07:48.095
so I could say,
sending money.amount.

00:07:48.095 --> 00:07:50.470
And you don't have to put
these curly braces if it's just

00:07:50.470 --> 00:07:51.800
a single property that
you're passing in,

00:07:51.800 --> 00:07:53.207
as we'll just see in a moment.

00:07:53.207 --> 00:07:55.040
So now I can call this
and say, for example,

00:07:55.040 --> 00:07:58.290
sendPayment, tickets, right?

00:07:58.290 --> 00:08:01.400
Now Kotlin, we also have--

00:08:01.400 --> 00:08:05.090
notice one thing here, I'm
not defining the return type.

00:08:05.090 --> 00:08:07.790
By default it's unit,
which is kind of like void,

00:08:07.790 --> 00:08:08.480
but it's not.

00:08:08.480 --> 00:08:12.505
It's actually a object which
is essentially a singleton,

00:08:12.505 --> 00:08:15.120
a single instance of an object.

00:08:15.120 --> 00:08:18.010
And if it is a unit, you don't
have to put it there, right?

00:08:18.010 --> 00:08:21.350
So I'm going to add
a new parameter here

00:08:21.350 --> 00:08:23.600
and I'm going to say, for
example, with message.

00:08:23.600 --> 00:08:25.700
And this is gone to
have string, and you

00:08:25.700 --> 00:08:27.980
can have default parameters.

00:08:27.980 --> 00:08:30.499
So here, notice that there's
no compilation error because I

00:08:30.499 --> 00:08:31.540
made a default parameter.

00:08:31.540 --> 00:08:34.039
This saves you a lot in
times of overloaded function,

00:08:34.039 --> 00:08:35.580
overloaded member
functions, right?

00:08:35.580 --> 00:08:37.870
I can just have
default parameters

00:08:37.870 --> 00:08:38.870
and then do what I want.

00:08:38.870 --> 00:08:40.429
And you can have multiple
default parameters.

00:08:40.429 --> 00:08:42.512
And since you can have
multiple default parameters

00:08:42.512 --> 00:08:47.420
and you can alternate which
one you want to pass in,

00:08:47.420 --> 00:08:49.630
you can also do
names parameters.

00:08:49.630 --> 00:08:56.300
So, in fact, I could say
message equals "Good luck!"

00:08:56.300 --> 00:08:59.430
and money equals tickets.

00:08:59.430 --> 00:09:02.660
And this is kind of useful
as well when you are using--

00:09:02.660 --> 00:09:05.740
you're talking to legacy
code, for example, some

00:09:05.740 --> 00:09:09.000
function that you can't modify,
and it's got 600 parameters,

00:09:09.000 --> 00:09:13.100
and they're probably 500 of them
are true and false Booleans,

00:09:13.100 --> 00:09:16.760
it kind of gives you some
insight into what parameters

00:09:16.760 --> 00:09:18.190
I'm passing in in
every position.

00:09:22.400 --> 00:09:24.000
Oh yeah.

00:09:24.000 --> 00:09:25.710
I love it when people crap--

00:09:25.710 --> 00:09:26.430
clap.

00:09:26.430 --> 00:09:31.630
[LAUGHTER]

00:09:31.630 --> 00:09:37.640
And I'm thinking to myself,
well this is going well.

00:09:37.640 --> 00:09:40.740
Anyway, right, let's go.

00:09:40.740 --> 00:09:43.660
Edit that out, like
adult supervision.

00:09:43.660 --> 00:09:44.454
Right.

00:09:44.454 --> 00:09:46.120
One other thing with
Kotlin is that when

00:09:46.120 --> 00:09:49.160
we have functions that
are really, really easy,

00:09:49.160 --> 00:09:52.120
like essentially
returning a single value,

00:09:52.120 --> 00:09:56.150
you can just do single
expression functions.

00:09:56.150 --> 00:09:59.130
So I omit the return
type explicitly,

00:09:59.130 --> 00:10:02.740
I omit the curly braces, and I
just return the actual function

00:10:02.740 --> 00:10:03.500
that I want to do.

00:10:03.500 --> 00:10:04.830
OK?

00:10:04.830 --> 00:10:08.760
So, in fact, the
concept of expression

00:10:08.760 --> 00:10:10.150
comes in many places in Kotlin.

00:10:10.150 --> 00:10:12.066
So for instance, let's
create another function

00:10:12.066 --> 00:10:15.380
that's called convert
ToDollars. convertToDollars,

00:10:15.380 --> 00:10:19.080
and this is going
to take a money.

00:10:19.080 --> 00:10:22.100
Money, and it's going
to return Money.

00:10:22.100 --> 00:10:23.600
And then what we're
going to do here

00:10:23.600 --> 00:10:27.310
is a when statement, so that's
essentially case, right.

00:10:27.310 --> 00:10:32.670
So when money_currency
is dollars,

00:10:32.670 --> 00:10:38.297
then we'll do return money
as is, right, because I

00:10:38.297 --> 00:10:39.380
don't need to do anything.

00:10:39.380 --> 00:10:43.490
And if it's EUR, then what
I'm going to do is return,

00:10:43.490 --> 00:10:50.682
we're going to do
money.amount times--

00:10:50.682 --> 00:10:52.390
sorry, I've got to
create a new instance.

00:10:52.390 --> 00:10:59.810
Money, and then it's going to
be money.amount times BigDecimal

00:10:59.810 --> 00:11:04.830
1.10, and then that's
going to be dollars.

00:11:04.830 --> 00:11:09.300
And else, throw
IllegalArgumentException,

00:11:09.300 --> 00:11:15.140
"not the currency
you're interested in!"

00:11:15.140 --> 00:11:18.590
So this you can actually
treat a when as an expression.

00:11:18.590 --> 00:11:22.240
So I can remove this return over
here, remove this return over

00:11:22.240 --> 00:11:25.480
here, put it just here,
and then this just

00:11:25.480 --> 00:11:29.060
makes the when always
return an expression.

00:11:29.060 --> 00:11:33.440
And in fact, you can even
remove the return here,

00:11:33.440 --> 00:11:37.760
remove the Money here,
and remove that there,

00:11:37.760 --> 00:11:39.350
and you get a single expression.

00:11:39.350 --> 00:11:40.150
OK?

00:11:40.150 --> 00:11:41.460
Single expression function.

00:11:41.460 --> 00:11:42.910
Now one thing that
you notice here

00:11:42.910 --> 00:11:46.330
that this is giving me an
error because this is--

00:11:46.330 --> 00:11:49.060
I'm trying to operate a
BigDecimal with an int,

00:11:49.060 --> 00:11:51.210
so we're going to go
and refactor this,

00:11:51.210 --> 00:11:54.300
and we're going to
call it BigDecimal, OK.

00:11:54.300 --> 00:11:57.700
Now talking about
BigDecimal, oh, here we go.

00:11:57.700 --> 00:12:06.430
BigDecimal, BigDecimal
100 and BigDecimal--

00:12:06.430 --> 00:12:08.670
I love typing BigDecimal.

00:12:08.670 --> 00:12:11.510
I love it.

00:12:11.510 --> 00:12:14.330
So we've got this over here.

00:12:14.330 --> 00:12:17.120
Now if you look at,
actually, BigDecimal--

00:12:17.120 --> 00:12:20.140
so if I create a new
BigDecimal, we'll call it bd1

00:12:20.140 --> 00:12:23.170
equals BigDecimal 100.

00:12:23.170 --> 00:12:25.790
You can see the bd1 gives me
a whole bunch of functions

00:12:25.790 --> 00:12:28.260
like divide, multiply,
all of these things.

00:12:28.260 --> 00:12:30.780
What if I wanted to do
something like a percent?

00:12:30.780 --> 00:12:33.660
I wanted a percentage
of BigDecimal.

00:12:33.660 --> 00:12:37.370
Now normally you
would, basically,

00:12:37.370 --> 00:12:39.597
inherit from that and then
create your own version

00:12:39.597 --> 00:12:41.430
and have all of these
things, but in Kotlin,

00:12:41.430 --> 00:12:42.600
one of the features
that we've added--

00:12:42.600 --> 00:12:43.760
and if you're familiar with C#--

00:12:43.760 --> 00:12:45.760
is called extension
functions, which essentially

00:12:45.760 --> 00:12:48.700
means that you can take any
class, any type, and extend it.

00:12:48.700 --> 00:12:50.957
So I can take a
function of BigDecimal,

00:12:50.957 --> 00:12:53.040
I put the name of the class
that I want to extend,

00:12:53.040 --> 00:12:55.005
and I say I want
to do a percent.

00:12:55.005 --> 00:12:56.380
And what is the
percentage that I

00:12:56.380 --> 00:13:00.810
want to do, for example, an
integer, and then it would be,

00:13:00.810 --> 00:13:01.540
let's see.

00:13:01.540 --> 00:13:03.950
So given that this is
an extension function,

00:13:03.950 --> 00:13:07.891
it's going to have an instance
of that class, of that object,

00:13:07.891 --> 00:13:08.390
right.

00:13:08.390 --> 00:13:10.700
So I can use that,
reference that with this.

00:13:10.700 --> 00:13:15.919
And I say this multiplied
by the percentage--

00:13:15.919 --> 00:13:18.210
and then this has got to to
be wrapped in a big decimal

00:13:18.210 --> 00:13:19.180
again--

00:13:19.180 --> 00:13:20.810
percentage.

00:13:20.810 --> 00:13:24.870
And then that divide--

00:13:24.870 --> 00:13:29.350
and then another BigDecimal 100.

00:13:29.350 --> 00:13:33.290
And what's wrong with this,
that should be percentage.

00:13:33.290 --> 00:13:36.120
So percent-- age.

00:13:36.120 --> 00:13:42.240
OK, so now what happens is
that on bd1, I have percentage.

00:13:42.240 --> 00:13:43.170
OK.

00:13:43.170 --> 00:13:46.250
And I could do percent
7, and that would give me

00:13:46.250 --> 00:13:47.360
a certain percent.

00:13:47.360 --> 00:13:49.890
And that extension function
gets included anywhere where

00:13:49.890 --> 00:13:51.760
it is defined in the package.

00:13:51.760 --> 00:13:55.560
So here in this case, I
have it in com.jetbrains.gio

00:13:55.560 --> 00:13:57.307
and that will get
included there.

00:13:57.307 --> 00:13:58.890
So you can create
extension functions,

00:13:58.890 --> 00:14:00.560
and we'll see that the
standard library actually

00:14:00.560 --> 00:14:02.669
consists of a whole bunch
of extension functions.

00:14:02.669 --> 00:14:04.210
Now we'll take this
one step further,

00:14:04.210 --> 00:14:06.670
because I can actually
extend everything.

00:14:06.670 --> 00:14:08.890
So let's go ahead and
extend an integer.

00:14:08.890 --> 00:14:11.720
So I'll say fun Int.

00:14:11.720 --> 00:14:15.760
percentOf and here
will do the reverse.

00:14:15.760 --> 00:14:19.120
So I want like 10 percent
of something, right.

00:14:19.120 --> 00:14:22.600
So I'll say money, for instance,
I want 10 percent of money.

00:14:22.600 --> 00:14:26.460
And that's going to return the--

00:14:26.460 --> 00:14:30.250
let's see, it's going
to return money.

00:14:30.250 --> 00:14:34.480
Then it will be amount.multiply
and then here it's going

00:14:34.480 --> 00:14:37.760
to reference the actual
instance, so it will be this--

00:14:37.760 --> 00:14:42.720
and again, this has to
be wrapped in BigDecimal,

00:14:42.720 --> 00:14:46.970
and then divide by 100.

00:14:46.970 --> 00:14:47.510
OK.

00:14:47.510 --> 00:14:50.330
And I think I got that
in the right order.

00:14:50.330 --> 00:14:52.690
If the implementation is
wrong, doesn't matter.

00:14:52.690 --> 00:14:53.480
Who cares.

00:14:53.480 --> 00:14:57.440
Anyway, so now what I can
do is something like this.

00:14:57.440 --> 00:15:05.410
Seven percentOf BigDecimal 100.

00:15:05.410 --> 00:15:05.910
OK?

00:15:05.910 --> 00:15:06.630
Oh no, sorry.

00:15:06.630 --> 00:15:07.620
Money.

00:15:07.620 --> 00:15:11.030
So I can do Money--
no, don't clap yet.

00:15:11.030 --> 00:15:12.100
Money.

00:15:12.100 --> 00:15:13.720
Oh, let's just take
the money I have.

00:15:13.720 --> 00:15:15.090
7.percentOf(popcorn).

00:15:15.090 --> 00:15:16.420
OK, nice?

00:15:20.350 --> 00:15:22.150
Let's do a little bit nicer.

00:15:22.150 --> 00:15:24.690
What I want to do is, in
fact, something like this.

00:15:24.690 --> 00:15:28.720
I want to do 7
percentOf popcorn.

00:15:28.720 --> 00:15:29.662
That would be nice.

00:15:29.662 --> 00:15:30.870
And you can actually do that.

00:15:30.870 --> 00:15:32.420
You see that little
wiggly there?

00:15:32.420 --> 00:15:33.340
Squiggly?

00:15:33.340 --> 00:15:35.090
Alt, Enter, add 'infix'.

00:15:35.090 --> 00:15:36.050
There you go.

00:15:36.050 --> 00:15:40.840
OK so any extension function
that has a single parameter

00:15:40.840 --> 00:15:42.839
can be called an infix notation.

00:15:42.839 --> 00:15:44.380
And what I've done
is essentially add

00:15:44.380 --> 00:15:45.512
the infix over there.

00:15:45.512 --> 00:15:46.970
And this is some
of the things that

00:15:46.970 --> 00:15:50.390
allow you know, with Kotlin,
to kind of create the whole DSL

00:15:50.390 --> 00:15:52.350
approach to things.

00:15:52.350 --> 00:15:53.050
Right.

00:15:53.050 --> 00:15:57.320
So one thing that I hated doing
here is all of this BigDecimal.

00:15:57.320 --> 00:15:59.210
That's a pain.

00:15:59.210 --> 00:16:02.600
And in Kotlin, when you want
to create a value of type long,

00:16:02.600 --> 00:16:05.334
you can say long 100L, and
that will be of type long.

00:16:05.334 --> 00:16:06.750
And it would be
awesome if I could

00:16:06.750 --> 00:16:12.940
do like, bd2 equals 100BD,
but you can't, and we

00:16:12.940 --> 00:16:14.050
don't have that built in.

00:16:14.050 --> 00:16:16.910
But what we do have in Kotlin
is called extension properties.

00:16:16.910 --> 00:16:19.050
So they're exactly like
extension functions,

00:16:19.050 --> 00:16:21.750
except they extend
with properties.

00:16:21.750 --> 00:16:26.950
So I could do something
like .bd, right?

00:16:26.950 --> 00:16:30.587
And now-- or let's, so now--

00:16:30.587 --> 00:16:33.170
see, it even says, do you want
to create an extension property

00:16:33.170 --> 00:16:34.420
on type integer?

00:16:34.420 --> 00:16:35.430
Yes.

00:16:35.430 --> 00:16:39.260
So this is going to
return a BigDecimal.

00:16:39.260 --> 00:16:48.330
And then here, I'm going to do
return BigDecimal, and this,

00:16:48.330 --> 00:16:49.570
which is the instance.

00:16:49.570 --> 00:16:51.740
And I can, in fact, convert
this to an expression

00:16:51.740 --> 00:16:53.700
to make it easier.

00:16:53.700 --> 00:16:54.670
So there you go.

00:16:54.670 --> 00:16:57.330
Now I have 100.bd.

00:16:57.330 --> 00:16:58.930
So when I'm passing
that in, it looks

00:16:58.930 --> 00:17:03.599
much nicer than BigDecimal,
I could just do 100.bd.

00:17:03.599 --> 00:17:04.099
OK?

00:17:10.960 --> 00:17:13.160
And one other thing around
functions that you can do

00:17:13.160 --> 00:17:16.560
is, there are certain
operators that you can extend.

00:17:16.560 --> 00:17:19.141
So you can extend, for
example, the plus operator.

00:17:19.141 --> 00:17:21.599
And what I'm going to do is
I'm not going to type this out,

00:17:21.599 --> 00:17:22.974
I've just got a
nice little thing

00:17:22.974 --> 00:17:24.720
that has done that for me.

00:17:24.720 --> 00:17:26.760
See how fast I am at typing?

00:17:26.760 --> 00:17:29.130
So what I've essentially
done is now override

00:17:29.130 --> 00:17:30.890
the plus operator for money.

00:17:30.890 --> 00:17:38.960
So now I can say costs equals
tickets plus popcorn, right.

00:17:38.960 --> 00:17:41.960
And that allows me to
add to monetary amounts.

00:17:41.960 --> 00:17:44.410
OK, you could do that with
plus, minus, multiply.

00:17:44.410 --> 00:17:46.820
A bunch of built-in
conventions that you

00:17:46.820 --> 00:17:50.970
can follow for certain operators
that allow you to do that.

00:17:50.970 --> 00:17:51.690
OK.

00:17:51.690 --> 00:17:54.330
So we've been creating a
whole bunch of types here.

00:17:54.330 --> 00:17:58.140
And let me go ahead and delete
all the stuff so we can focus.

00:17:58.140 --> 00:17:59.890
We've been creating a
bunch of types here.

00:17:59.890 --> 00:18:02.056
Notice that in any of these
types that I've created,

00:18:02.056 --> 00:18:05.220
I've never actually specified
the type, and you can.

00:18:05.220 --> 00:18:10.700
So I can do, for
instance, val train costs,

00:18:10.700 --> 00:18:14.520
for example, train
is of type Money

00:18:14.520 --> 00:18:18.500
and then initialize it
to some new value, right.

00:18:18.500 --> 00:18:22.360
100.bd, and then dollars.

00:18:22.360 --> 00:18:25.439
Now if I go ahead
and do train=null,

00:18:25.439 --> 00:18:26.730
it's going to give me an error.

00:18:26.730 --> 00:18:28.646
And it's going to give
me actually two errors.

00:18:28.646 --> 00:18:31.190
One of them is because
that's immutable variable.

00:18:31.190 --> 00:18:32.320
So I can fix that.

00:18:32.320 --> 00:18:34.180
I've now made this mutable.

00:18:34.180 --> 00:18:36.210
You see that the
IDE underlines it,

00:18:36.210 --> 00:18:39.510
so it wants to point it out
that this is really something

00:18:39.510 --> 00:18:40.860
you're going to shy away from.

00:18:40.860 --> 00:18:43.150
We don't enforce
immutability in Kotlin,

00:18:43.150 --> 00:18:44.657
but we kind of do recommend it.

00:18:44.657 --> 00:18:46.240
Like all of the lists
and all of these

00:18:46.240 --> 00:18:49.470
things are immutable by default.

00:18:49.470 --> 00:18:53.380
So I can't assign null
in Kotlin because Kotlin

00:18:53.380 --> 00:18:55.460
tries to get rid of the
null pointer exception

00:18:55.460 --> 00:18:58.730
by saying that types aren't
nullible by default, right.

00:18:58.730 --> 00:19:00.390
But there are
times when you want

00:19:00.390 --> 00:19:02.990
to have a type that is
nullable for whatever reason,

00:19:02.990 --> 00:19:04.230
you're bored.

00:19:04.230 --> 00:19:07.240
And you can add a question
mark, and then that

00:19:07.240 --> 00:19:10.965
will give you the ability
to assign null to that type.

00:19:10.965 --> 00:19:12.840
Now normally when you're
working with Kotlin,

00:19:12.840 --> 00:19:13.900
you probably don't
want to do this.

00:19:13.900 --> 00:19:15.858
You probably don't want
to have nullable types,

00:19:15.858 --> 00:19:21.610
but since we're interopping
with Java, Java can be null.

00:19:21.610 --> 00:19:25.480
So if I create a function
here that is, for instance,

00:19:25.480 --> 00:19:32.150
fun javaMoney, and that
takes money of type JavaMoney

00:19:32.150 --> 00:19:34.100
and does whatever with it.

00:19:34.100 --> 00:19:44.020
So let's say I do println
money.amount is valid.

00:19:44.020 --> 00:19:47.060
So this can be null.

00:19:47.060 --> 00:19:49.252
It could, if it's
called by an instance

00:19:49.252 --> 00:19:51.210
that a function that,
for example, is returning

00:19:51.210 --> 00:19:52.550
this type, it could be null.

00:19:52.550 --> 00:19:55.370
And you can indicate that
by adding the question mark.

00:19:55.370 --> 00:19:58.060
When you do that, you
can see that the IDE

00:19:58.060 --> 00:19:59.790
is going to give you error.

00:19:59.790 --> 00:20:02.570
It says only safe operators,
or the double exclamation mark

00:20:02.570 --> 00:20:04.260
are valid here, because
it's essentially

00:20:04.260 --> 00:20:06.718
saying you're going to run into
a null reference exception.

00:20:06.718 --> 00:20:08.590
So there's two ways
you can solve this.

00:20:08.590 --> 00:20:12.200
First of all, you can say,
for example, money, not null.

00:20:12.200 --> 00:20:17.840
And then do a if not null, then
go ahead and operate with it.

00:20:17.840 --> 00:20:20.410
Put this one upstairs in there.

00:20:20.410 --> 00:20:21.340
OK.

00:20:21.340 --> 00:20:22.460
That's one way.

00:20:22.460 --> 00:20:26.980
Or the shorter way is just to
use the safe operator or Elvis

00:20:26.980 --> 00:20:28.740
operator, which is over here.

00:20:28.740 --> 00:20:33.330
So now we just say if money is
not null, then do something.

00:20:33.330 --> 00:20:36.270
Now if you want to have
fun, you can also do that.

00:20:36.270 --> 00:20:38.490
And that says, I know
it's null, but I want

00:20:38.490 --> 00:20:39.990
to shoot myself in the foot.

00:20:39.990 --> 00:20:41.505
OK?

00:20:41.505 --> 00:20:43.130
And you've got to be
careful with that,

00:20:43.130 --> 00:20:45.480
because a lot of times when
people start with Kotlin,

00:20:45.480 --> 00:20:47.876
they get all of this little
squigglies over here,

00:20:47.876 --> 00:20:49.250
and they're like,
well I actually

00:20:49.250 --> 00:20:50.810
don't know if it's going
to be null because I really

00:20:50.810 --> 00:20:52.397
want it to not being null.

00:20:52.397 --> 00:20:54.730
So I'm not going to handle
the case where it's not null,

00:20:54.730 --> 00:20:55.894
so I'll just do that.

00:20:55.894 --> 00:20:58.310
And then they run the app and
they're like, wait a minute,

00:20:58.310 --> 00:21:00.940
you set Kotlin got rid of
null reference exceptions.

00:21:00.940 --> 00:21:01.440
Yes.

00:21:04.210 --> 00:21:06.380
OK.

00:21:06.380 --> 00:21:07.030
What else.

00:21:07.030 --> 00:21:07.610
Right.

00:21:07.610 --> 00:21:09.270
So let's switch to
some other stuff,

00:21:09.270 --> 00:21:11.176
like higher order functions.

00:21:11.176 --> 00:21:13.550
Now you're all familiar with
a high order function, which

00:21:13.550 --> 00:21:15.810
is basically a function
that takes a function

00:21:15.810 --> 00:21:18.420
or returns a function, and
we have those in Kotlin.

00:21:18.420 --> 00:21:22.550
So we can say findEmails
users List of User,

00:21:22.550 --> 00:21:25.150
and then I'll create a new
function, which is a predicate.

00:21:25.150 --> 00:21:27.040
So I'm passing in a
function here, right,

00:21:27.040 --> 00:21:30.650
a function that takes a
string and returns a Boolean.

00:21:30.650 --> 00:21:31.670
OK?

00:21:31.670 --> 00:21:34.971
And then this probably is going
to return a list of users.

00:21:34.971 --> 00:21:36.470
So essentially what
I'm doing is I'm

00:21:36.470 --> 00:21:38.050
filtering on a list of users.

00:21:38.050 --> 00:21:39.410
Right.

00:21:39.410 --> 00:21:43.050
So I'll do this later.

00:21:43.050 --> 00:21:45.670
To do later.

00:21:45.670 --> 00:21:46.810
OK.

00:21:46.810 --> 00:21:48.450
This to do, by the
way, is built in.

00:21:48.450 --> 00:21:51.180
You can use it instead of
not implemented exception--

00:21:51.180 --> 00:21:52.241
non implemented error.

00:21:52.241 --> 00:21:54.490
And it does a additional
thing that we won't get into,

00:21:54.490 --> 00:21:58.020
but nothing is actually
very nice in Kotlin,

00:21:58.020 --> 00:21:59.235
but we won't cover that now.

00:22:01.910 --> 00:22:03.300
It's nothing to worry about.

00:22:06.390 --> 00:22:07.280
I just made that up.

00:22:07.280 --> 00:22:08.620
OK.

00:22:08.620 --> 00:22:09.970
OK, thank you.

00:22:09.970 --> 00:22:13.770
So now how do I use this?

00:22:13.770 --> 00:22:17.490
I can do findEmails,
right, and I'll say--

00:22:17.490 --> 00:22:19.970
I actually have a user,
let's create some users here.

00:22:19.970 --> 00:22:22.060
So usersFromJSONFile.

00:22:22.060 --> 00:22:24.640
And I have some uses
over here, so users.json.

00:22:24.640 --> 00:22:28.350
So this is actually a
function that I have ready,

00:22:28.350 --> 00:22:31.570
which is basically using json
to read some users from a file.

00:22:31.570 --> 00:22:32.946
And this is a
typical data classs

00:22:32.946 --> 00:22:34.779
that you've already
seen, the only new thing

00:22:34.779 --> 00:22:39.021
here is that this also got
an enum class with a property

00:22:39.021 --> 00:22:39.520
Role.

00:22:39.520 --> 00:22:40.770
OK?

00:22:40.770 --> 00:22:43.600
So now I can do like
users, and then I'll

00:22:43.600 --> 00:22:45.120
pass in that function.

00:22:45.120 --> 00:22:46.920
Now I can pass in
the name function

00:22:46.920 --> 00:22:48.760
by using the column
column reference,

00:22:48.760 --> 00:22:50.380
or a can pass in a lambda.

00:22:50.380 --> 00:22:52.690
And in Kotlin, lambda
follows this syntax.

00:22:52.690 --> 00:22:57.510
You pass in the parameter name,
and then you say, for example,

00:22:57.510 --> 00:23:01.090
the parameter name
ends with right .com.

00:23:01.090 --> 00:23:04.880
So I'm getting a list of
users that end with .com.

00:23:04.880 --> 00:23:08.880
Now when you have a single
parameter in Kotlin,

00:23:08.880 --> 00:23:12.180
you can actually omit
having to explicitly mention

00:23:12.180 --> 00:23:14.980
it and replace it with it.

00:23:14.980 --> 00:23:17.277
So similar to Groovy,
you can just use it.

00:23:17.277 --> 00:23:19.110
The other thing that
you can doing in Kotlin

00:23:19.110 --> 00:23:22.710
is when the last parameter to
a function is another function,

00:23:22.710 --> 00:23:28.220
you can actually not
include it in the brackets.

00:23:28.220 --> 00:23:31.615
So it feels a little
bit like it's outside.

00:23:31.615 --> 00:23:33.740
And this is, again, one of
the characteristics that

00:23:33.740 --> 00:23:36.220
allow us to create nice
DSLs, and you can even

00:23:36.220 --> 00:23:37.770
do this like multi-line.

00:23:37.770 --> 00:23:40.140
So if you look at
findEmails now, in a sense

00:23:40.140 --> 00:23:43.900
it could actually feel like
it's part of the language,

00:23:43.900 --> 00:23:45.620
but it isn't, it's
actually a function.

00:23:45.620 --> 00:23:51.080
And when we implemented
aasynchronous programming with

00:23:51.080 --> 00:23:53.630
coroutines, we didn't
like-- you know,

00:23:53.630 --> 00:23:56.000
if you're familiar with C#,
C# does their sync or wait,

00:23:56.000 --> 00:23:57.560
there are keywords
in the language.

00:23:57.560 --> 00:23:58.935
In Kotlin, there
are not, they're

00:23:58.935 --> 00:24:00.660
essentially just functions.

00:24:00.660 --> 00:24:02.150
So that gives you
the flexibility

00:24:02.150 --> 00:24:06.170
of deciding how you want
to do different things.

00:24:06.170 --> 00:24:08.140
Now you don't have to
do all of these things,

00:24:08.140 --> 00:24:09.848
because all of these
things are built-in.

00:24:09.848 --> 00:24:12.220
So, for example, if
I say dotComUsers,

00:24:12.220 --> 00:24:16.480
I say users.filter, and you can
see that as I complete this,

00:24:16.480 --> 00:24:19.120
it actually opts for the
version of including out

00:24:19.120 --> 00:24:20.210
of the parameter.

00:24:20.210 --> 00:24:26.880
So I can say the
email.endsWith .com.

00:24:26.880 --> 00:24:32.340
And then I can go
and sort by it.id.

00:24:32.340 --> 00:24:35.030
And then let's go ahead
and do, for example,

00:24:35.030 --> 00:24:44.520
map that to a pair of
it.email and it.username.

00:24:44.520 --> 00:24:45.057
OK?

00:24:45.057 --> 00:24:46.640
So all of these
functions are actually

00:24:46.640 --> 00:24:48.266
built in in that
small standard library

00:24:48.266 --> 00:24:50.640
that ships, that you're not
going to problems on Android,

00:24:50.640 --> 00:24:51.310
it's very small.

00:24:51.310 --> 00:24:54.360
And they're all in,
essentially, extension functions

00:24:54.360 --> 00:24:58.180
on top of collections,
generic collections.

00:24:58.180 --> 00:25:01.510
So you have all of those
functional things that

00:25:01.510 --> 00:25:05.470
are very in fashion these days.

00:25:05.470 --> 00:25:10.380
And so this obviously
gives you a pair,

00:25:10.380 --> 00:25:12.960
and in fact, you can do
this even nicer, if instead

00:25:12.960 --> 00:25:17.760
of doing pair, it, to.

00:25:17.760 --> 00:25:19.730
So a map, email, to username.

00:25:19.730 --> 00:25:20.800
And guess what it is?

00:25:20.800 --> 00:25:25.460
It's just an infix function
that creates a pair.

00:25:25.460 --> 00:25:27.102
OK.?

00:25:27.102 --> 00:25:29.060
Now sometimes I don't go
through the whole map.

00:25:29.060 --> 00:25:33.060
I just want to, for example,
say get back a single element.

00:25:33.060 --> 00:25:37.690
And what you can also do
is destructure classes,

00:25:37.690 --> 00:25:39.470
data classes in Kotlin.

00:25:39.470 --> 00:25:44.030
So I could do something like
id, username, and email.

00:25:44.030 --> 00:25:47.670
OK and then I can
just use the ID.

00:25:47.670 --> 00:25:50.000
And this is great, but then
the IDE complains and says,

00:25:50.000 --> 00:25:51.557
well this variable
is never used.

00:25:51.557 --> 00:25:53.140
In that case, you
can actually replace

00:25:53.140 --> 00:25:56.880
that with an underscore.

00:25:56.880 --> 00:25:58.180
So there you go.

00:25:58.180 --> 00:26:00.015
And you can destructure
the values you want.

00:26:00.015 --> 00:26:02.640
Anything that you don't want to
use, replace with an underscore

00:26:02.640 --> 00:26:04.690
and you're good to go.

00:26:04.690 --> 00:26:05.900
Right.

00:26:05.900 --> 00:26:07.920
So what else can I show you?

00:26:07.920 --> 00:26:08.640
OK.

00:26:08.640 --> 00:26:11.170
So I've got some
other code here.

00:26:11.170 --> 00:26:13.850
If you're familiar with the
concept of algebraic data

00:26:13.850 --> 00:26:16.872
types, it's
essentially a type that

00:26:16.872 --> 00:26:19.330
can be of one type or another,
like for instance a Boolean.

00:26:19.330 --> 00:26:21.710
Now in Kotlin, the way that
we do that is with coclasses.

00:26:21.710 --> 00:26:23.250
But before I get
into that, let me

00:26:23.250 --> 00:26:25.190
go ahead and do an open here.

00:26:25.190 --> 00:26:28.470
Notice the first thing
here, that user result

00:26:28.470 --> 00:26:29.730
is giving me an error.

00:26:29.730 --> 00:26:32.320
Because by default in Kotlin,
you cannot inherit from

00:26:32.320 --> 00:26:32.940
classes.

00:26:32.940 --> 00:26:34.851
So all classes are
essentially final.

00:26:34.851 --> 00:26:36.350
If you want to
inherit from classes,

00:26:36.350 --> 00:26:40.870
you have to use the
open modifier, right?

00:26:40.870 --> 00:26:43.650
Now I've used the
sealed, and the sealed

00:26:43.650 --> 00:26:46.010
is essentially saying
that this is the hierarchy

00:26:46.010 --> 00:26:48.510
that user result has.

00:26:48.510 --> 00:26:50.540
Like, there's not going
to be any other class

00:26:50.540 --> 00:26:54.210
anywhere that is going to
inherit from user result.

00:26:54.210 --> 00:26:56.360
Everything that's going to
inherit from user result

00:26:56.360 --> 00:26:59.950
has to be in the same file, or
you can make these, of course,

00:26:59.950 --> 00:27:01.000
subclasses.

00:27:01.000 --> 00:27:06.070
So I could move this up there
and this would be a subclass,

00:27:06.070 --> 00:27:10.000
but then I would have to
prefix it with user result.

00:27:10.000 --> 00:27:10.860
OK.

00:27:10.860 --> 00:27:16.830
Now I've just created
it as a class outside,

00:27:16.830 --> 00:27:20.320
So why would I want to do this?

00:27:20.320 --> 00:27:21.452
Because it looks good.

00:27:21.452 --> 00:27:22.442
No.

00:27:22.442 --> 00:27:24.400
Well, this is actually
good because when you're

00:27:24.400 --> 00:27:27.940
doing some things, it's often
like your invoking a function

00:27:27.940 --> 00:27:30.110
and you're like, OK,
well if it's successful,

00:27:30.110 --> 00:27:31.300
I want it to return a value.

00:27:31.300 --> 00:27:33.320
If it's null, I'm going
to pass in a message.

00:27:33.320 --> 00:27:36.530
And then you get this type that
contains the values that you

00:27:36.530 --> 00:27:38.094
want to return when
it's successful,

00:27:38.094 --> 00:27:40.510
it contains the types that you
want to return when there's

00:27:40.510 --> 00:27:42.343
a message, and then
you've got to figure out

00:27:42.343 --> 00:27:45.740
the semantics of which
properties are applied

00:27:45.740 --> 00:27:48.050
to an error situation,
which properties are applied

00:27:48.050 --> 00:27:51.832
to non-error situation, or you
can just throw an exception.

00:27:51.832 --> 00:27:53.540
In this case, you can
use a function that

00:27:53.540 --> 00:27:54.960
basically returns two types.

00:27:54.960 --> 00:27:58.070
And then based on the
result, do different things.

00:27:58.070 --> 00:28:01.460
So here I say, for
instance, when--

00:28:01.460 --> 00:28:08.500
let's create an instant val,
result equals userresult--

00:28:08.500 --> 00:28:10.830
sorry, retrieveusers.

00:28:10.830 --> 00:28:17.490
So now I can do when
result is success,

00:28:17.490 --> 00:28:19.880
then we're going to do,
for instance, well we're

00:28:19.880 --> 00:28:21.255
going to get the
result, and then

00:28:21.255 --> 00:28:31.290
we're going to do users
forEach println the name.

00:28:31.290 --> 00:28:33.120
OK?

00:28:33.120 --> 00:28:35.320
username.

00:28:35.320 --> 00:28:39.550
And then we're going
to do a failure.

00:28:39.550 --> 00:28:44.370
Result println result.message.

00:28:44.370 --> 00:28:46.090
OK?

00:28:46.090 --> 00:28:49.390
So now based on
the result, based

00:28:49.390 --> 00:28:52.570
on the type that is returned to
me, I can do different things.

00:28:52.570 --> 00:28:55.290
I notice one thing over here,
that this has gone green.

00:28:55.290 --> 00:28:56.560
I don't know if you see
it on the big screen,

00:28:56.560 --> 00:28:57.680
but this has gone green.

00:28:57.680 --> 00:28:58.960
And this is a Smart cast.

00:28:58.960 --> 00:29:00.918
So that's another thing
that we have in Kotlin,

00:29:00.918 --> 00:29:04.402
and you saw that when I
was doing the null check,

00:29:04.402 --> 00:29:06.860
that is said this is not null,
because it is Smart casting.

00:29:06.860 --> 00:29:10.010
So you don't have to explicitly
come over here again and say,

00:29:10.010 --> 00:29:14.480
oh, I know that this is of
type success, let me go ahead

00:29:14.480 --> 00:29:17.650
and cast this to type success,
to then access the property.

00:29:17.650 --> 00:29:19.510
The compiler will do
that for you, that's

00:29:19.510 --> 00:29:22.260
what the smart casting is.

00:29:22.260 --> 00:29:23.170
Right.

00:29:23.170 --> 00:29:25.790
And last but not least,
before hand it off to Andrey

00:29:25.790 --> 00:29:28.510
quickly just mention, also,
that a lot of the things you've

00:29:28.510 --> 00:29:31.490
been seeing with the filter
map, all of those things,

00:29:31.490 --> 00:29:36.700
those are essentially
eager evaluation.

00:29:36.700 --> 00:29:39.470
But we also have the ability
to do lazy evaluation.

00:29:39.470 --> 00:29:43.250
So I can do val, for example,
sorry, generateSequence,

00:29:43.250 --> 00:29:46.320
and then have something,
for instance, 1.

00:29:46.320 --> 00:29:57.280
And then here, we'll do it times
10, and then we'll do values.

00:29:57.280 --> 00:30:07.740
Now I'll say values.take(10),
and then forEach println it.

00:30:07.740 --> 00:30:10.220
Now this is essentially
creating a sequence,

00:30:10.220 --> 00:30:11.529
a generator that is infinite.

00:30:11.529 --> 00:30:12.570
It's never going to stop.

00:30:12.570 --> 00:30:14.720
It's going to start at
one and multiply by 10.

00:30:14.720 --> 00:30:18.320
But what I'm saying here is that
I just want to take 10 elements

00:30:18.320 --> 00:30:19.800
and then print them out.

00:30:19.800 --> 00:30:23.140
And what it will do is basically
consume that until it hits 10.

00:30:23.140 --> 00:30:25.170
It prints out-- go away--

00:30:28.830 --> 00:30:33.060
it prints out a
beautiful Christmas tree

00:30:33.060 --> 00:30:35.420
that's one-sided.

00:30:35.420 --> 00:30:39.100
OK, pyramid, whatever,
and stops there.

00:30:39.100 --> 00:30:41.260
And anything that you
have, like for example,

00:30:41.260 --> 00:30:48.670
the users that we had, users
from Jason, users.json,

00:30:48.670 --> 00:30:51.750
you can say asSequence and
convert it into lazy evaluation

00:30:51.750 --> 00:30:52.250
as well.

00:30:52.250 --> 00:30:53.094
OK?

00:30:53.094 --> 00:30:55.010
That's all we have the
time to show you today.

00:30:55.010 --> 00:30:58.000
Obviously, there's way
more to the language.

00:30:58.000 --> 00:30:59.941
Go online, learn
everything about it,

00:30:59.941 --> 00:31:00.940
and thank you very much.

00:31:00.940 --> 00:31:02.260
And I'll hand it off to Andrey.

00:31:06.400 --> 00:31:08.170
ANDRY BRESLAV: Thank you, Hadi.

00:31:08.170 --> 00:31:09.720
Hello, everybody.

00:31:09.720 --> 00:31:15.120
So as you've seen Kotlin already
has many things in store,

00:31:15.120 --> 00:31:18.090
but I am the nasty person who
adds new futures before you

00:31:18.090 --> 00:31:19.960
learn the existing ones.

00:31:19.960 --> 00:31:22.140
So I'll be tell you
stories now, but I'll

00:31:22.140 --> 00:31:23.936
need to find a clicker.

00:31:23.936 --> 00:31:25.790
Do I have a clicker?

00:31:25.790 --> 00:31:27.280
No, OK.

00:31:27.280 --> 00:31:31.240
OK, so I'll be telling
stories without a clicker.

00:31:31.240 --> 00:31:33.860
So my job here is to
tell you about what

00:31:33.860 --> 00:31:36.440
we're going to have in the
future versions of Kotlin--

00:31:36.440 --> 00:31:37.440
oh, thank you very much.

00:31:40.440 --> 00:31:44.440
And the first big thing
we're working on now

00:31:44.440 --> 00:31:47.990
is platforms, supporting
different platforms.

00:31:47.990 --> 00:31:52.030
So historically, Kotlin
compiles to JVM bytecode,

00:31:52.030 --> 00:31:54.500
same as the Java
programming language.

00:31:54.500 --> 00:31:57.450
So we can run a
server on the desktop

00:31:57.450 --> 00:32:00.850
and of course on Android.

00:32:00.850 --> 00:32:03.610
And it's just the same
bytecode everywhere,

00:32:03.610 --> 00:32:05.630
this is why we can run
old versions of Android

00:32:05.630 --> 00:32:07.220
as well as new ones.

00:32:07.220 --> 00:32:10.280
But the story doesn't
end there, because we

00:32:10.280 --> 00:32:11.410
are adding new platforms.

00:32:11.410 --> 00:32:15.270
And recently, we've added--

00:32:15.270 --> 00:32:19.320
but God doesn't like platforms--

00:32:19.320 --> 00:32:21.330
recently we added
JavaScript, which

00:32:21.330 --> 00:32:24.680
means Kotlin can now compile
to JavaScript code and run

00:32:24.680 --> 00:32:27.420
in the browser or on node.js.

00:32:27.420 --> 00:32:32.370
So now we support three, major,
very popular virtual machines,

00:32:32.370 --> 00:32:36.700
JVM, Android Dalvik,
and JavaScript VMs.

00:32:36.700 --> 00:32:38.460
But there are many
US cases where

00:32:38.460 --> 00:32:41.020
a virtual machine is not
practical or is simply

00:32:41.020 --> 00:32:42.750
unavailable.

00:32:42.750 --> 00:32:46.360
For example, for
iOS, virtual machines

00:32:46.360 --> 00:32:47.630
are severely restricted.

00:32:47.630 --> 00:32:49.780
You can't do dynamic
code generation,

00:32:49.780 --> 00:32:52.920
or for a small embedded
system, a VM doesn't fit in.

00:32:52.920 --> 00:32:55.560
Or for, say, a Linux
command line tool,

00:32:55.560 --> 00:32:59.170
the VM will be a starting
tool for too long.

00:32:59.170 --> 00:33:01.650
So it's a no go
there, and that's

00:33:01.650 --> 00:33:04.330
why we're working on something
called Kotlin/Native,

00:33:04.330 --> 00:33:08.220
it's currently available
as a technology preview.

00:33:08.220 --> 00:33:11.710
And there, we basically use
LVM to compile Kotlin down

00:33:11.710 --> 00:33:14.320
to a native code, to
stand along binaries that

00:33:14.320 --> 00:33:15.710
can run on different platforms.

00:33:15.710 --> 00:33:19.000
Currently, we support
iOS, Linux, and Mac,

00:33:19.000 --> 00:33:21.410
and Windows is in the works.

00:33:21.410 --> 00:33:26.920
So this is taking us to
this vision with Kotlin,

00:33:26.920 --> 00:33:30.010
when it can run
inside every component

00:33:30.010 --> 00:33:34.010
of a modern application,
on any platform you like.

00:33:34.010 --> 00:33:36.120
So think full stack
web applications

00:33:36.120 --> 00:33:40.070
with the server and the
client both written in Kotlin,

00:33:40.070 --> 00:33:44.220
or think reuse code between
mobile platforms, Android

00:33:44.220 --> 00:33:45.650
and iOS for example.

00:33:45.650 --> 00:33:48.780
Or mix the two
previous use cases

00:33:48.780 --> 00:33:51.280
and get like a real
multiplatform scenario.

00:33:51.280 --> 00:33:54.970
So our vision for
Kotlin is having

00:33:54.970 --> 00:33:57.270
different models
in the same project

00:33:57.270 --> 00:34:00.270
compile to a
different platforms.

00:34:00.270 --> 00:34:02.770
And of course, you we want
to share code there, right?

00:34:02.770 --> 00:34:05.190
Because if you support
so many different things,

00:34:05.190 --> 00:34:07.650
you want to run the same
code in different places.

00:34:07.650 --> 00:34:10.920
And we're working on
making that possible.

00:34:10.920 --> 00:34:13.179
But there is a very
important thing,

00:34:13.179 --> 00:34:16.540
because previously,
many projects

00:34:16.540 --> 00:34:18.610
tried to unify platforms.

00:34:18.610 --> 00:34:21.330
And this often ends up
being like the least common

00:34:21.330 --> 00:34:24.550
denominator, when you
take only things that

00:34:24.550 --> 00:34:27.320
are available on all
platforms, you are basically

00:34:27.320 --> 00:34:29.659
stuck with a minimal
interface, and that's something

00:34:29.659 --> 00:34:31.239
we don't want to have there.

00:34:31.239 --> 00:34:33.630
So we want you to
be able to use all

00:34:33.630 --> 00:34:35.929
the platform-specific
fancy APIs like the newest

00:34:35.929 --> 00:34:40.050
version of Android or something
else as much as you like.

00:34:40.050 --> 00:34:41.730
And if you want to
share some code,

00:34:41.730 --> 00:34:46.860
only then you have to
resort to some common APIs.

00:34:46.860 --> 00:34:49.830
So the idea there is that you
have a common model with lots

00:34:49.830 --> 00:34:53.380
of business logic and stuff,
and it can work side by side

00:34:53.380 --> 00:34:56.540
with a platform specific
model written also in Kotlin,

00:34:56.540 --> 00:34:58.910
and those two can
talk to each other.

00:34:58.910 --> 00:35:01.790
So when you need, you
leverage the platform API,

00:35:01.790 --> 00:35:04.820
and when you need, you
use the Kotlin code.

00:35:04.820 --> 00:35:10.420
So take away here, our
future is multiplatform.

00:35:10.420 --> 00:35:11.450
Next-- oh.

00:35:17.020 --> 00:35:20.490
Next big thing is couroutines.

00:35:20.490 --> 00:35:23.690
So the rationale there is
pretty straightforward,

00:35:23.690 --> 00:35:26.860
everybody needs to write
asynchronous code, right?

00:35:26.860 --> 00:35:31.410
Because the world is too big
now for sequential execution.

00:35:31.410 --> 00:35:36.510
And it's our reality,
but it's hard, right?

00:35:36.510 --> 00:35:39.970
Who has written
asynchronous code?

00:35:39.970 --> 00:35:41.970
Quite so many hands.

00:35:41.970 --> 00:35:46.210
Those of you who don't actually
will be doing this very soon.

00:35:46.210 --> 00:35:48.419
And the problem is, it's
rather hard, actually,

00:35:48.419 --> 00:35:49.460
to write sequential code.

00:35:49.460 --> 00:35:52.120
Or it was hard before
languages learned

00:35:52.120 --> 00:35:56.190
to support you in doing that,
because a language can help you

00:35:56.190 --> 00:35:57.240
there a lot.

00:35:57.240 --> 00:36:00.040
So basically what we have
with coroutines in Kotlin,

00:36:00.040 --> 00:36:02.420
you're right asynchronous
code the same way

00:36:02.420 --> 00:36:03.916
you write synchronous code.

00:36:03.916 --> 00:36:05.540
So what do you use
in synchronous code?

00:36:05.540 --> 00:36:08.490
Loops, ifs, breaks
and continues,

00:36:08.490 --> 00:36:09.640
things like that, right?

00:36:09.640 --> 00:36:13.130
And it's the same things
you're using with coroutines

00:36:13.130 --> 00:36:18.390
for asynchronous code, so
that the language keeps track

00:36:18.390 --> 00:36:21.550
of everything and you don't have
to express an intricate control

00:36:21.550 --> 00:36:25.650
flow for a synchronous
computation in your code.

00:36:25.650 --> 00:36:29.760
No call backs, no fancy
functional structures,

00:36:29.760 --> 00:36:34.220
it's just plain old
sequential-looking code.

00:36:34.220 --> 00:36:35.400
And isn't it cool?

00:36:39.180 --> 00:36:40.630
Thank you.

00:36:40.630 --> 00:36:44.740
So the idea with coroutines
is that you basically

00:36:44.740 --> 00:36:48.310
have the same abstraction for
asynchronous and synchronous.

00:36:48.310 --> 00:36:51.400
And also, it's a nice
metaphor to think of them

00:36:51.400 --> 00:36:54.630
as almost free of threads.

00:36:54.630 --> 00:36:59.037
Like here is the only code
example I'm showing you.

00:36:59.037 --> 00:37:01.120
Basically, very many things
that are traditionally

00:37:01.120 --> 00:37:03.310
done with threads can
be done with coroutines,

00:37:03.310 --> 00:37:05.130
but coroutines are
extremely cheap.

00:37:05.130 --> 00:37:08.040
So here on the slide,
I have a code that

00:37:08.040 --> 00:37:09.980
creates 100,000 coroutines.

00:37:09.980 --> 00:37:11.070
Think about that.

00:37:11.070 --> 00:37:15.490
100,000 coroutines existing in
parallel, and each one of them

00:37:15.490 --> 00:37:18.790
waits for one second
and returns one.

00:37:18.790 --> 00:37:24.150
So this program completes
in, completes in one

00:37:24.150 --> 00:37:28.470
second, almost one second,
because all the coroutines wait

00:37:28.470 --> 00:37:30.250
in parallel, of course.

00:37:30.250 --> 00:37:35.150
But if you tried to do this with
threads, it just doesn't work.

00:37:35.150 --> 00:37:38.050
100,000 threads don't
fit into memory.

00:37:38.050 --> 00:37:39.200
That's it.

00:37:39.200 --> 00:37:42.540
So with coroutines, it's
a win-win situation.

00:37:42.540 --> 00:37:46.100
You get lots of performance,
so it's very efficient,

00:37:46.100 --> 00:37:47.930
and the code is simple.

00:37:47.930 --> 00:37:51.380
So take away here,
check out coroutines,

00:37:51.380 --> 00:37:54.070
because our future will likely
to even more asynchronous

00:37:54.070 --> 00:37:54.875
than our present.

00:37:57.580 --> 00:37:59.850
So I'm almost done,
and if you want

00:37:59.850 --> 00:38:02.710
to learn more about Kotlin,
check out our website.

00:38:02.710 --> 00:38:04.960
We have a section for Android.

00:38:04.960 --> 00:38:08.900
And also, we'll have a question
and answer session right

00:38:08.900 --> 00:38:14.250
after this talk, so come over
to the Developer sandbox,

00:38:14.250 --> 00:38:18.180
section C. Myself and Hadi will
be answering questions there.

00:38:18.180 --> 00:38:20.740
So thank you very much
for your attention.

