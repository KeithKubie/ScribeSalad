WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.860
[MUSIC PLAYING]

00:00:08.407 --> 00:00:08.990
SPEAKER 1: OK.

00:00:08.990 --> 00:00:10.310
So, welcome.

00:00:10.310 --> 00:00:11.340
Good morning, everyone.

00:00:11.340 --> 00:00:14.030
It's my pleasure to welcome
Professor Ousterhout

00:00:14.030 --> 00:00:16.630
for this Talks at
Google presentation.

00:00:16.630 --> 00:00:17.860
My name is [INAUDIBLE].

00:00:17.860 --> 00:00:21.200
I work in Technical
Infrastructure Cloud.

00:00:21.200 --> 00:00:24.170
Very quick intro to John to
get things started here--

00:00:24.170 --> 00:00:28.640
John is a Professor of Computer
Science at Stanford University.

00:00:28.640 --> 00:00:31.990
He spent, before that,
14 years in industry

00:00:31.990 --> 00:00:35.400
where he founded two companies,
Scriptics and Electric Cloud

00:00:35.400 --> 00:00:39.500
and, before that, 14 years as
a professor at UC Berkeley.

00:00:39.500 --> 00:00:42.620
Anybody here who has taken
a class with John before--

00:00:42.620 --> 00:00:45.300
so a bunch of his
students as well.

00:00:45.300 --> 00:00:47.090
So he's pretty
distinguished, so I'm not

00:00:47.090 --> 00:00:50.090
going to go through a
list of his awards here--

00:00:50.090 --> 00:00:53.810
a member of the National Academy
of Engineering, ACM Software

00:00:53.810 --> 00:00:57.800
System Award, UC Berkeley
Distinguished Teaching Award,

00:00:57.800 --> 00:00:59.480
to name a few here.

00:00:59.480 --> 00:01:02.360
But more relevant
to this talk, John

00:01:02.360 --> 00:01:05.810
has built several influential
systems, the Sprite operating

00:01:05.810 --> 00:01:10.430
system, Tcl, Tk, log-structured
file systems, Raft,

00:01:10.430 --> 00:01:13.470
and, more recently, RAMCloud.

00:01:13.470 --> 00:01:15.830
And I think his bios
says he has literally

00:01:15.830 --> 00:01:17.830
graded, like, thousands
of programming student

00:01:17.830 --> 00:01:19.540
assignments.

00:01:19.540 --> 00:01:22.340
And today, we are going to
hear the synthesis of all

00:01:22.340 --> 00:01:24.740
of John's first-hand knowledge
both from his research

00:01:24.740 --> 00:01:29.210
and teaching on a topic that's
very close to us, how to design

00:01:29.210 --> 00:01:31.900
and how not to design software.

00:01:31.900 --> 00:01:32.900
There is a book here.

00:01:32.900 --> 00:01:35.330
I don't have it to show.

00:01:35.330 --> 00:01:37.430
Let me show it to
the camera here.

00:01:37.430 --> 00:01:40.530
There is a book or "A
Philosophy of Software Design."

00:01:40.530 --> 00:01:43.170
I was pretty lucky to read
the pre-print of this.

00:01:43.170 --> 00:01:44.814
It's a really good book.

00:01:44.814 --> 00:01:46.730
And hopefully, he'll
tell us a little bit more

00:01:46.730 --> 00:01:47.521
about that as well.

00:01:47.521 --> 00:01:50.540
And last note, if
you have questions,

00:01:50.540 --> 00:01:52.860
since this is being recorded,
just raise your hand,

00:01:52.860 --> 00:01:54.110
and you'll get the mic to you.

00:01:54.110 --> 00:01:55.505
And then you can ask questions.

00:01:55.505 --> 00:01:56.800
So, welcome, John.

00:01:56.800 --> 00:01:57.070
JOHN OUTSERHOUT: Great.

00:01:57.070 --> 00:01:57.570
Thank you.

00:01:57.570 --> 00:02:02.649
[APPLAUSE]

00:02:02.649 --> 00:02:04.440
First of all, I do not
have an hour's worth

00:02:04.440 --> 00:02:05.760
of material prepared,
because there

00:02:05.760 --> 00:02:06.860
will be lots of questions.

00:02:06.860 --> 00:02:08.865
I'm happy to take
them in line as we go.

00:02:08.865 --> 00:02:10.740
At some point, probably,
there'll be too many

00:02:10.740 --> 00:02:12.280
and we're running late,
then I'll cut them off.

00:02:12.280 --> 00:02:14.880
But feel free to ask questions,
you know, expresses disbelief,

00:02:14.880 --> 00:02:17.430
argue, insult my mother,
whatever you wish,

00:02:17.430 --> 00:02:18.300
during the talk.

00:02:18.300 --> 00:02:20.840
But do make sure that the
insults are on the mic.

00:02:20.840 --> 00:02:23.110
[LAUGHTER]

00:02:23.110 --> 00:02:23.610
OK.

00:02:23.610 --> 00:02:25.318
So people have been
programming computers

00:02:25.318 --> 00:02:26.700
for more than 80 years now.

00:02:26.700 --> 00:02:31.162
And yet software design is
still basically a black art.

00:02:31.162 --> 00:02:34.770
There's essentially no agreement
on how to do software design

00:02:34.770 --> 00:02:36.990
or even what a good piece
of software looks like.

00:02:36.990 --> 00:02:39.750
You know, we talk a lot
about software engineering,

00:02:39.750 --> 00:02:43.630
and software tools, and
testing, and processes.

00:02:43.630 --> 00:02:46.080
But we have almost
no conversation

00:02:46.080 --> 00:02:49.200
about the fundamental act
of designing software.

00:02:49.200 --> 00:02:51.342
And this has bugged
me for a long time.

00:02:51.342 --> 00:02:53.550
So today, I'd like to tell
you about some things I've

00:02:53.550 --> 00:02:56.670
been doing to try and change
that, to start the conversation

00:02:56.670 --> 00:02:59.670
and to see if we can somehow
create a more, a greater,

00:02:59.670 --> 00:03:01.986
sense of design awareness
in the software community.

00:03:01.986 --> 00:03:03.360
And that consists
of a new course

00:03:03.360 --> 00:03:04.860
I developed at
Stanford and then,

00:03:04.860 --> 00:03:07.571
based on that, a book
on software design.

00:03:07.571 --> 00:03:08.070
OK.

00:03:08.070 --> 00:03:10.550
So let's start with the basics.

00:03:10.550 --> 00:03:14.570
If you had to pick one
idea, one concept that's

00:03:14.570 --> 00:03:16.945
the most important thing in
all of computer science, one

00:03:16.945 --> 00:03:19.070
thing that threads through
every aspect of computer

00:03:19.070 --> 00:03:21.470
science from AI to systems
to theory, first of all,

00:03:21.470 --> 00:03:22.505
what would you pick?

00:03:22.505 --> 00:03:23.532
AUDIENCE: Abstraction.

00:03:23.532 --> 00:03:24.740
JOHN OUTSERHOUT: Abstraction.

00:03:24.740 --> 00:03:25.690
AUDIENCE: Testing.

00:03:25.690 --> 00:03:26.020
JOHN OUTSERHOUT: Sorry?

00:03:26.020 --> 00:03:26.480
AUDIENCE: Testing.

00:03:26.480 --> 00:03:27.521
JOHN OUTSERHOUT: Testing.

00:03:27.521 --> 00:03:28.315
Other ideas?

00:03:28.315 --> 00:03:29.500
AUDIENCE: Composition.

00:03:29.500 --> 00:03:29.720
JOHN OUTSERHOUT: Sorry?

00:03:29.720 --> 00:03:30.560
AUDIENCE: Composition.

00:03:30.560 --> 00:03:31.790
JOHN OUTSERHOUT: Composition.

00:03:31.790 --> 00:03:32.962
AUDIENCE: Complexity.

00:03:32.962 --> 00:03:33.920
JOHN OUTSERHOUT: Sorry?

00:03:33.920 --> 00:03:34.795
AUDIENCE: Complexity.

00:03:34.795 --> 00:03:36.250
JOHN OUTSERHOUT: Complexity.

00:03:36.250 --> 00:03:38.220
So I asked Don
Knuth this question.

00:03:38.220 --> 00:03:40.850
He said, layers of
abstraction, which I would say

00:03:40.850 --> 00:03:42.090
is almost right.

00:03:42.090 --> 00:03:42.590
[LAUGHTER]

00:03:42.590 --> 00:03:46.440
Although, some would say,
by definition, it's right.

00:03:46.440 --> 00:03:49.550
What I would say is
problem decomposition.

00:03:49.550 --> 00:03:51.970
How do you take a
complicated problem or system

00:03:51.970 --> 00:03:53.960
and chop it up into
pieces that you can

00:03:53.960 --> 00:03:56.810
build relatively independently?

00:03:56.810 --> 00:03:59.540
And yet, as far as I know,
aside from what you're

00:03:59.540 --> 00:04:02.780
going to hear today, there
is no course anywhere

00:04:02.780 --> 00:04:05.390
where that concept is one
of the most important ideas

00:04:05.390 --> 00:04:06.350
in the course.

00:04:06.350 --> 00:04:09.170
We simply don't teach it.

00:04:09.170 --> 00:04:12.997
Second, we all know that
some programmers are way,

00:04:12.997 --> 00:04:14.330
way more productive than others.

00:04:14.330 --> 00:04:17.750
Google has coined the
term the 10x programmer.

00:04:17.750 --> 00:04:20.350
And yet, as far
as I know, no one

00:04:20.350 --> 00:04:23.507
attempts to teach
these skills either.

00:04:23.507 --> 00:04:25.840
And these ideas have been
sitting in the back of my head

00:04:25.840 --> 00:04:27.740
and bugging me for a long time.

00:04:27.740 --> 00:04:30.490
How can we have these things
that are so important,

00:04:30.490 --> 00:04:32.260
and yet we don't
really make any attempt

00:04:32.260 --> 00:04:33.385
to teach people this stuff?

00:04:33.385 --> 00:04:35.010
You know, if you're
a great programmer,

00:04:35.010 --> 00:04:37.030
somehow you just figure
it out on your own.

00:04:39.730 --> 00:04:42.700
So that leads to the
question, can we do this?

00:04:42.700 --> 00:04:44.550
And there's three
questions there.

00:04:44.550 --> 00:04:47.060
First, is it even possible?

00:04:47.060 --> 00:04:49.440
You know, is this just
a some sort of innate

00:04:49.440 --> 00:04:52.020
skill that you're born
with in your genes,

00:04:52.020 --> 00:04:53.860
or is it something
that can be taught?

00:04:53.860 --> 00:04:55.630
So first let's do
a quick survey.

00:04:55.630 --> 00:04:58.180
How many of you think this is
something that it's, you know,

00:04:58.180 --> 00:04:59.040
either you have it or you don't?

00:04:59.040 --> 00:05:00.123
You can't really teach it.

00:05:00.123 --> 00:05:02.952
It's just an innate skill.

00:05:02.952 --> 00:05:03.465
A few.

00:05:03.465 --> 00:05:04.840
How many think
that this could be

00:05:04.840 --> 00:05:07.720
taught in some way or another?

00:05:07.720 --> 00:05:08.260
Good.

00:05:08.260 --> 00:05:10.960
A few summers ago, I
read a really great book

00:05:10.960 --> 00:05:13.780
by Geoff Colvin titled
"Talent Is Overrated."

00:05:13.780 --> 00:05:15.260
If you want a fun read, read it.

00:05:15.260 --> 00:05:19.240
It's a relatively quick read
in which he goes through study

00:05:19.240 --> 00:05:21.100
after study that
shows in these fields

00:05:21.100 --> 00:05:24.550
where we think of some people
as being tremendously talented,

00:05:24.550 --> 00:05:27.100
in fact, the only thing
that really differentiates

00:05:27.100 --> 00:05:29.170
the top performers from
the average performers

00:05:29.170 --> 00:05:30.610
is how much they've practiced.

00:05:30.610 --> 00:05:33.064
That's the one consistent
correlating factor

00:05:33.064 --> 00:05:33.730
they could find.

00:05:33.730 --> 00:05:35.260
It's all about practice.

00:05:35.260 --> 00:05:36.940
So that got me
thinking, I mean, I

00:05:36.940 --> 00:05:40.330
believe it's got to be
possible to teach this.

00:05:40.330 --> 00:05:43.730
But the second thing is,
who's going to do it?

00:05:43.730 --> 00:05:47.050
Well, unfortunately, not
most of today's faculty.

00:05:47.050 --> 00:05:48.824
The problem is the
typical faculty member

00:05:48.824 --> 00:05:50.740
writes a little bit of
code as a grad student,

00:05:50.740 --> 00:05:52.156
never really gets
any instruction.

00:05:52.156 --> 00:05:54.610
You throw out some crappy
code for your dissertation,

00:05:54.610 --> 00:05:56.017
and then you become a professor.

00:05:56.017 --> 00:05:58.350
And then you decide coding
is what graduate students do,

00:05:58.350 --> 00:05:59.400
so you stop coding.

00:05:59.400 --> 00:06:01.670
And you never
write anymore code.

00:06:01.670 --> 00:06:04.630
And so, you know, the only way
to become a great developer

00:06:04.630 --> 00:06:06.610
and learn design skills
today is with tons

00:06:06.610 --> 00:06:09.200
of personal experience,
sort of trial and error.

00:06:09.200 --> 00:06:10.510
Faculty don't have that.

00:06:10.510 --> 00:06:12.830
So they can't teach
their students.

00:06:12.830 --> 00:06:16.000
And so the whole process
just continues over and over

00:06:16.000 --> 00:06:17.400
and over again.

00:06:17.400 --> 00:06:21.360
But, fortunately, I'm not
one of those faculty members.

00:06:21.360 --> 00:06:23.820
So maybe I have a better
chance of doing this.

00:06:23.820 --> 00:06:26.200
So, personally, I
love programming.

00:06:26.200 --> 00:06:29.070
I mean, programming, it's really
one of the top two or three

00:06:29.070 --> 00:06:31.320
things I live for-- you know,
my family, programming--

00:06:31.320 --> 00:06:32.550
[LAUGHTER]

00:06:32.550 --> 00:06:33.654
--really bad golf game.

00:06:33.654 --> 00:06:35.320
There's a sort of few
things [AUDIO OUT]

00:06:35.320 --> 00:06:36.710
the things that drive my life.

00:06:36.710 --> 00:06:39.570
But if I don't write 5,000
lines of code a year at least,

00:06:39.570 --> 00:06:41.837
I feel like it hasn't
been a great year for me.

00:06:41.837 --> 00:06:43.670
So in over my career,
I've probably written,

00:06:43.670 --> 00:06:46.750
I think now, 250,000 to
300,000 lines of code.

00:06:46.750 --> 00:06:48.504
So I've had a chance
to observe a lot.

00:06:48.504 --> 00:06:49.920
And, again, as
I've been doing it,

00:06:49.920 --> 00:06:51.930
I've been thinking
about design stuff.

00:06:51.930 --> 00:06:54.750
So I thought maybe, you know, if
anybody can do it in academia,

00:06:54.750 --> 00:06:58.750
I probably got about as
good a shot as anybody.

00:06:58.750 --> 00:07:02.140
Then the third question
is, well, how do you do it?

00:07:02.140 --> 00:07:04.840
So I combined all these
three things together.

00:07:04.840 --> 00:07:06.825
I finally decided only
one way to find out.

00:07:06.825 --> 00:07:08.200
I'm just going to
have to try it.

00:07:08.200 --> 00:07:11.630
You know, maybe I'll crash and
burn, but I'll give it a try.

00:07:11.630 --> 00:07:14.710
So I created a new course
at Stanford, CS 190 Software

00:07:14.710 --> 00:07:16.180
Design Studio.

00:07:16.180 --> 00:07:18.440
It's not taught like a
typical [INAUDIBLE] course.

00:07:18.440 --> 00:07:20.530
It's taught more
like the way you

00:07:20.530 --> 00:07:23.170
learned English
writing in high school

00:07:23.170 --> 00:07:24.640
with an iterative approach.

00:07:24.640 --> 00:07:26.560
So, you know, the way about
writing is you write something.

00:07:26.560 --> 00:07:27.602
Your teacher marks it up.

00:07:27.602 --> 00:07:28.518
You get it back again.

00:07:28.518 --> 00:07:29.080
You rewrite.

00:07:29.080 --> 00:07:30.280
They marking up again.

00:07:30.280 --> 00:07:32.740
And so the whole process
iterates several times.

00:07:32.740 --> 00:07:36.670
And it's that process of
getting criticism, incorporating

00:07:36.670 --> 00:07:38.230
the criticism and
learning and seeing

00:07:38.230 --> 00:07:39.800
how that makes things better.

00:07:39.800 --> 00:07:41.710
That's how you
become a good writer.

00:07:41.710 --> 00:07:45.020
So I thought we'll try the
same idea in the class.

00:07:45.020 --> 00:07:46.490
And so that's the way it works.

00:07:46.490 --> 00:07:48.850
Now, we only have 10
weeks in a quarter system.

00:07:48.850 --> 00:07:52.210
So we can only do three
iterations of this cycle.

00:07:52.210 --> 00:07:54.400
But the basic way it works
is in the first couple

00:07:54.400 --> 00:07:57.040
of weeks of the course,
students in teams of two

00:07:57.040 --> 00:07:59.890
build the largest
system they can possibly

00:07:59.890 --> 00:08:01.330
build in three weeks.

00:08:01.330 --> 00:08:04.900
That's typically about 2,000
to 3,000 lines of code, so,

00:08:04.900 --> 00:08:07.570
you know, still
not a huge system.

00:08:07.570 --> 00:08:10.930
Then after week three we
go into code review phase.

00:08:10.930 --> 00:08:13.510
Students read each
code and write reviews.

00:08:13.510 --> 00:08:16.029
And I read every
single line of code

00:08:16.029 --> 00:08:17.320
written by all of the students.

00:08:17.320 --> 00:08:19.690
This is sort of one of the
limitations of the class

00:08:19.690 --> 00:08:20.190
right now.

00:08:20.190 --> 00:08:22.273
So I end up reading 20,000
to 30,000 lines of code

00:08:22.273 --> 00:08:24.700
in that week.

00:08:24.700 --> 00:08:26.725
And then we do code
reviews in class

00:08:26.725 --> 00:08:28.850
where students will present
pieces of their project

00:08:28.850 --> 00:08:30.430
and other students
will critique it.

00:08:30.430 --> 00:08:32.650
And then I do
longer code reviews.

00:08:32.650 --> 00:08:33.940
I read everybody's projects.

00:08:33.940 --> 00:08:36.750
I typically make 50 to 100
comments on every team.

00:08:36.750 --> 00:08:39.280
And then I meet with the
teams individually for an hour

00:08:39.280 --> 00:08:40.780
and go over it with them.

00:08:40.780 --> 00:08:42.520
Then the second
phase is they revise

00:08:42.520 --> 00:08:43.659
based on the code reviews.

00:08:43.659 --> 00:08:46.075
They actually add a little bit
of additional functionality

00:08:46.075 --> 00:08:47.360
as well in the second phase.

00:08:47.360 --> 00:08:49.059
We do another round
of code reviews.

00:08:49.059 --> 00:08:51.100
And then the third phase,
they get a new project.

00:08:51.100 --> 00:08:52.780
They start from scratch again.

00:08:52.780 --> 00:08:55.100
And we finally do a third
round of code reviews.

00:08:55.100 --> 00:08:57.880
And when they do this, the
students get no ideas from me

00:08:57.880 --> 00:08:58.930
about how to design.

00:08:58.930 --> 00:09:00.890
I just tell them what
the system has to do.

00:09:00.890 --> 00:09:03.340
They have to start from
scratch and figure everything

00:09:03.340 --> 00:09:04.040
out themselves.

00:09:04.040 --> 00:09:06.420
So they make lots of
mistakes in the first phase,

00:09:06.420 --> 00:09:08.560
but that's part of the
learning of the class.

00:09:08.560 --> 00:09:09.775
Yeah, another question?

00:09:09.775 --> 00:09:12.997
Mic's coming here.

00:09:12.997 --> 00:09:14.580
AUDIENCE: I watched
your YouTube video

00:09:14.580 --> 00:09:15.704
on the same topic you gave.

00:09:15.704 --> 00:09:19.150
And in that one, phase three,
it was past the project

00:09:19.150 --> 00:09:22.220
to person on the left and
inherit someone else's code.

00:09:22.220 --> 00:09:23.230
Why did you change it?

00:09:23.230 --> 00:09:23.420
JOHN OUTSERHOUT: Yeah.

00:09:23.420 --> 00:09:24.860
In the first two times
I taught the class,

00:09:24.860 --> 00:09:27.026
I actually scrambled the
projects in the third phase

00:09:27.026 --> 00:09:29.570
and made people add over
somebody else's project.

00:09:29.570 --> 00:09:31.220
That was a good
learning experience,

00:09:31.220 --> 00:09:34.880
but the problem is people
end up spending a lot of time

00:09:34.880 --> 00:09:37.780
decoding other people's projects
and being frustrated with it.

00:09:37.780 --> 00:09:39.650
That has some value,
but they don't

00:09:39.650 --> 00:09:41.800
spend as much time
doing real design stuff.

00:09:41.800 --> 00:09:43.910
And so I finally
decided if what I really

00:09:43.910 --> 00:09:45.440
want is to teach
people design, I

00:09:45.440 --> 00:09:48.050
think they'll learn more if
they get to start from scratch

00:09:48.050 --> 00:09:50.600
and do a new design project.

00:09:50.600 --> 00:09:51.375
So I changed it.

00:09:51.375 --> 00:09:52.450
I may change back again.

00:09:52.450 --> 00:09:55.540
I'll try this for a while
and see if it works.

00:09:55.540 --> 00:09:56.040
OK.

00:09:56.040 --> 00:09:59.620
So that's the basic
idea of the course.

00:09:59.620 --> 00:10:03.510
Now, you may be wondering, so
what are the magic secrets.

00:10:03.510 --> 00:10:05.680
How do you do software design?

00:10:05.680 --> 00:10:07.410
And by the way,
what makes me think

00:10:07.410 --> 00:10:09.510
I know what the secrets are?

00:10:09.510 --> 00:10:12.330
So first of all, I don't
claim to know all the answers.

00:10:12.330 --> 00:10:15.810
I have, you know, some ideas
that have kind of coalesced

00:10:15.810 --> 00:10:18.015
in my mind over the
years, which I'm using

00:10:18.015 --> 00:10:19.140
in the course and the book.

00:10:19.140 --> 00:10:20.130
I don't claim those are the end.

00:10:20.130 --> 00:10:21.840
Actually, I'm hoping
more to use those

00:10:21.840 --> 00:10:25.080
to start a discussion of
all of them over time.

00:10:25.080 --> 00:10:29.430
But in the class, there's about
sort of 10 high level ideas.

00:10:29.430 --> 00:10:32.460
They're very abstract,
almost philosophical.

00:10:32.460 --> 00:10:34.490
I can't give you a recipe.

00:10:34.490 --> 00:10:36.180
You know, follow these
10 steps, and you

00:10:36.180 --> 00:10:37.360
will produce a great design.

00:10:37.360 --> 00:10:39.330
I'm not sure that
there is such a recipe.

00:10:39.330 --> 00:10:41.370
So instead, there
are these vague ideas

00:10:41.370 --> 00:10:44.580
that I talk about while
students are doing

00:10:44.580 --> 00:10:47.080
their first round of design.

00:10:47.080 --> 00:10:48.654
I'm not sure they
sink in very well,

00:10:48.654 --> 00:10:49.820
because they're so abstract.

00:10:49.820 --> 00:10:53.010
It's probably hard to figure
out how to apply them.

00:10:53.010 --> 00:10:54.474
The way they work
best, though, was

00:10:54.474 --> 00:10:55.640
when we do the code reviews.

00:10:55.640 --> 00:10:58.890
Then I can show the
students how they violated

00:10:58.890 --> 00:11:00.750
some of these
principles and what

00:11:00.750 --> 00:11:02.430
the consequence
was in their code

00:11:02.430 --> 00:11:03.690
and how they should change it.

00:11:03.690 --> 00:11:05.970
And then they can go back
and apply the principles

00:11:05.970 --> 00:11:07.080
as they revise.

00:11:07.080 --> 00:11:11.230
And then I think the
ideas start sinking in.

00:11:11.230 --> 00:11:12.880
So it's sort of a--

00:11:12.880 --> 00:11:14.022
question in back, yeah.

00:11:19.324 --> 00:11:20.300
AUDIENCE: Yeah.

00:11:20.300 --> 00:11:23.630
I'm curious what you think about
how does the sort of end to end

00:11:23.630 --> 00:11:26.919
principle in sort of
software design factor

00:11:26.919 --> 00:11:29.210
into this in terms of trying
to push all the complexity

00:11:29.210 --> 00:11:32.107
to the edges of the system?

00:11:32.107 --> 00:11:33.690
JOHN OUTSERHOUT: End
to end principle?

00:11:33.690 --> 00:11:35.065
AUDIENCE: So like
the [INAUDIBLE]

00:11:35.065 --> 00:11:37.640
example of TCP, the checksum,
you know, is done end to end.

00:11:37.640 --> 00:11:40.640
It's not in the
intermediate router stages.

00:11:40.640 --> 00:11:42.725
And that was a design
principle that they had.

00:11:42.725 --> 00:11:44.070
JOHN OUTSERHOUT: I'll
have to think about that.

00:11:44.070 --> 00:11:46.611
I'm not sure that relates in a
direct way to this principles,

00:11:46.611 --> 00:11:48.870
but I'll have to
think about that.

00:11:48.870 --> 00:11:50.860
So there are these
vague principles.

00:11:50.860 --> 00:11:53.355
Then the other thing I try and
do is talk about red flags.

00:11:53.355 --> 00:11:55.590
So red flags are
very specific things

00:11:55.590 --> 00:11:59.040
that, if you see this sort
of behavior or pattern,

00:11:59.040 --> 00:12:00.390
you're probably in trouble.

00:12:00.390 --> 00:12:01.806
And actually I
think for beginners

00:12:01.806 --> 00:12:04.180
in particular, red flags
are really useful to people.

00:12:04.180 --> 00:12:07.170
Because even if you don't know
how to design the right system,

00:12:07.170 --> 00:12:08.890
if you can see
you're going wrong,

00:12:08.890 --> 00:12:10.860
then just try something
else until eventually

00:12:10.860 --> 00:12:12.540
the red flags go away.

00:12:12.540 --> 00:12:15.000
And you'll probably end up
in a pretty decent place.

00:12:15.000 --> 00:12:18.392
So red flags are
really very useful.

00:12:18.392 --> 00:12:19.850
So what I'd like
to do is I'm going

00:12:19.850 --> 00:12:21.950
to talk about the
four things that

00:12:21.950 --> 00:12:24.380
are in red just to give you
a sense of some of the ideas.

00:12:24.380 --> 00:12:26.000
Two of them are
design principles.

00:12:26.000 --> 00:12:27.040
Classes should be deep.

00:12:27.040 --> 00:12:28.786
Define areas out of existence.

00:12:28.786 --> 00:12:30.410
And two of them are
more about mindset.

00:12:30.410 --> 00:12:34.610
I'll talk about
those afterwards.

00:12:34.610 --> 00:12:38.990
So the first one is this notion
that classes should be deep.

00:12:38.990 --> 00:12:41.240
This is really just
another way of thinking

00:12:41.240 --> 00:12:45.290
about the idea of information
hiding David Parnas first put

00:12:45.290 --> 00:12:48.110
out in a paper in
the early 1970s.

00:12:48.110 --> 00:12:50.270
By the way, to me,
this paper is one

00:12:50.270 --> 00:12:52.880
of the two most important
classic papers and all software

00:12:52.880 --> 00:12:54.310
design and engineering.

00:12:54.310 --> 00:12:56.513
Has anybody here read
this paper in classes?

00:12:56.513 --> 00:12:57.380
Great.

00:12:57.380 --> 00:12:59.490
It's still topical
and relevant today.

00:12:59.490 --> 00:13:01.256
The last third maybe
not so much so,

00:13:01.256 --> 00:13:03.630
but the first part's still--
and it's got a great example

00:13:03.630 --> 00:13:05.600
and easy to read.

00:13:05.600 --> 00:13:07.280
So the way I think
about it, think

00:13:07.280 --> 00:13:09.760
about a class as a rectangle.

00:13:09.760 --> 00:13:13.160
And the area of the rectangle
is the functionality

00:13:13.160 --> 00:13:14.210
that class provides.

00:13:14.210 --> 00:13:17.780
So you can think of that's the
benefit that the class provides

00:13:17.780 --> 00:13:19.950
to the rest of the system.

00:13:19.950 --> 00:13:22.710
Then think about the
top edge as that's

00:13:22.710 --> 00:13:24.460
the interface to the class.

00:13:24.460 --> 00:13:27.720
And by interface, I
mean everything someone

00:13:27.720 --> 00:13:30.820
has to have in their mind
in order to use that class.

00:13:30.820 --> 00:13:33.180
It's not just the signatures
for the functions,

00:13:33.180 --> 00:13:35.700
but things like side effects
and dependencies and things

00:13:35.700 --> 00:13:37.700
like that.

00:13:37.700 --> 00:13:38.810
That's really the cost.

00:13:38.810 --> 00:13:41.680
You think that that's
the complexity cost

00:13:41.680 --> 00:13:45.310
that this class imposes
on the rest of the system.

00:13:45.310 --> 00:13:48.020
So we'd like that to be
as small as possible.

00:13:48.020 --> 00:13:51.050
So ideally, what you'd
like is the greatest cost--

00:13:51.050 --> 00:13:52.690
sorry, greatest
benefit, least cost.

00:13:52.690 --> 00:13:56.230
So you'd like the smallest
interface and then the largest

00:13:56.230 --> 00:13:57.140
area.

00:13:57.140 --> 00:14:00.270
So the opposite of that
I call a shallow class.

00:14:00.270 --> 00:14:01.730
So that's something
that has either

00:14:01.730 --> 00:14:03.813
not a whole lot of
functionality or really, really

00:14:03.813 --> 00:14:06.110
complicated interface or both.

00:14:06.110 --> 00:14:08.720
Those classes, they just
don't give us much leverage

00:14:08.720 --> 00:14:09.870
against complexity.

00:14:09.870 --> 00:14:12.350
In fact, in the worst
case, in the worst case,

00:14:12.350 --> 00:14:15.429
the additional overhead
of the interface

00:14:15.429 --> 00:14:16.970
adds more complexity
than what you've

00:14:16.970 --> 00:14:20.784
hidden underneath the interface,
and it's a net negative.

00:14:20.784 --> 00:14:22.950
What we'd like to have, of
course, on the other side

00:14:22.950 --> 00:14:24.390
is a deep class--

00:14:24.390 --> 00:14:28.020
very simple interface
with a very large amount

00:14:28.020 --> 00:14:29.640
of functionality underneath it.

00:14:29.640 --> 00:14:31.200
I mean, that's another way of
thinking about abstraction,

00:14:31.200 --> 00:14:31.710
right?

00:14:31.710 --> 00:14:33.700
The idea of abstraction
is we're trying

00:14:33.700 --> 00:14:35.760
to provide a simple
way of thinking

00:14:35.760 --> 00:14:38.760
about something that's actually
quite complicated underneath.

00:14:38.760 --> 00:14:41.457
So deep classes are
good abstractions.

00:14:41.457 --> 00:14:43.290
And this notion you can
apply it to classes.

00:14:43.290 --> 00:14:45.330
You can apply it to
methods within classes.

00:14:45.330 --> 00:14:47.640
You can apply it to interfaces
in general or modules

00:14:47.640 --> 00:14:49.380
in a system or
subsystems, anything

00:14:49.380 --> 00:14:53.724
like that that has an
interface or an implementation.

00:14:53.724 --> 00:14:55.009
Yeah, question.

00:14:55.009 --> 00:14:56.550
AUDIENCE: Is this
one of the concepts

00:14:56.550 --> 00:14:58.434
that you give your
students before they start

00:14:58.434 --> 00:14:59.850
the first project or after?

00:14:59.850 --> 00:15:04.770
Because it seem important
to give at least

00:15:04.770 --> 00:15:05.979
a few hints at the beginning.

00:15:05.979 --> 00:15:08.061
JOHN OUTSERHOUT: This is
what I give them before--

00:15:08.061 --> 00:15:09.580
well, it's concurrent
while they're

00:15:09.580 --> 00:15:10.380
doing the first project.

00:15:10.380 --> 00:15:12.400
We don't have enough time for
me to go through all the ideas

00:15:12.400 --> 00:15:13.470
before they start designing.

00:15:13.470 --> 00:15:14.590
So while they're
designing, we're

00:15:14.590 --> 00:15:16.006
talking about this
stuff in class.

00:15:18.870 --> 00:15:21.700
Here's a classical example
of a shallow method,

00:15:21.700 --> 00:15:25.400
which I have to say I
see distressingly often.

00:15:25.400 --> 00:15:28.340
There is essentially
no information hiding

00:15:28.340 --> 00:15:29.372
in this method.

00:15:29.372 --> 00:15:30.830
In order to use
it, you pretty much

00:15:30.830 --> 00:15:33.010
need to understand the
complete implementation.

00:15:33.010 --> 00:15:35.343
And, by the way, there's
almost no implementation there.

00:15:35.343 --> 00:15:39.020
In fact, this is so bad that
it takes more keystrokes

00:15:39.020 --> 00:15:42.860
to invoke the method
than if you had just did

00:15:42.860 --> 00:15:45.080
the body of the
function yourself.

00:15:45.080 --> 00:15:48.020
So it's basically
a complete loss,

00:15:48.020 --> 00:15:51.590
just adding complexity and
getting nothing back for it.

00:15:51.590 --> 00:15:54.396
Another example, actually,
of a relatively shallow class

00:15:54.396 --> 00:15:56.810
I see all the time is a
class for list manipulation.

00:15:56.810 --> 00:15:57.770
This is very shallow.

00:15:57.770 --> 00:15:59.190
I mean, lists are really
easy to manipulate.

00:15:59.190 --> 00:16:00.200
It's two pointers.

00:16:00.200 --> 00:16:02.200
We know the pointers are
hiding underneath there

00:16:02.200 --> 00:16:03.440
someplace anyhow.

00:16:03.440 --> 00:16:06.260
And so that's a
very shallow class.

00:16:06.260 --> 00:16:08.716
Now, you can't always
eliminate shallow classes.

00:16:08.716 --> 00:16:10.340
You know, sometimes
you end up the best

00:16:10.340 --> 00:16:11.800
you can do is a shallow class.

00:16:11.800 --> 00:16:15.320
And so I wouldn't say you
should never, ever have them.

00:16:15.320 --> 00:16:17.280
But a shallow class
doesn't buy you

00:16:17.280 --> 00:16:18.530
much from a design standpoint.

00:16:18.530 --> 00:16:21.205
It doesn't help you in the
fight against complexity.

00:16:24.530 --> 00:16:30.240
AUDIENCE: [INAUDIBLE]

00:16:30.240 --> 00:16:33.440
AUDIENCE: So I think one thing
that is perhaps a bit subtle

00:16:33.440 --> 00:16:36.500
is that the size of the class
is not the amount of code that

00:16:36.500 --> 00:16:37.420
is in it right now.

00:16:37.420 --> 00:16:40.640
It might be the amount of code
that you eventually have to add

00:16:40.640 --> 00:16:43.790
or if you have to have multiple
implementations of it, right?

00:16:43.790 --> 00:16:46.790
So maybe this doesn't
make sense in isolation,

00:16:46.790 --> 00:16:48.880
but perhaps there
is something else,

00:16:48.880 --> 00:16:50.960
there is another
implementation of it

00:16:50.960 --> 00:16:53.750
maybe right now or in the future
which is going and storing

00:16:53.750 --> 00:16:56.830
stuff in a database or
something like that.

00:16:56.830 --> 00:17:00.570
And so I kind of
wonder if you disagree

00:17:00.570 --> 00:17:02.520
with that
characterization that you

00:17:02.520 --> 00:17:05.290
need to keep track of the
evolution of the class in mind

00:17:05.290 --> 00:17:06.901
when deciding on its depth.

00:17:06.901 --> 00:17:08.609
JOHN OUTSERHOUT: Well,
I agree with that.

00:17:08.609 --> 00:17:10.525
In fact, the whole idea
behind software design

00:17:10.525 --> 00:17:12.185
is we're doing things
for the future.

00:17:12.185 --> 00:17:14.520
It's we're doing things today
to make it easier for us

00:17:14.520 --> 00:17:15.631
to develop in the future.

00:17:15.631 --> 00:17:17.339
And you have to think
a little bit ahead.

00:17:17.339 --> 00:17:19.380
Although, of course, you
know the classic problem

00:17:19.380 --> 00:17:21.780
with software is we can't
visualize the future very well.

00:17:21.780 --> 00:17:23.839
So it's dangerous to try
and think too far ahead.

00:17:23.839 --> 00:17:25.827
But I agree with your
concept in general.

00:17:25.827 --> 00:17:27.660
In this particular case,
though, the problem

00:17:27.660 --> 00:17:31.920
is that the interface is
already so specialized

00:17:31.920 --> 00:17:34.204
that there's just
probably not a lot of room

00:17:34.204 --> 00:17:35.370
for wiggle room under there.

00:17:35.370 --> 00:17:37.830
Almost certainly anything you
change to the implementation

00:17:37.830 --> 00:17:40.100
is probably also going
to change the interface.

00:17:40.100 --> 00:17:43.547
And so, again, it's probably
not going to help you.

00:17:43.547 --> 00:17:45.380
But, you know, if you
have reason to believe

00:17:45.380 --> 00:17:47.460
it will, well, yeah, sure.

00:17:49.965 --> 00:17:52.090
So the problem that leads
to this-- and by the way,

00:17:52.090 --> 00:17:54.480
I think this is one of the
biggest mistakes people make,

00:17:54.480 --> 00:17:58.480
too many, too small,
too shallow classes.

00:17:58.480 --> 00:18:01.180
And the reason people do
that is because they've

00:18:01.180 --> 00:18:03.750
been taught classes and
methods should be small.

00:18:03.750 --> 00:18:05.500
How many of you at
sometime in some course

00:18:05.500 --> 00:18:08.240
were taught your
method should be small?

00:18:08.240 --> 00:18:11.150
And how many of you have been
given a number, like any method

00:18:11.150 --> 00:18:14.334
larger than n lines,
you should chop it up?

00:18:14.334 --> 00:18:16.500
How many of you have heard
something like that said?

00:18:16.500 --> 00:18:17.820
OK.

00:18:17.820 --> 00:18:19.790
Tell me a small value
of n you've heard.

00:18:19.790 --> 00:18:20.547
AUDIENCE: 20.

00:18:20.547 --> 00:18:21.380
JOHN OUTSERHOUT: 20?

00:18:21.380 --> 00:18:22.475
[INTERPOSING VOICES]

00:18:22.475 --> 00:18:24.058
JOHN OUTSERHOUT: Has
anybody heard 10?

00:18:24.058 --> 00:18:26.280
[LAUGHTER]

00:18:26.280 --> 00:18:28.430
I've heard 10 sometimes.

00:18:28.430 --> 00:18:31.220
So if you take this
to the extreme,

00:18:31.220 --> 00:18:34.500
this results in what
I call classitis.

00:18:34.500 --> 00:18:38.640
Classitis is when somebody
says classes are good

00:18:38.640 --> 00:18:40.590
and somebody else
thought what they heard

00:18:40.590 --> 00:18:43.060
was more classes are better.

00:18:43.060 --> 00:18:44.760
[LAUGHTER]

00:18:44.760 --> 00:18:47.130
And so under
classitis, your goal

00:18:47.130 --> 00:18:50.520
is to have as many small
classes as possible

00:18:50.520 --> 00:18:52.650
where each class
adds the tiniest

00:18:52.650 --> 00:18:54.990
possible amount of
new functionality

00:18:54.990 --> 00:18:56.220
to the previous classes.

00:18:56.220 --> 00:18:57.928
If you want more
functionality than that,

00:18:57.928 --> 00:19:00.204
make another class for it.

00:19:00.204 --> 00:19:02.120
Probably the best example
of this in the world

00:19:02.120 --> 00:19:04.370
today is the Java Class Library.

00:19:04.370 --> 00:19:07.220
There's nothing in the Java
language that requires this.

00:19:07.220 --> 00:19:10.070
But somehow this has
just become the culture

00:19:10.070 --> 00:19:14.232
in the Java world, these tons of
little tiny shallow interfaces.

00:19:14.232 --> 00:19:16.690
Like, for example, the thing
that just bugged me about Java

00:19:16.690 --> 00:19:18.860
when I started programming,
if I want to open a file

00:19:18.860 --> 00:19:20.530
and read serialized
objects from it,

00:19:20.530 --> 00:19:23.922
I have to create three
objects for that.

00:19:23.922 --> 00:19:25.630
First, I have to create
this file stream.

00:19:25.630 --> 00:19:27.820
But for some reason,
I don't get buffering.

00:19:27.820 --> 00:19:29.880
If I want buffering--

00:19:29.880 --> 00:19:31.570
it's like, do you
want it eat today?

00:19:31.570 --> 00:19:32.872
[LAUGHTER]

00:19:32.872 --> 00:19:35.080
If I want buffering, I have
to create another object.

00:19:35.080 --> 00:19:36.850
And then if I want read
serialized objects,

00:19:36.850 --> 00:19:38.380
you add another
object on top of that.

00:19:38.380 --> 00:19:39.700
And each of these
can throw exceptions

00:19:39.700 --> 00:19:40.440
that I have to catch.

00:19:40.440 --> 00:19:42.315
And then exceptions can
come halfway through,

00:19:42.315 --> 00:19:43.750
and I have to do clean up--

00:19:43.750 --> 00:19:46.090
enormous amount of
complexity for something

00:19:46.090 --> 00:19:47.454
that's really, really simple.

00:19:47.454 --> 00:19:49.870
So I think they lost sight of
the idea that, first of all,

00:19:49.870 --> 00:19:52.780
in managing complexity, the
common case matters a lot.

00:19:52.780 --> 00:19:55.525
You want to make the common
case really, really simple.

00:19:55.525 --> 00:19:57.370
I shouldn't have
to do all of this.

00:19:57.370 --> 00:19:58.120
OK.

00:19:58.120 --> 00:20:00.110
Maybe I want to be able
to not have buffering,

00:20:00.110 --> 00:20:01.760
but that should be an
option that-- you know,

00:20:01.760 --> 00:20:04.384
if I don't want buffering, that
should be where things get more

00:20:04.384 --> 00:20:06.790
complicated, not to have to
remember to ask especially

00:20:06.790 --> 00:20:08.720
for buffering.

00:20:08.720 --> 00:20:10.130
So to me, it's not about length.

00:20:10.130 --> 00:20:12.080
Length is really not
the fundamental issues.

00:20:12.080 --> 00:20:13.496
I don't have
problems with methods

00:20:13.496 --> 00:20:16.160
that are hundreds of lines long
if they're relatively clean

00:20:16.160 --> 00:20:18.550
and if they have a
deep interface to them.

00:20:18.550 --> 00:20:19.490
It's abstraction.

00:20:19.490 --> 00:20:21.050
That's the most important thing.

00:20:21.050 --> 00:20:23.000
So rather than
striving for length,

00:20:23.000 --> 00:20:25.209
you should first try and
get these deep abstractions.

00:20:25.209 --> 00:20:26.750
And then if you end
up with something

00:20:26.750 --> 00:20:29.540
that's really big and long,
then see if you can chop it up.

00:20:29.540 --> 00:20:32.950
But depth is more important.

00:20:32.950 --> 00:20:35.110
So what's an example
of a deep interface?

00:20:35.110 --> 00:20:37.480
My favorite in the
world, probably one

00:20:37.480 --> 00:20:39.400
of the most beautiful
interfaces ever invented

00:20:39.400 --> 00:20:42.090
is that Unix file
I/O interface--

00:20:42.090 --> 00:20:45.460
five functions, falling
over easy interfaces

00:20:45.460 --> 00:20:46.210
to every function.

00:20:46.210 --> 00:20:49.680
The only complexity is the flags
and the permissions for open

00:20:49.680 --> 00:20:51.910
are a little bit funky,
but everything else

00:20:51.910 --> 00:20:53.900
is very, very simple.

00:20:53.900 --> 00:20:55.840
And then think
about what's hidden

00:20:55.840 --> 00:20:57.490
behind this simple interface.

00:20:57.490 --> 00:21:00.580
There's typically hundreds
of thousands of lines of code

00:21:00.580 --> 00:21:03.340
behind that that do everything
from managing disk space

00:21:03.340 --> 00:21:06.700
to file caching to, you
know, device drivers--

00:21:06.700 --> 00:21:09.580
enormous amount of code and, of
course, many other lower level

00:21:09.580 --> 00:21:14.050
interfaces behind this, but
just this amazingly beautiful

00:21:14.050 --> 00:21:16.180
five functions.

00:21:16.180 --> 00:21:18.610
Now, today, people look at
this and think, well, duh,

00:21:18.610 --> 00:21:20.650
of course, that's the
way you design things.

00:21:20.650 --> 00:21:22.810
But it was not like this.

00:21:22.810 --> 00:21:25.180
Has anybody in this
room actually programmed

00:21:25.180 --> 00:21:28.300
at around the time
Unix came out?

00:21:28.300 --> 00:21:31.620
Only a few of us are old
enough to have done that.

00:21:31.620 --> 00:21:33.840
Things were pretty
horrible before then.

00:21:33.840 --> 00:21:35.700
Like, for example, in
pre-Unix file systems,

00:21:35.700 --> 00:21:37.949
there would be a totally
different set of kernel calls

00:21:37.949 --> 00:21:40.620
if you wanted to open a file for
random access versus sequential

00:21:40.620 --> 00:21:41.240
access--

00:21:41.240 --> 00:21:43.950
two different sets kernel
calls, different kinds of files.

00:21:43.950 --> 00:21:47.170
You'd have to declare your file
random access or sequential.

00:21:47.170 --> 00:21:52.014
And Unix just had this
amazing the simple interface.

00:21:52.014 --> 00:21:54.990
So anyhow-- a beautiful example.

00:21:54.990 --> 00:21:55.490
OK.

00:21:55.490 --> 00:21:59.520
Let me go to my second
design principle, which is

00:21:59.520 --> 00:22:03.020
define errors out of existence.

00:22:03.020 --> 00:22:08.500
So we all know that exceptions
are a huge source of complexity

00:22:08.500 --> 00:22:09.240
in systems.

00:22:09.240 --> 00:22:11.082
For example, in the
RAMCloud storage system,

00:22:11.082 --> 00:22:13.415
we thought we were building
a low latency storage system

00:22:13.415 --> 00:22:15.998
and figured out we'd be spending
all of our time making things

00:22:15.998 --> 00:22:17.330
really fast and low latency.

00:22:17.330 --> 00:22:21.450
But, in fact, 90% of our time
went into doing crash recovery.

00:22:21.450 --> 00:22:23.860
So they're a huge
source of complexity.

00:22:23.860 --> 00:22:28.140
And, again, the common wisdom
kind of leads people astray.

00:22:28.140 --> 00:22:31.860
You're taught to program
defensively, which is good.

00:22:31.860 --> 00:22:33.720
But people then
think, ah, I should

00:22:33.720 --> 00:22:35.190
be throwing lots of exceptions.

00:22:35.190 --> 00:22:36.630
The more exceptions
I'm throwing,

00:22:36.630 --> 00:22:38.710
the better defense I'm doing.

00:22:38.710 --> 00:22:42.780
And as long as I, building my
module, catch all the errors

00:22:42.780 --> 00:22:44.640
and heave them up in
the air as exceptions,

00:22:44.640 --> 00:22:46.986
I don't have to worry
about where they land

00:22:46.986 --> 00:22:48.360
or who's going to
deal with them.

00:22:48.360 --> 00:22:49.150
I've done my job.

00:22:49.150 --> 00:22:51.080
In fact, the more of them I
throw, the better programmer

00:22:51.080 --> 00:22:51.780
I am.

00:22:51.780 --> 00:22:54.000
But then that just
results in this explosion

00:22:54.000 --> 00:22:56.484
of exceptions that have
to be caught and handled.

00:22:56.484 --> 00:22:58.650
And then the exceptions
themselves create more bugs.

00:22:58.650 --> 00:23:01.480
And you have secondary
exceptions and so on.

00:23:01.480 --> 00:23:04.410
So I would argue,
in general, overall,

00:23:04.410 --> 00:23:06.960
we should try to minimize
the number of places

00:23:06.960 --> 00:23:08.670
where you have to
handle exceptions.

00:23:08.670 --> 00:23:11.730
You can't completely eliminate
it, but try to minimize that.

00:23:11.730 --> 00:23:14.370
And the best case of all--

00:23:14.370 --> 00:23:16.860
which I found you can
do surprisingly often--

00:23:16.860 --> 00:23:19.470
is simply to redefine
the semantics,

00:23:19.470 --> 00:23:20.572
so that there is no error.

00:23:20.572 --> 00:23:21.780
There is no exception at all.

00:23:21.780 --> 00:23:22.710
That's the best.

00:23:22.710 --> 00:23:24.740
It's just gone completely.

00:23:24.740 --> 00:23:27.320
So let me give you
three examples of that.

00:23:27.320 --> 00:23:30.130
First one-- when I was designing
the Tcl scripting language

00:23:30.130 --> 00:23:33.010
many years ago, I introduced
an unset command, which

00:23:33.010 --> 00:23:35.780
deletes one and more variables.

00:23:35.780 --> 00:23:38.322
When I was doing
this, I thought--

00:23:38.322 --> 00:23:40.280
by the way, this is a
classic mistake, people--

00:23:40.280 --> 00:23:42.700
I thought why in
their right mind

00:23:42.700 --> 00:23:45.080
would anybody ever delete a
variable that doesn't exist?

00:23:45.080 --> 00:23:46.250
That makes no sense.

00:23:46.250 --> 00:23:49.510
So I'm going to throw
an exception for that.

00:23:49.510 --> 00:23:52.220
Well, turns out people
do that all the time.

00:23:52.220 --> 00:23:54.640
For example, you're halfway
through a computation.

00:23:54.640 --> 00:23:56.030
You decide you
just want to bail.

00:23:56.030 --> 00:23:57.740
So you want to clean up all
the mess you might have made.

00:23:57.740 --> 00:23:59.140
So you go through and
delete every variable

00:23:59.140 --> 00:24:00.730
that you might have
created, but you

00:24:00.730 --> 00:24:02.146
don't know which
ones you actually

00:24:02.146 --> 00:24:03.520
got around to creating yet.

00:24:03.520 --> 00:24:05.690
And so some of them don't exist.

00:24:05.690 --> 00:24:08.460
So in practice, people complain
about this all the time.

00:24:08.460 --> 00:24:10.840
And in fact, if you
look at Tcl code,

00:24:10.840 --> 00:24:13.990
I bet virtually every
invocation of the unset command

00:24:13.990 --> 00:24:16.840
is wrapped in a catch command
that will catch the exception

00:24:16.840 --> 00:24:19.890
and throw it away
when it happens.

00:24:19.890 --> 00:24:22.130
So what I should have done--

00:24:22.130 --> 00:24:24.059
in fact, I don't know
why I didn't fix it

00:24:24.059 --> 00:24:25.100
once I found the problem.

00:24:25.100 --> 00:24:26.825
That was my second mistake.

00:24:26.825 --> 00:24:28.950
What I should have done
was redefine the semantics,

00:24:28.950 --> 00:24:33.420
so that unset makes
a variable not exist.

00:24:33.420 --> 00:24:35.070
And if you think
of it that way, ah,

00:24:35.070 --> 00:24:37.820
well, if the variable doesn't
exist already, we're done,

00:24:37.820 --> 00:24:40.840
clean, no harm, no foul.

00:24:40.840 --> 00:24:42.350
So that's what I
should have done,

00:24:42.350 --> 00:24:45.060
should not have
thrown that exception.

00:24:45.060 --> 00:24:46.835
Another example
is file deletion.

00:24:50.210 --> 00:24:53.021
In Windows, at least
in the early days,

00:24:53.021 --> 00:24:55.130
if you tried to
delete a file when

00:24:55.130 --> 00:24:58.559
some process had the file
open, that was not allowed.

00:24:58.559 --> 00:24:59.600
Anybody experienced this?

00:24:59.600 --> 00:25:01.450
Anybody that have used
Windows experience this?

00:25:01.450 --> 00:25:02.532
It's this horrible thing.

00:25:02.532 --> 00:25:04.490
And then now you figure,
OK, who's got it open?

00:25:04.490 --> 00:25:06.906
You start going around killing
programs to try and make it

00:25:06.906 --> 00:25:08.135
so you delete the file.

00:25:08.135 --> 00:25:10.010
And you can't find which
program has it open.

00:25:10.010 --> 00:25:12.142
So finally, you just
give up, and you reboot.

00:25:12.142 --> 00:25:13.100
And then it turns out--

00:25:13.100 --> 00:25:14.340
[LAUGHTER]

00:25:14.340 --> 00:25:16.130
And then it turns out
that it's a system

00:25:16.130 --> 00:25:17.400
daemon that has the file open.

00:25:17.400 --> 00:25:19.240
So when you reboot,
it's still in use.

00:25:19.240 --> 00:25:20.730
You can't delete.

00:25:20.730 --> 00:25:25.430
So Unix has a beautiful
really lovely solution

00:25:25.430 --> 00:25:27.620
that makes this error go away.

00:25:27.620 --> 00:25:29.900
In Unix, if you delete
a file while it's open,

00:25:29.900 --> 00:25:32.465
what happens is it deletes
the file from the directory

00:25:32.465 --> 00:25:33.550
and from the namespace.

00:25:33.550 --> 00:25:35.960
It no longer appears
anywhere in the file system.

00:25:35.960 --> 00:25:37.910
But the actual
contents of the file

00:25:37.910 --> 00:25:41.360
still hang around, so that any
process that's using the file

00:25:41.360 --> 00:25:43.670
can continue to access the file.

00:25:43.670 --> 00:25:47.750
And then when the last
open instance of the file

00:25:47.750 --> 00:25:50.330
is closed, then finally it
cleans up and throws away

00:25:50.330 --> 00:25:51.260
everything else.

00:25:51.260 --> 00:25:52.460
It's a lovely solution.

00:25:52.460 --> 00:25:53.820
Because you could have
made the other mistake,

00:25:53.820 --> 00:25:55.611
which is that I'm going
to delete the file.

00:25:55.611 --> 00:25:57.970
And now, anybody doing I/O
on the file gets an error.

00:25:57.970 --> 00:25:58.970
That would probably
be even worse,

00:25:58.970 --> 00:26:00.410
because now every
program would have

00:26:00.410 --> 00:26:01.700
to be written to
handle the case where

00:26:01.700 --> 00:26:04.039
the file goes away in the
middle of your accessing it.

00:26:04.039 --> 00:26:06.080
So Unix had this beautiful
solution where there's

00:26:06.080 --> 00:26:07.730
no errors on either side.

00:26:07.730 --> 00:26:11.040
It just does the right thing.

00:26:11.040 --> 00:26:13.377
So Windows, they eventually
realized this was a problem.

00:26:13.377 --> 00:26:15.960
And I don't know where they are
in the evolution of fixing it.

00:26:15.960 --> 00:26:18.110
But I know that the
first stage they did

00:26:18.110 --> 00:26:19.910
is they had some
special flag you

00:26:19.910 --> 00:26:22.490
could set that would say, delete
the file even if it's open.

00:26:22.490 --> 00:26:24.531
Or you can maybe when you
open the file-- so then

00:26:24.531 --> 00:26:27.020
you can allow it to be
deleted while it's open.

00:26:27.020 --> 00:26:29.210
But they didn't get rid
of the directory entry.

00:26:29.210 --> 00:26:31.520
They kept the
directory entry around.

00:26:31.520 --> 00:26:34.784
And so you couldn't recreate
the file while it was open.

00:26:34.784 --> 00:26:36.700
So if you were, for
example, trying to rebuild

00:26:36.700 --> 00:26:38.241
and, you know, the
binary was in use,

00:26:38.241 --> 00:26:41.130
you couldn't create a new
version of the binary file,

00:26:41.130 --> 00:26:43.110
because the directory
entry was locked down.

00:26:43.110 --> 00:26:45.437
So they still
didn't get it right.

00:26:45.437 --> 00:26:48.020
So, again-- examples of why you
just want to make these errors

00:26:48.020 --> 00:26:49.330
go away.

00:26:49.330 --> 00:26:52.160
A third example,
which people often

00:26:52.160 --> 00:26:56.250
consider more controversial when
I say this one, is substrings.

00:26:56.250 --> 00:26:57.980
So in Java, there's
various methods

00:26:57.980 --> 00:27:00.290
that will extract a
substring out of a string.

00:27:00.290 --> 00:27:02.824
And these methods are
very exception happy.

00:27:02.824 --> 00:27:05.240
If either of indices is outside
the range of the substring

00:27:05.240 --> 00:27:07.823
and throws an exception-- and I
believe if they're kind of out

00:27:07.823 --> 00:27:09.950
of order, it throws
an exception--

00:27:09.950 --> 00:27:11.630
I find this a huge pain.

00:27:11.630 --> 00:27:14.420
I end up, typically,
having to write my own code

00:27:14.420 --> 00:27:18.500
to effectively clip my indices
to the range of the string

00:27:18.500 --> 00:27:20.820
before I invoke the
Java substring command,

00:27:20.820 --> 00:27:22.820
so I won't get these exceptions.

00:27:22.820 --> 00:27:24.960
I consider this just a bad idea.

00:27:24.960 --> 00:27:27.560
Instead, it'd be so
much simpler just

00:27:27.560 --> 00:27:30.140
to find substring,
so that it returns

00:27:30.140 --> 00:27:33.770
the overlap between the
indices you've specified

00:27:33.770 --> 00:27:36.600
and the available
contents of the string.

00:27:36.600 --> 00:27:38.780
So if both of the indices
are outside the range

00:27:38.780 --> 00:27:40.580
of the string, it
returns an empty string.

00:27:40.580 --> 00:27:41.720
You know, if they
are in reverse order,

00:27:41.720 --> 00:27:43.845
clearly there can't be
anything in the right order.

00:27:43.845 --> 00:27:46.460
It doesn't return and just does
the clipping automatically.

00:27:46.460 --> 00:27:49.190
This would eliminate so much
extra code people have to write

00:27:49.190 --> 00:27:52.040
and also, I suspect, a lot of
runtime exceptions that occur,

00:27:52.040 --> 00:27:54.650
because people forgot
to clip their indices

00:27:54.650 --> 00:27:58.250
to the range of the string
before they invoke the command.

00:27:58.250 --> 00:28:01.166
So, again, the overall idea
here is to try and reduce

00:28:01.166 --> 00:28:02.540
the number of
places where people

00:28:02.540 --> 00:28:04.514
have to deal with exceptions.

00:28:04.514 --> 00:28:06.680
The book talks about a few
other ways of doing this.

00:28:06.680 --> 00:28:10.580
But the best case of all is just
to define the exceptions away.

00:28:10.580 --> 00:28:14.766
Just make the normal behavior
always do the right thing.

00:28:14.766 --> 00:28:16.640
And nobody's objecting
on the Java substring.

00:28:16.640 --> 00:28:19.546
Usually somebody raises their
hand and objects to that.

00:28:19.546 --> 00:28:20.046
Yeah.

00:28:23.205 --> 00:28:23.830
AUDIENCE: Yeah.

00:28:23.830 --> 00:28:26.766
So not objecting, but defining
[INAUDIBLE] the semantics,

00:28:26.766 --> 00:28:28.390
perhaps, is a more
complete definition.

00:28:28.390 --> 00:28:31.060
I mean, you could
simply say, OK,

00:28:31.060 --> 00:28:33.430
whatever set of
parameters you pass,

00:28:33.430 --> 00:28:36.770
you have random behavior that
are difficult to explain.

00:28:36.770 --> 00:28:39.310
But the examples you gave
were very, very intuitive,

00:28:39.310 --> 00:28:43.090
like when you defined
overlap between the indexes

00:28:43.090 --> 00:28:46.891
and the available space
or the Tcl, et cetera.

00:28:46.891 --> 00:28:49.390
JOHN OUTSERHOUT: Somebody want
to argue that Java substrings

00:28:49.390 --> 00:28:50.350
should throw exceptions?

00:28:50.350 --> 00:28:50.974
AUDIENCE: Yeah.

00:28:50.974 --> 00:28:52.190
[INAUDIBLE]

00:28:52.190 --> 00:28:54.490
JOHN OUTSERHOUT: Let's bring
the microphone over here.

00:28:54.490 --> 00:28:55.420
AUDIENCE: [INAUDIBLE]

00:28:55.420 --> 00:28:57.795
JOHN OUTSERHOUT: I know some
of you thinking it, so yeah.

00:29:01.161 --> 00:29:03.410
AUDIENCE: I think it should
throw a runtime exception,

00:29:03.410 --> 00:29:06.590
because, like, you can--

00:29:06.590 --> 00:29:08.990
sometimes it could be
just the wrong assumptions

00:29:08.990 --> 00:29:10.414
on client side.

00:29:10.414 --> 00:29:12.080
Like, they've just
done something wrong.

00:29:12.080 --> 00:29:16.070
And they're assuming that's
correct range, but it's not.

00:29:16.070 --> 00:29:18.510
I think it should be
a runtime exception.

00:29:18.510 --> 00:29:19.380
JOHN OUTSERHOUT: This is
part of the philosophy

00:29:19.380 --> 00:29:21.046
about we're going to
try and keep people

00:29:21.046 --> 00:29:26.030
from making mistakes, which
it's kind of a noble thought.

00:29:26.030 --> 00:29:29.180
But the problem is that it's
really hard to keep people

00:29:29.180 --> 00:29:30.690
from making mistakes.

00:29:30.690 --> 00:29:33.071
And so typically what
happens when we try and do

00:29:33.071 --> 00:29:35.570
this is we introduce lots of
complexity, which makes it hard

00:29:35.570 --> 00:29:37.057
to even do the right thing.

00:29:37.057 --> 00:29:39.390
And so I'd argue, in general,
we want to make it really,

00:29:39.390 --> 00:29:43.460
really easy to do the common
case and the right thing.

00:29:43.460 --> 00:29:45.764
You still have to do
testing to catch mistakes.

00:29:45.764 --> 00:29:47.180
And so this isn't
going to replace

00:29:47.180 --> 00:29:48.432
the need for unit tests.

00:29:48.432 --> 00:29:50.390
But, in general, I think
when you try and build

00:29:50.390 --> 00:29:52.473
systems that can keep
people from making mistakes,

00:29:52.473 --> 00:29:55.160
you usually create a whole lot
of complexity for everybody.

00:29:55.160 --> 00:29:56.780
AUDIENCE: So how
do you distinguish

00:29:56.780 --> 00:30:02.720
between Java substring versus
java.string.character@index?

00:30:02.720 --> 00:30:07.449
Should that throw an exception
if the index is out of range?

00:30:07.449 --> 00:30:08.740
JOHN OUTSERHOUT: Good question.

00:30:08.740 --> 00:30:10.880
That one probably should,
because it can't really

00:30:10.880 --> 00:30:11.780
return a character.

00:30:11.780 --> 00:30:14.600
You know, what do you--

00:30:14.600 --> 00:30:16.710
you know, you could redefine
it kind of like IEEE

00:30:16.710 --> 00:30:18.210
Floating-Point did,
where there were

00:30:18.210 --> 00:30:20.270
special values that
represented arithmetic errors

00:30:20.270 --> 00:30:21.146
and things like that.

00:30:21.146 --> 00:30:22.978
So if you have some
sort of a null character

00:30:22.978 --> 00:30:24.870
that you could return,
that might make sense.

00:30:24.870 --> 00:30:27.200
But we really have that
in our character sets.

00:30:27.200 --> 00:30:29.510
So in that case,
you really can't.

00:30:29.510 --> 00:30:31.720
I'm not sure what you
would return if you're

00:30:31.720 --> 00:30:34.560
going to return something.

00:30:34.560 --> 00:30:36.631
So, yeah, so in that
case, you probably

00:30:36.631 --> 00:30:37.880
do have to throw an exception.

00:30:37.880 --> 00:30:38.754
AUDIENCE: [INAUDIBLE]

00:30:38.754 --> 00:30:40.532
AUDIENCE: -optional character.

00:30:40.532 --> 00:30:41.990
AUDIENCE: So one
question-- so when

00:30:41.990 --> 00:30:44.150
is it a good idea to
actually throw exceptions?

00:30:44.150 --> 00:30:46.970
So the intuitive case is you
want to eliminate exceptions

00:30:46.970 --> 00:30:49.630
as much as possible, then
how do you decide, no,

00:30:49.630 --> 00:30:50.880
there's nothing that I can do?

00:30:50.880 --> 00:30:52.700
My changing semantics
doesn't work.

00:30:52.700 --> 00:30:54.840
And I really have to
throw an exception now.

00:30:54.840 --> 00:30:56.120
JOHN OUTSERHOUT: Well, if you
fundamentally can't carry out

00:30:56.120 --> 00:30:57.860
your contract with
your caller and if you

00:30:57.860 --> 00:30:59.270
can't implement your
interface, then sort of

00:30:59.270 --> 00:31:00.500
have to throw an exception.

00:31:00.500 --> 00:31:01.970
You know, like,
if you're reading

00:31:01.970 --> 00:31:03.410
[INAUDIBLE] you're
doing a read operation

00:31:03.410 --> 00:31:05.480
and the read can't succeed,
because you got an I/O error,

00:31:05.480 --> 00:31:06.230
you have to.

00:31:06.230 --> 00:31:08.720
That's information that you
do have to reflect that back

00:31:08.720 --> 00:31:09.947
to the caller.

00:31:09.947 --> 00:31:11.530
So you can't eliminate
all exceptions.

00:31:11.530 --> 00:31:13.220
You know, some of the
students in the class

00:31:13.220 --> 00:31:14.750
thought this was
really a great idea.

00:31:14.750 --> 00:31:16.530
And so they basically
wrote no exception handlers

00:31:16.530 --> 00:31:17.155
in their code--

00:31:17.155 --> 00:31:17.730
[LAUGHTER]

00:31:17.730 --> 00:31:20.140
--and said, I'm just defining
them out of existence.

00:31:20.140 --> 00:31:22.410
I said, no, no, some of
them actually matter.

00:31:22.410 --> 00:31:24.970
You have to-- and a lot of
software design, I think,

00:31:24.970 --> 00:31:27.180
is figuring out what matters
and what doesn't matter.

00:31:27.180 --> 00:31:30.609
And, ideally, you'd like to make
as little matter as possible.

00:31:30.609 --> 00:31:31.900
You know, you'd like to be as--

00:31:31.900 --> 00:31:33.651
to not depend on
very many things.

00:31:33.651 --> 00:31:35.650
But you have to recognize
the things that really

00:31:35.650 --> 00:31:37.060
are important and do matter.

00:31:37.060 --> 00:31:39.700
And those you do have to
reflect in the system.

00:31:39.700 --> 00:31:41.140
Yeah.

00:31:41.140 --> 00:31:43.450
AUDIENCE: Do you have
thoughts on exceptions

00:31:43.450 --> 00:31:46.962
versus extra status code
or extra error code return?

00:31:46.962 --> 00:31:49.420
JOHN OUTSERHOUT: Boy, that's
a classic argument, exceptions

00:31:49.420 --> 00:31:52.750
versus return values.

00:31:52.750 --> 00:31:54.790
Now, there are times
when each make sense.

00:31:54.790 --> 00:31:58.450
I believe exceptions actually
provide the most value when

00:31:58.450 --> 00:32:01.110
you throw them farthest.

00:32:01.110 --> 00:32:02.819
If they're going a
long way up the stack,

00:32:02.819 --> 00:32:04.735
that's where they provide
the biggest benefit.

00:32:04.735 --> 00:32:06.270
Because you've
made it unnecessary

00:32:06.270 --> 00:32:08.446
for a whole bunch of
intermediate layers

00:32:08.446 --> 00:32:09.570
to deal with the situation.

00:32:09.570 --> 00:32:12.194
You can take it all the way back
to the source and deal with it

00:32:12.194 --> 00:32:12.880
at the source.

00:32:12.880 --> 00:32:16.020
If you are catching exceptions
in methods you call,

00:32:16.020 --> 00:32:18.690
you know, there's not as
much value for that compared

00:32:18.690 --> 00:32:20.160
to just getting a return value.

00:32:20.160 --> 00:32:21.830
It's not a whole lot different.

00:32:21.830 --> 00:32:23.288
One of the problems
with exceptions

00:32:23.288 --> 00:32:25.530
is, also, they all
have clunky syntax.

00:32:25.530 --> 00:32:27.390
And, actually,
checking a return value

00:32:27.390 --> 00:32:29.010
is actually simpler
syntactically

00:32:29.010 --> 00:32:30.739
than declaring an
exception handler.

00:32:30.739 --> 00:32:33.030
But, you know, a lot of times,
some of these exceptions

00:32:33.030 --> 00:32:35.220
you really will want them
to propagate a long ways.

00:32:35.220 --> 00:32:38.900
And so then even if the
caller is going to look at it,

00:32:38.900 --> 00:32:41.400
you probably want to manifest
it as an exception rather than

00:32:41.400 --> 00:32:43.020
a return value.

00:32:43.020 --> 00:32:45.000
AUDIENCE: Any
thought on crashing

00:32:45.000 --> 00:32:47.157
as a way of, like,
avoiding [INAUDIBLE],, like,

00:32:47.157 --> 00:32:47.990
passing [INAUDIBLE]?

00:32:47.990 --> 00:32:49.910
JOHN OUTSERHOUT: Any thoughts
on crashing as a way?

00:32:49.910 --> 00:32:50.400
AUDIENCE: Yes.

00:32:50.400 --> 00:32:51.180
JOHN OUTSERHOUT: Yeah, yeah.

00:32:51.180 --> 00:32:52.710
Actually, crashing
is a fine thing

00:32:52.710 --> 00:32:54.420
to do in certain situations.

00:32:54.420 --> 00:32:55.950
Like, for example,
in most programs,

00:32:55.950 --> 00:32:58.490
I would argue you should not
be trying to [AUDIO OUT] out

00:32:58.490 --> 00:32:59.850
of memory exceptions.

00:32:59.850 --> 00:33:02.160
It's just hopelessly
complicate to try and do that,

00:33:02.160 --> 00:33:03.830
because it depends
so much on memory.

00:33:03.830 --> 00:33:06.270
That for most applications,
if you run out of memory,

00:33:06.270 --> 00:33:06.770
just crash.

00:33:06.770 --> 00:33:08.261
I mean, print a
message and crash.

00:33:08.261 --> 00:33:09.260
It almost never happens.

00:33:09.260 --> 00:33:12.870
Machines today they have
tons of memory anyhow.

00:33:12.870 --> 00:33:15.864
You know, again,
use with caution.

00:33:15.864 --> 00:33:18.030
But I think there are
situations where just crashing

00:33:18.030 --> 00:33:19.950
is a fine thing, a
fine way to do it.

00:33:19.950 --> 00:33:22.290
The alternative would
create so much complexity

00:33:22.290 --> 00:33:24.706
that you probably wouldn't get
it right in the first place

00:33:24.706 --> 00:33:26.270
and it'd end up crashing anyway.

00:33:26.270 --> 00:33:28.730
SPEAKER 1: Hey, John, there's
17 questions on the Dory.

00:33:28.730 --> 00:33:30.710
So I'll just ask
the top ranked one,

00:33:30.710 --> 00:33:32.504
so that we don't
run out of time.

00:33:32.504 --> 00:33:33.920
The question is
from [INAUDIBLE]..

00:33:33.920 --> 00:33:38.030
And in real life, development is
often under these constraints--

00:33:38.030 --> 00:33:39.890
for example, tight
schedule, need

00:33:39.890 --> 00:33:41.990
to experiment and be
flexible about design,

00:33:41.990 --> 00:33:44.870
lack of mature tools,
library, et cetera.

00:33:44.870 --> 00:33:47.570
Does your approach to software
design philosophy change

00:33:47.570 --> 00:33:50.025
based on the real
world constraints?

00:33:50.025 --> 00:33:50.900
JOHN OUTSERHOUT: Yes.

00:33:50.900 --> 00:33:52.390
And actually, that's
a good lead-in.

00:33:52.390 --> 00:33:53.790
Let me move on to the
next part of the talk,

00:33:53.790 --> 00:33:55.010
which I'm going to
talking about that.

00:33:55.010 --> 00:33:56.593
And I think I want
to get moving, too,

00:33:56.593 --> 00:34:01.080
because we're starting to
run a little tight on time.

00:34:01.080 --> 00:34:03.270
[AUDIO OUT] about a couple
of specific techniques

00:34:03.270 --> 00:34:04.440
or philosophies you can use.

00:34:04.440 --> 00:34:06.780
But I think one of the biggest
obstacles to good design

00:34:06.780 --> 00:34:08.081
is mindset.

00:34:08.081 --> 00:34:09.580
If you don't have
the right mindset,

00:34:09.580 --> 00:34:12.580
you will just never
produce a good design.

00:34:12.580 --> 00:34:16.230
And I think there's two ways
of approaching the programming

00:34:16.230 --> 00:34:19.980
or design process, which I
call tactical and strategic.

00:34:19.980 --> 00:34:22.719
Unfortunately, most people
take the wrong approach,

00:34:22.719 --> 00:34:25.090
which is the tactical approach.

00:34:25.090 --> 00:34:28.190
In the tactical
approach, your goal

00:34:28.190 --> 00:34:29.940
is to get something working--

00:34:29.940 --> 00:34:33.011
you know, your next feature,
fixing a bug, whatever.

00:34:33.011 --> 00:34:34.969
But that's your goal, to
get something working.

00:34:34.969 --> 00:34:37.050
So you think, how
can that be wrong?

00:34:37.050 --> 00:34:39.469
Isn't that the whole goal of,
you know, building systems?

00:34:39.469 --> 00:34:41.199
We want them to be working.

00:34:41.199 --> 00:34:42.699
Well, the problem
with this approach

00:34:42.699 --> 00:34:44.365
is that when you do
it, then you usually

00:34:44.365 --> 00:34:48.170
have a mindset that, well, I'll
try and make it mostly clean.

00:34:48.170 --> 00:34:49.219
But if I have a little--

00:34:49.219 --> 00:34:52.000
if I take a couple of, you
know, short cuts or a little bit

00:34:52.000 --> 00:34:54.770
a kluges, as long as I
don't do too many of them,

00:34:54.770 --> 00:34:58.090
if I get it working,
that's what really counts.

00:34:58.090 --> 00:35:01.911
The problem with that is that
those kluges build up really

00:35:01.911 --> 00:35:02.410
fast.

00:35:02.410 --> 00:35:03.826
Because not only
are you doing it,

00:35:03.826 --> 00:35:06.185
but everybody else on
your team is doing it.

00:35:06.185 --> 00:35:08.560
And then after a while you
start saying, well, I probably

00:35:08.560 --> 00:35:10.435
shouldn't have made that
decision back there,

00:35:10.435 --> 00:35:13.300
but we've got our next
deadline we've got to hit.

00:35:13.300 --> 00:35:15.860
You know, I'll try and find
time after that deadline.

00:35:15.860 --> 00:35:17.020
But then by the time
the deadline is done,

00:35:17.020 --> 00:35:18.310
you've introduced
so many kluges,

00:35:18.310 --> 00:35:20.560
you realize it's going to
take weeks to fix all these.

00:35:20.560 --> 00:35:22.030
And you don't have
time for that.

00:35:22.030 --> 00:35:24.440
And so it just never happens.

00:35:24.440 --> 00:35:27.410
So the result of this
inevitably is the system turns

00:35:27.410 --> 00:35:31.270
to spaghetti
really, really fast.

00:35:31.270 --> 00:35:34.300
And the problem
is that complexity

00:35:34.300 --> 00:35:36.340
isn't one mistake you make.

00:35:36.340 --> 00:35:39.310
It's not a single big thing that
makes the system complicated.

00:35:39.310 --> 00:35:41.320
It's hundreds or
thousands of mistakes

00:35:41.320 --> 00:35:44.801
made by many people
over a period of time.

00:35:44.801 --> 00:35:46.300
And so that means,
first of all, you

00:35:46.300 --> 00:35:48.466
don't notice it as it's
happening, because it's just

00:35:48.466 --> 00:35:49.542
a bit at a time.

00:35:49.542 --> 00:35:51.250
But then, even worse,
once it's happened,

00:35:51.250 --> 00:35:52.420
it's almost impossible to fix.

00:35:52.420 --> 00:35:54.010
Because there's no one
thing you can go back

00:35:54.010 --> 00:35:55.134
and fix to fix the problem.

00:35:55.134 --> 00:35:58.160
It's thousands of things
in hundreds of places.

00:35:58.160 --> 00:35:59.590
And so it's just
so overwhelming,

00:35:59.590 --> 00:36:01.350
you never get to it.

00:36:01.350 --> 00:36:02.960
So, by the way,
there's an extreme

00:36:02.960 --> 00:36:05.900
of the tactical programmer,
sort of personality type,

00:36:05.900 --> 00:36:08.420
I call the tactical tornado.

00:36:08.420 --> 00:36:11.660
This is a person who turns
out enormous amounts of pretty

00:36:11.660 --> 00:36:16.220
shoddy code that kind of
80% works at a huge rate

00:36:16.220 --> 00:36:19.074
and leaves a wake of
destruction behind them.

00:36:19.074 --> 00:36:20.690
[LAUGHTER]

00:36:20.690 --> 00:36:24.039
And in many organizations, these
people are considered heroes.

00:36:24.039 --> 00:36:25.830
This is who management
goes to when we need

00:36:25.830 --> 00:36:26.840
the new feature for tomorrow.

00:36:26.840 --> 00:36:28.298
And they'll have
a feature tomorrow

00:36:28.298 --> 00:36:32.930
that works for most of
the day tomorrow, anyhow.

00:36:32.930 --> 00:36:35.430
In fact, actually, when I gave
this talk, somebody said, oh,

00:36:35.430 --> 00:36:37.304
is that what you mean
by the 10x programmers?

00:36:37.304 --> 00:36:41.530
[LAUGHTER]

00:36:41.530 --> 00:36:42.740
No.

00:36:42.740 --> 00:36:43.840
No.

00:36:43.840 --> 00:36:45.670
How many of you feel
like you've been

00:36:45.670 --> 00:36:48.130
in the presence of one or
more tactical tornadoes

00:36:48.130 --> 00:36:49.601
over your career?

00:36:49.601 --> 00:36:50.100
Yeah.

00:36:50.100 --> 00:36:51.340
Every organization has them.

00:36:51.340 --> 00:36:53.170
I'm sure they're here at Google.

00:36:53.170 --> 00:36:55.360
And, unfortunately, one
of the things I hope to do

00:36:55.360 --> 00:36:56.860
is to provide a
name for this, so we

00:36:56.860 --> 00:36:59.570
can start calling them out
and maybe educate management

00:36:59.570 --> 00:37:00.070
about them.

00:37:00.070 --> 00:37:02.153
How many of you feel like
your management actually

00:37:02.153 --> 00:37:03.960
rewards technical tornadoes?

00:37:03.960 --> 00:37:07.610
Yeah, that's even
worse, unfortunately.

00:37:07.610 --> 00:37:09.470
So, you know, the
tactical approach

00:37:09.470 --> 00:37:13.049
is really, really easy to slide
into, very hard not to do that.

00:37:13.049 --> 00:37:14.840
But so the first thing
you have to realize,

00:37:14.840 --> 00:37:16.610
if you want to do great
design, you have to realize

00:37:16.610 --> 00:37:17.930
working code is not enough.

00:37:17.930 --> 00:37:20.910
That can't be the only goal.

00:37:20.910 --> 00:37:22.800
It's sort of table stakes.

00:37:22.800 --> 00:37:24.521
Of course, things have to work.

00:37:24.521 --> 00:37:26.020
But that shouldn't
be the real goal.

00:37:28.800 --> 00:37:32.040
Instead, you should take what I
call a strategic approach where

00:37:32.040 --> 00:37:33.720
the goal is a great design.

00:37:33.720 --> 00:37:35.190
That's the most important thing.

00:37:35.190 --> 00:37:37.960
Yes, it's got to work today, but
we have to have a great design.

00:37:37.960 --> 00:37:39.720
Why do we want a great design?

00:37:39.720 --> 00:37:42.330
It's so that we can
develop fast in the future.

00:37:42.330 --> 00:37:44.100
So it's really all
about investing.

00:37:44.100 --> 00:37:45.960
We'll invest in
good design today,

00:37:45.960 --> 00:37:47.490
because most of
the code we develop

00:37:47.490 --> 00:37:49.470
is going to be in the future.

00:37:49.470 --> 00:37:51.270
And so if we mess
things up today,

00:37:51.270 --> 00:37:53.457
we're slowing ourselves
down for the future.

00:37:53.457 --> 00:37:55.040
So you have to think
about complexity,

00:37:55.040 --> 00:37:58.230
try and find ways to drive
complexity out of the system.

00:37:58.230 --> 00:38:00.150
And, fundamentally--
this is the hard part--

00:38:00.150 --> 00:38:01.660
you have to sweat
the small stuff.

00:38:01.660 --> 00:38:03.960
And you sort of have to have
a zero tolerance approach.

00:38:03.960 --> 00:38:06.540
Don't let those little
bits of lint creep in.

00:38:06.540 --> 00:38:09.420
Because if they do, then
you're going to slide back

00:38:09.420 --> 00:38:11.430
into a tactical mode again.

00:38:11.430 --> 00:38:14.640
You know, so if you
program strategically,

00:38:14.640 --> 00:38:16.500
you're going to go slower first.

00:38:16.500 --> 00:38:19.166
But, presumably, in the end,
you'll end up going faster.

00:38:19.166 --> 00:38:20.790
I mean, even with a
strategic approach,

00:38:20.790 --> 00:38:22.920
you're development will
still slow down over time,

00:38:22.920 --> 00:38:25.420
because complexity
is inevitable.

00:38:25.420 --> 00:38:26.260
We can't prevent it.

00:38:26.260 --> 00:38:30.230
We can only kind of slow the
growth as much as we can.

00:38:30.230 --> 00:38:33.850
But, eventually, you'll end
up [INAUDIBLE] to be faster.

00:38:33.850 --> 00:38:37.067
So the issue is
you have to invest.

00:38:37.067 --> 00:38:39.400
If you're not willing to take
a little bit of extra time

00:38:39.400 --> 00:38:42.790
today, at least a little bit,
you can't do good design.

00:38:42.790 --> 00:38:45.650
But in my opinion,
it all pays back.

00:38:45.650 --> 00:38:47.680
You always get your
investment back.

00:38:47.680 --> 00:38:50.770
Now, the challenge is what are
the parameters of these curves?

00:38:50.770 --> 00:38:54.490
Like, how much slower do
I have to go initially?

00:38:54.490 --> 00:38:55.990
You know, when do
I get to the point

00:38:55.990 --> 00:38:58.450
where the slopes are the same,
so I'm at least now running

00:38:58.450 --> 00:39:00.940
as fast as I was tactically?

00:39:00.940 --> 00:39:03.370
When do I actually catch up
so I actually have a net gain?

00:39:03.370 --> 00:39:06.940
And then how much
faster I go at the end?

00:39:06.940 --> 00:39:09.650
Unfortunately, I don't know
of any quantitative answers

00:39:09.650 --> 00:39:10.780
to any of those questions.

00:39:10.780 --> 00:39:12.070
You know, I have opinions.

00:39:12.070 --> 00:39:14.890
Like, my opinion is that
the crossover period

00:39:14.890 --> 00:39:16.945
is somewhere in the 6 to
12 month range, roughly

00:39:16.945 --> 00:39:18.820
how long it takes you
to forget about why you

00:39:18.820 --> 00:39:20.680
wrote that last chunk of code.

00:39:20.680 --> 00:39:23.821
But I don't have any data to
back that up, unfortunately.

00:39:23.821 --> 00:39:24.820
So that's the challenge.

00:39:24.820 --> 00:39:28.360
Because, you know, people
can see the cost today,

00:39:28.360 --> 00:39:30.502
but they can't
really estimate when

00:39:30.502 --> 00:39:32.710
the benefit's going to come
or how long in the future

00:39:32.710 --> 00:39:33.520
it's going to be.

00:39:33.520 --> 00:39:36.050
And so it's really easy just
to optimize for this part

00:39:36.050 --> 00:39:36.550
down here.

00:39:40.200 --> 00:39:41.700
AUDIENCE: Yeah,
just quick question.

00:39:41.700 --> 00:39:44.130
Have you thought of analyzing
open source development

00:39:44.130 --> 00:39:47.550
and seeing whether or
not you can observe this?

00:39:47.550 --> 00:39:50.160
I mean, it would require
some judgment calls, I guess.

00:39:50.160 --> 00:39:50.660
But--

00:39:50.660 --> 00:39:50.834
JOHN OUTSERHOUT:
I'm not sure how

00:39:50.834 --> 00:39:53.100
you do-- you can look
at the rate of commits

00:39:53.100 --> 00:39:54.290
from the new lines added.

00:39:54.290 --> 00:39:55.620
But the problem is you
don't know how much effort

00:39:55.620 --> 00:39:56.345
went into those.

00:39:56.345 --> 00:39:56.970
AUDIENCE: Yeah.

00:39:56.970 --> 00:39:57.690
JOHN OUTSERHOUT: So--

00:39:57.690 --> 00:39:59.610
AUDIENCE: I was thinking like
when a new storage device comes

00:39:59.610 --> 00:40:01.410
out and people are writing
new file systems or something.

00:40:01.410 --> 00:40:03.618
You know, you could look at
this across different OSs

00:40:03.618 --> 00:40:05.476
and see how things happen.

00:40:05.476 --> 00:40:07.410
JOHN OUTSERHOUT: Yeah,
that's a thought.

00:40:07.410 --> 00:40:09.249
It's hard.

00:40:09.249 --> 00:40:11.040
So the question is,
how much do you invest?

00:40:11.040 --> 00:40:13.120
Actually, let me charge
for a couple more slides,

00:40:13.120 --> 00:40:16.240
because we're starting to
run a little tight on time.

00:40:16.240 --> 00:40:17.010
So how much?

00:40:17.010 --> 00:40:18.150
What's the right
amount to invest?

00:40:18.150 --> 00:40:20.025
And, you know, if you
look at most start-ups,

00:40:20.025 --> 00:40:22.800
honestly, they're mostly
completely, 100%, tactical.

00:40:22.800 --> 00:40:25.300
They feel a tremendous pressure
to get the products out.

00:40:25.300 --> 00:40:28.060
You know, our financing is
going to run out in six months.

00:40:28.060 --> 00:40:30.170
Whatever evil we
put in, you know,

00:40:30.170 --> 00:40:32.370
when we become famous and
wealthy and do out IPO,

00:40:32.370 --> 00:40:33.870
we'll be able to
hire more engineers

00:40:33.870 --> 00:40:35.340
to clean up this mess.

00:40:35.340 --> 00:40:38.550
And so, you know, they end up
with these horrible spaghetti

00:40:38.550 --> 00:40:39.119
code bases.

00:40:39.119 --> 00:40:41.160
And, unfortunately, of
course, once you get that,

00:40:41.160 --> 00:40:44.070
it's pretty much
impossible to clean it up.

00:40:44.070 --> 00:40:45.570
I've never heard
of anybody-- maybe

00:40:45.570 --> 00:40:46.990
if you could go back
and completely rewrite,

00:40:46.990 --> 00:40:47.735
you could do it.

00:40:47.735 --> 00:40:49.360
Maybe there have been
examples of that,

00:40:49.360 --> 00:40:51.160
but it almost never happens.

00:40:51.160 --> 00:40:54.090
So to me, Facebook is the
poster child for this.

00:40:54.090 --> 00:40:56.010
They even built it into
their company motto--

00:40:56.010 --> 00:40:57.450
move quickly and break things.

00:40:57.450 --> 00:40:58.946
And they did both of those.

00:40:58.946 --> 00:40:59.700
[LAUGHTER]

00:40:59.700 --> 00:41:02.270
So now, in a sense,
developers kind of like this.

00:41:02.270 --> 00:41:03.870
So fresh college
hires could come in.

00:41:03.870 --> 00:41:04.950
They're super empowered.

00:41:04.950 --> 00:41:07.400
They push their first
commits, and they're changing

00:41:07.400 --> 00:41:08.840
the website in one week.

00:41:08.840 --> 00:41:11.090
The first week on the job
feels like, you know, really

00:41:11.090 --> 00:41:12.580
empowering for them.

00:41:12.580 --> 00:41:15.467
But their code base was
just a notorious mess.

00:41:15.467 --> 00:41:17.300
One summer, a couple
of my graduate students

00:41:17.300 --> 00:41:18.320
went there for internships.

00:41:18.320 --> 00:41:19.903
They came back, and
they just couldn't

00:41:19.903 --> 00:41:21.630
believe what they'd seen.

00:41:21.630 --> 00:41:24.350
And this was interesting,
because my students

00:41:24.350 --> 00:41:27.110
had been whining for the
whole previous year about why

00:41:27.110 --> 00:41:29.840
do we have to write unit
tests and write documentation.

00:41:29.840 --> 00:41:31.265
Linux doesn't have
any unit tests.

00:41:31.265 --> 00:41:32.990
And Linux doesn't
have any comments.

00:41:32.990 --> 00:41:34.640
Why do we have to do this?

00:41:34.640 --> 00:41:37.620
I never heard that again after
they came back from Facebook.

00:41:37.620 --> 00:41:40.580
[LAUGHTER]

00:41:40.580 --> 00:41:42.910
So Facebook has
eventually realized this.

00:41:42.910 --> 00:41:46.240
And so they changed their
motto to "move quickly

00:41:46.240 --> 00:41:47.420
with solid infrastructure."

00:41:47.420 --> 00:41:49.211
It's like, you know,
no, no, I meant to say

00:41:49.211 --> 00:41:50.480
wouldn't, not would.

00:41:50.480 --> 00:41:55.066
[LAUGHTER]

00:41:55.066 --> 00:41:56.440
So have they been
able to fix it?

00:41:56.440 --> 00:41:57.187
I don't know.

00:41:57.187 --> 00:41:59.020
Now, people hear this,
they say, well, yeah,

00:41:59.020 --> 00:42:00.853
but Mark Zuckerberg is
the fourth wealthiest

00:42:00.853 --> 00:42:02.860
person on the planet.

00:42:02.860 --> 00:42:04.554
How can this be a bad approach?

00:42:04.554 --> 00:42:06.220
And, of course, the
answer is, you know,

00:42:06.220 --> 00:42:07.870
you can be successful
with crappy code.

00:42:07.870 --> 00:42:10.078
You can be tactical and
build companies that succeed.

00:42:10.078 --> 00:42:11.890
Facebook has done it.

00:42:11.890 --> 00:42:13.780
But I have two thoughts on this.

00:42:13.780 --> 00:42:16.970
One is you can also succeed
with the other approach.

00:42:16.970 --> 00:42:18.960
And although, I don't
have personal experience

00:42:18.960 --> 00:42:20.626
with either of these
companies, my sense

00:42:20.626 --> 00:42:23.140
is that both Google and VMware
took a much more, sort of,

00:42:23.140 --> 00:42:25.420
stronger design culture
approach at least

00:42:25.420 --> 00:42:28.914
particularly in the early
years, you know, 2000 to 2010.

00:42:28.914 --> 00:42:31.080
Those were the two companies
known in Silicon Valley

00:42:31.080 --> 00:42:33.610
as this is where the really
great software developers go.

00:42:33.610 --> 00:42:35.200
They really care about design.

00:42:35.200 --> 00:42:37.150
And they do really good coding.

00:42:37.150 --> 00:42:40.374
And the reason this matters is
that if you have that culture,

00:42:40.374 --> 00:42:42.040
I think you're in a
much better position

00:42:42.040 --> 00:42:44.050
to recruit the best programmers.

00:42:44.050 --> 00:42:46.270
And we know about
this 10x phenomenon.

00:42:46.270 --> 00:42:49.060
You know, the best way
to get great products out

00:42:49.060 --> 00:42:51.970
fast is to get the
best programmers.

00:42:51.970 --> 00:42:53.530
And so I think the
strongest argument

00:42:53.530 --> 00:42:55.360
in favor of a good
design culture

00:42:55.360 --> 00:42:57.850
is that it allows you
to hire top people.

00:42:57.850 --> 00:42:59.950
And that will give
you an advantage.

00:42:59.950 --> 00:43:02.380
So you can do things the
crappy way if you want,

00:43:02.380 --> 00:43:03.880
but there's enough
success stories

00:43:03.880 --> 00:43:05.379
to show that you
can make this work.

00:43:05.379 --> 00:43:08.250
You can do the
investment approach.

00:43:08.250 --> 00:43:08.750
OK.

00:43:08.750 --> 00:43:11.420
But then again, OK,
but how much to invest?

00:43:11.420 --> 00:43:13.470
I would say how
much can you afford?

00:43:13.470 --> 00:43:15.200
You know, just ask
yourself what's

00:43:15.200 --> 00:43:18.530
the most we can afford at
this stage in our lifetime

00:43:18.530 --> 00:43:19.820
to invest.

00:43:19.820 --> 00:43:24.140
I think in terms of maybe 10%
or 20%, something like that.

00:43:24.140 --> 00:43:27.290
I bet, almost everybody, you can
afford to go 10% slower today

00:43:27.290 --> 00:43:29.205
realizing you're going
to get it all back.

00:43:29.205 --> 00:43:30.080
It's not a sunk cost.

00:43:30.080 --> 00:43:31.670
It's all coming back to you.

00:43:31.670 --> 00:43:33.967
In somewhere, you know,
six months to a few years,

00:43:33.967 --> 00:43:35.550
you're going to get
it all back again.

00:43:35.550 --> 00:43:36.633
You can afford to do that.

00:43:36.633 --> 00:43:40.000
And I think in terms of
small steps, not heroics.

00:43:40.000 --> 00:43:42.170
You know, you can't
spend six months

00:43:42.170 --> 00:43:45.300
and completely design
the whole system,

00:43:45.300 --> 00:43:48.400
you know, from first principles
before you write any code.

00:43:48.400 --> 00:43:49.260
That doesn't work.

00:43:49.260 --> 00:43:50.916
We know one of the
problems of software

00:43:50.916 --> 00:43:52.790
is we can't visualize
the way our systems are

00:43:52.790 --> 00:43:53.580
going to turn out.

00:43:53.580 --> 00:43:55.750
You have to use a somewhat
iterative approach.

00:43:55.750 --> 00:43:58.671
So I'd say, think of it
in terms of small steps.

00:43:58.671 --> 00:44:00.170
So when you're
building new modules,

00:44:00.170 --> 00:44:02.420
take a little bit of time
to design the interface.

00:44:02.420 --> 00:44:04.320
Try to come up
with deep classes.

00:44:04.320 --> 00:44:05.990
Write the documentation
as you're going,

00:44:05.990 --> 00:44:07.880
unit tests, of course.

00:44:07.880 --> 00:44:09.660
And then whenever
you make changes,

00:44:09.660 --> 00:44:12.540
you have to realize you can't
get it right the first time.

00:44:12.540 --> 00:44:14.000
It's one of the
rules of software.

00:44:14.000 --> 00:44:14.583
We just can't.

00:44:14.583 --> 00:44:16.517
So assume every time
you're in a system,

00:44:16.517 --> 00:44:18.350
you're going to have
to be improving things.

00:44:18.350 --> 00:44:21.230
Always look for something
you can make better.

00:44:21.230 --> 00:44:24.710
One reason for this is you're
probably making something worse

00:44:24.710 --> 00:44:25.830
when you go in also.

00:44:25.830 --> 00:44:27.620
So even if you just
want to break even,

00:44:27.620 --> 00:44:30.080
you've got to find
something to improve.

00:44:30.080 --> 00:44:34.440
So I just think that I'm just
trying to at least break even.

00:44:34.440 --> 00:44:37.000
So this is against
the normal philosophy.

00:44:37.000 --> 00:44:39.500
I think, oftentimes, when people
are changing existing code,

00:44:39.500 --> 00:44:42.260
they go for what's the smallest
number of lines of code

00:44:42.260 --> 00:44:44.184
I can possibly
change to do this.

00:44:44.184 --> 00:44:46.100
I think sometimes it's
because they're afraid.

00:44:46.100 --> 00:44:47.780
I don't understand this.

00:44:47.780 --> 00:44:48.590
I'm going to break
something, so I'll

00:44:48.590 --> 00:44:49.950
make the fewest lines of change.

00:44:49.950 --> 00:44:52.030
So I'll just kind of directly
access a global variable,

00:44:52.030 --> 00:44:53.696
another file, rather
than trying to find

00:44:53.696 --> 00:44:55.350
a clean interface for it.

00:44:55.350 --> 00:44:56.270
So don't do that.

00:44:56.270 --> 00:44:59.270
Try and find a clean
way of doing things.

00:44:59.270 --> 00:45:02.090
And ideally, in the
best case, you'd

00:45:02.090 --> 00:45:04.820
like to end up where
you would have ended up

00:45:04.820 --> 00:45:07.850
if you had built the whole
system from scratch knowing

00:45:07.850 --> 00:45:08.940
what you know today.

00:45:08.940 --> 00:45:09.530
That's what you're like.

00:45:09.530 --> 00:45:11.863
Is this the way we would have
done it if we had built it

00:45:11.863 --> 00:45:12.800
from scratch?

00:45:12.800 --> 00:45:13.880
That's the ideal.

00:45:13.880 --> 00:45:16.290
Now, you know, you
can't always do that.

00:45:16.290 --> 00:45:18.090
Sometimes that would
be a refactoring

00:45:18.090 --> 00:45:20.780
that's way beyond the
scale of what you can do.

00:45:20.780 --> 00:45:24.440
So, again, I would just say
ask yourself at any given point

00:45:24.440 --> 00:45:27.920
in time, am I doing the
most I possibly can?

00:45:27.920 --> 00:45:29.600
Don't just give in
and the boss says

00:45:29.600 --> 00:45:30.750
we've got to get a
release out tomorrow,

00:45:30.750 --> 00:45:31.760
so I'm just going to
hack this thing in

00:45:31.760 --> 00:45:32.720
to make the boss happy.

00:45:32.720 --> 00:45:35.310
Ask, is this the best
I can possibly do?

00:45:35.310 --> 00:45:36.350
Yeah.

00:45:36.350 --> 00:45:38.420
AUDIENCE: John, will
you touch on layering,

00:45:38.420 --> 00:45:42.020
which is often considered very
good in software engineering,

00:45:42.020 --> 00:45:45.110
but it also has a
challenge of performance

00:45:45.110 --> 00:45:47.570
of the code when it executes?

00:45:47.570 --> 00:45:50.780
Often, the functionality is
replicated in multiple layers.

00:45:50.780 --> 00:45:52.880
And it's not clear
how to distill that

00:45:52.880 --> 00:45:54.440
without mucking up the code.

00:45:56.604 --> 00:45:59.020
JOHN OUTSERHOUT: So is your
question, are the layers good?

00:45:59.020 --> 00:45:59.660
AUDIENCE: Yeah.

00:45:59.660 --> 00:46:02.015
So how do [AUDIO OUT]
deal with layers,

00:46:02.015 --> 00:46:03.880
the demand for
abstraction layers,

00:46:03.880 --> 00:46:05.730
and the demand for
performance both

00:46:05.730 --> 00:46:06.270
contradicting each other here?

00:46:06.270 --> 00:46:08.170
JOHN OUTSERHOUT: We need
layers for managing complexity.

00:46:08.170 --> 00:46:09.030
So in that sense, they're good.

00:46:09.030 --> 00:46:10.613
They do have problems
for performance.

00:46:10.613 --> 00:46:13.020
I think people do
too many layers.

00:46:13.020 --> 00:46:15.630
And so I think that's a
common mistake is just

00:46:15.630 --> 00:46:17.142
to throw in lots
of skinny layers,

00:46:17.142 --> 00:46:19.350
again, rather than having
a smaller number of meatier

00:46:19.350 --> 00:46:20.649
layers.

00:46:20.649 --> 00:46:21.440
That's one problem.

00:46:21.440 --> 00:46:23.730
The other thing is that
for cases where performance

00:46:23.730 --> 00:46:26.610
matters, if you think
a little bit about what

00:46:26.610 --> 00:46:28.530
your key performance
metrics are,

00:46:28.530 --> 00:46:32.220
I believe you can often define
your layers in a way that

00:46:32.220 --> 00:46:35.460
allows you to achieve very high
performance even with layering.

00:46:35.460 --> 00:46:38.047
But you have to be thinking a
little bit about sort of this,

00:46:38.047 --> 00:46:40.110
the overall, kind of gross
level performance metrics

00:46:40.110 --> 00:46:41.693
while you're doing
your system design.

00:46:44.110 --> 00:46:44.610
OK.

00:46:44.610 --> 00:46:47.090
So anyhow, I think this
investment thing is the biggest

00:46:47.090 --> 00:46:49.280
challenge, particularly because
a lot of managers, I think,

00:46:49.280 --> 00:46:49.910
don't really get it.

00:46:49.910 --> 00:46:51.909
And they're sort of pushing
for the next feature

00:46:51.909 --> 00:46:53.270
or the next release.

00:46:53.270 --> 00:46:56.180
I don't know how to
combat that except to have

00:46:56.180 --> 00:46:57.711
the people that
everybody recognizes

00:46:57.711 --> 00:46:59.960
of the great engineers in
the company go to management

00:46:59.960 --> 00:47:01.250
and try and get
management buy in.

00:47:01.250 --> 00:47:02.380
And I think it'd be
great if companies

00:47:02.380 --> 00:47:04.630
can have sort of explicit--
this is in our engineering

00:47:04.630 --> 00:47:05.390
philosophy.

00:47:05.390 --> 00:47:08.090
We will invest at
10% [INAUDIBLE]..

00:47:08.090 --> 00:47:10.280
Roughly, on average,
10% of our resources

00:47:10.280 --> 00:47:12.950
are going towards making designs
better, not just cranking out

00:47:12.950 --> 00:47:13.865
next features.

00:47:13.865 --> 00:47:15.060
Yeah, John.

00:47:15.060 --> 00:47:15.890
AUDIENCE: Hi, John.

00:47:15.890 --> 00:47:17.639
I haven't looked at
this for 20 years now,

00:47:17.639 --> 00:47:20.090
but the quantitative analyzes
that you're describing

00:47:20.090 --> 00:47:22.100
were the domain of
the social engineering

00:47:22.100 --> 00:47:23.497
community for a while.

00:47:23.497 --> 00:47:25.580
I'm wondering if you sort
of poked into that space

00:47:25.580 --> 00:47:28.380
to see if they have
experimentation, numbers,

00:47:28.380 --> 00:47:30.140
analyzes, that might be useful.

00:47:30.140 --> 00:47:31.940
Or have they just
dropped off the map?

00:47:31.940 --> 00:47:33.110
JOHN OUTSERHOUT: I haven't
looked very carefully,

00:47:33.110 --> 00:47:34.944
partly because I'm sort
of skeptical that it

00:47:34.944 --> 00:47:36.859
is possible to measure
it in a meaningful way.

00:47:36.859 --> 00:47:39.110
So I haven't-- but I would
[AUDIO OUT] see numbers

00:47:39.110 --> 00:47:40.860
if there were [AUDIO OUT]
were believable.

00:47:40.860 --> 00:47:43.030
But I haven't looked
enough to know.

00:47:43.030 --> 00:47:43.530
OK.

00:47:43.530 --> 00:47:44.730
So I just have a
couple more slides,

00:47:44.730 --> 00:47:46.470
then I'll open it
up for questions.

00:47:46.470 --> 00:47:48.310
So is the course working?

00:47:48.310 --> 00:47:50.522
You know, it's hard
to tell for sure.

00:47:50.522 --> 00:47:52.980
I mean, you can't become a
great programmer in one quarter.

00:47:52.980 --> 00:47:55.455
It'll take, still, lots of
experience for these people.

00:47:55.455 --> 00:47:56.880
We'll have to come back
and ask them once they've

00:47:56.880 --> 00:47:58.440
been out at industry a while.

00:47:58.440 --> 00:48:01.320
This is just sort of the first
step in the process I think.

00:48:01.320 --> 00:48:05.270
But the class has a really
fun energy to it, really fun.

00:48:05.270 --> 00:48:07.881
The students start off in the
first round of code reviews.

00:48:07.881 --> 00:48:09.630
And they're very
tentative, kind of afraid

00:48:09.630 --> 00:48:11.296
to criticize each
other, not really sure

00:48:11.296 --> 00:48:13.110
what they should be saying.

00:48:13.110 --> 00:48:14.820
So the first round's
kind of tentative.

00:48:14.820 --> 00:48:18.640
Then they meet with me,
and they get unloaded on.

00:48:18.640 --> 00:48:21.180
And then they start-- oh,
OK, I can do that, too.

00:48:21.180 --> 00:48:23.931
And so about halfway through the
second code review, typically

00:48:23.931 --> 00:48:26.430
the tone of discussions changes
where students are now being

00:48:26.430 --> 00:48:27.810
more critical of each other.

00:48:27.810 --> 00:48:29.643
We have these interesting
arguments in class

00:48:29.643 --> 00:48:32.590
about whether one approach is
more complicated than another.

00:48:32.590 --> 00:48:34.710
And it's really clear by
the end of the quarter

00:48:34.710 --> 00:48:36.130
that the students are
thinking about programming

00:48:36.130 --> 00:48:38.546
in a very different way than
they thought about it before.

00:48:38.546 --> 00:48:40.960
So I think that's
really encouraging.

00:48:40.960 --> 00:48:43.530
I will have to say, though, even
if the students don't become

00:48:43.530 --> 00:48:46.385
better designers, actually,
I'm becoming a better designer

00:48:46.385 --> 00:48:47.490
from teaching the class.

00:48:47.490 --> 00:48:48.965
It's really interesting for me.

00:48:48.965 --> 00:48:50.580
You know, you might
think it's tedious

00:48:50.580 --> 00:48:52.650
reading 20,000 lines
of code in a week three

00:48:52.650 --> 00:48:54.480
times over a quarter.

00:48:54.480 --> 00:48:56.830
And it does take some time.

00:48:56.830 --> 00:48:58.679
But, actually, I
learn a lot from that,

00:48:58.679 --> 00:49:00.720
because the students are
all doing the same thing

00:49:00.720 --> 00:49:01.415
in the same language.

00:49:01.415 --> 00:49:03.120
And so I can see
different approaches.

00:49:03.120 --> 00:49:05.780
And I can see kind of common
mistakes that they make.

00:49:05.780 --> 00:49:07.620
And, actually, what's
ended up happening is

00:49:07.620 --> 00:49:10.470
I've changed my view about a
couple of the design issues

00:49:10.470 --> 00:49:12.180
as a result of
teaching the course.

00:49:12.180 --> 00:49:14.430
And in particular, the one
at the bottom of this slide

00:49:14.430 --> 00:49:19.020
was I realized that
making classes just

00:49:19.020 --> 00:49:22.230
slightly general purpose,
even though you're only

00:49:22.230 --> 00:49:24.540
going to use them in
one place, actually

00:49:24.540 --> 00:49:26.460
makes the amazingly
simpler and deeper.

00:49:26.460 --> 00:49:28.037
I hadn't realized
that until I saw

00:49:28.037 --> 00:49:30.120
some student projects,
actually, the second time I

00:49:30.120 --> 00:49:31.260
was teaching the course.

00:49:31.260 --> 00:49:34.115
So it's been really
interesting for me to see this.

00:49:34.115 --> 00:49:35.490
And I feel like
I'm learning more

00:49:35.490 --> 00:49:37.640
about the process
of software design

00:49:37.640 --> 00:49:41.992
and getting better ideas
for how to teach it as I go.

00:49:41.992 --> 00:49:43.950
Then as I've talked to
people about the course,

00:49:43.950 --> 00:49:46.190
people kept saying, well, you
should write a book on this.

00:49:46.190 --> 00:49:47.480
And I was on
sabbatical last year,

00:49:47.480 --> 00:49:48.950
so I decided, OK,
I would do that.

00:49:48.950 --> 00:49:50.370
So I have written this book.

00:49:50.370 --> 00:49:53.750
It's a relatively small
book, 170 pages, again,

00:49:53.750 --> 00:49:58.470
still fairly philosophical in
nature more than prescriptive.

00:49:58.470 --> 00:50:01.100
So the hope is that I can reach
more people, because I can only

00:50:01.100 --> 00:50:03.145
teach 20 people a
year in the class.

00:50:03.145 --> 00:50:04.400
I can't do more than that.

00:50:04.400 --> 00:50:07.700
And ideally, I'm hoping the
book will kind of be a lightning

00:50:07.700 --> 00:50:09.807
rod that maybe we can
kick start a discussion.

00:50:09.807 --> 00:50:11.390
I hope people write
to me and disagree

00:50:11.390 --> 00:50:14.210
with things in the book or
suggest other design ideas

00:50:14.210 --> 00:50:16.550
or provide better examples.

00:50:16.550 --> 00:50:19.980
I'm also trying to define
terms that people can use.

00:50:19.980 --> 00:50:22.220
One of the things I hope
maybe the book can do

00:50:22.220 --> 00:50:24.710
is people can use
that in design reviews

00:50:24.710 --> 00:50:26.240
to have ideas and
ways of talking

00:50:26.240 --> 00:50:28.760
about design and design ideas.

00:50:28.760 --> 00:50:30.465
Actually, I have a
question for you.

00:50:30.465 --> 00:50:32.090
How many people here
do design reviews?

00:50:32.090 --> 00:50:33.614
I assume almost everybody.

00:50:33.614 --> 00:50:35.030
And how many of
you in your design

00:50:35.030 --> 00:50:37.550
reviews it's common
for you to discuss

00:50:37.550 --> 00:50:41.330
design issues as opposed
to coding style and bugs?

00:50:41.330 --> 00:50:43.750
How many of you commonly
talk about design things?

00:50:43.750 --> 00:50:44.360
Good.

00:50:44.360 --> 00:50:44.960
Great.

00:50:44.960 --> 00:50:47.090
I'd like to see more of that.

00:50:47.090 --> 00:50:49.174
So now the book's been out
for a couple of months.

00:50:49.174 --> 00:50:51.048
If you read it and have
thoughts or comments,

00:50:51.048 --> 00:50:52.550
I'd love to get
your input on it.

00:50:52.550 --> 00:50:54.855
My view is this is
just a first stab.

00:50:54.855 --> 00:50:56.730
If this actually ends
up being a useful book,

00:50:56.730 --> 00:50:57.820
it'll probably be--

00:50:57.820 --> 00:50:58.500
it's kind of like software.

00:50:58.500 --> 00:50:59.870
At about version
three, you know,

00:50:59.870 --> 00:51:01.411
where it really hits
its stride, I'll

00:51:01.411 --> 00:51:04.130
need to get feedback and revise
and fix things that are wrong

00:51:04.130 --> 00:51:06.710
and add new ideas.

00:51:06.710 --> 00:51:08.862
So just to conclude,
I really believe

00:51:08.862 --> 00:51:10.070
we can teach software design.

00:51:10.070 --> 00:51:12.062
I really believe we can.

00:51:12.062 --> 00:51:13.520
My current approach,
unfortunately,

00:51:13.520 --> 00:51:14.856
is woefully non-scalable.

00:51:14.856 --> 00:51:15.980
I haven't figured that out.

00:51:15.980 --> 00:51:17.938
I really need somebody
with a lot of experience

00:51:17.938 --> 00:51:20.710
I think reading
the student's code.

00:51:20.710 --> 00:51:22.699
I feel like some
principles are emerging.

00:51:22.699 --> 00:51:25.240
You know, if you read the book
and agree or disagree with me,

00:51:25.240 --> 00:51:28.020
I'd be curious to hear
your take on that.

00:51:28.020 --> 00:51:30.500
What I hope to do in
the future is just

00:51:30.500 --> 00:51:32.500
to somehow leverage this
out into the community.

00:51:32.500 --> 00:51:35.710
I'd love to see just a greater
sense of design awareness

00:51:35.710 --> 00:51:38.450
in the software community as a
whole can we have a discussion.

00:51:38.450 --> 00:51:40.210
We make an important
part of our community

00:51:40.210 --> 00:51:41.890
it's just sad that
we don't really

00:51:41.890 --> 00:51:44.150
even have discussion today.

00:51:44.150 --> 00:51:46.210
So I created a mailing
list for discussion topics

00:51:46.210 --> 00:51:46.900
about the book.

00:51:46.900 --> 00:51:48.483
Hasn't been much
traffic on it so far,

00:51:48.483 --> 00:51:50.740
but I hope there will
be more in the future.

00:51:50.740 --> 00:51:52.710
And, again, I hope to
take ideas from people

00:51:52.710 --> 00:51:55.720
and make the book better and
better and the class better

00:51:55.720 --> 00:51:56.590
over time.

00:51:56.590 --> 00:51:58.660
And the long-term
goal is it'd be great

00:51:58.660 --> 00:52:00.310
if, 5 or 10 years
from now, we actually

00:52:00.310 --> 00:52:03.280
have a relatively
robust set of principles

00:52:03.280 --> 00:52:06.689
that most developers agree
are good for software design.

00:52:06.689 --> 00:52:08.230
So thanks for your
attention, and I'd

00:52:08.230 --> 00:52:09.890
be happy to take more questions.

00:52:09.890 --> 00:52:14.840
[APPLAUSE]

00:52:14.840 --> 00:52:17.090
SPEAKER 1: So let me get a
few questions from the Dory

00:52:17.090 --> 00:52:17.752
out here.

00:52:21.370 --> 00:52:24.760
Do testing considerations,
like unit testing or marks,

00:52:24.760 --> 00:52:27.502
influence interfaces
and abstractions?

00:52:27.502 --> 00:52:29.210
JOHN OUTSERHOUT:
Testing considerations--

00:52:29.210 --> 00:52:31.340
I'm a huge fan of,
particularly, unit tests--

00:52:31.340 --> 00:52:32.524
crucially important.

00:52:32.524 --> 00:52:34.940
I have debated whether to try
and teach them in the class.

00:52:34.940 --> 00:52:37.630
Actually, I did a little bit
at one time in the class,

00:52:37.630 --> 00:52:40.190
but it was just too much of
a distraction for the class.

00:52:40.190 --> 00:52:41.224
We only have 10 weeks.

00:52:41.224 --> 00:52:42.890
And so I finally
decided, for the class,

00:52:42.890 --> 00:52:44.390
I just got to focus on design.

00:52:44.390 --> 00:52:46.550
So I don't do unit
testing in the class.

00:52:46.550 --> 00:52:49.110
But I'm a complete
advocate of unit tests.

00:52:49.110 --> 00:52:52.290
I can't imagine doing
software without unit tests.

00:52:52.290 --> 00:52:57.400
AUDIENCE: So I was
intrigued by the first part

00:52:57.400 --> 00:53:01.210
of the discussion when you said
in the iterative process you

00:53:01.210 --> 00:53:03.770
actually dropped--

00:53:03.770 --> 00:53:08.770
you initially had students
build on other students code.

00:53:08.770 --> 00:53:12.460
To me, that's a very,
very real world problem.

00:53:12.460 --> 00:53:14.350
And I'm just
surprised that you--

00:53:14.350 --> 00:53:15.977
I mean, I wish you
would teach that.

00:53:15.977 --> 00:53:17.810
JOHN OUTSERHOUT: You
know, I agree with you.

00:53:17.810 --> 00:53:20.500
In a perfect world, that would
do one of the things we do.

00:53:20.500 --> 00:53:22.810
The problem is
we've got 10 weeks.

00:53:22.810 --> 00:53:24.160
How do I use that 10 weeks?

00:53:24.160 --> 00:53:27.580
And I decided I want to try and
do the most I can on design.

00:53:27.580 --> 00:53:30.070
And so I have to
sacrifice other things.

00:53:30.070 --> 00:53:32.410
It's the same reason why
unit testing got thrown out,

00:53:32.410 --> 00:53:34.160
because I felt like
it was better for them

00:53:34.160 --> 00:53:36.681
to be thinking about more
design issues than unit testing

00:53:36.681 --> 00:53:37.180
issues.

00:53:37.180 --> 00:53:38.950
But I agree with your
thought completely.

00:53:38.950 --> 00:53:40.930
Yeah.

00:53:40.930 --> 00:53:42.837
AUDIENCE: Do you have
TAs for the course?

00:53:42.837 --> 00:53:44.170
JOHN OUTSERHOUT: Do we have TAs?

00:53:44.170 --> 00:53:44.900
Yeah, me.

00:53:44.900 --> 00:53:46.110
[LAUGHTER]

00:53:46.110 --> 00:53:46.840
Not right now.

00:53:46.840 --> 00:53:49.720
Because I just
worry that the TAs

00:53:49.720 --> 00:53:52.900
would not be able to give
high enough level of feedback.

00:53:52.900 --> 00:53:55.910
I've started wondering if
maybe students who have taken

00:53:55.910 --> 00:53:58.840
the course previously could TA.

00:53:58.840 --> 00:54:01.900
So far, actually, the demand has
not been more than my capacity.

00:54:01.900 --> 00:54:03.970
And so I've been able
to keep it small.

00:54:03.970 --> 00:54:06.280
If the demand grows, I
may try an experiment

00:54:06.280 --> 00:54:10.780
to see if previous course
participants can TA.

00:54:10.780 --> 00:54:13.510
But, again, I worry.

00:54:13.510 --> 00:54:15.090
Also, for the first
few offerings,

00:54:15.090 --> 00:54:16.840
I wanted to read all
the code myself, too,

00:54:16.840 --> 00:54:19.265
because I wanted to
learn from it as well.

00:54:19.265 --> 00:54:21.640
AUDIENCE: Have you thought
about using software engineers

00:54:21.640 --> 00:54:23.710
as TAs?

00:54:23.710 --> 00:54:25.510
We read and write
code every day.

00:54:25.510 --> 00:54:26.740
[LAUGHTER]

00:54:26.740 --> 00:54:28.090
JOHN OUTSERHOUT: I'm not
opposed to it in principle.

00:54:28.090 --> 00:54:29.506
But I'd want to
make sure students

00:54:29.506 --> 00:54:31.280
don't get mixed messages.

00:54:31.280 --> 00:54:33.964
And so particularly
because the ideas

00:54:33.964 --> 00:54:35.380
I'm teaching in
the course are not

00:54:35.380 --> 00:54:39.522
ideas that are not necessarily
widely spread in the community.

00:54:39.522 --> 00:54:40.980
Like the worst
thing would happened

00:54:40.980 --> 00:54:42.520
is if a software engineer
comes in and says,

00:54:42.520 --> 00:54:44.330
no, this method is
longer than 20 lines.

00:54:44.330 --> 00:54:45.413
You've got to break it up.

00:54:47.810 --> 00:54:50.840
So if I could find people
that are sort of bought

00:54:50.840 --> 00:54:52.670
into the philosophy--
and maybe, you know,

00:54:52.670 --> 00:54:54.800
the book gets out there
and more people buy in,

00:54:54.800 --> 00:54:56.857
maybe we can do more of that.

00:54:56.857 --> 00:54:57.440
SPEAKER 1: OK.

00:54:57.440 --> 00:55:00.485
One question from the Dory,
the second highest rate one--

00:55:00.485 --> 00:55:02.760
are threads still a bad idea?

00:55:02.760 --> 00:55:07.370
[LAUGHTER]

00:55:07.370 --> 00:55:09.997
JOHN OUTSERHOUT: You know, one
of the interesting things when

00:55:09.997 --> 00:55:11.830
the only form in which
you publish something

00:55:11.830 --> 00:55:14.180
is a set of slides rather
than a paper-- which that was.

00:55:14.180 --> 00:55:15.680
It was just an invited talking
at a [INAUDIBLE] conference

00:55:15.680 --> 00:55:17.200
a long time ago.

00:55:17.200 --> 00:55:17.990
It's interesting.

00:55:17.990 --> 00:55:19.460
People can come
back and interpret

00:55:19.460 --> 00:55:22.280
that in whole bunches of
different ways over the years.

00:55:22.280 --> 00:55:25.264
So that was done in a very
narrow context of the time

00:55:25.264 --> 00:55:27.680
where people were starting to
introduce threads for things

00:55:27.680 --> 00:55:28.760
that didn't even need threads.

00:55:28.760 --> 00:55:31.218
They were doing threading on
machines that didn't even have

00:55:31.218 --> 00:55:32.750
multiple processors on them.

00:55:32.750 --> 00:55:36.791
And so that talk was
a reaction to that.

00:55:36.791 --> 00:55:37.790
Threads are unavoidable.

00:55:37.790 --> 00:55:40.710
I mean, for certain things,
you just have to use them.

00:55:40.710 --> 00:55:43.799
But they're still sort
of the next to worst

00:55:43.799 --> 00:55:45.590
alternative where the
worst alternative may

00:55:45.590 --> 00:55:47.900
be, in some cases,
not using threads--

00:55:47.900 --> 00:55:49.230
incredibly hard to program.

00:55:49.230 --> 00:55:50.646
So I'm still not
a fan of threads,

00:55:50.646 --> 00:55:52.365
but they're kind
of a fact of life.

00:55:52.365 --> 00:55:52.865
Yeah.

00:55:52.865 --> 00:55:55.510
AUDIENCE: I have a
question on Tcl language.

00:55:55.510 --> 00:56:01.150
I think the language is sort
of very simple in itself,

00:56:01.150 --> 00:56:07.480
but eventually not gained,
like, larger scope of adoption.

00:56:07.480 --> 00:56:12.850
I want to ask, because you
are the language inventor, is

00:56:12.850 --> 00:56:16.270
your like high level
issues in the language

00:56:16.270 --> 00:56:20.014
of design you saying you got
it wrong, which makes it--

00:56:20.014 --> 00:56:22.180
JOHN OUTSERHOUT: What even
happened to Tcl, I think,

00:56:22.180 --> 00:56:24.559
would be your question.

00:56:24.559 --> 00:56:26.350
I don't want to diverge
too much from that.

00:56:26.350 --> 00:56:28.940
I would say two things.

00:56:28.940 --> 00:56:31.360
First, one of the
things Tcl was best at

00:56:31.360 --> 00:56:34.960
was doing kind of simple
interactive GUIs with Tk.

00:56:34.960 --> 00:56:37.000
And when the web came
along, the web basically

00:56:37.000 --> 00:56:39.790
took that over and Tcl did not
make the transition to the web.

00:56:39.790 --> 00:56:42.210
So a lot of things people would
have used Tcl Tk for, they

00:56:42.210 --> 00:56:43.870
end up doing in the web.

00:56:43.870 --> 00:56:47.004
The second thing is, is it
really with the right language?

00:56:47.004 --> 00:56:49.420
I'm not sure, in retrospect,
that it's the right language.

00:56:49.420 --> 00:56:51.640
Actually, I built it for
a very different purpose.

00:56:51.640 --> 00:56:54.420
I built it as more of a
textual command language

00:56:54.420 --> 00:56:56.170
that you'd be typing
commands to programs,

00:56:56.170 --> 00:56:57.700
almost like a shell language.

00:56:57.700 --> 00:57:00.560
And then it ended up getting
used as a scripting language.

00:57:00.560 --> 00:57:03.460
It has a bunch of
interesting properties.

00:57:03.460 --> 00:57:05.650
But I don't know, if
I were doing it again,

00:57:05.650 --> 00:57:07.570
I'm not sure I would
design the same language.

00:57:07.570 --> 00:57:08.620
But I think that the
biggest thing that

00:57:08.620 --> 00:57:10.210
happened is kind of
the web came along

00:57:10.210 --> 00:57:13.507
and Tcl did not effectively
make the transition to the web.

00:57:13.507 --> 00:57:14.090
SPEAKER 1: OK.

00:57:14.090 --> 00:57:16.670
So there's a lot of really
interesting questions

00:57:16.670 --> 00:57:18.170
both on the Dory
and in the room.

00:57:18.170 --> 00:57:19.250
In the interest
of time, I'm going

00:57:19.250 --> 00:57:21.620
to do two more Dory questions
and two more in the room.

00:57:21.620 --> 00:57:24.920
And then John is going to
stay around and hopefully

00:57:24.920 --> 00:57:26.220
answer more questions as well.

00:57:26.220 --> 00:57:26.720
OK.

00:57:26.720 --> 00:57:30.170
So any thoughts on
the hiring process

00:57:30.170 --> 00:57:32.162
based on what you've observed?

00:57:32.162 --> 00:57:33.620
And the question
has, how would you

00:57:33.620 --> 00:57:35.870
change the hiring process
which is so algorithm heavy?

00:57:35.870 --> 00:57:38.380
Can you share your experience
when you ran your company?

00:57:38.380 --> 00:57:39.610
JOHN OUTSERHOUT: Hiring
process, actually, I'm

00:57:39.610 --> 00:57:40.810
not sure it relates
to software design.

00:57:40.810 --> 00:57:43.320
But I have a very strong
opinion about hiring process,

00:57:43.320 --> 00:57:47.700
which is you should hire
for slope, not y-intercept.

00:57:47.700 --> 00:57:51.864
I think people, when they hire,
they do a pattern match of what

00:57:51.864 --> 00:57:53.280
this person has
done, try and find

00:57:53.280 --> 00:57:56.211
the person who has exactly
done the job we want to do.

00:57:56.211 --> 00:57:58.210
I think that's the wrong
way to hire in general.

00:57:58.210 --> 00:57:59.918
I think you want to
hire the person who's

00:57:59.918 --> 00:58:02.190
the fastest learner, who
has the fastest slope.

00:58:02.190 --> 00:58:03.960
I don't particularly
care whether they've

00:58:03.960 --> 00:58:05.080
done the job I want to do.

00:58:05.080 --> 00:58:06.496
Because particularly
at a startup,

00:58:06.496 --> 00:58:09.180
when things change so rapidly,
you know, things change.

00:58:09.180 --> 00:58:11.220
So I look for people
who are really smart

00:58:11.220 --> 00:58:12.729
fast learners rather.

00:58:12.729 --> 00:58:15.270
Also, by the way, the person
who has done this job five times

00:58:15.270 --> 00:58:17.250
before, you sort of
wonder, well, you know,

00:58:17.250 --> 00:58:19.676
why haven't they moved
on to the next job?

00:58:19.676 --> 00:58:21.800
Oftentimes, those people
kind of hit their plateau.

00:58:21.800 --> 00:58:24.359
Whereas, the person with the
rapid slope, has the potential.

00:58:24.359 --> 00:58:24.900
AUDIENCE: OK.

00:58:24.900 --> 00:58:25.290
JOHN OUTSERHOUT:
That's my [INAUDIBLE]..

00:58:25.290 --> 00:58:26.956
SPEAKER 1: Last
question from the Dory--

00:58:26.956 --> 00:58:29.470
what do you think
about Hyrum's Law?

00:58:29.470 --> 00:58:31.760
JOHN OUTSERHOUT: Sorry,
remind what Hyrum's Law is?

00:58:31.760 --> 00:58:32.551
SPEAKER 1: It's a--

00:58:32.551 --> 00:58:36.240
I googled it and it says with
a sufficient number of uses

00:58:36.240 --> 00:58:38.100
of an API, it does
not matter what

00:58:38.100 --> 00:58:39.570
you promise in the contract.

00:58:39.570 --> 00:58:41.760
All observable
behaviors of your system

00:58:41.760 --> 00:58:44.366
will be depended on by somebody.

00:58:44.366 --> 00:58:47.047
[LAUGHTER]

00:58:47.047 --> 00:58:48.630
JOHN OUTSERHOUT: I
think there's truth

00:58:48.630 --> 00:58:51.420
to that, that, yeah, over time
what happens is the, sort of,

00:58:51.420 --> 00:58:53.580
application, they
find every crevice

00:58:53.580 --> 00:58:55.230
and sink their roots under that.

00:58:55.230 --> 00:58:56.220
They will discover.

00:58:56.220 --> 00:58:59.340
So unless you're very
careful with your APIs,

00:58:59.340 --> 00:59:00.720
I think that's probably true--

00:59:00.720 --> 00:59:02.753
sad, but true.

00:59:02.753 --> 00:59:03.252
Yeah.

00:59:03.252 --> 00:59:04.180
AUDIENCE: Hi.

00:59:04.180 --> 00:59:06.670
Have you observed any
change in the simplicity

00:59:06.670 --> 00:59:08.920
or the complexity
of a software design

00:59:08.920 --> 00:59:11.459
based on the choice of
languages and support ecosystem?

00:59:11.459 --> 00:59:13.000
JOHN OUTSERHOUT:
Oh, a good question.

00:59:13.000 --> 00:59:15.550
There's some languages somehow
lend themselves to better

00:59:15.550 --> 00:59:17.920
design than other languages.

00:59:17.920 --> 00:59:20.140
You know, there probably are--

00:59:20.140 --> 00:59:23.230
I think that's mostly a
secondary, sort of second order

00:59:23.230 --> 00:59:23.750
thing.

00:59:23.750 --> 00:59:26.224
But, for example, today, I'd
rather program in C++ than C,

00:59:26.224 --> 00:59:28.390
because I liked some of the
object oriented features

00:59:28.390 --> 00:59:29.320
in C++.

00:59:29.320 --> 00:59:32.740
Now, C++ is sort of a big beast
of a language with a horrible

00:59:32.740 --> 00:59:36.217
learning curve, but I
appreciate the power of it.

00:59:36.217 --> 00:59:38.050
But, honestly, I think
the design principles

00:59:38.050 --> 00:59:39.430
are fairly universal.

00:59:39.430 --> 00:59:41.230
You can use them
in any language.

00:59:41.230 --> 00:59:44.560
You know, that simple file
system interface for Unix

00:59:44.560 --> 00:59:46.777
was done in C with no
object oriented stuff.

00:59:46.777 --> 00:59:48.610
And then people would
say, oh, no, actually,

00:59:48.610 --> 00:59:50.140
you notice it's actually
object oriented,

00:59:50.140 --> 00:59:51.220
because there's a
file descriptor that

00:59:51.220 --> 00:59:52.460
gets passed around.

00:59:52.460 --> 00:59:55.170
And the object oriented
was really crucial to that.

00:59:55.170 --> 00:59:57.820
I say, no, they just found
a really sweet interface.

00:59:57.820 --> 01:00:02.170
So I haven't found one language
that somehow was dramatically

01:00:02.170 --> 01:00:04.370
better than others for design.

01:00:04.370 --> 01:00:05.950
But if people have
opinions, I'd be

01:00:05.950 --> 01:00:08.000
curious to hear other
opinions about that.

01:00:08.000 --> 01:00:09.610
SPEAKER 1: So back
to hiring, you

01:00:09.610 --> 01:00:13.440
mentioned we should hire on
slope, not on y-intercept.

01:00:13.440 --> 01:00:15.260
And I radically agree.

01:00:15.260 --> 01:00:17.159
How do I estimate the slope?

01:00:17.159 --> 01:00:18.700
JOHN OUTSERHOUT:
How do measure that?

01:00:18.700 --> 01:00:19.050
SPEAKER 1: Right?

01:00:19.050 --> 01:00:19.590
Especially, like--

01:00:19.590 --> 01:00:20.230
JOHN OUTSERHOUT: I have no idea.

01:00:20.230 --> 01:00:21.580
SPEAKER 1: --you need at
least two points, right?

01:00:21.580 --> 01:00:23.060
In an interview, I get only one.

01:00:23.060 --> 01:00:25.480
And I am terrified of hiring
more tactical tornadoes.

01:00:25.480 --> 01:00:27.410
[LAUGHTER]

01:00:27.410 --> 01:00:28.660
JOHN OUTSERHOUT: I don't know.

01:00:28.660 --> 01:00:32.220
You know, so I'll tell you
what correlated best for me,

01:00:32.220 --> 01:00:35.744
but it's sort of crazy is that
I found in my experienced people

01:00:35.744 --> 01:00:37.660
who worked out best were
the ones where I just

01:00:37.660 --> 01:00:40.859
really enjoyed my conversation
with them during the interview.

01:00:40.859 --> 01:00:41.900
And that's sort of weird.

01:00:41.900 --> 01:00:43.480
I feel kind of
funny saying that,

01:00:43.480 --> 01:00:45.700
because that means somehow
somebody sucked up to me.

01:00:45.700 --> 01:00:47.570
And I liked them and hired them.

01:00:47.570 --> 01:00:50.980
I don't think that's it because
I have a pretty sensitive meter

01:00:50.980 --> 01:00:52.270
for suck-upness.

01:00:52.270 --> 01:00:56.090
And that really pisses me off.

01:00:56.090 --> 01:00:58.705
And people have also pointed,
if you take that edge, that's

01:00:58.705 --> 01:00:59.770
kind of a risk that
you're just hiring

01:00:59.770 --> 01:01:00.550
more people like yourself.

01:01:00.550 --> 01:01:02.860
And so you're not going
to do diversity very well.

01:01:02.860 --> 01:01:05.286
So I have no idea
what to make of that

01:01:05.286 --> 01:01:06.660
or whether it's
even a good idea.

01:01:06.660 --> 01:01:08.680
But that's the one
thing that seemed

01:01:08.680 --> 01:01:11.417
to correlate in my experience.

01:01:11.417 --> 01:01:12.000
SPEAKER 1: OK.

01:01:12.000 --> 01:01:12.900
Yeah.

01:01:12.900 --> 01:01:15.540
So let's thank John
once again now.

01:01:15.540 --> 01:01:21.290
[APPLAUSE]

