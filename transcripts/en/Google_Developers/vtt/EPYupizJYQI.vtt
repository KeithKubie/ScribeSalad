WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.801
&gt;&gt; PARLANTE: This morning, I talked about
strings, they're just the most basic stuff,

00:00:02.801 --> 00:00:05.641
and then we had the string exercises. So the
time for the rest of the day I'm going to

00:00:05.641 --> 00:00:10.330
talked about lists and tuples, what are their
structures. We'll have--had a little exercises

00:00:10.330 --> 00:00:15.019
about that, and then I'll finish off talking
about dictionaries and files, chart tables,

00:00:15.019 --> 00:00:18.630
and then we'll have a large exercise, and
that will complete the day. So that's in line

00:00:18.630 --> 00:00:22.830
for today. I'll probably get you out here
around, I don't know, 4:15 or some like that.

00:00:22.830 --> 00:00:31.830
All right. So let's talk about another Python
type, so let's fire up the interpreter here.

00:00:31.830 --> 00:00:37.710
So I did strings. So the next topic I'm going
to show you is the lists. So the lists is

00:00:37.710 --> 00:00:42.030
in a--appears in square brackets. So if I
wanted a lists of like the numbers one, two,

00:00:42.030 --> 00:00:47.531
three, that will look like that, like--I mean
I could tie it into a variable to make it

00:00:47.531 --> 00:00:54.829
very much like my last example. The elements
in a lists, they often are of the same type

00:00:54.829 --> 00:01:00.630
but there's no requirement, so I could have
like "1, 2," and then like "aaaa",--oops,

00:01:00.630 --> 00:01:09.280
okay. That's probably--oh, three commas. I'm
sorry. So, it'll give a list of a, you know,

00:01:09.280 --> 00:01:12.600
different types. In reality, mostly, you'll
have a list of all the same thing for just,

00:01:12.600 --> 00:01:20.179
you know, just sort the most intuitive case.
Now, Python has this sort of design idea that

00:01:20.179 --> 00:01:26.209
instead of having, you know, one syntax for
strings and another syntax for list or whatever,

00:01:26.209 --> 00:01:31.280
Python tries to use the one syntax very consistently
for all things, and so this is a nice quality.

00:01:31.280 --> 00:01:36.380
It means when you're learning it, there's
less to memorize. So, for example, the length

00:01:36.380 --> 00:01:41.670
function for lists is just the one we learned
before. So, yeah, I could say "lan(a)", just

00:01:41.670 --> 00:01:47.039
like for strings. And in fact, many of the
bits of syntax or operations for strings were

00:01:47.039 --> 00:01:52.380
countless as well. And so Pythons are deliberately
consistent. So, for example, I could do a

00:01:52.380 --> 00:02:02.469
"+". So I could say, well, I have the list
"[1, 2, "aaaa"], you know, "+ [3, 4]". And

00:02:02.469 --> 00:02:06.079
like with strings, we've seen that, right?
It puts them together to make a bigger string.

00:02:06.079 --> 00:02:11.370
With list, they're like, put some together
to make a bigger list. So one difference that

00:02:11.370 --> 00:02:18.879
list have--I'll set this back to "a = [1,
2, 3]. Is what is--what is the equals to?

00:02:18.879 --> 00:02:27.510
So if I say "b = a", "end. The key thing to
remember here is this does not make a copy.

00:02:27.510 --> 00:02:30.909
What this has done is there's this one list
sitting in memory somewhere, and it used to

00:02:30.909 --> 00:02:35.540
be that "a" was pointing to it; and now, "b"
is pointing to that same list. So there's

00:02:35.540 --> 00:02:40.190
one list, and they're both pointing to it.
The way you could tell, all right, we do a

00:02:40.190 --> 00:02:43.239
little experiment--oh, I'm sorry; I really
didn't to talk about. How do you refer to

00:02:43.239 --> 00:02:45.970
the--an element inside of here? Yeah, it's
just like, just like in the string. So, if

00:02:45.970 --> 00:02:51.970
I say "a [0]", that's the first element, remember?
So I can check my experiment by using this

00:02:51.970 --> 00:02:56.090
on the right hand, so I'll say, well, I'll
set "a[0] = 13". I'm going to change that

00:02:56.090 --> 00:03:01.359
first element; lists are mutable, you can
change them. Unlike strings, Strings are the

00:03:01.359 --> 00:03:08.670
ones that don't' change. So if I look at "a",
it's now different. But if I look at "b",

00:03:08.670 --> 00:03:13.610
it's different also. So this kind of shows
how they were just pointing to the one thing.

00:03:13.610 --> 00:03:17.640
If you want to make a cut--mostly, you're
just having the one list or whatever it is,

00:03:17.640 --> 00:03:21.190
and having pointers sort of sprinkle through
your [INDISTINCT] all pointing, all sort of--I

00:03:21.190 --> 00:03:26.829
could say, sharing that data structure. For
most part, that's just totally fine. You shouldn't--[INDISTINCT]

00:03:26.829 --> 00:03:31.439
block that out. I will show you how to make
a copy, just if you wanted to. The way you

00:03:31.439 --> 00:03:36.260
make a copy--or actually, I'll set "b" to
be a copy of "a"--is of you--the Pythonic

00:03:36.260 --> 00:03:43.640
way is use slice syntax. So if you say, "[:]" that's
the kind of Pythonic way of saying, "Well,

00:03:43.640 --> 00:03:48.200
here's a linear quantitative things. Please
make a copy of it." So, now "b" relays a copy

00:03:48.200 --> 00:03:49.200
if I change "a" and "b" would change. Yeah?
Question over here?

00:03:49.200 --> 00:03:56.719
&gt;&gt; So the question was, if you'll be framing
a copy for me to change "b" and also change

00:03:56.719 --> 00:03:58.260
anything...?
&gt;&gt; PARLANTE: Yeah. So the question is question

00:03:58.260 --> 00:04:03.780
is, so before I made I copy, if I change "b"
or if it's "a"? Yes. So there's this one list

00:04:03.780 --> 00:04:08.209
in memory, they're both pointing to it. They're
literally sharing it. Now, I'm going to say,

00:04:08.209 --> 00:04:11.560
"Look, as a practical matter for your Python
programs, there's just not a problem. It's

00:04:11.560 --> 00:04:17.780
just fine." In C++ or in C, you would want
to make copies mainly because of the memory

00:04:17.780 --> 00:04:21.670
management, like trying to know when to free,
you know, when to reclaim the memory. But

00:04:21.670 --> 00:04:25.350
Python, like, you know, any reason about language
has a garbage collector. It just takes care

00:04:25.350 --> 00:04:29.260
of the memory collection, and so as a result,
this need to make copies, just kind of goes

00:04:29.260 --> 00:04:34.080
where--when I found transitioning from CC++
language is, to Python I found that it was

00:04:34.080 --> 00:04:37.130
making a lot of your copies, likes the need
do that had just gone away. So I guess what

00:04:37.130 --> 00:04:39.590
I'm saying is like, you may have an instinct
to make copies, where I'd say, attempt to

00:04:39.590 --> 00:04:43.580
keep in check, the key you'll find, it just
not make copies and most stuffs just going

00:04:43.580 --> 00:04:49.320
to work fine. All right. So let's see we got
the square brackets, the length, the--let's

00:04:49.320 --> 00:04:57.950
see, what are "a" and "b" this days? Oh, they're
the same. The "==" does comparisons just like

00:04:57.950 --> 00:05:02.530
string. So you have two lists. It actually
follows the list and checks piece by piece,

00:05:02.530 --> 00:05:07.950
which are the same. So as before, it does
have a kind of an intuitive notion of checking.

00:05:07.950 --> 00:05:13.030
Now, what's the other thing we did lists,
right, or I'm with strings [INDISTINCT] was

00:05:13.030 --> 00:05:17.440
slices. That works with list as well. So right
here, I've got these lists. If I say "a",

00:05:17.440 --> 00:05:25.660
you know, I don't know what, [1:3] or whatever,
I can pull a slice out of the list. So for--maybe

00:05:25.660 --> 00:05:29.990
the most common case is, like, if I want to
talk about a list, except or without the right

00:05:29.990 --> 00:05:34.620
installment. So, I'll wait until we get to
the exercises, but, yeah, you've got this

00:05:34.620 --> 00:05:42.030
very concise syntax for kind of talky about
some parts of a list. All right. So let me

00:05:42.030 --> 00:05:52.680
show you the main syntax for this thing. So
a very common thing to do--actually, I'm going

00:05:52.680 --> 00:05:59.720
to--I'll write it over here and I'll I speak
louder, a very common thing to do is to loop

00:05:59.720 --> 00:06:05.970
over a list. And so, in--for example in C,
or right, you've maybe written that loop where

00:06:05.970 --> 00:06:11.960
you say, you know, "for i = 0, i&lt; something",
in Python, it would be very rare to do that.

00:06:11.960 --> 00:06:16.521
There's just a built-in for each list--for
each construct that just loops over a list,

00:06:16.521 --> 00:06:21.440
and it's very commonly used which is I'm going
to--if I actually walk over here and write

00:06:21.440 --> 00:06:24.740
it out, you'll figure must be pretty kind.
All right. The first word is, you begin with

00:06:24.740 --> 00:06:30.470
"for", and then just click whatever variable
name you'd like. So I sort of underline that

00:06:30.470 --> 00:06:39.910
list, and then you have the word "in", and
then you have whatever the list is, and then

00:06:39.910 --> 00:06:44.551
a colon, and then you just do--you know, whatever
it is you wanted to do for each element in

00:06:44.551 --> 00:06:51.890
the list. So, for example, I might say, you
know, "print VAR" or whatever. So this is

00:06:51.890 --> 00:06:56.370
just a built-in way of looping over a list
and doing something for each one. So, for

00:06:56.370 --> 00:07:02.840
example, now, here I've got "a", so I might
say "for num in a:"--now, here, I'm going

00:07:02.840 --> 00:07:06.740
to write it all on one line just because I'm
in the interpreter. The Google [INDISTINCT],

00:07:06.740 --> 00:07:09.780
the more correct thing would be to have a
colon and then go to the next line, but it

00:07:09.780 --> 00:07:14.940
turns out you can't just crunch it under the
line as I'm doing here. So if I say "for num

00:07:14.940 --> 00:07:20.080
in a: prints num", then what that's going
to do--the role of "..." there is just an

00:07:20.080 --> 00:07:21.790
artifact to the interpreter, just to let you
know there's more up that's coming, so you

00:07:21.790 --> 00:07:27.940
can ignore that. So really what that did is
it just looped over the list and, you know,

00:07:27.940 --> 00:07:32.370
once for each element, it's going to run this
body of code, and each time through that value

00:07:32.370 --> 00:07:37.800
"num" is just going to be, you know, a one
element from the list. So, this is a, you

00:07:37.800 --> 00:07:41.140
know, it's the very common case. You just
want to loop over the thing, you know, sort

00:07:41.140 --> 00:07:44.670
of for each. Yeah, question back here.
&gt;&gt; How does it know that numbers are also

00:07:44.670 --> 00:07:46.830
those numbers?
&gt;&gt; PARLANTE: Well, so let's do it, so the

00:07:46.830 --> 00:07:50.170
question is how does it know that num is also
those numbers? What its doing is num is just

00:07:50.170 --> 00:07:53.880
a variable name just chosen by me, it could
have been anything, and what it does in the

00:07:53.880 --> 00:07:59.860
loop, essentially, what it's doing inside
the loop is like num is equal to whatever,

00:07:59.860 --> 00:08:04.210
you know, kind of like, what the next value
is. It assigns it into num, just like a variable,

00:08:04.210 --> 00:08:07.130
and then after that, then it runs with a little
bit of code I have, and then it loops around

00:08:07.130 --> 00:08:13.840
and does the next one. So in other languages,
it might--it's similar to the idea of an iterator.

00:08:13.840 --> 00:08:17.001
So, this is for--the exercises of this will
come up late. The idea that you have a list

00:08:17.001 --> 00:08:21.190
of a bunch of things and you kind of want
to do something for each one, that is--that's

00:08:21.190 --> 00:08:26.330
a common case and this is certainly the syntax
you should use for that. There is a related

00:08:26.330 --> 00:08:33.740
syntax--this is like this is the first one.
The second one is very simple which is just--you

00:08:33.740 --> 00:08:39.990
have some value, and you want to, you want
to check if it is in a list, and you can imagine--I'm

00:08:39.990 --> 00:08:45.420
sorry, is this too low down? You guys can't
see? Sorry. I'll write it up above. I'll put

00:08:45.420 --> 00:08:55.260
up here. Let's stuck this here, all right.
If you want to check if a value is in a list,

00:08:55.260 --> 00:09:01.860
you can write this way. You just put whatever
the value is and then the word "in"; just

00:09:01.860 --> 00:09:09.970
the "in" by itself, and then whatever the
list is. So it's very short. So, if you've

00:09:09.970 --> 00:09:14.870
got a--I mean, this works for list. It actually
works for a lot of things, just "in" in Python.

00:09:14.870 --> 00:09:18.250
There's this built-in way that you've got
some composite data structure, and you want

00:09:18.250 --> 00:09:23.360
to tell, is this thing in here? So what's
"a"? So, for example, I can just write "2

00:09:23.360 --> 00:09:28.630
in a", and that's just going to go over "a"
figure out somehow, or with what something,

00:09:28.630 --> 00:09:34.330
like, let's say the "14 in a". There's the
"False". So there's another one--this sort

00:09:34.330 --> 00:09:37.480
of higher in the food chain things, you might
have an instinct, "Oh, I want to see if it's

00:09:37.480 --> 00:09:41.430
in here. Oh, I'm going to write a four loop,
and I guess I'll loop through, and I'll compare

00:09:41.430 --> 00:09:44.680
each one with equals, equals rarely." I'd
be like, "no". In Python, you've--it's just

00:09:44.680 --> 00:09:49.810
built-in. You'll say, "Look, is this in there?"
It works for actually a lot of data structures,

00:09:49.810 --> 00:09:52.760
and in--the [INDISTINCT] case it's actually
quite efficient, you know. It does--it does

00:09:52.760 --> 00:09:57.000
something smart depending on what data structure
you have. So you should not worry about doing

00:09:57.000 --> 00:10:01.790
something with them. So, along with slices,
you should just--so I'd rather that you just

00:10:01.790 --> 00:10:05.471
go ahead and memorize those. Those two syntactic
constructs are very common, you should just

00:10:05.471 --> 00:10:11.890
know those. And, of course, my examples later
on, so up here all sorts of time. All right.

00:10:11.890 --> 00:10:18.301
So let me show you just as with the string,
we had methods like ".lower" and ".replace"

00:10:18.301 --> 00:10:21.680
and ".find", whatever. The list is the same
way. It's got all sorts of built-in stuff.

00:10:21.680 --> 00:10:27.920
I'm just going to show you a couple. One is
there's an append--and you can just guess

00:10:27.920 --> 00:10:34.000
what that does. Just to--puts it on the end
there. One important thing about append is

00:10:34.000 --> 00:10:40.990
that it does not return a new list. It returns
the special value of none which I, you know,

00:10:40.990 --> 00:10:44.990
you saw in the [INDISTINCT] a little bit.
None upper case N--I'll just type here--is

00:10:44.990 --> 00:10:51.841
sort of the null value. It means like nothing.
So, "a.append", it returns nothing. What it

00:10:51.841 --> 00:10:59.680
does is it modifies the list. So, it does
not--it would be wrong to write this, "a = a.append(xx)",

00:10:59.680 --> 00:11:11.290
you know, say, well, I have to say no. I mean
there is this follow the world where--I mean

00:11:11.290 --> 00:11:14.779
some other language maybe that were, but in
Python that just happens to not work at all.

00:11:14.779 --> 00:11:20.250
And it's because append does not return anything.
It modifies the list in place, and that's--I've

00:11:20.250 --> 00:11:23.710
absolutely made that here myself. It's just
the--there's this two different paradigms

00:11:23.710 --> 00:11:29.550
they could have chose, and they chose the
one right at that one. All right. Also, there's

00:11:29.550 --> 00:11:34.980
a--it's kind of the reverse of append, there's
pop. And so if I--this is by position. So

00:11:34.980 --> 00:11:40.910
if I say, "pop(0)", what that's going to do
is it pop--it removes, it sure pops up the

00:11:40.910 --> 00:11:45.210
zero with element, and returns it to me, and
it modifies list. So, it kind of removes it

00:11:45.210 --> 00:11:47.880
from the list and send it to you. So, you
want to kind of remove an element and just

00:11:47.880 --> 00:11:55.650
kind of get it out of there. Then, pop--pop
[INDISTINCT]. And were--and, then you should

00:11:55.650 --> 00:12:00.080
look at the docs. Yes, there are dozens of
built-in list methods for all sorts of common

00:12:00.080 --> 00:12:04.270
stuff. And if you have a problem involving
manipulating a list, searching it or replacing

00:12:04.270 --> 00:12:09.910
or whatever, yeah, you should go look it and
go find the built-in ones. There is a particular

00:12:09.910 --> 00:12:17.230
case though that I want to show you and that
is--well, actually--I'm sorry. There is--there's

00:12:17.230 --> 00:12:21.520
one--another one that I'm going to show you,
which is something I haven't talk about so

00:12:21.520 --> 00:12:30.710
far. So here is A, there's a--I guess this
is an operator called del, I mean, delete.

00:12:30.710 --> 00:12:35.529
And what delete does, obviously, it deletes.
But, particularly, you can use it on a variable.

00:12:35.529 --> 00:12:41.480
So if I say del A, what that does is it kind
of removed the definition of A from my local

00:12:41.480 --> 00:12:44.650
scope. Whereas, when I design A to six or
whatever that I put in there. So, now, if--after

00:12:44.650 --> 00:12:51.029
that if I try and use A, it's like, "Oh, that's
not define." So it's kind of the reverse of

00:12:51.029 --> 00:12:55.110
the direction I've tried before. And what
happens, the del also works on list. So if

00:12:55.110 --> 00:13:01.461
I say A is equal to one, two, three, and let's
say if I can say, well, you know--if I can

00:13:01.461 --> 00:13:07.950
say "A[1]", that's the two, right. So in terms
on how you can use a del to actually retain

00:13:07.950 --> 00:13:13.610
the list, so if I say del of "A[1]", that
kind of deletes out on that list, but now,

00:13:13.610 --> 00:13:18.690
the list actually shrinks. So that's--I've
shown you how to add, I've shown you how to

00:13:18.690 --> 00:13:21.220
pop, also del has another way. You can surf
the one there. Yes, question over here.

00:13:21.220 --> 00:13:24.410
&gt;&gt; So if you do--if you design A to B for
instance without copying it but actually point...

00:13:24.410 --> 00:13:31.710
&gt;&gt; PARLANTE: And so this one--in these cases,
we're actually just doing the interpreter.

00:13:31.710 --> 00:13:35.430
Okay, let's say B is something like it's 12,
and I say A equals B.

00:13:35.430 --> 00:13:39.180
&gt;&gt; And then you del A?
&gt;&gt; PARLANTE: Okay. And so if I say del A...

00:13:39.180 --> 00:13:42.649
&gt;&gt; B is still B.
&gt;&gt; PARLANTE: ...then B is still fine.

00:13:42.649 --> 00:13:45.320
&gt;&gt; Okay.
&gt;&gt; PARLANTE: All right. The del A--what it

00:13:45.320 --> 00:13:48.810
does, it's just kind of removes--I mean, it's
sort like when I had A and B point at the

00:13:48.810 --> 00:13:51.930
list, right. It's like, well, the list is
still there. Deleting A, I'm just like--I'm

00:13:51.930 --> 00:13:55.290
deleting the idea of A, but whatever it pointed
to, something else might have been pointing

00:13:55.290 --> 00:13:59.660
to as well. Now, with the 12--I use the word
point there as a little inaccurate but the

00:13:59.660 --> 00:14:06.330
basic pattern holds. All right, so the most
interesting thing with list I want to show

00:14:06.330 --> 00:14:12.800
you is sorting. So there's this old way of
doing sorting. Well, there's actually a dot

00:14:12.800 --> 00:14:18.960
sort method on the list and I want you to
not use that one. I'm going to show you this

00:14:18.960 --> 00:14:24.890
newer, cooler way that it's just better than
everyone. And you can--yeah, with all those

00:14:24.890 --> 00:14:28.790
dinosaurs were using dot sort you can just
like look down on them. All right, so what

00:14:28.790 --> 00:14:31.730
I'm going to do--well, first of all I'm going
to show you the most basic case. So let's

00:14:31.730 --> 00:14:40.500
say A equal to you know, four, two, one, six.
So the simplest way to do sorting is there's

00:14:40.500 --> 00:14:48.540
a function called sorted. And you can feed
a list into sorted, and what it does is it

00:14:48.540 --> 00:14:54.111
makes a new list and it sorts it, sorts it
in increasing order. Now, so in this case

00:14:54.111 --> 00:14:58.180
when I call sorted on A, it's making this
new list and then it sort again. In this case,

00:14:58.180 --> 00:15:06.060
we're getting a numeric sort. In reality what's
going on is it's the comparison in Python

00:15:06.060 --> 00:15:10.303
depends on the type of thing being compared.
And in this case, it's a list of int. And

00:15:10.303 --> 00:15:14.520
so when I gets down to the comparing one int
to another it sees like, "Oh, this is two

00:15:14.520 --> 00:15:19.520
ints, so I should do a numeric comparison.
If, instead, I have the list of strings, it

00:15:19.520 --> 00:15:22.390
would have gotten down to comparison with
the scene, "Oh, I have two strings," and so

00:15:22.390 --> 00:15:25.690
it would have done a textual comparison. Again,
it has that sort of Python quality like at

00:15:25.690 --> 00:15:30.720
the last possible second it sees whatever
the two types are and it does something appropriate,

00:15:30.720 --> 00:15:36.110
I guess. So one of the things about sorted--and,
actually, I'll pull up the help page for sorted.

00:15:36.110 --> 00:15:42.890
Remember help? So if I say "help(sorted)",
it's pretty [INDISTINCT], "sorted(iterable)".

00:15:42.890 --> 00:15:47.560
So this actually works for a list. You can
actually feed into sorted any--an iterator--some

00:15:47.560 --> 00:15:51.760
other things that kind of--are capable of
producing list so that they are not themselves

00:15:51.760 --> 00:15:55.990
list, you can feed those into sorted too,
it just works with all of this, anything that

00:15:55.990 --> 00:16:04.040
kind of looks like a sequence. So these syntax
here were first two optional named arguments.

00:16:04.040 --> 00:16:09.330
And so this built-in, like--yeah, you can
just not specify CMP or key or reverse, but

00:16:09.330 --> 00:16:13.440
if you do specify them, then, you can sort
give these extra arguments. This is a nice

00:16:13.440 --> 00:16:17.560
quality in Python. So in this case, I had
"sorted(a)". In that way, I could also say,

00:16:17.560 --> 00:16:22.600
"sorted(a,..." and then one of the optional
argument is called reverse. So, I mean, I

00:16:22.600 --> 00:16:25.930
have to go look up and see if that was the
name, but I see the name was reverse. And

00:16:25.930 --> 00:16:31.780
if I pass through for that, then, it still
sorts them but I just get it the backwards

00:16:31.780 --> 00:16:34.839
way. So that's a very common problem. I see
you just want to sort the other way so, and

00:16:34.839 --> 00:16:40.670
so that's the built-in. Yes, question.
&gt;&gt; I just need to ask to see whether A gets

00:16:40.670 --> 00:16:47.260
assign a sorted list or gets [INDISTINCT].
&gt;&gt; PARLANTE: Yeah, sorted makes a copy. It

00:16:47.260 --> 00:16:50.029
makes a new one and sorts that.
&gt;&gt; [INDISTINCT] into a new...

00:16:50.029 --> 00:16:54.019
&gt;&gt; PARLANTE: Yeah. Yeah. So for example--well,
so here is A, it's unchanged right?

00:16:54.019 --> 00:16:57.220
&gt;&gt; Yeah.
&gt;&gt; PARLANTE: And here's "sorted(a)". What

00:16:57.220 --> 00:17:01.590
I could do--this is what you're suggesting--is
I could say A is equal to "sorted(a)". Like

00:17:01.590 --> 00:17:05.720
yeah, I don't care to keep the original on
that, that's fine. So now, it's sorted. So

00:17:05.720 --> 00:17:09.509
you have the--once we spend over it you would
even don't have a choice right, so this way

00:17:09.509 --> 00:17:20.490
you get to pick. All right. So let me show
you just like basic sorting. So, now, I want

00:17:20.490 --> 00:17:26.029
to show you this little more sophisticated
about how to do custom sorting in Python.

00:17:26.029 --> 00:17:30.100
And the Python syntax--the Python structure
for this, I think, is really nice, but it's

00:17:30.100 --> 00:17:34.220
going to be a little more complicated. All
right, so I'm going--and I'm going to set

00:17:34.220 --> 00:17:40.320
up my case, so it's exactly the same as the
one in the handout. All right, so here, I'm

00:17:40.320 --> 00:17:48.090
going to have some strings. So if I say "sorted(a)"
here, the strings what--by default what I

00:17:48.090 --> 00:17:53.419
get is textual sort. Now, the problem I want
to consider is--for custom sorting, right,

00:17:53.419 --> 00:17:59.059
you want to sort some other way, not just
textually. The case I want to consider is,

00:17:59.059 --> 00:18:05.179
well, suppose I want to sort this by length,
right. I want to D first and then the B's

00:18:05.179 --> 00:18:10.230
and then C's, right. I want kind of increase
in order by length just for--just as an example.

00:18:10.230 --> 00:18:17.429
How might I do that? Well the old way to specify
custom sorting in a lot of languages is that

00:18:17.429 --> 00:18:23.279
you write what's called the two argument competitor.
You provide some function that takes two arguments

00:18:23.279 --> 00:18:27.470
and compares those two and returns either
a negative number or zero or positive number

00:18:27.470 --> 00:18:30.850
depending on how you wish for those to be
ordered and you feed that into the sorting

00:18:30.850 --> 00:18:36.840
function and then uses it. That is a classic
technique, the two argument comparative technique.

00:18:36.840 --> 00:18:40.929
But it's a little messy, it's a little difficult
to describe, and it's just not that great.

00:18:40.929 --> 00:18:45.080
So Python, we're not just going to do that
way. I'm going to show you a different way.

00:18:45.080 --> 00:18:50.990
And the idea is I'm going--here's a piece
of art in the handout. So in this case at

00:18:50.990 --> 00:18:57.820
the top, I've got my original list. And I've
got this idea that what I want to do is I

00:18:57.820 --> 00:19:03.600
want to sort by the length. So the way it's
going to work in Python is I'm going--you--we

00:19:03.600 --> 00:19:11.419
are going to provide a function of one argument.
This called the key function. And this function

00:19:11.419 --> 00:19:15.450
of one argument, then, what the system is
going to do is it's going to run it over our

00:19:15.450 --> 00:19:19.690
original list. And for each element in the
original list, it's going to call the function

00:19:19.690 --> 00:19:24.559
of one argument and it's going to get a single
value and it's going to build up a list of

00:19:24.559 --> 00:19:28.989
those new values. So I'm going to kind of
walk over here kind of point at my drawing.

00:19:28.989 --> 00:19:34.191
So here at the top, we've got my original
list. Now, imagine the function of one argument

00:19:34.191 --> 00:19:38.049
that I'm going to use in this case is the
Len function. We've been using it all along,

00:19:38.049 --> 00:19:43.239
right. And Len, when you call it on a string,
it returns the length to that string. So I'm

00:19:43.239 --> 00:19:48.019
going to give it--I'll show you the syntax,
but I'm going to say, "Hey, use Len as the

00:19:48.019 --> 00:19:53.370
kind of key function in this case." So it's
going to call Len--what is it--five times,

00:19:53.370 --> 00:19:56.460
and it's going to get this numbers right.
Three for the string length--three for the

00:19:56.460 --> 00:20:02.649
string length, just gets this kind of shadow
list of new values. So--now, here's where

00:20:02.649 --> 00:20:10.210
the magic happens. What the sorting is going
to do when I call sorted, I specify key function,

00:20:10.210 --> 00:20:15.070
it's going to make the shadow list and then
it's going to sort the shadow list. So the

00:20:15.070 --> 00:20:18.869
one is going to come first, right, and then
the two, whatever, it figures that out. And

00:20:18.869 --> 00:20:23.289
I got to make this hand waved motion that's
why it's kind like sorting motion, but then

00:20:23.289 --> 00:20:29.320
it applies it to the original list. It actually
shifts around the original elements. And so

00:20:29.320 --> 00:20:34.950
the result is that I get to the bottom. I
get the original elements but sorted according

00:20:34.950 --> 00:20:40.850
to the values of the shadow list. Now, it's
a little hard--yeah, it's a bit much to follow,

00:20:40.850 --> 00:20:45.770
but I'll tell you, in my experience this is
a much more convenient way to do custom sorting.

00:20:45.770 --> 00:20:49.580
You just set--sort of gets your brain around
this idea projecting out the shadow list.

00:20:49.580 --> 00:20:53.169
So before I take questions, let me just demo
that working. Show you what that looks like

00:20:53.169 --> 00:20:59.740
and then we can--then, we can work on some
of the examples. Right, so there's A, and

00:20:59.740 --> 00:21:05.769
here's Len, it's like a function. It's a lot
like a function. So what I'm going to say

00:21:05.769 --> 00:21:13.919
is what I want is "sorted(a)", and I'm going
to give this optional argument called "key=..."

00:21:13.919 --> 00:21:18.429
and I'm going to specify a function to use,
in this case I'm just going to say, "Yes,

00:21:18.429 --> 00:21:24.210
use Len." So if I do that, then, it's under
the hood. It's kind of projecting out that

00:21:24.210 --> 00:21:28.621
list. Now, let me do a second example, and
I'm going to change my list a little bit.

00:21:28.621 --> 00:21:42.940
Let's changed--let's changed "a[1]='aaaz".
I'm going to mix my problem up a little bit

00:21:42.940 --> 00:21:52.039
here. Let's say, "How do I"--I want to sort
this by the last character in each string.

00:21:52.039 --> 00:21:57.240
I want to ignore all the other characters.
Just give me--this is the sort of problem,

00:21:57.240 --> 00:22:01.049
there's a custom sort that you might solve
with the key equals function. And I'm going

00:22:01.049 --> 00:22:06.230
to do it with a def just like what you've
done. So I'm going to say "def Last(s)", and

00:22:06.230 --> 00:22:13.409
we're going to do this on one line. There's
nothing--because I'm the interpreter here.

00:22:13.409 --> 00:22:20.440
So let's say, def Last(s): return s[-1]".
Okay. Now, last is fine. So, now, if I say,

00:22:20.440 --> 00:22:25.649
"Last" just like so, like, "Oh," that points
to a function just like if I say Len, okay,

00:22:25.649 --> 00:22:28.740
yeah, that's function. The one that's built-in,
the one's I just made, but it's still going

00:22:28.740 --> 00:22:33.419
to work. All right, so the last function,
you give it a string and it just return that

00:22:33.419 --> 00:22:41.769
last character. So, now, if I say sorted so,
now, I remind what is that? So now, if I say

00:22:41.769 --> 00:22:50.279
"sorted(a, key=..." just the thing I just
defined, "Last", then check it out. So, now,

00:22:50.279 --> 00:22:54.279
I've done custom sorting. And in this case,
what it's doing in the shadow list is it just

00:22:54.279 --> 00:22:58.200
pulling out whatever the last, you know, the
minus one--whatever the last character is

00:22:58.200 --> 00:22:59.960
sorting by that. So there's a couple example
of custom sorting. Yes, question.

00:22:59.960 --> 00:23:00.960
&gt;&gt; So if the last time when A was DD, would
it release by factors DD, would it [INDISTINCT]

00:23:00.960 --> 00:23:16.099
like do the first sort by number of characters
and then within if there were two?

00:23:16.099 --> 00:23:19.019
&gt;&gt; PARLANTE: Actually, yeah. So I'm going
to answer a slightly different question. So--I

00:23:19.019 --> 00:23:23.200
mean there's this idea of, "What if I want
to sort by one thing and then I want to sort

00:23:23.200 --> 00:23:28.350
by something else?" You know, let me--I can
answer that more effectively when I've covered

00:23:28.350 --> 00:23:32.669
one more data structure. There is a way of
doing that, but I'd like to just hold off

00:23:32.669 --> 00:23:40.115
on it. I mean, it's a very reasonable question.
&gt;&gt; [INDISTINCT] what, would it just be random

00:23:40.115 --> 00:23:41.115
if you didn't use that extra [INDISTINCT].
&gt;&gt; PARLANTE: I don't think it would works.

00:23:41.115 --> 00:23:42.159
Do you want? But what I preferred to, I'm
going to save time and show you the way that

00:23:42.159 --> 00:23:46.070
it does work, then, we can talk about it,
okay. And so that's why unsatisfying, but

00:23:46.070 --> 00:23:50.510
there's these other data structure we'd really
need for this. All right, so I understand--I

00:23:50.510 --> 00:23:54.383
think the sorted thing is one of the more
difficult things, kind of kick your head around.

00:23:54.383 --> 00:23:58.950
But, yeah, predictably, the exercises have
like a bunch of custom sorts and it's a very

00:23:58.950 --> 00:24:03.789
powerful technique. So I'd say hold off on
that. And then I do have this beautiful art

00:24:03.789 --> 00:24:06.809
in the handout so try and--try and follow.
So just hold on with that, on the next set

00:24:06.809 --> 00:24:12.159
of exercises which will be pretty soon, you'll
get a chance to play with that. All right,

00:24:12.159 --> 00:24:20.950
so let me show you, just a couple other things
with the list. So one--I'll stick with A,

00:24:20.950 --> 00:24:24.859
just these strings. One fairly common thing
to do once you've got your program and you

00:24:24.859 --> 00:24:30.350
want to now produce your output is you want
to--you want to make a string out of list.

00:24:30.350 --> 00:24:33.679
So, like, one thing you might do is maybe
loop through this list, right? I could type

00:24:33.679 --> 00:24:40.600
"for s in a:" and, you know, kind of print
each element or something. It turns out, that's

00:24:40.600 --> 00:24:46.571
okay but there's a built in that just takes
the list and sort of concatenates or whatever

00:24:46.571 --> 00:24:50.830
all the parts of it together just in one step.
So that's such common on our version; that's

00:24:50.830 --> 00:24:55.639
nice to know. So, for example, if I were to
say, so this is called dot join. So if I were

00:24:55.639 --> 00:25:03.779
to say ':'.join(a), what it does is it just
puts it all together in one string just in

00:25:03.779 --> 00:25:09.549
one step. And so it's a little unintuitive
but actually the case I most use--use most

00:25:09.549 --> 00:25:16.609
often is backslash n; like I say new line,
dot join, and then really I've now got one

00:25:16.609 --> 00:25:19.429
per line but just all in one step. And then
I can just print that in one step or, you

00:25:19.429 --> 00:25:23.029
know, write it to a file or whatever. So that
is a handy one to know. I'll switch back to

00:25:23.029 --> 00:25:29.460
the colon 1. So going in the other direction,
there's also a split. So actually here, I'll

00:25:29.460 --> 00:25:35.539
say b is equal to that so now b is the string
I'll put together. If I say, ':'.split(b)--oops,

00:25:35.539 --> 00:25:50.970
was that wrong? Oh, I'm sorry, no, it's the
other way. Sorry, b.split(':') so you have

00:25:50.970 --> 00:25:56.659
a string, you called dot split and you say
here is essentially the delimiter. Then it

00:25:56.659 --> 00:26:01.220
kind of explodes it out so you can recover
the original list. So split out either--you

00:26:01.220 --> 00:26:05.529
know these are really not actually deep but
this just happens to be a common case. So

00:26:05.529 --> 00:26:09.679
those are handy to know. Oh, I should mention,
those are not regular expressions; those are

00:26:09.679 --> 00:26:10.679
just substrings. We'll do regular expressions
tomorrow. Yes, question?

00:26:10.679 --> 00:26:14.100
&gt;&gt; Can you talk about something really simple
which is like, what if you were going through

00:26:14.100 --> 00:26:21.570
a list of data and you're making a list. Maybe
here you are just defining this but

00:26:21.570 --> 00:26:24.429
&gt;&gt; PARLANTE: Yes, yes. Yes, here, so let's
do a little example like that, yes. So the

00:26:24.429 --> 00:26:29.239
question is how do you kind of make a list,
yes. So one pattern that shows up in the exercises

00:26:29.239 --> 00:26:33.190
is like let's say I've got "a" here and I
want to loop through this and I want to--I

00:26:33.190 --> 00:26:36.490
want to pick out some of them and put them
on some other list. A pattern might be like

00:26:36.490 --> 00:26:41.789
this where I'll say a result is equal to the
empty list and then I'll say something like

00:26:41.789 --> 00:26:47.019
for s in a: and I going to kind of--I want
to add some of them to the results or whatever.

00:26:47.019 --> 00:26:50.889
The way you would do that, I'll just add them
all in this case but I'm going to loop through

00:26:50.889 --> 00:26:56.139
it. I want to put some of this. I would just
use append so I'd say result.append(s) in

00:26:56.139 --> 00:27:02.229
this case. So now if I look at results, I
mean, essentially what I've done is I've just

00:27:02.229 --> 00:27:06.440
copied all this over. So in terms of--that
is a common pattern. You start with empty

00:27:06.440 --> 00:27:16.220
list and you kind of put some stuff in it.
&gt;&gt; I guess, like let's say you're our data

00:27:16.220 --> 00:27:17.220
or whatever, you don't have any list and your'e
starting your for loop...

00:27:17.220 --> 00:27:18.289
&gt;&gt; PARLANTE: Yes, yes. So the question is,
yes, what if you have documents, I mean, what

00:27:18.289 --> 00:27:21.970
you are getting at is realistic. The trick
is I'm going to show you how to open files

00:27:21.970 --> 00:27:25.360
and read text out of it and then I think at
that moment I'll answer that question. But,

00:27:25.360 --> 00:27:29.309
yes, thus far, I'm just doing list a little
bit. You know, I haven't gotten to that yet.

00:27:29.309 --> 00:27:35.559
All righty, so the last thing I'll show you
is just for completeness; I haven't showed

00:27:35.559 --> 00:27:40.890
you like a traditional for loop like i equal
zero one to the--you know, like in C or java

00:27:40.890 --> 00:27:44.799
script, you might do that all the time. Mostly,
the ones I've shown you, these techniques

00:27:44.799 --> 00:27:52.019
just cover it. However, there--I will show
you how--if you want to count a bunch of numbers,

00:27:52.019 --> 00:27:58.720
the way to do that is there is a function
called range. And what range does is it sort

00:27:58.720 --> 00:28:04.349
of on--if I say range 20 it's sort of on the
fly appears to build this list, starting at

00:28:04.349 --> 00:28:09.299
zero and running up to but not including that
number. So, if you want to count from, you

00:28:09.299 --> 00:28:13.769
know, zero to nineteen, you could say for
i in and then call range to kind of on the

00:28:13.769 --> 00:28:18.119
fly make this list appear, and so that would
be a way. Now, there is a little bit of difference

00:28:18.119 --> 00:28:23.499
between Python 2, 4 and Python 3, whether
that list is really created in memory or is

00:28:23.499 --> 00:28:28.389
it fake-created. The more modern version is
just fake-created or you know which saves

00:28:28.389 --> 00:28:33.529
memory. So you can--you should not worry about
that efficiency detail because the more modern

00:28:33.529 --> 00:28:37.359
versions are just all over it. Now, I have
shown you just the most simple case of calling

00:28:37.359 --> 00:28:42.609
range where you give it one argument but in
fact you can specify the starting number and

00:28:42.609 --> 00:28:47.320
the end number and should it go by fives,
all those kinds of permutations range supports

00:28:47.320 --> 00:28:50.830
when you give it more optional arguments.
And so if you want to generate a series of

00:28:50.830 --> 00:28:56.250
numbers, that would be the way to do it. There
is also a while loop which now I'm just going

00:28:56.250 --> 00:29:00.749
to demonstrate but yes, it works like while
loops in other languages. The most common

00:29:00.749 --> 00:29:03.779
case though is the one I've showed you, just
the for loop to loop over our question. Last

00:29:03.779 --> 00:29:07.179
thing I'll have to say about the for loop
is that it does have this constraint which

00:29:07.179 --> 00:29:13.740
is when you are looping over a list, you cannot
modify that list in a way which changes its

00:29:13.740 --> 00:29:17.239
length or structure. So you can't add an element--it
kind of makes sense, if you add an element

00:29:17.239 --> 00:29:21.960
in the loop, you could kind of get this weird
infinite structure. So do not modify while

00:29:21.960 --> 00:29:26.380
iterating over. Incidentally, Java has that
same constraint, sort of, based on--there

00:29:26.380 --> 00:29:31.739
is an implementation reality underneath there.
All righty, so we are almost ready for another

00:29:31.739 --> 00:29:41.809
exercise. The last thing I want to show you
is the tuple. So, I showed you strings surrounded

00:29:41.809 --> 00:29:47.980
by quotes, lists surrounded by curly braces.
The tuple is actually--it's a modest little

00:29:47.980 --> 00:29:58.720
data structure and it looks like this. Tuple
is put in parenthesis and has commas inside

00:29:58.720 --> 00:30:04.471
to separate the elements. So a tuple--now
a list can grow and shrink, right? It can

00:30:04.471 --> 00:30:07.909
start as length zero and I can append, put
stuff in there, delete, whatever. The tuple

00:30:07.909 --> 00:30:13.099
is fixed-sized. You create it length three,
it's length three forever. In fact, it's immutable.

00:30:13.099 --> 00:30:19.960
You just can't change it. So what--the tuple
is good if you have some fixed number of items.

00:30:19.960 --> 00:30:24.740
Like let's say you want to store an x, y,
z coordinate in three dimensional space, right,

00:30:24.740 --> 00:30:27.850
there's never going to be a fourth number.
You know it's just these three, I want to

00:30:27.850 --> 00:30:34.750
lock them together. Tuples are good for that.
Or let's say you have a URL and a score and

00:30:34.750 --> 00:30:38.659
it's these two things so, like, I want these
two things to go together. In Python, you

00:30:38.659 --> 00:30:43.559
can put those on a tuple length 2 and store
that on a list or return it from a function

00:30:43.559 --> 00:30:48.230
or whatever. So the tuple is the kind of anonymous
way of taking a fixed number of things and

00:30:48.230 --> 00:30:52.250
just kind of locking them together so you
can pass them around or store them or whatever.

00:30:52.250 --> 00:30:58.629
So the--and in the later exercises, you'll
see some examples of this. So I'll sign a

00:30:58.629 --> 00:31:03.909
to this tuple I guess. And then kind of like
you could guess, I'll make this claim that

00:31:03.909 --> 00:31:08.669
Python is all consistent. So how do suppose
you tell the length of a tuple? Of course,

00:31:08.669 --> 00:31:14.009
it's len, right? And how do you pick an element
out? Yes, it's square bracket. So all that

00:31:14.009 --> 00:31:17.429
stuff list, strings, you know, pretty much
works for tuples as well. The one difference

00:31:17.429 --> 00:31:22.779
is the tuple is immutable. So if I say a square
bracket zero equals 13, I try to sign into

00:31:22.779 --> 00:31:27.889
it, that's going to fail, right? So the tuple
can't be changed. Once you create it, it's

00:31:27.889 --> 00:31:38.379
like a string. So tuples and strings, immutable;
lists, mutable. There was a question earlier

00:31:38.379 --> 00:31:49.019
about sorting. And it turns out, if you want
to sort by one thing and then sort by another

00:31:49.019 --> 00:31:55.229
thing, the best way to do that is with tuples.
And so I think I can do a short example here

00:31:55.229 --> 00:32:06.210
so I'll say 1, comma, a, comma, so this is--I'm
making a list of tuples here. Oops, okay,

00:32:06.210 --> 00:32:14.669
let's make that b and then here we'll make
this 2, comma, a. So, the way it's going to

00:32:14.669 --> 00:32:20.049
work is if you sort tuples, just the natural
under-the-hood sorting, what it does is it

00:32:20.049 --> 00:32:23.539
first compares the first elements of the tuples.
And if they're different, it just sorts by

00:32:23.539 --> 00:32:29.009
that. But if those elements are the same then
it goes to the next one. So here, and I need

00:32:29.009 --> 00:32:37.299
to make this--and I would just say 1a. All
right, so what I've made is a list of tuples.

00:32:37.299 --> 00:32:44.909
And to show this off, I think if I do sorted
on that, where the first number are the same,

00:32:44.909 --> 00:32:49.570
it goes to the second, right. So in the two
1 cases, then it is sorted by a b and then

00:32:49.570 --> 00:32:54.739
this one is last. So that is a little bit
of a detail. It's not something--I haven't

00:32:54.739 --> 00:32:59.519
planned on mentioning this but for the question
back here, if you want to sort on one thing

00:32:59.519 --> 00:33:04.879
and then sort by something else, what you
can do is write your key function to return

00:33:04.879 --> 00:33:10.239
a tuple. And then in--by whatever you put
in that tuple, you can get the behavior you

00:33:10.239 --> 00:33:13.619
want, you know, put the thing you want to
sort on first, that's the first thing, and

00:33:13.619 --> 00:33:16.450
then a comma and whatever the second thing
is and it will just go automatically go to

00:33:16.450 --> 00:33:20.899
the second thing if the first thing is the
same. And that is just built-in Python sorting,

00:33:20.899 --> 00:33:26.099
like it gets how to sort tuples that way.
All righty, so one other thing I have to show

00:33:26.099 --> 00:33:29.972
you with tuples, this is kind of, dare I say,
kind of a Perl, I think it is sort of a Perl

00:33:29.972 --> 00:33:36.609
feature is that if you say (x, y), there's
a special thing with assignment and variables,

00:33:36.609 --> 00:33:44.719
if you say (x, y) in tuple equals (1, 2),
what it does is kind of a parallel assignment.

00:33:44.719 --> 00:33:55.080
So now, x, x is 1 and y is 2, not super common
thing to use but it does show up now and then.

00:33:55.080 --> 00:34:01.249
The--okay, now, there's more stuff though
I'll show you later about that. All righty,

00:34:01.249 --> 00:34:07.259
so what we've seen really at this point, so
let's take in, is list, how to loop over them

00:34:07.259 --> 00:34:11.790
and dot append or whatever and sorting and
a little bit about tuples. So what I would

00:34:11.790 --> 00:34:18.899
like you to do is take a look at the exercise.
I'm sorry, question?

00:34:18.899 --> 00:34:27.240
&gt;&gt; Yes, does slicing work with tuples?
&gt;&gt; PARLANTE: Yes, slicing works with tuples.

00:34:27.240 --> 00:34:32.510
So what I would like you to do is take a look
at the exercise list 1 dot P Y. This is going

00:34:32.510 --> 00:34:39.309
to involve doing basic stuff with lists and
also a little bit of custom sorting. As before,

00:34:39.309 --> 00:34:42.649
if you are just so unbelievably fast that
you finish those then there's a list dot 2

00:34:42.649 --> 00:34:46.250
dot P Y. But mostly, I'm just hoping people
can, you know, get at least some of the problems

00:34:46.250 --> 00:34:50.770
done in list 1 dot P Y. And what I'd like
you to do is work on that, say, for half an

00:34:50.770 --> 00:34:56.790
hour. So I'm going to pull you guys back here
at 2:20. I'll do one more lecture and then

00:34:56.790 --> 00:35:00.660
we'll have significantly bigger exercise till
I finish out the afternoon. Okay, so, off

00:35:00.660 --> 00:35:01.400
with coding.

