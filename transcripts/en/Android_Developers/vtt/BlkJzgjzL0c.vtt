WEBVTT
Kind: captions
Language: en

00:00:02.590 --> 00:00:04.030
ADAM POWELL: Hi there.

00:00:04.030 --> 00:00:07.250
So as Dave said, we're always
a little bit more personable

00:00:07.250 --> 00:00:08.000
right after lunch.

00:00:08.000 --> 00:00:10.629
We're also a little bit more
excitable right after coffee.

00:00:10.629 --> 00:00:12.170
So you're catching
us at a good time.

00:00:12.170 --> 00:00:13.960
YIGIT BOYAR: Yeah,
just had coffee.

00:00:13.960 --> 00:00:15.510
ADAM POWELL: So this talk
is about Android application

00:00:15.510 --> 00:00:16.104
architecture.

00:00:16.104 --> 00:00:16.770
I'm Adam Powell.

00:00:16.770 --> 00:00:18.870
I'm on the Android
framework team.

00:00:18.870 --> 00:00:19.270
YIGIT BOYAR: I'm Yigit Boyar.

00:00:19.270 --> 00:00:20.890
I'm also in the
Android framework team.

00:00:20.890 --> 00:00:22.010
ADAM POWELL: So this
is actually going

00:00:22.010 --> 00:00:23.770
to be a little bit of a
special extended edition

00:00:23.770 --> 00:00:26.186
version of a talk that we gave
earlier this year at Google

00:00:26.186 --> 00:00:28.150
I/O. And just like every
good special edition,

00:00:28.150 --> 00:00:30.160
the original version
isn't available on video.

00:00:30.160 --> 00:00:32.420
So here you are.

00:00:32.420 --> 00:00:35.360
So the important thing about
application architecture

00:00:35.360 --> 00:00:38.580
is, really, you need to act
early in your applications.

00:00:38.580 --> 00:00:40.250
As soon as you
start writing code,

00:00:40.250 --> 00:00:41.750
you've made these
decisions that are

00:00:41.750 --> 00:00:44.112
going to affect how your
application is going to be

00:00:44.112 --> 00:00:45.320
developed from there forward.

00:00:48.610 --> 00:00:51.639
So those decisions
stick with you.

00:00:51.639 --> 00:00:53.930
These really, really deeply
influence your application.

00:00:53.930 --> 00:00:56.120
And we're going to show
you a few of the ways

00:00:56.120 --> 00:00:58.280
that this really affects
how you might write

00:00:58.280 --> 00:01:00.360
your app as you move forward.

00:01:00.360 --> 00:01:02.040
It really makes it
easier or harder

00:01:02.040 --> 00:01:04.300
to think about the problems
that you're really setting

00:01:04.300 --> 00:01:06.860
to solve in your application.

00:01:06.860 --> 00:01:09.876
So you might be asking, OK,
well, which patterns do I use?

00:01:09.876 --> 00:01:11.250
There's a lot of
stuff out there.

00:01:11.250 --> 00:01:14.870
And you can really get
into a lot of alphabet soup

00:01:14.870 --> 00:01:18.170
as you start looking over all
of the different prescriptive

00:01:18.170 --> 00:01:19.930
patterns that you
can look into--

00:01:19.930 --> 00:01:21.304
YIGIT BOYAR: I'm super confused.

00:01:21.304 --> 00:01:23.720
ADAM POWELL: Yeah, I mean,
I've got all these things here.

00:01:23.720 --> 00:01:25.778
YIGIT BOYAR: That's
me, by the way.

00:01:25.778 --> 00:01:29.350
That's me, this cartoon.

00:01:29.350 --> 00:01:31.580
ADAM POWELL: So this isn't
a survey of libraries.

00:01:31.580 --> 00:01:34.190
That's not what we're
here to talk about today.

00:01:34.190 --> 00:01:36.450
There really are a lot of
great libraries out there.

00:01:36.450 --> 00:01:38.283
And you should really
look into many of them

00:01:38.283 --> 00:01:40.420
and see what they
can do for you.

00:01:40.420 --> 00:01:42.320
And the trends change quickly.

00:01:42.320 --> 00:01:44.820
The challenges you're going
to face are really timeless.

00:01:44.820 --> 00:01:47.430
The properties of some of these
devices that we're writing for

00:01:47.430 --> 00:01:50.780
have been the same properties
from the first time

00:01:50.780 --> 00:01:53.210
any one of us held a smartphone.

00:01:53.210 --> 00:01:55.720
And really, lava flow
happens over time.

00:01:55.720 --> 00:01:57.810
This is kind of this
phenomenon where,

00:01:57.810 --> 00:02:00.690
after your code goes through
a number of refactorings,

00:02:00.690 --> 00:02:02.940
there isn't really kind of
an overarching principle

00:02:02.940 --> 00:02:04.450
that ties it all
together anymore.

00:02:04.450 --> 00:02:06.556
Someone new who comes
to your code base

00:02:06.556 --> 00:02:08.139
may or may not
understand what's going

00:02:08.139 --> 00:02:11.030
on as you start piling up
all of these different pieces

00:02:11.030 --> 00:02:14.490
that really no
longer fit together.

00:02:14.490 --> 00:02:16.840
The important takeaway
from this is to architect

00:02:16.840 --> 00:02:18.640
for user experience.

00:02:18.640 --> 00:02:21.070
Really, nobody in
your user base is

00:02:21.070 --> 00:02:23.360
going to care exactly
what patterns you used

00:02:23.360 --> 00:02:24.830
to produce your application.

00:02:24.830 --> 00:02:27.205
They're going to care about
the experience that they have

00:02:27.205 --> 00:02:29.850
while they've got
it in their hand.

00:02:29.850 --> 00:02:33.527
YIGIT BOYAR: All right, so
let's look at some examples.

00:02:33.527 --> 00:02:34.360
There's some videos.

00:02:34.360 --> 00:02:36.430
So here's an application.

00:02:36.430 --> 00:02:37.700
It's very simple.

00:02:37.700 --> 00:02:41.310
I'm posting a comment on
a photo, trying to type.

00:02:41.310 --> 00:02:42.950
All right, there you go, Send.

00:02:42.950 --> 00:02:43.850
And I'm waiting.

00:02:43.850 --> 00:02:45.120
Why am I waiting?

00:02:45.120 --> 00:02:46.260
I have no idea.

00:02:46.260 --> 00:02:47.910
I'm just waiting, waiting.

00:02:47.910 --> 00:02:49.330
All right, it sent.

00:02:49.330 --> 00:02:53.120
So what was the problem here?

00:02:53.120 --> 00:02:55.700
So what's happening was, the
user clicks on the Send button.

00:02:55.700 --> 00:02:59.470
It goes to your controller,
goes to your network,

00:02:59.470 --> 00:03:02.430
network comes back whenever
it wants to come back.

00:03:02.430 --> 00:03:04.079
And then you update your UI.

00:03:04.079 --> 00:03:05.870
Meanwhile, you blocked
the user because you

00:03:05.870 --> 00:03:06.911
don't know what happened.

00:03:06.911 --> 00:03:08.850
Maybe the comment will not go.

00:03:08.850 --> 00:03:11.250
What if we get rid of
this, introduce something

00:03:11.250 --> 00:03:13.980
you can call a model, which
is your storage, which

00:03:13.980 --> 00:03:16.500
is where you keep your
comments and everything?

00:03:16.500 --> 00:03:18.960
So then when the user
hits the Send button,

00:03:18.960 --> 00:03:22.410
you keep it in your
model, update your UI,

00:03:22.410 --> 00:03:25.860
then tell the network
that this has been added.

00:03:25.860 --> 00:03:29.200
And when the network comes
back, you can update your UI.

00:03:29.200 --> 00:03:31.740
So let's look at the
same example, this time

00:03:31.740 --> 00:03:33.640
with the fix, how it looks.

00:03:33.640 --> 00:03:34.880
So I come here.

00:03:34.880 --> 00:03:37.710
I type my comment--
the same comment

00:03:37.710 --> 00:03:39.960
so you make sure it's
the same use case.

00:03:39.960 --> 00:03:41.410
I send it.

00:03:41.410 --> 00:03:42.600
I still see the comment.

00:03:42.600 --> 00:03:45.320
It's a little bit gray,
but I see it there.

00:03:45.320 --> 00:03:48.310
When the network finally
comes back, it turns black.

00:03:48.310 --> 00:03:49.850
User has a clue.

00:03:49.850 --> 00:03:51.440
You can design it better.

00:03:51.440 --> 00:03:52.480
I couldn't.

00:03:52.480 --> 00:03:55.570
But that's the idea.

00:03:55.570 --> 00:03:57.290
You give the feedback instantly.

00:03:57.290 --> 00:03:59.040
ADAM POWELL: Your
designers are wonderful.

00:03:59.040 --> 00:04:01.874
Make sure that you
appreciate them.

00:04:01.874 --> 00:04:04.290
YIGIT BOYAR: I told you, why
did you give me a design job?

00:04:06.980 --> 00:04:09.670
OK, let's look at one more demo.

00:04:09.670 --> 00:04:11.520
It's the same puppy.

00:04:11.520 --> 00:04:13.680
So I keep commenting
that I really like it.

00:04:13.680 --> 00:04:14.570
I keep commenting.

00:04:14.570 --> 00:04:18.279
And I hit Send.

00:04:18.279 --> 00:04:20.690
OK, you're going to see
that it's greyed out.

00:04:20.690 --> 00:04:22.329
I see the responses only.

00:04:22.329 --> 00:04:22.870
That's great.

00:04:22.870 --> 00:04:23.700
It turns black.

00:04:23.700 --> 00:04:24.580
That's great.

00:04:24.580 --> 00:04:26.110
I go back to that page again.

00:04:26.110 --> 00:04:26.790
It's empty.

00:04:26.790 --> 00:04:30.300
Like, I was here
literally two seconds ago.

00:04:30.300 --> 00:04:30.970
I came back.

00:04:30.970 --> 00:04:33.960
I come back to the page,
and it's not there.

00:04:33.960 --> 00:04:35.370
This is inconsistent.

00:04:35.370 --> 00:04:37.960
I feel like something got lost.

00:04:37.960 --> 00:04:40.750
So what was happening here?

00:04:40.750 --> 00:04:45.520
So the view controller, as we
said before, told the model,

00:04:45.520 --> 00:04:47.750
model told the
network, it came back,

00:04:47.750 --> 00:04:49.780
we updated the UI-- great.

00:04:49.780 --> 00:04:53.130
But the problem is the
model didn't have anything.

00:04:53.130 --> 00:04:57.380
It only is still
fed by the network.

00:04:57.380 --> 00:05:00.730
What if, instead, you
kept a persistent model?

00:05:00.730 --> 00:05:03.020
So the idea is that your
data stays on your client.

00:05:03.020 --> 00:05:04.880
There's something
that you can always

00:05:04.880 --> 00:05:08.000
access unless the phone crashes,
which-- you can't do anything

00:05:08.000 --> 00:05:09.210
in that case.

00:05:09.210 --> 00:05:11.320
Instead, we have some
application logic

00:05:11.320 --> 00:05:14.280
that is responsible
to synchronize network

00:05:14.280 --> 00:05:15.910
and your persistent model.

00:05:15.910 --> 00:05:18.230
It's really important
to look at this problem

00:05:18.230 --> 00:05:22.130
as a synchronization problem
rather than making API calls.

00:05:22.130 --> 00:05:23.330
That simplifies a lot.

00:05:23.330 --> 00:05:26.960
So this application logic
syncs with the network,

00:05:26.960 --> 00:05:28.790
fetches whatever
you want to fetch,

00:05:28.790 --> 00:05:31.700
updates the model, then just
notifies in the event-- OK,

00:05:31.700 --> 00:05:32.200
I'm done.

00:05:32.200 --> 00:05:33.760
I made some changes.

00:05:33.760 --> 00:05:36.660
Hey guys, if anybody wants to
know about it, here they are.

00:05:36.660 --> 00:05:39.550
And then your view
controller goes and fetches

00:05:39.550 --> 00:05:41.850
the data and updates the view.

00:05:41.850 --> 00:05:43.876
Let's say the user clicked
on the Send button.

00:05:43.876 --> 00:05:46.990
The view control tells the
application logic, OK, I

00:05:46.990 --> 00:05:48.020
have this comment.

00:05:48.020 --> 00:05:50.260
Please send it.

00:05:50.260 --> 00:05:52.087
The logic instantly
updates the disk.

00:05:52.087 --> 00:05:53.670
That's the first
thing you have to do.

00:05:53.670 --> 00:05:56.420
You update the local
storage and tell, hey,

00:05:56.420 --> 00:05:57.570
I updated this comment.

00:05:57.570 --> 00:05:58.930
I added this comment.

00:05:58.930 --> 00:06:01.720
And it also calls the network.

00:06:01.720 --> 00:06:03.570
Now, there's two things
going on right now.

00:06:03.570 --> 00:06:05.680
While you're making
the network query,

00:06:05.680 --> 00:06:07.590
the view controller
gets notified.

00:06:07.590 --> 00:06:10.180
OK, I have a new comment
to fetch, goes to model,

00:06:10.180 --> 00:06:11.630
update the UI.

00:06:11.630 --> 00:06:14.690
When the network finally
returns, the application logic

00:06:14.690 --> 00:06:16.920
updates the model
again and says, OK,

00:06:16.920 --> 00:06:18.760
I seek to comment to server.

00:06:18.760 --> 00:06:21.830
If anybody's inserted,
do something.

00:06:21.830 --> 00:06:25.280
And then the view controller
goes, updates the view again.

00:06:25.280 --> 00:06:28.230
So everybody has
very simple duties.

00:06:28.230 --> 00:06:30.960
And they are decoupled.

00:06:30.960 --> 00:06:34.230
So see how it looks when
we implement it properly.

00:06:34.230 --> 00:06:35.000
I come here.

00:06:35.000 --> 00:06:35.840
It's instant.

00:06:35.840 --> 00:06:38.110
Because it's coming
from the local storage.

00:06:38.110 --> 00:06:41.560
It cannot be slow unless
something is going really bad

00:06:41.560 --> 00:06:45.276
on your device, which
sometimes happens.

00:06:45.276 --> 00:06:53.800
All right, so one more
example-- OK, it's running.

00:06:53.800 --> 00:06:56.890
So I'm so excited that
I keep sending comments.

00:06:56.890 --> 00:06:58.940
But they're only seeing
the first comment I sent.

00:06:58.940 --> 00:07:02.035
Something is-- oh, OK,
they just showed up.

00:07:02.035 --> 00:07:03.410
ADAM POWELL: What
happened there?

00:07:03.410 --> 00:07:04.493
YIGIT BOYAR: I don't know.

00:07:04.493 --> 00:07:05.720
What happened there?

00:07:05.720 --> 00:07:08.390
Now I figure out
what happened there.

00:07:08.390 --> 00:07:09.540
So this was my background.

00:07:09.540 --> 00:07:11.860
Because I had this great
pool on the background

00:07:11.860 --> 00:07:13.750
that processes all
these things one by one

00:07:13.750 --> 00:07:15.730
so that I don't create
too many threads.

00:07:15.730 --> 00:07:18.950
So And I loaded the activity
to-- a fetch bitmap job

00:07:18.950 --> 00:07:22.280
came for the photo, and the
other one to load the comments

00:07:22.280 --> 00:07:23.480
from the disk.

00:07:23.480 --> 00:07:24.910
So I had two executors.

00:07:24.910 --> 00:07:25.840
They started running.

00:07:25.840 --> 00:07:29.100
Meanwhile, this user started
spamming my application

00:07:29.100 --> 00:07:31.930
with all these new comments.

00:07:31.930 --> 00:07:33.500
I finished it in the comments.

00:07:33.500 --> 00:07:34.440
The other one came.

00:07:34.440 --> 00:07:36.480
We put the comment in the disk.

00:07:36.480 --> 00:07:38.870
And now we are trying
to send it to servers.

00:07:38.870 --> 00:07:40.780
Meanwhile, the
network is really bad.

00:07:40.780 --> 00:07:43.640
So the fetch bitmap
job is still running.

00:07:43.640 --> 00:07:45.760
The view controller
got the notification

00:07:45.760 --> 00:07:48.780
about the new comment and
wanted to refresh itself.

00:07:48.780 --> 00:07:52.080
But the queue already is full.

00:07:52.080 --> 00:07:52.680
I'm using.

00:07:52.680 --> 00:07:55.000
And then the job cannot run.

00:07:55.000 --> 00:07:57.010
So the UI is not
updating because I'm

00:07:57.010 --> 00:07:58.770
trying to fetch a bitmap.

00:07:58.770 --> 00:07:59.370
This is bad.

00:07:59.370 --> 00:07:59.870
This is bad.

00:07:59.870 --> 00:08:02.210
That means the
priorities are not good.

00:08:02.210 --> 00:08:03.430
But it's very hard to know.

00:08:03.430 --> 00:08:05.290
You don't know how
long the job will take.

00:08:05.290 --> 00:08:07.790
You cannot estimate
it all the time.

00:08:07.790 --> 00:08:11.100
But what you can do is
separate these things.

00:08:11.100 --> 00:08:14.320
So if I have a different
queue for my network tasks,

00:08:14.320 --> 00:08:16.980
and a different queue
for my local tasks,

00:08:16.980 --> 00:08:20.080
when my network is
flaky, my application

00:08:20.080 --> 00:08:21.230
is still responsive.

00:08:21.230 --> 00:08:23.090
Because they are never affected.

00:08:23.090 --> 00:08:26.760
So if we're on
the same jobs that

00:08:26.760 --> 00:08:29.000
were on the previous
center, as you can see now,

00:08:29.000 --> 00:08:32.210
they're going into
different threads.

00:08:32.210 --> 00:08:33.809
And the local test
queue just keeps

00:08:33.809 --> 00:08:36.320
running because disk fine.

00:08:36.320 --> 00:08:38.835
Because we couldn't fetch the
bitmap, we couldn't update.

00:08:38.835 --> 00:08:40.460
We couldn't send the
comment to server.

00:08:40.460 --> 00:08:44.777
But who cares-- user
is still seeing it.

00:08:44.777 --> 00:08:47.850
And if we make the
changes, well, you

00:08:47.850 --> 00:08:49.980
see everything is sending.

00:08:49.980 --> 00:08:52.860
And as it gets time to
run the server jobs,

00:08:52.860 --> 00:08:54.720
we're seeing there
they're starting to turn

00:08:54.720 --> 00:08:57.069
black, from top, one by one.

00:08:57.069 --> 00:08:58.360
They will eventually be synced.

00:09:01.370 --> 00:09:04.370
So one of the feedbacks we
get after [INAUDIBLE] is, OK,

00:09:04.370 --> 00:09:06.640
but how does the
activity get notified?

00:09:06.640 --> 00:09:10.220
So activity is a very,
very simple state machine

00:09:10.220 --> 00:09:11.770
in this scenario.

00:09:11.770 --> 00:09:14.320
When it is created,
you set up your UI.

00:09:14.320 --> 00:09:16.170
That's all you do.

00:09:16.170 --> 00:09:19.050
When you start, you
register for the events

00:09:19.050 --> 00:09:20.160
you want to know about.

00:09:20.160 --> 00:09:21.970
And you load your data.

00:09:21.970 --> 00:09:25.210
This is how it ensures
that between restarts

00:09:25.210 --> 00:09:27.302
or whatever, if there
are some events you miss,

00:09:27.302 --> 00:09:28.260
you'll never miss them.

00:09:28.260 --> 00:09:30.050
Because the onStart,
you register

00:09:30.050 --> 00:09:33.040
and you refresh your data.

00:09:33.040 --> 00:09:36.585
And when an event comes,
just refresh your data.

00:09:36.585 --> 00:09:38.610
It's like the same
thing over and over.

00:09:38.610 --> 00:09:41.240
OnStop-- don't
refresh your data.

00:09:41.240 --> 00:09:43.170
You just unregister from events.

00:09:43.170 --> 00:09:44.880
So your life cycle
is very simple.

00:09:44.880 --> 00:09:46.135
Like, this happens, I do this.

00:09:46.135 --> 00:09:47.134
This happens, I do this.

00:09:47.134 --> 00:09:50.520
This makes it easier to
test, much more stable, much

00:09:50.520 --> 00:09:52.980
more easier to understand.

00:09:52.980 --> 00:09:54.340
OK, back to you, Adam.

00:09:54.340 --> 00:10:00.330
ADAM POWELL: All right, so the
key takeaway from all the demo

00:10:00.330 --> 00:10:02.280
that we just saw
there was, really, you

00:10:02.280 --> 00:10:04.320
need to design for offline.

00:10:04.320 --> 00:10:07.190
Always assume that the
network is not your friend.

00:10:07.190 --> 00:10:08.510
It's going to be slow.

00:10:08.510 --> 00:10:11.145
And if you want to deliver
a good user experience,

00:10:11.145 --> 00:10:13.520
you really can't just blame
the network for why something

00:10:13.520 --> 00:10:14.690
isn't popping in quickly.

00:10:14.690 --> 00:10:16.170
The table stakes
have really been

00:10:16.170 --> 00:10:19.500
raised on this when
it comes to mobile.

00:10:19.500 --> 00:10:23.700
So to solve this, back
your UI with a local model

00:10:23.700 --> 00:10:25.280
and use your other
application logic

00:10:25.280 --> 00:10:27.750
to sync the model and
server rather than doing

00:10:27.750 --> 00:10:29.420
this as live API calls.

00:10:29.420 --> 00:10:32.540
It can be really tempting to
try to optimize for the case

00:10:32.540 --> 00:10:35.344
where you want data freshness
above all else, where you

00:10:35.344 --> 00:10:37.260
really don't want to
show anything to the user

00:10:37.260 --> 00:10:39.430
unless you're really,
really sure about it.

00:10:39.430 --> 00:10:41.160
But this is one of
those things where,

00:10:41.160 --> 00:10:44.930
if you assume success
versus assuming failure,

00:10:44.930 --> 00:10:48.672
then what types of claims
are you really making

00:10:48.672 --> 00:10:50.130
about your software
when you assume

00:10:50.130 --> 00:10:52.120
failure in the common case?

00:10:52.120 --> 00:10:54.090
I mean, your software
is going to work, right?

00:10:54.090 --> 00:10:56.150
Your server is going to
come back with the answer

00:10:56.150 --> 00:10:57.620
that you expected, right?

00:10:57.620 --> 00:10:58.990
So optimize for those cases.

00:10:58.990 --> 00:10:59.850
Predict it.

00:10:59.850 --> 00:11:02.149
Show it to the user early.

00:11:02.149 --> 00:11:04.190
YIGIT BOYAR: By the way,
I just learned yesterday

00:11:04.190 --> 00:11:07.890
there's is a fancy new name
called optimistic rendering.

00:11:07.890 --> 00:11:11.290
I feel like now it is
called optimistic rendering.

00:11:11.290 --> 00:11:14.429
ADAM POWELL: Yeah,
you see this principle

00:11:14.429 --> 00:11:16.720
at work in a lot of other
areas of software development

00:11:16.720 --> 00:11:17.220
as well.

00:11:17.220 --> 00:11:19.580
Games is one really
prominent example

00:11:19.580 --> 00:11:22.720
where a lot of network
latency compensation

00:11:22.720 --> 00:11:25.940
systems in multiplayer games
are based on this principle.

00:11:25.940 --> 00:11:28.380
They predict based
on what happened

00:11:28.380 --> 00:11:31.010
in the previous known
state from the network.

00:11:31.010 --> 00:11:35.800
So you can use these same
ideas in your own apps.

00:11:35.800 --> 00:11:38.910
So make sure that these
things don't necessarily

00:11:38.910 --> 00:11:41.630
depend on each other unless
it's in a very loose fashion.

00:11:41.630 --> 00:11:43.040
Use events and
callbacks and such

00:11:43.040 --> 00:11:45.382
when needed to notify
other parts of your system

00:11:45.382 --> 00:11:46.590
about a state that's changed.

00:11:50.710 --> 00:11:53.200
So everybody always asks us
about dependency injection

00:11:53.200 --> 00:11:53.820
as well.

00:11:53.820 --> 00:11:54.360
Is it good?

00:11:54.360 --> 00:11:55.270
Is it bad?

00:11:55.270 --> 00:11:56.107
What should I use?

00:11:56.107 --> 00:11:57.190
What library should I use?

00:11:57.190 --> 00:11:59.130
Well, I mean, use
it if it helps.

00:11:59.130 --> 00:12:00.670
Everything has a cost.

00:12:00.670 --> 00:12:03.609
So know the side effects of
what it is that you're doing

00:12:03.609 --> 00:12:05.150
and what it is that
you're including.

00:12:05.150 --> 00:12:07.280
It's very, very easy to
include a new dependency

00:12:07.280 --> 00:12:08.310
in your application.

00:12:08.310 --> 00:12:10.560
And it's not always easy to
see what the costs of that

00:12:10.560 --> 00:12:12.430
are going to be at run time,
especially when you're just

00:12:12.430 --> 00:12:13.770
bench testing at your desk.

00:12:13.770 --> 00:12:16.228
Everything is in the optimal
case when you're sitting there

00:12:16.228 --> 00:12:17.220
at your desk.

00:12:17.220 --> 00:12:20.950
So avoid reflection for
better performance as well.

00:12:20.950 --> 00:12:22.860
Many dependency
injection frameworks

00:12:22.860 --> 00:12:25.550
have a heavy runtime component
versus a compile time

00:12:25.550 --> 00:12:26.170
component.

00:12:26.170 --> 00:12:28.641
Some systems like Dagger
2 do this at compile time,

00:12:28.641 --> 00:12:31.140
and it ends up being much more
optimal for your application.

00:12:31.140 --> 00:12:33.530
So take a look into these and
see what the tradeoffs are.

00:12:36.180 --> 00:12:39.680
When it comes to networking,
so we talked about other things

00:12:39.680 --> 00:12:40.320
that we can do.

00:12:40.320 --> 00:12:44.480
Always assume the network
is going to be slow, janky.

00:12:44.480 --> 00:12:46.610
Always assume that
you've got your phone

00:12:46.610 --> 00:12:48.760
in the middle of a conference
with a crowded Wi-Fi

00:12:48.760 --> 00:12:50.930
and completely
slammed cell towers.

00:12:50.930 --> 00:12:53.730
That's basically your case that
you want to optimize for here.

00:12:53.730 --> 00:12:55.896
Because this is when people
are going to notice that

00:12:55.896 --> 00:12:57.920
your application is
broken when it falls over.

00:12:57.920 --> 00:13:00.210
So your API design
at the network layer

00:13:00.210 --> 00:13:02.540
can actually affect
this as well.

00:13:02.540 --> 00:13:05.700
So design your back end for
your client, not the other way

00:13:05.700 --> 00:13:06.556
around.

00:13:06.556 --> 00:13:09.180
And this is one of those things
that sounds really obvious when

00:13:09.180 --> 00:13:10.470
you get up here and say it.

00:13:10.470 --> 00:13:13.784
But as you start building server
back ends for these things,

00:13:13.784 --> 00:13:15.200
you start exposing
pieces that you

00:13:15.200 --> 00:13:16.820
may need, so on and so forth.

00:13:16.820 --> 00:13:20.210
And really you start building
it up as a series of layers.

00:13:20.210 --> 00:13:22.970
So you have the very
low level components

00:13:22.970 --> 00:13:24.804
that provide your data,
such as the network.

00:13:24.804 --> 00:13:26.678
And then you have the
higher level components

00:13:26.678 --> 00:13:28.010
that provide the presentation.

00:13:28.010 --> 00:13:30.830
And it's very tempting to not
have the higher levels inform

00:13:30.830 --> 00:13:32.180
the design of the lower levels.

00:13:32.180 --> 00:13:35.280
But you can get a lot
of wins by doing this.

00:13:35.280 --> 00:13:37.630
Also, process as much
as you can on the server

00:13:37.630 --> 00:13:38.590
side to begin with.

00:13:38.590 --> 00:13:39.992
You have these
big, beefy servers

00:13:39.992 --> 00:13:41.950
in the cloud that can do
a lot of work for you.

00:13:41.950 --> 00:13:46.430
Don't offload stuff to the
client that you don't have to.

00:13:46.430 --> 00:13:49.430
More specifically, pass
metadata to the client.

00:13:49.430 --> 00:13:51.900
This is something that
can really, really improve

00:13:51.900 --> 00:13:52.930
your user experience.

00:13:52.930 --> 00:13:55.520
If you have a
large blob of data,

00:13:55.520 --> 00:13:58.220
such as a big photo, that
you're going to pull down

00:13:58.220 --> 00:14:02.330
as part of syncing some sort
of social app, for example,

00:14:02.330 --> 00:14:04.230
what do you know about
this image at the time

00:14:04.230 --> 00:14:07.640
that you've made this request
and gotten this response back?

00:14:07.640 --> 00:14:08.910
Well, not a whole lot.

00:14:08.910 --> 00:14:11.285
So what are you going to show
while that loads, while you

00:14:11.285 --> 00:14:13.389
actually go fetch that image?

00:14:13.389 --> 00:14:15.430
A better case would be to
pass along a little bit

00:14:15.430 --> 00:14:16.570
more metadata.

00:14:16.570 --> 00:14:19.741
Give your application some
hints that it needs to succeed.

00:14:19.741 --> 00:14:21.740
In this case, we're passing
the width and height

00:14:21.740 --> 00:14:25.250
of this image in advance before
we go fetch the image itself.

00:14:25.250 --> 00:14:28.300
This allows us to perfectly
size a placeholder in our UI

00:14:28.300 --> 00:14:31.030
so that you don't have your
UI jumping back and forth

00:14:31.030 --> 00:14:32.980
as the user scrolls
through or attempts

00:14:32.980 --> 00:14:34.910
to move back and forth.

00:14:34.910 --> 00:14:36.910
We've also passed along
some palette information

00:14:36.910 --> 00:14:40.100
here just to be able to give
our UI a little bit more

00:14:40.100 --> 00:14:43.170
of a splash of color that
keeps the flavor of the image

00:14:43.170 --> 00:14:45.180
before we actually
have the real bits.

00:14:48.250 --> 00:14:50.021
Battery and data--
this is another concern

00:14:50.021 --> 00:14:52.270
that you've got whenever
you're talking to the network

00:14:52.270 --> 00:14:53.811
as well, especially
when you're doing

00:14:53.811 --> 00:14:55.390
any sort of background syncing.

00:14:55.390 --> 00:14:58.120
Batch your requests
as much as possible.

00:14:58.120 --> 00:15:00.070
Now, we've provided
a lot of other tools

00:15:00.070 --> 00:15:03.420
in recent versions of Android
to help you do this effectively.

00:15:03.420 --> 00:15:05.880
Things like Doze and
Marshmallow are great examples.

00:15:05.880 --> 00:15:07.970
Doze will do a lot
of this for you.

00:15:07.970 --> 00:15:10.930
But really, don't just rely
on that as your sole way

00:15:10.930 --> 00:15:11.890
of dealing with this.

00:15:11.890 --> 00:15:13.400
Doze is essentially
the last line

00:15:13.400 --> 00:15:15.160
of defense for the
user at this point.

00:15:15.160 --> 00:15:16.930
Use the job scheduler
when it makes sense.

00:15:16.930 --> 00:15:19.130
Give Android as much
information about what

00:15:19.130 --> 00:15:21.237
it is that your app is
actually trying to do.

00:15:21.237 --> 00:15:22.820
And that way, Android
can make smarter

00:15:22.820 --> 00:15:26.870
decisions about how
best to optimize that.

00:15:26.870 --> 00:15:30.700
The key takeaway here is
act locally, sync globally.

00:15:30.700 --> 00:15:34.100
You really want to give the user
a very fast, very responsive

00:15:34.100 --> 00:15:37.100
local experience whenever
they're using your application.

00:15:37.100 --> 00:15:39.950
And then make sure that you
keep that in sync with the cloud

00:15:39.950 --> 00:15:43.275
almost as an afterthought
compared with the presentation

00:15:43.275 --> 00:15:44.400
that you're trying to give.

00:15:46.797 --> 00:15:48.380
So no talk of
application architecture

00:15:48.380 --> 00:15:49.838
would be complete
without some sort

00:15:49.838 --> 00:15:53.320
of addressing of the question
of activities and fragments.

00:15:53.320 --> 00:15:56.610
This is something that we
constantly get questions about,

00:15:56.610 --> 00:15:57.810
even within Google.

00:15:57.810 --> 00:16:00.530
We'll get questions, like, OK,
well, should I use activities

00:16:00.530 --> 00:16:02.280
or should I use fragments
to build my app?

00:16:02.280 --> 00:16:04.790
It's like, well,
that doesn't entirely

00:16:04.790 --> 00:16:07.300
make a whole lot of
sense to question.

00:16:07.300 --> 00:16:09.250
Fragments are really
just encapsulated parts

00:16:09.250 --> 00:16:09.990
of an activity.

00:16:09.990 --> 00:16:13.441
So when you build
up your application,

00:16:13.441 --> 00:16:15.190
when your activity
starts getting too big,

00:16:15.190 --> 00:16:16.430
and you need to
start breaking it up

00:16:16.430 --> 00:16:18.340
so you can still think
about it effectively,

00:16:18.340 --> 00:16:20.631
it's a great time to break
it down into some fragments.

00:16:20.631 --> 00:16:23.207
Or if you start by building
single fragments that sort

00:16:23.207 --> 00:16:25.165
of compose together a
little bit more than that

00:16:25.165 --> 00:16:27.309
so that you keep your
concerns separated,

00:16:27.309 --> 00:16:29.100
that can help keep
things a little bit more

00:16:29.100 --> 00:16:30.475
straight in your
head so that you

00:16:30.475 --> 00:16:33.310
don't end up with these
giant activity god classes.

00:16:33.310 --> 00:16:35.880
Fragments and views is
another one that we get a lot.

00:16:35.880 --> 00:16:37.590
Now, this is
something that we talk

00:16:37.590 --> 00:16:39.360
about quite a bit on
the framework team

00:16:39.360 --> 00:16:41.890
in terms of, one of
the almost regrets

00:16:41.890 --> 00:16:43.710
of the fragment
API at this point

00:16:43.710 --> 00:16:46.130
is that you've got this handy
little tag that you can just

00:16:46.130 --> 00:16:48.070
stick in your layout that
says, fragment, and says,

00:16:48.070 --> 00:16:49.400
go ahead and
instantiate a fragment

00:16:49.400 --> 00:16:51.700
and stick it right here in
my layout when I inflate it.

00:16:51.700 --> 00:16:53.533
And this thing is really,
really convenient.

00:16:53.533 --> 00:16:55.430
It makes for great code
examples and demos,

00:16:55.430 --> 00:16:58.300
because you can do things
like have a layout that sticks

00:16:58.300 --> 00:16:59.630
two fragments side by side.

00:16:59.630 --> 00:17:02.820
And then you rotate the
device, and it sticks them

00:17:02.820 --> 00:17:04.252
stacked on top of one another.

00:17:04.252 --> 00:17:05.210
And you say, hey, look.

00:17:05.210 --> 00:17:07.430
Look at this great decoupled
system that I've got.

00:17:07.430 --> 00:17:10.329
It makes for fantastic demo.

00:17:10.329 --> 00:17:12.140
But realistically,
this makes people

00:17:12.140 --> 00:17:15.510
think of fragments as being
view constructs themselves.

00:17:15.510 --> 00:17:16.980
And really, they kind of aren't.

00:17:16.980 --> 00:17:19.839
So they live in these
very different worlds.

00:17:19.839 --> 00:17:22.310
So views are really the
nuts and bolts of your UIs

00:17:22.310 --> 00:17:24.930
that you're building, whereas
activities and fragments are

00:17:24.930 --> 00:17:27.069
the lifecycle constructs
that basically provide

00:17:27.069 --> 00:17:30.710
the plug-in points of contact
with the rest of the system

00:17:30.710 --> 00:17:33.880
that tells you what's going on.

00:17:33.880 --> 00:17:35.740
So many times,
you're going to want

00:17:35.740 --> 00:17:38.560
to use both to keep these
responsibilities clear.

00:17:38.560 --> 00:17:40.700
Just as Yigit mentioned
earlier, you're

00:17:40.700 --> 00:17:43.560
going to want to use
these signals that you

00:17:43.560 --> 00:17:46.990
get from your activity and,
in conjunction with that,

00:17:46.990 --> 00:17:50.560
through your fragments as
well, if you're using those,

00:17:50.560 --> 00:17:53.390
to basically inform when you
should register, unregister

00:17:53.390 --> 00:17:56.420
for events, so on and so forth.

00:17:56.420 --> 00:17:58.920
But the views should really be
their own encapsulated pieces

00:17:58.920 --> 00:18:00.503
separate from that
that are controlled

00:18:00.503 --> 00:18:01.630
by these other constructs.

00:18:04.320 --> 00:18:07.550
OK, so moving along to another
topic of contention often--

00:18:07.550 --> 00:18:09.280
memory.

00:18:09.280 --> 00:18:11.330
So this is something
that we talk about a lot.

00:18:11.330 --> 00:18:13.200
If you've watched
any of Colt's talks

00:18:13.200 --> 00:18:14.840
on the Android
performance practices,

00:18:14.840 --> 00:18:16.640
you've seen some of these.

00:18:16.640 --> 00:18:19.090
Avoid allocating objects
in hot code paths.

00:18:19.090 --> 00:18:21.300
Putting pressure on
the GC is not so great.

00:18:21.300 --> 00:18:23.210
Art is a lot better
at this these days

00:18:23.210 --> 00:18:25.670
than Android used to
be at all of this.

00:18:25.670 --> 00:18:28.050
But there's still a lot of
those devices out in the wild.

00:18:28.050 --> 00:18:31.220
And if you watch this in a
few sensitive code paths,

00:18:31.220 --> 00:18:33.200
then you're going to
end up with a little bit

00:18:33.200 --> 00:18:34.300
of a smoother experience.

00:18:34.300 --> 00:18:35.883
So you can pool and
reuse some objects

00:18:35.883 --> 00:18:37.160
when you measure a problem.

00:18:37.160 --> 00:18:38.910
That last part is
really the key--

00:18:38.910 --> 00:18:40.064
when you measure a problem.

00:18:40.064 --> 00:18:42.480
Make sure that you're measuring
these things before you go

00:18:42.480 --> 00:18:45.150
and contort the
internals of your system.

00:18:45.150 --> 00:18:48.036
And these are the sorts of
things where, some things, you

00:18:48.036 --> 00:18:49.660
can make some decisions
early that will

00:18:49.660 --> 00:18:52.260
help you move into
these optimizations

00:18:52.260 --> 00:18:53.410
should you need them.

00:18:53.410 --> 00:18:55.659
And some things, it
really doesn't matter.

00:18:55.659 --> 00:18:57.700
So write the code the way
that it's clearer first

00:18:57.700 --> 00:18:59.630
and then optimize later.

00:18:59.630 --> 00:19:01.721
So GC still kind of
remains your enemy,

00:19:01.721 --> 00:19:03.470
especially on some of
these older devices,

00:19:03.470 --> 00:19:05.886
even as the garbage collector
in Android gets much better.

00:19:09.195 --> 00:19:13.110
So a perfect example of how
this may affect your API design

00:19:13.110 --> 00:19:15.757
internally-- just with
smaller components.

00:19:15.757 --> 00:19:18.090
Now, what's the difference
between these two approaches?

00:19:18.090 --> 00:19:22.610
Well, the top one is arguably
more idiomatic, much cleaner.

00:19:22.610 --> 00:19:25.460
You can make some assumptions
about it in terms of, OK, well,

00:19:25.460 --> 00:19:27.980
the object it returns
is hopefully safe

00:19:27.980 --> 00:19:29.950
if that's a mutable
object to begin with.

00:19:29.950 --> 00:19:32.250
But in order for
that to be true, then

00:19:32.250 --> 00:19:34.890
this getter has to be
allocating a new rect for me

00:19:34.890 --> 00:19:35.870
that it returns.

00:19:35.870 --> 00:19:37.780
Well, now we've got allocation.

00:19:37.780 --> 00:19:40.480
So where do you
end up using that?

00:19:40.480 --> 00:19:43.970
Versus the second form here,
which is basically just taking

00:19:43.970 --> 00:19:46.694
an input parameter that the
method is going to fill out.

00:19:46.694 --> 00:19:48.110
You know that the
second one isn't

00:19:48.110 --> 00:19:51.082
going to perform any additional
allocation in this case.

00:19:51.082 --> 00:19:52.790
This is the sort of
thing that you really

00:19:52.790 --> 00:19:55.130
only want to worry about in
extremely hot code paths.

00:19:55.130 --> 00:19:58.010
We're talking layout that
gets run many, many times.

00:19:58.010 --> 00:20:01.022
We're talking drawing that
gets run 60 times per second.

00:20:01.022 --> 00:20:02.480
If you're talking
about things that

00:20:02.480 --> 00:20:04.104
happen in terms of
your event handlers,

00:20:04.104 --> 00:20:05.970
like clicks, and so
on, and so forth,

00:20:05.970 --> 00:20:08.160
you really don't need to
be contorting your system

00:20:08.160 --> 00:20:09.040
this much internally.

00:20:12.090 --> 00:20:15.180
But for that very small
percentage of your code,

00:20:15.180 --> 00:20:18.170
it is OK to write ugly code
if it helps your users.

00:20:18.170 --> 00:20:19.920
Your users are not
going to see your code.

00:20:19.920 --> 00:20:21.760
They're going to see your UI.

00:20:21.760 --> 00:20:24.880
If your UI is ugly because
it's behaving badly,

00:20:24.880 --> 00:20:26.520
then that's something
that they do see.

00:20:26.520 --> 00:20:30.570
That's something that really
does affect their experience.

00:20:30.570 --> 00:20:34.450
The performance critical code
really isn't the majority.

00:20:34.450 --> 00:20:37.040
And, well, all compiled code
looks ugly eventually anyways.

00:20:40.030 --> 00:20:42.320
So with that, we're
going to move over

00:20:42.320 --> 00:20:44.870
to another demo that kind of
brings a bunch of these ideas

00:20:44.870 --> 00:20:45.420
together.

00:20:45.420 --> 00:20:47.910
YIGIT BOYAR: OK, so
after the I/O talk,

00:20:47.910 --> 00:20:51.610
one of the feedbacks we received
was, OK, talk these things,

00:20:51.610 --> 00:20:54.570
but show me some code.

00:20:54.570 --> 00:20:56.930
So this time, we wrote
this sample application.

00:20:56.930 --> 00:20:59.240
Keep in mind, this is
a sample implication.

00:20:59.240 --> 00:21:01.910
And the main focus
here is, how do you

00:21:01.910 --> 00:21:04.450
look at this problem more as
a synchronization problem?

00:21:04.450 --> 00:21:06.970
How do you design an
application to work offline?

00:21:06.970 --> 00:21:10.080
And we are going to
release the source code.

00:21:10.080 --> 00:21:13.250
I'm just waiting
for some approvals.

00:21:13.250 --> 00:21:14.520
So here's my application.

00:21:14.520 --> 00:21:17.550
I just lost my Chrome.

00:21:17.550 --> 00:21:18.070
All right.

00:21:18.070 --> 00:21:19.320
Let's come here.

00:21:19.320 --> 00:21:20.570
So it's a real app.

00:21:20.570 --> 00:21:22.650
There is a real server
running on my computer

00:21:22.650 --> 00:21:25.680
just for the
purpose of the demo.

00:21:25.680 --> 00:21:29.780
And the application is
just a list of posts.

00:21:29.780 --> 00:21:31.310
Hello, everybody, I can say.

00:21:31.310 --> 00:21:33.050
I can say, everybody.

00:21:36.660 --> 00:21:37.870
So how does this work?

00:21:37.870 --> 00:21:40.110
So let's do something dangerous.

00:21:40.110 --> 00:21:42.490
And it's not that dangerous.

00:21:42.490 --> 00:21:45.060
I'll do more dangerous
things later.

00:21:45.060 --> 00:21:47.630
So I just disabled the network.

00:21:47.630 --> 00:21:51.640
And I send one more.

00:21:51.640 --> 00:21:55.370
So right now, please
forgive my UI.

00:21:55.370 --> 00:21:59.005
So there is an upload club
on the right bottom of text

00:21:59.005 --> 00:22:03.540
that tells the user, this is
not the same as other ones.

00:22:03.540 --> 00:22:05.080
It's almost going to send.

00:22:05.080 --> 00:22:07.190
It's not there yet,
so if I actually

00:22:07.190 --> 00:22:08.342
look at my real server.

00:22:08.342 --> 00:22:14.410
And my application, when
the network recovers,

00:22:14.410 --> 00:22:16.030
it will eventually post it.

00:22:16.030 --> 00:22:18.600
And it's going to update the UI.

00:22:18.600 --> 00:22:21.745
Now, with some other examples
we saw in the previous time--

00:22:21.745 --> 00:22:23.770
actually, we can
crash the server, too.

00:22:23.770 --> 00:22:25.566
So now the server is
not running anymore.

00:22:29.560 --> 00:22:33.270
So for this demo, I have a
very simple back off time.

00:22:33.270 --> 00:22:36.057
But it'll try back off.

00:22:36.057 --> 00:22:37.640
ADAM POWELL: I mean,
it does cry, too.

00:22:37.640 --> 00:22:38.800
YIGIT BOYAR: These are
my application-- yeah,

00:22:38.800 --> 00:22:39.780
it does cry too.

00:22:39.780 --> 00:22:41.537
These are my
application logs here.

00:22:41.537 --> 00:22:44.120
It actually keeps trying to post
it, because there is network.

00:22:44.120 --> 00:22:46.300
It's just the
server is crashing.

00:22:46.300 --> 00:22:51.870
And now I finally bring
the server up-- oops,

00:22:51.870 --> 00:22:55.930
not like that, not like that.

00:22:55.930 --> 00:22:59.860
OK, so it started backing off.

00:22:59.860 --> 00:23:02.097
It will eventually send
the comment to the server.

00:23:02.097 --> 00:23:02.680
It Dies there.

00:23:02.680 --> 00:23:04.250
It keeps retrying.

00:23:04.250 --> 00:23:06.060
And yes, it did send.

00:23:06.060 --> 00:23:11.298
So let's do one more case where
we do crash the server again.

00:23:15.190 --> 00:23:17.950
OK, one more comment--
it's the same.

00:23:17.950 --> 00:23:19.840
Oh wait, it didn't crash.

00:23:19.840 --> 00:23:21.205
Sorry, I crashed the logger.

00:23:24.530 --> 00:23:26.750
So we crashed the
server this time.

00:23:26.750 --> 00:23:28.150
See, the application works.

00:23:28.150 --> 00:23:30.420
ADAM POWELL: You wrote a server
that doesn't even crash right.

00:23:30.420 --> 00:23:31.670
Come on, what do we have here?

00:23:34.165 --> 00:23:36.540
YIGIT BOYAR: It should crash
for the purpose of the demo.

00:23:36.540 --> 00:23:38.490
I hope your servers won't crash.

00:23:38.490 --> 00:23:39.910
So I sent one more comment.

00:23:39.910 --> 00:23:43.510
And then I simply go out.

00:23:43.510 --> 00:23:45.310
So my emulator
may crash, though.

00:23:45.310 --> 00:23:47.630
It's been having some problems.

00:23:47.630 --> 00:23:49.340
I did go out.

00:23:49.340 --> 00:23:52.440
And I am going to
kill that application.

00:23:52.440 --> 00:23:53.210
I come back.

00:23:57.180 --> 00:23:59.910
OK, so the comment
is still there.

00:23:59.910 --> 00:24:02.410
It cannot update the feed, but
the comment is waiting for me

00:24:02.410 --> 00:24:03.390
there.

00:24:03.390 --> 00:24:05.165
And I will just run the server.

00:24:05.165 --> 00:24:06.890
The screen does
eventually synchronise.

00:24:06.890 --> 00:24:09.680
So the idea is the
application doesn't care

00:24:09.680 --> 00:24:10.860
about when the comment goes.

00:24:10.860 --> 00:24:13.650
It's staying in the disk
waiting to be uploaded.

00:24:13.650 --> 00:24:16.440
There is some other job that's
taking care of the upload.

00:24:16.440 --> 00:24:18.690
But it will eventually
go to server,

00:24:18.690 --> 00:24:21.170
unless I have a bug, of course.

00:24:21.170 --> 00:24:25.508
So how do we take
care of these things?

00:24:29.030 --> 00:24:34.329
The way it works is we
have this feed activity.

00:24:34.329 --> 00:24:36.245
By the way, again, this
is a demo application.

00:24:36.245 --> 00:24:37.828
I'm trying to focus
on certain things.

00:24:37.828 --> 00:24:41.010
There might be toerh problems
with this demo application.

00:24:41.010 --> 00:24:44.160
The important take away is the
thing we're focusing on here.

00:24:44.160 --> 00:24:47.650
So this application,
when you call Send Post,

00:24:47.650 --> 00:24:51.280
it simply tells the feed
controller to send the post.

00:24:51.280 --> 00:24:54.040
Which, as the job to
the disk-- there's

00:24:54.040 --> 00:24:56.770
something persistent
that will eventually run,

00:24:56.770 --> 00:24:58.810
which is responsible
to update the disk,

00:24:58.810 --> 00:25:01.820
as well as sending the post.

00:25:01.820 --> 00:25:03.590
So it updates the disk.

00:25:03.590 --> 00:25:05.480
And then this
[? pitches ?] an event.

00:25:05.480 --> 00:25:08.020
When this event is
this page, my activity

00:25:08.020 --> 00:25:10.930
knows about this event,
refreshes itself.

00:25:10.930 --> 00:25:13.710
When it runs, it
does the same thing.

00:25:13.710 --> 00:25:15.839
Or when it's cancelled,
it does the same thing.

00:25:15.839 --> 00:25:16.880
This is a persistent job.

00:25:16.880 --> 00:25:19.800
That means it's going
to be saved in the disk

00:25:19.800 --> 00:25:23.580
until it succeeds or
reaches the retry limit.

00:25:23.580 --> 00:25:24.580
They say, OK, all right.

00:25:24.580 --> 00:25:26.780
The comment is posted-- nice.

00:25:26.780 --> 00:25:29.230
And so another problem
about synchronization--

00:25:29.230 --> 00:25:33.050
what happens if I'm offline?

00:25:33.050 --> 00:25:33.775
Send comments.

00:25:36.890 --> 00:25:39.790
So it's not working, eventually.

00:25:39.790 --> 00:25:43.140
And I go to this website.

00:25:43.140 --> 00:25:44.800
And I create a comment here.

00:25:44.800 --> 00:25:45.920
I'm from the web.

00:25:53.450 --> 00:25:57.210
So now these two states
are inconsistent.

00:25:57.210 --> 00:25:59.960
My client doesn't know
about the new one.

00:25:59.960 --> 00:26:02.400
And I have a comment locally.

00:26:02.400 --> 00:26:04.270
So if I enable my
network-- by the way,

00:26:04.270 --> 00:26:06.220
normally, when the
network comes back,

00:26:06.220 --> 00:26:07.830
you would refresh your feed.

00:26:07.830 --> 00:26:10.680
But I'm not doing it for
the purpose of the demo.

00:26:10.680 --> 00:26:12.250
So when the network
comes back, it's

00:26:12.250 --> 00:26:15.190
going to send the
post instantly.

00:26:15.190 --> 00:26:16.740
So it's out of sync.

00:26:16.740 --> 00:26:18.573
But when I eventually
refresh, it's

00:26:18.573 --> 00:26:20.760
going to add anyone
to the correct order.

00:26:20.760 --> 00:26:23.600
This is because everything is
time stamped by the server.

00:26:23.600 --> 00:26:27.910
So until a post is
sent to the server,

00:26:27.910 --> 00:26:30.400
you make a best guess
time stamp on it.

00:26:30.400 --> 00:26:33.870
So for this example, the
way I do it is-- again,

00:26:33.870 --> 00:26:36.200
it may change per
your application.

00:26:36.200 --> 00:26:39.925
But the way this
one does is-- wait,

00:26:39.925 --> 00:26:41.050
let me open the [? safe ?].

00:26:43.720 --> 00:26:46.440
OK, so when it
creates, it actually

00:26:46.440 --> 00:26:51.630
creates the model to get
the best time stamp I have.

00:26:51.630 --> 00:26:55.140
This is a way to synchronize
if my client's time is, really,

00:26:55.140 --> 00:26:56.190
really off.

00:26:56.190 --> 00:26:59.810
And if the new comment is not on
top, that may look really bad.

00:26:59.810 --> 00:27:03.000
Because it changed your server
ordering, your UI ordering.

00:27:03.000 --> 00:27:04.850
But that may cause problems.

00:27:04.850 --> 00:27:10.580
So what I do here is I assign
a best case time stamp locally.

00:27:10.580 --> 00:27:12.314
And then we do it
on later on server.

00:27:16.140 --> 00:27:18.490
So we get the network again.

00:27:18.490 --> 00:27:21.840
And again, like another case,
because of the persistence,

00:27:21.840 --> 00:27:25.850
so I send the post here,
click on the usernames,

00:27:25.850 --> 00:27:27.730
moves it to the user's post.

00:27:27.730 --> 00:27:28.500
And it's done.

00:27:28.500 --> 00:27:31.154
I never fetched this user feed.

00:27:31.154 --> 00:27:32.070
But the post is there.

00:27:32.070 --> 00:27:33.486
It's everywhere
in my application.

00:27:33.486 --> 00:27:34.510
Because it's on my disk.

00:27:34.510 --> 00:27:36.710
I don't care if it
is not synced or not.

00:27:36.710 --> 00:27:38.340
I have a proper model
for that object.

00:27:38.340 --> 00:27:40.240
It's a simple value object.

00:27:40.240 --> 00:27:42.660
But it's always working.

00:27:42.660 --> 00:27:45.360
And let's say, I'm
in the user feed,

00:27:45.360 --> 00:27:46.680
but then recover the network.

00:27:49.310 --> 00:27:50.340
It will eventually send.

00:27:50.340 --> 00:27:51.940
And the feed will update, too.

00:27:51.940 --> 00:27:55.070
If I go back, it's already
updated here instantly.

00:27:55.070 --> 00:27:58.570
This is because if a UI is
interested in a certain event,

00:27:58.570 --> 00:27:59.900
it listens for it.

00:27:59.900 --> 00:28:03.872
Now, I'm using a
global event bus here.

00:28:03.872 --> 00:28:05.580
You can probably
implement the same thing

00:28:05.580 --> 00:28:07.906
with RX or Broadcase.

00:28:07.906 --> 00:28:10.030
This is a sample application
that does it this way,

00:28:10.030 --> 00:28:11.300
and it works.

00:28:11.300 --> 00:28:12.800
There might be
multiple ways to do

00:28:12.800 --> 00:28:16.330
the same thing, the right
thing, or maybe a better way.

00:28:16.330 --> 00:28:17.600
So we'll get more fancy.

00:28:17.600 --> 00:28:21.380
OK, what if the
server is crashing?

00:28:21.380 --> 00:28:23.150
So this is my real
server, by the way.

00:28:23.150 --> 00:28:24.125
It's a lot of fun.

00:28:24.125 --> 00:28:26.840
It's a magical language.

00:28:26.840 --> 00:28:30.240
So I'm going to
turn on a flag here.

00:28:30.240 --> 00:28:34.320
What this will do is the server
is going to save the post,

00:28:34.320 --> 00:28:36.730
but it's going to
crash afterwards.

00:28:36.730 --> 00:28:39.800
So I won't be able
to realize that I

00:28:39.800 --> 00:28:42.970
could synchronize that post.

00:28:42.970 --> 00:28:45.060
So the server is crashing now.

00:28:45.060 --> 00:28:47.250
I go back here.

00:28:47.250 --> 00:28:49.750
I can say, OK, [INAUDIBLE].

00:28:49.750 --> 00:28:52.470
So the job tries 20 times.

00:28:52.470 --> 00:28:56.420
And it backs off 250
milliseconds exponentially.

00:28:56.420 --> 00:28:59.280
So if will keep trying,
trying, trying, try me again.

00:29:03.520 --> 00:29:08.230
So now the server is crashing,
as you can see the crash logs.

00:29:08.230 --> 00:29:10.110
It saved the post to the disk.

00:29:10.110 --> 00:29:11.310
But the client doesn't know.

00:29:11.310 --> 00:29:13.180
So the client keeps retrying.

00:29:13.180 --> 00:29:16.410
But what happens is
that your fetch feeds

00:29:16.410 --> 00:29:18.220
post endpoint is working fine.

00:29:18.220 --> 00:29:20.130
So you refresh.

00:29:20.130 --> 00:29:21.590
So the post came back.

00:29:21.590 --> 00:29:22.930
I know it's the same post.

00:29:22.930 --> 00:29:24.430
So how do I know
it's the same post?

00:29:24.430 --> 00:29:26.900
This comes into a
little bit API design.

00:29:26.900 --> 00:29:29.240
But we want to do a full demo.

00:29:29.240 --> 00:29:31.860
So I did figure out it's the
same post and updated it.

00:29:31.860 --> 00:29:36.340
Although my sent posts
have never succeeded.

00:29:36.340 --> 00:29:38.420
So the way it works
in this application

00:29:38.420 --> 00:29:44.650
is, by design, each element
is assigned a client ID.

00:29:44.650 --> 00:29:47.614
So if you look at these examples
here-- are they visible?

00:29:47.614 --> 00:29:50.980
Yeah, all right, so
there's a user ID.

00:29:50.980 --> 00:29:52.350
And there's also a client ID.

00:29:52.350 --> 00:29:55.220
This client ID is
randomly generated

00:29:55.220 --> 00:29:58.530
a unique per user per post.

00:29:58.530 --> 00:30:00.720
So there is a unique
key in my [INAUDIBLE].

00:30:00.720 --> 00:30:02.270
It says user ID and client ID.

00:30:02.270 --> 00:30:03.690
It's a unique tuple.

00:30:03.690 --> 00:30:07.150
You rely on the fact that
it's not going to conflict.

00:30:07.150 --> 00:30:09.220
I mean, technically it can.

00:30:09.220 --> 00:30:10.900
Probably it won't.

00:30:10.900 --> 00:30:15.150
So by doing this, when I receive
the post from the server,

00:30:15.150 --> 00:30:17.320
I know the post already
exists in my disk.

00:30:17.320 --> 00:30:20.347
And I update that one, saying
that, OK, I sync this one.

00:30:20.347 --> 00:30:21.930
I don't know what
happened to the job.

00:30:21.930 --> 00:30:22.800
I don't care.

00:30:22.800 --> 00:30:25.220
And then the job
knows while running.

00:30:25.220 --> 00:30:28.780
Before trying to send
the post, it checks, hey,

00:30:28.780 --> 00:30:30.300
is this already synced?

00:30:30.300 --> 00:30:35.330
So here, if you can see the
code here, it just loads it.

00:30:35.330 --> 00:30:37.080
And if it's already
synchronized,

00:30:37.080 --> 00:30:38.140
it doesn't do anything.

00:30:38.140 --> 00:30:39.880
Oh, hey, this has been updated.

00:30:39.880 --> 00:30:40.380
Good news.

00:30:40.380 --> 00:30:41.760
Everything is working fine.

00:30:44.700 --> 00:30:50.450
So one more thing--
OK, so the last idea

00:30:50.450 --> 00:30:56.680
here is that this works because
we look at the problem as two

00:30:56.680 --> 00:30:57.610
separate problems.

00:30:57.610 --> 00:30:59.290
One of them is
only responsible--

00:30:59.290 --> 00:31:02.970
take the user interaction,
process the model locally.

00:31:02.970 --> 00:31:05.920
And the other one is responsible
to synchronize with the server

00:31:05.920 --> 00:31:06.942
however it does.

00:31:06.942 --> 00:31:07.650
It's not trivial.

00:31:07.650 --> 00:31:10.700
You're writing a bunch of
additional code to say,

00:31:10.700 --> 00:31:13.420
local client IDs have
to handle conflicts.

00:31:13.420 --> 00:31:15.170
But it works.

00:31:15.170 --> 00:31:17.310
So let's look at
one more demo here.

00:31:17.310 --> 00:31:21.210
This time, I will
shut down the server.

00:31:21.210 --> 00:31:23.770
So I'm sending-- I'm
again that excited kid.

00:31:23.770 --> 00:31:25.740
I keep sending all
these messages.

00:31:25.740 --> 00:31:28.000
Of course, they're
not going to go.

00:31:28.000 --> 00:31:31.720
If I look at here,
they're not going.

00:31:31.720 --> 00:31:36.800
When I recover the server, now
the first job is backing off.

00:31:36.800 --> 00:31:37.910
It will eventually finish.

00:31:37.910 --> 00:31:39.450
Meanwhile, I can send more.

00:31:42.100 --> 00:31:44.550
As you can see, they are going
out one by one, one by one,

00:31:44.550 --> 00:31:47.910
in the correct order--
my scroll position lost.

00:31:47.910 --> 00:31:50.170
This works because
these jobs are

00:31:50.170 --> 00:31:52.460
running through the
same queue per pause.

00:31:52.460 --> 00:31:56.230
So I know that whoever came
first will be handled first.

00:31:56.230 --> 00:31:58.920
So we guarantee that
they are in order.

00:31:58.920 --> 00:32:00.670
We cannot guarantee
they are time stamped.

00:32:00.670 --> 00:32:03.150
Because that's
technically not possible

00:32:03.150 --> 00:32:06.400
unless you want to rely on
what your client timestamp is.

00:32:06.400 --> 00:32:09.870
But we granted their order.

00:32:09.870 --> 00:32:11.640
Again, this is all
independent of the UI.

00:32:11.640 --> 00:32:12.770
It doesn't care at all.

00:32:12.770 --> 00:32:16.120
The only thing it knows is, how
do I load this from the disk,

00:32:16.120 --> 00:32:19.770
and how do I send these comments
to my application logic?

00:32:19.770 --> 00:32:21.830
One more example I
want to go-- actually I

00:32:21.830 --> 00:32:23.210
want to go through this code.

00:32:23.210 --> 00:32:25.626
So one of the problems with
this event-driven architecture

00:32:25.626 --> 00:32:28.205
is since all these
events are happening,

00:32:28.205 --> 00:32:29.080
how do I synchronize?

00:32:29.080 --> 00:32:31.460
What if I miss an event?

00:32:31.460 --> 00:32:34.500
Or what if the timeline's
timestamps don't match?

00:32:34.500 --> 00:32:36.690
Again, for this
demo application,

00:32:36.690 --> 00:32:40.610
the way this one works is every
single event that is important

00:32:40.610 --> 00:32:41.810
comes with a timestamp.

00:32:41.810 --> 00:32:44.390
So for example, for
fetching a feed event,

00:32:44.390 --> 00:32:47.500
timestamp is the timestamp
of the oldest post.

00:32:47.500 --> 00:32:50.490
So if someone is going
to load those once,

00:32:50.490 --> 00:32:53.210
it makes sure it includes
that timestamp in the query.

00:32:53.210 --> 00:32:55.430
So it loads things
afterwards, that.

00:32:55.430 --> 00:32:59.730
So every time the feed
activity receives an event--

00:32:59.730 --> 00:33:05.600
let's say [INAUDIBLE]-- it
checks if this is for my user.

00:33:05.600 --> 00:33:07.840
And if this is for
my user, it just

00:33:07.840 --> 00:33:09.670
calls the refresh
with the oldest one.

00:33:09.670 --> 00:33:12.910
And then that refresh method,
while querying the model,

00:33:12.910 --> 00:33:14.150
it uses that timestamp.

00:33:14.150 --> 00:33:17.240
Or if there's no
timestamp, it uses top one.

00:33:17.240 --> 00:33:19.310
Because you don't want to
keep refreshing things.

00:33:22.170 --> 00:33:25.285
Yeah, that is, mostly-- let
me see if I miss anything.

00:33:30.070 --> 00:33:33.880
OK, I think we are going
to publish this code, both

00:33:33.880 --> 00:33:36.890
the server side and
the client side,

00:33:36.890 --> 00:33:39.640
to Github as soon as-- I
needed some clarification here

00:33:39.640 --> 00:33:40.500
and there.

00:33:40.500 --> 00:33:43.195
But you can play with it.

00:33:43.195 --> 00:33:44.570
We'll be happy to
get [INAUDIBLE]

00:33:44.570 --> 00:33:48.356
or whatever if you think
something could be done better.

00:33:48.356 --> 00:33:51.812
And it's nice to share and
just move on from there.

00:33:51.812 --> 00:33:55.170
All right, sure, that's it.

00:33:55.170 --> 00:33:57.452
It's time for some questions.

00:33:57.452 --> 00:34:00.383
[APPLAUSE]

00:34:06.955 --> 00:34:09.330
ADAM POWELL: I think that
we've got a microphone floating

00:34:09.330 --> 00:34:10.610
around perhaps.

00:34:10.610 --> 00:34:13.110
There we go.

00:34:13.110 --> 00:34:16.570
AUDIENCE: Will it contain tests?

00:34:16.570 --> 00:34:17.400
YIGIT BOYAR: Huh?

00:34:17.400 --> 00:34:19.670
AUDIENCE: Will the
project contain tests?

00:34:19.670 --> 00:34:23.420
YIGIT BOYAR: Yes,
it actually does.

00:34:23.420 --> 00:34:25.199
So actually, I should
have showed it.

00:34:25.199 --> 00:34:30.750
So if you look at-- well,
they may not be great tests.

00:34:30.750 --> 00:34:32.159
I am not a testing expert.

00:34:32.159 --> 00:34:34.092
But they do test.

00:34:34.092 --> 00:34:35.550
They're mostly
interrogation tests.

00:34:35.550 --> 00:34:38.380
If you look at something more
fancy, for example, fetching

00:34:38.380 --> 00:34:41.723
the feed, so I say we do--

00:34:41.723 --> 00:34:43.639
ADAM POWELL: Can we
switch the slide back over

00:34:43.639 --> 00:34:44.837
to the computer real quick?

00:34:44.837 --> 00:34:47.498
YIGIT BOYAR: Oh, sorry.

00:34:47.498 --> 00:34:48.789
Can we go back to the computer?

00:34:51.489 --> 00:34:53.199
OK, thank you.

00:34:53.199 --> 00:34:56.634
So the application uses Dagger.

00:34:56.634 --> 00:35:00.822
This is how I marked
some of the API calls.

00:35:00.822 --> 00:35:04.580
But let's see-- fetch
feed, no, send comment.

00:35:04.580 --> 00:35:05.422
That will be nice.

00:35:09.070 --> 00:35:11.035
ADAM POWELL: So
short answer, yes.

00:35:11.035 --> 00:35:12.160
YIGIT BOYAR: They are here.

00:35:12.160 --> 00:35:13.284
I had some very nice tests.

00:35:13.284 --> 00:35:15.630
I cannot find-- OK, I found it.

00:35:15.630 --> 00:35:16.230
400.

00:35:16.230 --> 00:35:21.420
So this is creating the
job, mocking the API service

00:35:21.420 --> 00:35:26.730
so that if someone tries
to send a post, return 404.

00:35:26.730 --> 00:35:29.490
That injects the test
component, runs the job,

00:35:29.490 --> 00:35:31.180
checks the appropriate
event to send.

00:35:31.180 --> 00:35:38.300
So one of the things is when
some outputs happen as events,

00:35:38.300 --> 00:35:40.720
it's not very easy to test them.

00:35:40.720 --> 00:35:43.730
In this example I'm using,
in the test application,

00:35:43.730 --> 00:35:46.130
I'm using a logging
event bus that basically

00:35:46.130 --> 00:35:49.950
logs every single event so that
I can assert on those later on.

00:35:49.950 --> 00:35:52.390
Again, there might be different
or better ways to do this.

00:35:52.390 --> 00:35:53.765
But this is
something that works.

00:35:53.765 --> 00:35:54.650
And we have tests.

00:36:06.400 --> 00:36:09.360
AUDIENCE: What's your opinion
on using custom views instead

00:36:09.360 --> 00:36:12.530
of fragments so you don't
have to deal with the fragment

00:36:12.530 --> 00:36:13.920
quirks, if you will?

00:36:13.920 --> 00:36:17.510
So things like child fragment
manager or popping in the back

00:36:17.510 --> 00:36:20.092
stack after you
have a saved state.

00:36:20.092 --> 00:36:21.800
ADAM POWELL: So again,
I think that those

00:36:21.800 --> 00:36:23.540
are kind of unrelated.

00:36:23.540 --> 00:36:27.030
Just because a fragment
controls views.

00:36:27.030 --> 00:36:28.440
It's not a view itself.

00:36:28.440 --> 00:36:29.940
That was kind of
what we were trying

00:36:29.940 --> 00:36:32.240
to get at a little bit earlier.

00:36:32.240 --> 00:36:34.160
Overall, I think
that a lot of people

00:36:34.160 --> 00:36:37.290
write fragments when they really
meant to write a custom view.

00:36:37.290 --> 00:36:40.630
So I think that in many
cases, see exactly what it

00:36:40.630 --> 00:36:44.530
is that your particular
chunk of encapsulated UI

00:36:44.530 --> 00:36:46.747
needs to express and respond to.

00:36:46.747 --> 00:36:48.330
If those are events
that can be coming

00:36:48.330 --> 00:36:50.240
from some alternate
component that's

00:36:50.240 --> 00:36:54.930
kind of composing that piece's
place within the overall UI,

00:36:54.930 --> 00:36:57.940
then that speaks to it being
probably a little bit more

00:36:57.940 --> 00:36:59.172
like a view group.

00:36:59.172 --> 00:37:00.630
If it's something
that really needs

00:37:00.630 --> 00:37:04.140
to respond to other
elements of the application

00:37:04.140 --> 00:37:06.420
lifecycle and the
activity lifecycle,

00:37:06.420 --> 00:37:09.120
if it's doing something
like registering for events,

00:37:09.120 --> 00:37:11.300
dealing with things
like that, then it

00:37:11.300 --> 00:37:13.500
may be more appropriate for
a fragment in that case.

00:37:13.500 --> 00:37:15.240
But overall, I think
that people tend

00:37:15.240 --> 00:37:17.860
to lean a little bit
too heavily on fragments

00:37:17.860 --> 00:37:19.950
when they think of one
particular subsegment

00:37:19.950 --> 00:37:20.530
of their UI.

00:37:26.485 --> 00:37:27.730
AUDIENCE: Hi.

00:37:27.730 --> 00:37:30.340
One question I had
was, how do you

00:37:30.340 --> 00:37:34.020
handle the serialization
of these jobs to disk

00:37:34.020 --> 00:37:35.970
and back out when the app dies?

00:37:35.970 --> 00:37:39.160
Do you roll your own logic,
or do you use something

00:37:39.160 --> 00:37:41.960
like a framework or something?

00:37:41.960 --> 00:37:43.710
YIGIT BOYAR: For this
demo application,

00:37:43.710 --> 00:37:46.730
I'm using Job Queue, which is
some library I wrote before.

00:37:46.730 --> 00:37:48.790
You can simply serialize them.

00:37:48.790 --> 00:37:50.360
You can use Tape.

00:37:50.360 --> 00:37:52.540
There was recently
another talk to use

00:37:52.540 --> 00:37:56.570
Tape to serialize your
stuff, to make it like a job.

00:37:56.570 --> 00:37:59.040
There's multiple solutions
for this out there.

00:37:59.040 --> 00:38:01.180
It's not that complex either.

00:38:01.180 --> 00:38:03.642
You can choose one of them
which fits your needs.

00:38:03.642 --> 00:38:04.600
AUDIENCE: Cool, thanks.

00:38:08.450 --> 00:38:09.950
ADAM POWELL: We've
got one up front.

00:38:13.337 --> 00:38:14.920
AUDIENCE: In this
kind of application,

00:38:14.920 --> 00:38:17.620
would you use a sync adapter,
or would you use like async REST

00:38:17.620 --> 00:38:20.446
calls to contact the server?

00:38:20.446 --> 00:38:21.820
YIGIT BOYAR: So
for the demo-- so

00:38:21.820 --> 00:38:24.420
one of the things we gave
in examples in the slides

00:38:24.420 --> 00:38:28.950
was to separate your local
tasks from the server tasks.

00:38:28.950 --> 00:38:32.410
The way we do it is
for UI-related stuff,

00:38:32.410 --> 00:38:34.040
I'm using a sync task.

00:38:34.040 --> 00:38:36.500
I never use it for
network, only for UI stuff.

00:38:36.500 --> 00:38:39.100
ANd for network, I'm
using the job queue.

00:38:39.100 --> 00:38:42.919
So the jobs are the only ones
that are calling the network.

00:38:42.919 --> 00:38:45.210
ADAM POWELL: Yeah, the sync
adapter is generally useful

00:38:45.210 --> 00:38:48.310
once you have a more
sophisticated account

00:38:48.310 --> 00:38:50.790
infrastructure, and you have
some of the other machinery

00:38:50.790 --> 00:38:53.280
that that was really
kind of built around.

00:38:53.280 --> 00:38:55.730
So if it seems like
you're going through a lot

00:38:55.730 --> 00:38:59.255
of additional machinery to
work with a sync adapter,

00:38:59.255 --> 00:39:01.380
then maybe start taking a
look at some more things,

00:39:01.380 --> 00:39:03.120
just like a job scheduler,
and so on, and so forth,

00:39:03.120 --> 00:39:05.000
and see if that's
something that is simpler

00:39:05.000 --> 00:39:06.291
that can still meet your needs.

00:39:10.717 --> 00:39:13.050
AUDIENCE: When you start
building all these applications

00:39:13.050 --> 00:39:15.970
with these different
versions of data models--

00:39:15.970 --> 00:39:20.010
so you might have, like, fetch
data off the network, updates

00:39:20.010 --> 00:39:23.180
that the user has made to the
data that hasn't been actually

00:39:23.180 --> 00:39:26.580
pushed to the database, do
you guys have any classes that

00:39:26.580 --> 00:39:29.040
can help us maintain
all this application

00:39:29.040 --> 00:39:33.360
logic or any libraries that
you would suggest we use

00:39:33.360 --> 00:39:37.710
to maintain all these versions?

00:39:37.710 --> 00:39:40.079
ADAM POWELL: Do you
have any suggestions?

00:39:40.079 --> 00:39:42.120
YIGIT BOYAR: I'm sorry,
nothing about versioning.

00:39:42.120 --> 00:39:45.560
But that actually reminds
me of something I forgot.

00:39:45.560 --> 00:39:47.310
One of the important
things in your client

00:39:47.310 --> 00:39:50.040
is your client's consistency.

00:39:50.040 --> 00:39:51.920
And the server may crash.

00:39:51.920 --> 00:39:55.029
But your server may also
start returning bad data.

00:39:55.029 --> 00:39:56.570
So one of the things
this client does

00:39:56.570 --> 00:39:59.390
is, if I open a user model,
let's say-- everything save.

00:40:03.780 --> 00:40:06.660
So before we save
anything, we will date it.

00:40:06.660 --> 00:40:09.670
And if it is not valid for this
client, we just throw it out.

00:40:09.670 --> 00:40:11.570
Because I don't understand.

00:40:11.570 --> 00:40:12.480
The server has a bug.

00:40:12.480 --> 00:40:13.896
Maybe the server
is a new version.

00:40:13.896 --> 00:40:15.160
I don't know.

00:40:15.160 --> 00:40:18.020
If I don't understand
object, I throw it out.

00:40:18.020 --> 00:40:20.830
This makes it easier for the
rest of the application to,

00:40:20.830 --> 00:40:24.344
like, OK, if the object is
there, it's properly filled.

00:40:24.344 --> 00:40:26.760
ADAM POWELL: So to the point
of dealing with specific data

00:40:26.760 --> 00:40:28.797
inconsistencies,
especially across upgrades,

00:40:28.797 --> 00:40:30.880
different server versions,
and so on and so forth,

00:40:30.880 --> 00:40:32.838
what we found with working
with a lot of teams,

00:40:32.838 --> 00:40:35.285
both within Google and
external to Google,

00:40:35.285 --> 00:40:39.740
is that many times, the actual
pieces of business logic

00:40:39.740 --> 00:40:41.500
that make an app
interesting tend

00:40:41.500 --> 00:40:44.570
to differ so much between
applications that we've

00:40:44.570 --> 00:40:47.150
had a lot of difficulty finding
a one size fits all solution

00:40:47.150 --> 00:40:50.200
to just offer as a
prescription of, hey everyone,

00:40:50.200 --> 00:40:53.290
go use this for dealing with
this particular problem space.

00:40:53.290 --> 00:40:55.740
It is something that you can
make a lot of assumptions

00:40:55.740 --> 00:40:57.550
based on the shape
of your data and what

00:40:57.550 --> 00:40:59.710
it is that your data is
actually representing.

00:40:59.710 --> 00:41:02.490
So often times, you need
something a lot less complex

00:41:02.490 --> 00:41:05.472
than some general solution that
solves for the entire world.

00:41:05.472 --> 00:41:07.680
But if you've got some ideas,
please track some of us

00:41:07.680 --> 00:41:09.570
down in the halls here.

00:41:09.570 --> 00:41:11.190
And we'd love to
hear about them.

00:41:18.400 --> 00:41:19.086
Anyone else?

00:41:22.350 --> 00:41:25.182
All right, well,
thank you very much.

00:41:25.182 --> 00:41:26.140
YIGIT BOYAR: Thank you.

00:41:26.140 --> 00:41:30.140
[APPLAUSE]

