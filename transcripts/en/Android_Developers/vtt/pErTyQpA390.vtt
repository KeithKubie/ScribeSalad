WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.500
[MUSIC PLAYING]

00:00:06.700 --> 00:00:07.950
LUCAS BERGSTROM: Good morning.

00:00:07.950 --> 00:00:09.830
[APPLAUSE]

00:00:13.600 --> 00:00:15.470
It's great to see
everybody here.

00:00:15.470 --> 00:00:18.740
Hi, I'm Lukas Bergstrom,
Product Manager for Android

00:00:18.740 --> 00:00:20.300
Architecture Components.

00:00:20.300 --> 00:00:23.090
And before I get started,
I'm curious how many of you

00:00:23.090 --> 00:00:26.720
were here last year when
we announced Architecture

00:00:26.720 --> 00:00:29.530
Components for the first time?

00:00:29.530 --> 00:00:30.240
Awesome.

00:00:30.240 --> 00:00:32.790
OK, this is a much bigger
venue, so that's actually

00:00:32.790 --> 00:00:35.220
a decent percentage.

00:00:35.220 --> 00:00:38.520
When we did launch Architecture
Components last year,

00:00:38.520 --> 00:00:41.590
we were doing something
sort of different for us.

00:00:41.590 --> 00:00:45.450
For the first time, we were
offering explicit guidance

00:00:45.450 --> 00:00:47.970
in how to architect
your app and giving you

00:00:47.970 --> 00:00:51.280
components letting you do that.

00:00:51.280 --> 00:00:53.610
And frankly, for us it was
a little bit of a journey

00:00:53.610 --> 00:00:54.900
into the unknown.

00:00:54.900 --> 00:00:59.710
So 12 months in, let's
check in on how we're doing.

00:00:59.710 --> 00:01:03.600
So we've shipped 26 releases
since May of last year.

00:01:03.600 --> 00:01:05.880
So we've been
constantly iterating

00:01:05.880 --> 00:01:10.260
and improving the core set
of architecture components.

00:01:10.260 --> 00:01:12.790
In the sign of any healthy
open-source project,

00:01:12.790 --> 00:01:14.514
we have a very
active issue tracker.

00:01:14.514 --> 00:01:15.930
I'd like to thank
everybody that's

00:01:15.930 --> 00:01:20.580
taken time to file a feature
request or even a bug.

00:01:20.580 --> 00:01:23.070
And we've closed a lot of those.

00:01:23.070 --> 00:01:26.760
We launched a major new library,
Paging, which is now stable.

00:01:26.760 --> 00:01:29.770
And we'll talk a little
bit more about it today.

00:01:29.770 --> 00:01:32.910
And I'm pleased to say that
based on our survey data,

00:01:32.910 --> 00:01:36.030
over half of you are
using or planning

00:01:36.030 --> 00:01:37.830
to use Architecture Components.

00:01:37.830 --> 00:01:41.130
And this survey was
done only a few months

00:01:41.130 --> 00:01:42.840
after we went stable.

00:01:42.840 --> 00:01:44.910
So this data is pretty
out of date by now.

00:01:44.910 --> 00:01:47.820
But I'm pretty proud of the
fact that only a few months

00:01:47.820 --> 00:01:51.300
after launching to stable, over
half of the Android developers

00:01:51.300 --> 00:01:55.290
we talked to were planning
to use this stuff.

00:01:55.290 --> 00:01:58.500
But more importantly
than any of this,

00:01:58.500 --> 00:02:01.170
you've told us that
Architecture Components actually

00:02:01.170 --> 00:02:04.350
make it easier for you
to build robust apps.

00:02:04.350 --> 00:02:08.130
That having a clear path on
how to architect your app

00:02:08.130 --> 00:02:11.180
and components that help you
realize that has actually

00:02:11.180 --> 00:02:12.930
made a difference in
the real world in how

00:02:12.930 --> 00:02:14.430
you build your apps.

00:02:14.430 --> 00:02:17.260
And we've heard
that not just once,

00:02:17.260 --> 00:02:19.260
but we've heard
that over and over

00:02:19.260 --> 00:02:22.560
from a lot of developers that
have taken time to speak to us.

00:02:25.880 --> 00:02:30.010
So Architecture
Components has grown.

00:02:30.010 --> 00:02:32.470
And we're going to
continue to invest here.

00:02:32.470 --> 00:02:37.930
This is foundational, we think,
for Android apps going forward.

00:02:37.930 --> 00:02:41.540
But not just are we investing
in Architecture Components,

00:02:41.540 --> 00:02:44.110
but this year with
Jetpack, we're

00:02:44.110 --> 00:02:46.990
going to take that same approach
that we took with Architecture

00:02:46.990 --> 00:02:49.900
Components, a blank
sheet of paper approach

00:02:49.900 --> 00:02:53.410
to how Android developer
experience should be.

00:02:53.410 --> 00:02:56.590
And, you know, how we can
improve things for you.

00:02:56.590 --> 00:02:59.230
And Jetpack is going to
take that and apply that

00:02:59.230 --> 00:03:01.960
to the rest of the developer
API service that we offer.

00:03:05.020 --> 00:03:08.380
So now I'm going to turn
it over to you, Yigit,

00:03:08.380 --> 00:03:11.300
to talk about what's new
in Architecture Components.

00:03:11.300 --> 00:03:12.820
YIGIT BOYAR: Thanks, Lukas.

00:03:12.820 --> 00:03:14.780
[APPLAUSE]

00:03:18.310 --> 00:03:19.440
Thank you.

00:03:19.440 --> 00:03:21.620
So we all talk about
what we have been

00:03:21.620 --> 00:03:23.660
doing in this last one year.

00:03:23.660 --> 00:03:26.000
We all look at the
existing libraries,

00:03:26.000 --> 00:03:28.370
talk about the
improvements, and also look

00:03:28.370 --> 00:03:33.950
at the new shiny stuff, paging,
navigation, and work manager.

00:03:33.950 --> 00:03:35.910
Let's start with life cycles.

00:03:35.910 --> 00:03:38.990
So we shipped lifecycles
in the last I/O.

00:03:38.990 --> 00:03:42.890
But to better understand why
we have created this component,

00:03:42.890 --> 00:03:44.930
let's go to two years before.

00:03:44.930 --> 00:03:48.410
In 2016, we did a bunch
of developer surveys

00:03:48.410 --> 00:03:50.990
and asked developers,
what is the hardest

00:03:50.990 --> 00:03:53.150
part of Android development?

00:03:53.150 --> 00:03:56.750
And by far in the
list, big surprise,

00:03:56.750 --> 00:03:59.360
was lifecycle management.

00:03:59.360 --> 00:04:00.890
We're wondering,
like, what can be

00:04:00.890 --> 00:04:05.120
hard about a phone rotating or
user switching applications?

00:04:05.120 --> 00:04:07.070
This happens all
the time on Android.

00:04:07.070 --> 00:04:09.600
Android is built for this.

00:04:09.600 --> 00:04:11.540
But if you look at
the problem in detail,

00:04:11.540 --> 00:04:15.060
if you want to handle them
properly in your application,

00:04:15.060 --> 00:04:18.589
you need to understand these
state graphs very well.

00:04:18.589 --> 00:04:20.810
And when these two
are interleaved,

00:04:20.810 --> 00:04:23.220
it becomes very confusing.

00:04:23.220 --> 00:04:25.880
So we have created
lifecycles component

00:04:25.880 --> 00:04:28.280
to get rid of these problems.

00:04:28.280 --> 00:04:31.510
And it seems to be working
because many developers give

00:04:31.510 --> 00:04:34.490
us testimonials where
a group of problems

00:04:34.490 --> 00:04:36.990
just disappeared from
their applications

00:04:36.990 --> 00:04:40.610
when they started
using these libraries.

00:04:40.610 --> 00:04:43.950
Another important change for
lifecycles was one year ago

00:04:43.950 --> 00:04:47.540
we had introduced them
as an optional library.

00:04:47.540 --> 00:04:51.360
But now, they are a fundamental
part of Android development.

00:04:51.360 --> 00:04:54.500
You don't need to do any
additional libraries to start

00:04:54.500 --> 00:04:55.880
using them.

00:04:55.880 --> 00:05:00.140
Now both AppCompatActivity and
the Fragment class implement

00:05:00.140 --> 00:05:03.626
lifecycle when they're
out of the box.

00:05:03.626 --> 00:05:05.960
Another interesting
thing that happened

00:05:05.960 --> 00:05:07.820
was the community adoption.

00:05:07.820 --> 00:05:11.550
So we ourselves create new APIs
that works with lifecycles.

00:05:11.550 --> 00:05:13.250
But we know other
people are doing

00:05:13.250 --> 00:05:14.840
the same in their libraries.

00:05:14.840 --> 00:05:18.680
And this is so much easier
because already AppCompat

00:05:18.680 --> 00:05:21.170
has these dependencies
so you can easily depend

00:05:21.170 --> 00:05:23.000
on them in your libraries.

00:05:23.000 --> 00:05:27.290
One great example of this is the
AutoDispose library from Uber.

00:05:27.290 --> 00:05:29.420
So if you're using
RxJava, but you

00:05:29.420 --> 00:05:32.360
want the automatic
lifecycle management,

00:05:32.360 --> 00:05:35.840
you can just add this auto
disposable onto your stream,

00:05:35.840 --> 00:05:39.530
give it a lifecycle, and it will
manage the subscription for you

00:05:39.530 --> 00:05:42.360
for free.

00:05:42.360 --> 00:05:45.980
Now, working on these things we
also discovered more problems

00:05:45.980 --> 00:05:47.400
we have.

00:05:47.400 --> 00:05:50.200
One of them is the
Fragment view's lifecycle.

00:05:50.200 --> 00:05:52.910
Now, Fragment has a very
complicated lifecycle.

00:05:52.910 --> 00:05:54.800
Let's look at an example.

00:05:54.800 --> 00:05:57.590
So if you have a Fragment
that when it is created

00:05:57.590 --> 00:06:01.242
it stops observing
LiveData, it goes

00:06:01.242 --> 00:06:02.450
through the regular creation.

00:06:02.450 --> 00:06:04.190
We create a View for it.

00:06:04.190 --> 00:06:06.440
And it goes to the resume state.

00:06:06.440 --> 00:06:09.830
At this point, if you are
meanwhile using your LiveData,

00:06:09.830 --> 00:06:11.720
your UI will start
displaying them.

00:06:11.720 --> 00:06:12.845
Everything works fine.

00:06:12.845 --> 00:06:15.860
Later on, user hits
a button, so you

00:06:15.860 --> 00:06:17.620
want to detach this
Fragment because they

00:06:17.620 --> 00:06:19.850
are going to another Fragment.

00:06:19.850 --> 00:06:21.980
And you are going to
stop that Fragment.

00:06:21.980 --> 00:06:23.930
But once the
Fragment is stopped,

00:06:23.930 --> 00:06:25.310
we don't need the View for it.

00:06:25.310 --> 00:06:27.730
You would like to
reclaim those resources.

00:06:27.730 --> 00:06:29.345
So we destroy the View.

00:06:29.345 --> 00:06:31.834
Later on, user hits
the back button.

00:06:31.834 --> 00:06:33.500
You'll go back to the
previous Fragment.

00:06:33.500 --> 00:06:34.800
We reattach it.

00:06:34.800 --> 00:06:37.400
Now, because we have
destroyed the View,

00:06:37.400 --> 00:06:39.080
we need to create a new one.

00:06:39.080 --> 00:06:42.080
We go ahead and do it, but
this is a brand new View.

00:06:42.080 --> 00:06:44.930
It goes through the
regular creation cycle.

00:06:44.930 --> 00:06:46.605
And now we have a bug.

00:06:46.605 --> 00:06:50.410
This new View will never resume
the state of that LiveData

00:06:50.410 --> 00:06:52.400
because you are
using the Fragment

00:06:52.400 --> 00:06:54.080
lifecycle to observe it.

00:06:54.080 --> 00:06:57.770
So we don't have any reason
to redispatch the same value.

00:06:57.770 --> 00:06:59.860
Of course, if LiveData
receives any value,

00:06:59.860 --> 00:07:01.460
the UI will be updated.

00:07:01.460 --> 00:07:05.320
But it's kind of too late,
because on recreate, your UI

00:07:05.320 --> 00:07:07.350
has a bad state.

00:07:07.350 --> 00:07:09.830
Now, this left you
with two options.

00:07:09.830 --> 00:07:11.930
You would either
subscribe in onCreate.

00:07:11.930 --> 00:07:14.840
It looks very clean,
one time setup.

00:07:14.840 --> 00:07:17.240
But it will fail if
you recreate the View,

00:07:17.240 --> 00:07:19.880
so you needed to
manually update the View.

00:07:19.880 --> 00:07:22.490
Or you were subscribing
onCreateView,

00:07:22.490 --> 00:07:24.350
which handles recreation.

00:07:24.350 --> 00:07:26.300
But now you have
double subscriptions

00:07:26.300 --> 00:07:27.380
that you need to remove.

00:07:27.380 --> 00:07:30.380
You lose the automatic
lifecycle management.

00:07:30.380 --> 00:07:32.660
So the problem here
is that Fragments have

00:07:32.660 --> 00:07:35.010
not one but two lifecycles.

00:07:35.010 --> 00:07:38.720
And we have decided to embrace
it and give the Fragment

00:07:38.720 --> 00:07:41.610
View its own lifecycle.

00:07:41.610 --> 00:07:45.680
So now, starting with support
library 28, or Android Text

00:07:45.680 --> 00:07:49.790
Fragments 1.0, while
observing your LiveData,

00:07:49.790 --> 00:07:52.850
you can specify
the real lifecycle.

00:07:52.850 --> 00:07:55.650
So while you are observing,
if it is about the View,

00:07:55.650 --> 00:07:56.900
you use the View lifecycle.

00:07:56.900 --> 00:07:59.170
Otherwise, use the
Fragment lifecycle.

00:07:59.170 --> 00:08:03.380
And we manage the
subscription for you for free.

00:08:03.380 --> 00:08:06.520
OK, data binding--
so when we started

00:08:06.520 --> 00:08:08.939
to look at our offerings
as part of Jetpack,

00:08:08.939 --> 00:08:10.730
we had decided to move
data binding as part

00:08:10.730 --> 00:08:12.200
of Architecture Competence.

00:08:12.200 --> 00:08:14.630
But if you're not already
using data binding,

00:08:14.630 --> 00:08:19.100
data binding is our solution
for boilerplate free UIs.

00:08:19.100 --> 00:08:21.995
So if you have an object like
this in your application,

00:08:21.995 --> 00:08:25.160
in your binding layouts,
you can reference the fees

00:08:25.160 --> 00:08:26.260
in your object.

00:08:26.260 --> 00:08:29.600
And we take care of
updating the UI for you.

00:08:29.600 --> 00:08:32.780
In Data Binding 3.1, we
have added native support

00:08:32.780 --> 00:08:34.760
for LiveData.

00:08:34.760 --> 00:08:36.750
So if you're a view
model like this,

00:08:36.750 --> 00:08:39.710
which has a LiveData for
users, and if you pass it

00:08:39.710 --> 00:08:42.320
as a parameter to
your binding, you

00:08:42.320 --> 00:08:45.980
can use that LiveData as if it's
a regular field in your binding

00:08:45.980 --> 00:08:46.760
expressions.

00:08:46.760 --> 00:08:49.430
Data Binding will
understand that is LiveData

00:08:49.430 --> 00:08:52.030
and generate the correct code.

00:08:52.030 --> 00:08:53.600
Unfortunately,
this is not enough

00:08:53.600 --> 00:08:56.030
for it to observe it
because Data Binding doesn't

00:08:56.030 --> 00:08:57.680
have a lifecycle.

00:08:57.680 --> 00:09:00.560
To fix that, when you get
your binding instance,

00:09:00.560 --> 00:09:03.440
you just tell it which
lifecycle it should use.

00:09:03.440 --> 00:09:06.310
It will start observing the
LiveData to keep itself up

00:09:06.310 --> 00:09:06.810
to date.

00:09:06.810 --> 00:09:10.360
You don't need to write
any code for this.

00:09:10.360 --> 00:09:14.030
We have also rewritten parts
of the Data Binding compiler

00:09:14.030 --> 00:09:15.650
to be a lot more incremental.

00:09:15.650 --> 00:09:18.320
So if you have a project
with multiple modules,

00:09:18.320 --> 00:09:21.080
it's going to
compile a lot faster.

00:09:21.080 --> 00:09:23.900
We are also working on making
the compilation even more

00:09:23.900 --> 00:09:24.740
incremental.

00:09:24.740 --> 00:09:27.080
But they're not finished yet.

00:09:27.080 --> 00:09:29.440
This new compiler also
gave us the ability

00:09:29.440 --> 00:09:31.280
to support Instant Apps.

00:09:31.280 --> 00:09:34.130
Now you can use Data Binding
in the future modules

00:09:34.130 --> 00:09:36.984
of your Instant Apps.

00:09:36.984 --> 00:09:40.980
OK, Room, my favorite
Architecture Component.

00:09:40.980 --> 00:09:44.120
So Room is our solution
for object mapping

00:09:44.120 --> 00:09:47.900
that minds the gap between
the ASCII lite and your Java

00:09:47.900 --> 00:09:49.820
or coupling code.

00:09:49.820 --> 00:09:52.700
One important change
we did in Room 1.1

00:09:52.700 --> 00:09:55.820
was the support for
better multithreading.

00:09:55.820 --> 00:09:58.340
So if you are
using one Room 1.0,

00:09:58.340 --> 00:10:00.510
and if you have one
thread that is trying

00:10:00.510 --> 00:10:03.314
to insert a lot of
data into the database,

00:10:03.314 --> 00:10:04.730
and you have another
thread that's

00:10:04.730 --> 00:10:08.630
trying to read data while
the write is executing,

00:10:08.630 --> 00:10:10.320
your read will be blocked.

00:10:10.320 --> 00:10:14.051
And it can only execute
after the write is complete.

00:10:14.051 --> 00:10:19.400
In Room 1.1 with writer logging,
they can run in parallel now.

00:10:19.400 --> 00:10:22.460
And another nice feature
of this thing, your writes

00:10:22.460 --> 00:10:25.640
run a lot faster than before.

00:10:25.640 --> 00:10:27.440
Best part of this
change, you don't

00:10:27.440 --> 00:10:30.350
need to do anything to
take advantage of this.

00:10:30.350 --> 00:10:33.470
If the device is running
Jelly Bean or newer,

00:10:33.470 --> 00:10:35.630
and it's not a
low memory device,

00:10:35.630 --> 00:10:39.500
we are going to enable
writer logging for free.

00:10:39.500 --> 00:10:42.890
OK, another important
addition to Room

00:10:42.890 --> 00:10:44.660
was the support for RawQuery.

00:10:44.660 --> 00:10:47.450
But to better understand
why we need RawQuery,

00:10:47.450 --> 00:10:50.160
let's talk about the
Query annotation.

00:10:50.160 --> 00:10:51.980
Now, when you are
using Room, you

00:10:51.980 --> 00:10:54.920
can specify your SQL
query in this annotation.

00:10:54.920 --> 00:10:57.770
You can use the name
bind parameters.

00:10:57.770 --> 00:11:01.130
You can pass those parameters
as regular function arguments.

00:11:01.130 --> 00:11:04.040
And you can tell the
Room what to return.

00:11:04.040 --> 00:11:06.590
The best part of this
setup is that Room

00:11:06.590 --> 00:11:09.560
is going to validate all
of this at compile time.

00:11:09.560 --> 00:11:11.580
So if there's a
mistake in your query,

00:11:11.580 --> 00:11:13.020
if your parameters
doesn't match,

00:11:13.020 --> 00:11:15.470
or what you try to return
doesn't make sense,

00:11:15.470 --> 00:11:17.210
it's going to fail
the compilation

00:11:17.210 --> 00:11:19.820
and let you know what is wrong.

00:11:19.820 --> 00:11:21.920
Now, this is all
cool except what

00:11:21.920 --> 00:11:24.720
if you don't know the
query at compile time?

00:11:24.720 --> 00:11:26.960
What if you're writing a
real estate application,

00:11:26.960 --> 00:11:30.890
my user can't search the
houses with their price?

00:11:30.890 --> 00:11:34.130
Maybe they want to specify
number of bedrooms, bathrooms,

00:11:34.130 --> 00:11:35.810
whether it has a yard.

00:11:35.810 --> 00:11:37.970
If you needed to
query in a method

00:11:37.970 --> 00:11:42.930
for each iteration of this, that
will be impossible to maintain.

00:11:42.930 --> 00:11:44.810
So what you do in
this case is you

00:11:44.810 --> 00:11:48.470
create the query at runtime
based on the options

00:11:48.470 --> 00:11:49.530
the user provided.

00:11:49.530 --> 00:11:52.830
And you prepare the
arguments for that query.

00:11:52.830 --> 00:11:55.310
Now you obtain an instance
of the Room database

00:11:55.310 --> 00:11:58.770
and use this query
method to get the result.

00:11:58.770 --> 00:12:00.180
So far so good.

00:12:00.180 --> 00:12:04.714
The problem with this approach
is that it returns your cursor.

00:12:04.714 --> 00:12:06.200
Who wants a cursor?

00:12:06.200 --> 00:12:09.060
You're trying to get
the list of houses.

00:12:09.060 --> 00:12:11.450
So this looks like a
failure of the library.

00:12:11.450 --> 00:12:15.680
Hence, we have decided to
introduce RawQuery annotation.

00:12:15.680 --> 00:12:19.250
It looks very similar to Query
except instead of specifying

00:12:19.250 --> 00:12:22.550
the query in the
annotation, you pass it

00:12:22.550 --> 00:12:24.380
as a parameter to the function.

00:12:24.380 --> 00:12:27.320
And then you tell us what
you want us to return.

00:12:27.320 --> 00:12:30.380
Now, here, Room cannot
validate that query anymore.

00:12:30.380 --> 00:12:32.930
So it's kind of, you promised
us to send the right query,

00:12:32.930 --> 00:12:35.870
and we'll take care of it.

00:12:35.870 --> 00:12:39.750
Once you have that, if you go
back to our previous example,

00:12:39.750 --> 00:12:41.870
we can get an
instance of our Dao.

00:12:41.870 --> 00:12:43.820
Now we need to
merge our parameters

00:12:43.820 --> 00:12:46.760
and the query in this simplest
guide query class, which

00:12:46.760 --> 00:12:48.950
is basic data holder.

00:12:48.950 --> 00:12:50.870
And then you can pass
it through the Dao

00:12:50.870 --> 00:12:54.870
and get the list of houses--
no more cursors, no more boiler

00:12:54.870 --> 00:12:57.455
plate code.

00:12:57.455 --> 00:13:02.590
OK, Paging-- so Paging is
our solution for lazy loading

00:13:02.590 --> 00:13:04.010
in RecyclerView.

00:13:04.010 --> 00:13:07.700
But to better understand why
we developed this component,

00:13:07.700 --> 00:13:09.622
let's go through an example.

00:13:09.622 --> 00:13:10.830
So you have a list like this.

00:13:10.830 --> 00:13:11.640
It's very common.

00:13:11.640 --> 00:13:13.560
Every single
application has this.

00:13:13.560 --> 00:13:15.150
User can scroll.

00:13:15.150 --> 00:13:18.180
But you know, it actually
represents a much larger list

00:13:18.180 --> 00:13:19.830
than what's on screen.

00:13:19.830 --> 00:13:22.840
And if you're an application
like Twitter, for instance,

00:13:22.840 --> 00:13:24.810
it's a really, really long list.

00:13:24.810 --> 00:13:27.045
So you probably cannot
fit it to memory,

00:13:27.045 --> 00:13:30.060
and it's also very
inefficient to log all of it.

00:13:30.060 --> 00:13:32.130
So what you will do is
you will keep some of it

00:13:32.130 --> 00:13:34.680
in memory, the rest
of it in database,

00:13:34.680 --> 00:13:36.480
and you also have your
server compromised

00:13:36.480 --> 00:13:38.460
where you pull this data from.

00:13:38.460 --> 00:13:42.040
Now, this is actually very
hard to implement properly.

00:13:42.040 --> 00:13:43.620
That's why we have
created the Paging

00:13:43.620 --> 00:13:46.180
Library to make
these common falls

00:13:46.180 --> 00:13:50.366
very easy and
efficient to implement.

00:13:50.366 --> 00:13:53.520
Paging Library comes with
a PagedList class, which

00:13:53.520 --> 00:13:56.340
is an actual Java
List implementation,

00:13:56.340 --> 00:13:58.650
but it works with a data source.

00:13:58.650 --> 00:14:01.500
Every time you access the
items in the PagedList,

00:14:01.500 --> 00:14:04.320
it pulls data from the
data source lazily.

00:14:04.320 --> 00:14:06.570
So if user scrolls,
you need more data,

00:14:06.570 --> 00:14:09.570
it just brings in more data.

00:14:09.570 --> 00:14:11.400
Now, let's look
at how we can get

00:14:11.400 --> 00:14:13.110
an instance of these classes.

00:14:13.110 --> 00:14:15.375
It's actually super easy
if you are using Room.

00:14:15.375 --> 00:14:18.310
So Room already denotes how
to create a data source.

00:14:18.310 --> 00:14:21.270
It's a great example of how
these Architecture Components

00:14:21.270 --> 00:14:23.370
work very well together.

00:14:23.370 --> 00:14:26.160
So you can just tell the Room
to return your data source

00:14:26.160 --> 00:14:27.930
or a data source factory.

00:14:27.930 --> 00:14:30.210
In this case, I'm using
a data source factory

00:14:30.210 --> 00:14:33.030
because data waves is
something that changes.

00:14:33.030 --> 00:14:35.850
And each data source
represents a snapshot.

00:14:35.850 --> 00:14:38.815
So we need a factory so that
we can create new data sources,

00:14:38.815 --> 00:14:41.310
run database changes.

00:14:41.310 --> 00:14:44.950
Once you have that, you can use
this Live Paged Builder class,

00:14:44.950 --> 00:14:47.840
pass the page size,
and code build on it.

00:14:47.840 --> 00:14:51.240
It's going to give you a
live data of pages of users.

00:14:51.240 --> 00:14:55.610
This is almost the same thing
as LiveData of list of users.

00:14:55.610 --> 00:14:57.780
Now, in your
activity or Fragment,

00:14:57.780 --> 00:14:59.340
you would use this
page to set up

00:14:59.340 --> 00:15:01.470
there, which is the
RecycleView adapter that

00:15:01.470 --> 00:15:03.300
works with PagedList.

00:15:03.300 --> 00:15:05.460
You would observe the
live data every time

00:15:05.460 --> 00:15:08.400
we have a new page list,
give it to the adaptor.

00:15:08.400 --> 00:15:10.560
And inside your
adapter, you can just

00:15:10.560 --> 00:15:13.920
call this get item function
to obtain the user object.

00:15:13.920 --> 00:15:16.890
This is a super
simple code to write.

00:15:16.890 --> 00:15:19.970
And we take care of all the
hard work of paging it lazily

00:15:19.970 --> 00:15:21.900
for you.

00:15:21.900 --> 00:15:23.900
Now, even though I have
shown all those examples

00:15:23.900 --> 00:15:28.150
with LiveData, paging supports
RxJava out of the box.

00:15:28.150 --> 00:15:29.820
So if you are using
RxJava and you

00:15:29.820 --> 00:15:32.340
want that observable
of pages, you

00:15:32.340 --> 00:15:36.060
can just get the same
factory that Room generates.

00:15:36.060 --> 00:15:38.640
But instead use the
Rx PagedList builder

00:15:38.640 --> 00:15:42.870
to build your
observable or flowable.

00:15:42.870 --> 00:15:45.110
Now, paging supports
paging from the databases

00:15:45.110 --> 00:15:46.520
I have shown here.

00:15:46.520 --> 00:15:49.530
But it also supports
paging from the network.

00:15:49.530 --> 00:15:52.710
Or you can combine both
database and the network

00:15:52.710 --> 00:15:54.870
for the best user experience.

00:15:54.870 --> 00:15:57.630
To learn more about it,
please join me and Chris Craik

00:15:57.630 --> 00:16:01.190
tomorrow at 2:30 in
the Paging session.

00:16:01.190 --> 00:16:03.005
All right, now about FOO.

00:16:06.252 --> 00:16:07.710
LUKAS BERGSTROM:
I think, possibly,

00:16:07.710 --> 00:16:10.330
some of the suspense about
what FOO is is gone now.

00:16:10.330 --> 00:16:13.770
But when you think
about core problems

00:16:13.770 --> 00:16:16.390
that almost every
app has to deal with,

00:16:16.390 --> 00:16:19.350
in-app navigation has to be
close to the top of the list

00:16:19.350 --> 00:16:20.340
there.

00:16:20.340 --> 00:16:24.000
Right now the framework doesn't
really offer anything for you

00:16:24.000 --> 00:16:27.180
to do or anything
for you to use there

00:16:27.180 --> 00:16:30.330
other than start activity,
which for various reasons

00:16:30.330 --> 00:16:32.470
is not the best option.

00:16:32.470 --> 00:16:35.370
So that means that
for navigation, there

00:16:35.370 --> 00:16:38.520
are a bunch of things that you
have to figure out on your own.

00:16:38.520 --> 00:16:42.510
And that ranges from executing
a Fragment transaction

00:16:42.510 --> 00:16:45.630
without throwing an
exception, hopefully.

00:16:45.630 --> 00:16:49.110
Passing arguments from place
to place, possibly even

00:16:49.110 --> 00:16:52.110
with type safety if you
can figure that out.

00:16:52.110 --> 00:16:53.560
Testing the
navigation is working

00:16:53.560 --> 00:16:55.560
and that the right things
are happening when you

00:16:55.560 --> 00:16:58.870
navigate from place to place.

00:16:58.870 --> 00:17:01.320
Making sure that the up and
back buttons work correctly

00:17:01.320 --> 00:17:04.980
and take the user where
they're supposed to go.

00:17:04.980 --> 00:17:07.290
Mapping deep links to
destinations in your app

00:17:07.290 --> 00:17:09.160
and having that work.

00:17:09.160 --> 00:17:11.910
And by the time you've
solved all of these problems,

00:17:11.910 --> 00:17:14.609
you've typically gone
one of two directions.

00:17:14.609 --> 00:17:18.060
You've either written 60%
of a navigation framework

00:17:18.060 --> 00:17:19.349
just for your app.

00:17:19.349 --> 00:17:23.020
Or you've got a lot of
error-prone boilerplate.

00:17:23.020 --> 00:17:25.347
So everywhere navigation
needs to happen,

00:17:25.347 --> 00:17:27.180
you've got a bunch of
parallel lines of code

00:17:27.180 --> 00:17:30.110
that need to be changed any
time the navigational structure

00:17:30.110 --> 00:17:31.740
of the app changes.

00:17:31.740 --> 00:17:35.010
And this is all pretty
brittle and can end up

00:17:35.010 --> 00:17:36.030
being a headache.

00:17:36.030 --> 00:17:40.440
And individually these
problems are pretty tractable.

00:17:40.440 --> 00:17:44.080
But when you compose them
into a real-world example--

00:17:44.080 --> 00:17:47.610
so say I have an item
screened in my app, maybe

00:17:47.610 --> 00:17:49.500
a product screen.

00:17:49.500 --> 00:17:53.040
And that screen is
accessible via Deeplink.

00:17:53.040 --> 00:17:56.430
But actually, there
are other pages

00:17:56.430 --> 00:17:59.160
that if the user
had navigated here

00:17:59.160 --> 00:18:01.170
by opening the app
from the home screen,

00:18:01.170 --> 00:18:03.690
they would have come via the
home screen, the category

00:18:03.690 --> 00:18:04.830
screen.

00:18:04.830 --> 00:18:08.400
And I want the up button to
take them through those screens

00:18:08.400 --> 00:18:11.220
rather than exiting the app.

00:18:11.220 --> 00:18:14.280
So that means that if someone
deep links into the app,

00:18:14.280 --> 00:18:17.070
I need to synthesize
these screens

00:18:17.070 --> 00:18:20.670
and add them to the back
stack, but only on a deep link.

00:18:20.670 --> 00:18:22.710
And talking to a
third party developer,

00:18:22.710 --> 00:18:24.510
he said, you know,
it's when you're

00:18:24.510 --> 00:18:28.960
in the middle of writing code
to do this on any deep link

00:18:28.960 --> 00:18:31.830
into my app and synthesize
the back stack correctly,

00:18:31.830 --> 00:18:33.590
you start to feel
like maybe this is

00:18:33.590 --> 00:18:36.450
a failure of the framework.

00:18:36.450 --> 00:18:39.300
And so that's why we're
really happy to be launching

00:18:39.300 --> 00:18:45.240
navigation, which is both a
runtime component that performs

00:18:45.240 --> 00:18:48.210
navigation for you
and a visual tool that

00:18:48.210 --> 00:18:51.970
works with XML to define
the navigational structure

00:18:51.970 --> 00:18:55.900
of your app and then
allows you to just navigate

00:18:55.900 --> 00:18:57.690
at runtime with a
single navigate call.

00:19:00.450 --> 00:19:02.400
And so the kinds of
things that you're

00:19:02.400 --> 00:19:05.340
going to get for
free, that you simply

00:19:05.340 --> 00:19:08.160
need to define in XML and
then the navigation framework

00:19:08.160 --> 00:19:13.290
will handle at runtime
for you are animations,

00:19:13.290 --> 00:19:18.310
passing arguments in a typesafe
way from place to place,

00:19:18.310 --> 00:19:22.260
making sure that up and
back work correctly,

00:19:22.260 --> 00:19:27.420
and mapping deep links to
various screens in your app.

00:19:27.420 --> 00:19:32.080
And last but not least, no more
Fragment transactions ever.

00:19:32.080 --> 00:19:34.020
[APPLAUSE]

00:19:39.510 --> 00:19:43.180
So I'll show you a couple
demos of this in action.

00:19:43.180 --> 00:19:47.760
The first one is just to kind
of give you an idea of what this

00:19:47.760 --> 00:19:48.390
all is.

00:19:48.390 --> 00:19:51.510
So we're looking at a set
of Fragment destinations

00:19:51.510 --> 00:19:52.830
in my app.

00:19:52.830 --> 00:19:54.120
And I'm adding a new one.

00:19:54.120 --> 00:19:56.374
And now I'm creating an action.

00:19:56.374 --> 00:19:58.290
And this action is the
thing that I'm actually

00:19:58.290 --> 00:20:03.060
going to call at runtime
to go from place to place.

00:20:03.060 --> 00:20:05.910
And you can see that there
are a bunch of other options

00:20:05.910 --> 00:20:08.880
that we'll get into more
in the navigation talk.

00:20:08.880 --> 00:20:11.790
But the one thing I do want to
show you in more detail right

00:20:11.790 --> 00:20:15.960
now is the example we
went through before.

00:20:15.960 --> 00:20:19.530
So this is a simplified
version of that where

00:20:19.530 --> 00:20:20.970
there isn't a category screen.

00:20:20.970 --> 00:20:24.700
We just have the home screen
and then the item screen.

00:20:24.700 --> 00:20:27.330
But I'm going to, right
now, configure this

00:20:27.330 --> 00:20:31.725
to both have a deep link
pointing at the item screen

00:20:31.725 --> 00:20:35.130
and to make sure that if
someone deep links into the app,

00:20:35.130 --> 00:20:38.250
that they go to the
home screen first when

00:20:38.250 --> 00:20:41.190
they hit up or back rather
than just exiting the app right

00:20:41.190 --> 00:20:42.420
away.

00:20:42.420 --> 00:20:46.140
So first, I'm just going
to configure a deep link

00:20:46.140 --> 00:20:48.100
on this screen.

00:20:48.100 --> 00:20:50.560
And the curly brackets that
I'm going to put around

00:20:50.560 --> 00:20:53.210
item ID indicate that
I want to extract

00:20:53.210 --> 00:20:55.890
a variable there and
pass it as an argument

00:20:55.890 --> 00:20:57.760
into the item screen.

00:20:57.760 --> 00:20:59.440
OK, and now that's ready to go.

00:20:59.440 --> 00:21:01.680
And if I compile and run
my app, that I'll just

00:21:01.680 --> 00:21:05.140
work and navigate to
the right destination.

00:21:05.140 --> 00:21:08.220
Now, I just set the screen
to the start destination.

00:21:08.220 --> 00:21:11.580
That means that it's the
hierarchical parent of all

00:21:11.580 --> 00:21:13.570
the other screens in the graph.

00:21:13.570 --> 00:21:16.470
So when someone deep
links into the item screen

00:21:16.470 --> 00:21:19.050
and then hits up, they're
going to go directly

00:21:19.050 --> 00:21:21.190
to that home screen.

00:21:21.190 --> 00:21:23.760
So now I've just solved
in 30 seconds what

00:21:23.760 --> 00:21:26.940
would have been a really
terrible and time consuming

00:21:26.940 --> 00:21:32.454
task in Java or Kotlin
back in the old world.

00:21:32.454 --> 00:21:34.120
So now I'm going to
pass it off to Yigit

00:21:34.120 --> 00:21:37.370
to talk about Work Manager.

00:21:37.370 --> 00:21:40.400
YIGIT BOYAR: I've been using
navigation a couple of weeks

00:21:40.400 --> 00:21:41.150
for some demos.

00:21:41.150 --> 00:21:45.170
It feels like magic, so
I hope you all liked it.

00:21:45.170 --> 00:21:48.880
Our next Architecture
Component is Work Manager.

00:21:48.880 --> 00:21:50.870
Now, Work Manager
is our solution

00:21:50.870 --> 00:21:53.720
for deferable
guaranteed execution.

00:21:53.720 --> 00:21:55.130
What do I mean by this?

00:21:55.130 --> 00:21:58.370
You're out of actions on Android
that you really, really want

00:21:58.370 --> 00:22:00.530
to do if user does something.

00:22:00.530 --> 00:22:03.320
For instance, if user
decides to send a tweet,

00:22:03.320 --> 00:22:04.940
you want to send it now.

00:22:04.940 --> 00:22:06.950
But if there is no
network connection,

00:22:06.950 --> 00:22:08.910
you want to send it
as soon as device

00:22:08.910 --> 00:22:12.380
is connected to the internet.

00:22:12.380 --> 00:22:13.850
There's things
like uploading logs

00:22:13.850 --> 00:22:16.850
you may want to do if
the device is charging.

00:22:16.850 --> 00:22:18.680
Or you may want to
periodically sync

00:22:18.680 --> 00:22:20.900
your data with your backup.

00:22:20.900 --> 00:22:23.540
Now, we know this is not
a new problem on Android.

00:22:23.540 --> 00:22:25.610
And we had some
solutions for this.

00:22:25.610 --> 00:22:28.630
We have introduced
JobScheduler in Lollipop.

00:22:28.630 --> 00:22:30.510
And we have Firebase
JobDispatcher

00:22:30.510 --> 00:22:33.110
that back forced this
functionality in the devices

00:22:33.110 --> 00:22:35.280
which has Google Play services.

00:22:35.280 --> 00:22:38.645
And we also have AlarmManager
for exact timing.

00:22:38.645 --> 00:22:44.090
Now, each of these has different
behaviors and different APIs.

00:22:44.090 --> 00:22:46.470
It becomes very
hard to implement.

00:22:46.470 --> 00:22:50.740
Hence we have built WorkManager
that sits on top of them

00:22:50.740 --> 00:22:56.250
and provides a much cleaner
API with new functionalities.

00:22:56.250 --> 00:22:58.970
WorkManager has two
simple concepts.

00:22:58.970 --> 00:23:02.420
You have the workers that
execute these actions.

00:23:02.420 --> 00:23:08.280
And you have the work requests
which trigger these workers.

00:23:08.280 --> 00:23:10.370
Now, if you want to
look at a sample worker,

00:23:10.370 --> 00:23:12.260
this is basically all you do.

00:23:12.260 --> 00:23:14.090
You extend the worker class.

00:23:14.090 --> 00:23:17.970
You implement one function
that says do the work.

00:23:17.970 --> 00:23:20.090
And that function
just needs to return

00:23:20.090 --> 00:23:22.810
to us what happened as
a result of that work.

00:23:22.810 --> 00:23:25.870
So you can do whatever you
do, and you return the result.

00:23:25.870 --> 00:23:29.060
There is no services,
no intents, no bundles,

00:23:29.060 --> 00:23:31.580
nothing like that.

00:23:31.580 --> 00:23:35.260
Once we have the worker, we
need to create a work request.

00:23:35.260 --> 00:23:38.180
So you can use this
one time work builder.

00:23:38.180 --> 00:23:41.060
Or there's a periodic
version of this one.

00:23:41.060 --> 00:23:43.460
You can specify
the worker class.

00:23:43.460 --> 00:23:46.460
But now, you can
also add constraints.

00:23:46.460 --> 00:23:49.370
You can tell it only run if
there's network connection

00:23:49.370 --> 00:23:51.650
if the device is charging.

00:23:51.650 --> 00:23:53.630
Or you can specify
a back off criteria.

00:23:53.630 --> 00:23:57.740
So if the worker is failing,
how should we retry it?

00:23:57.740 --> 00:24:01.970
You can also pass input
parameters to these workers.

00:24:01.970 --> 00:24:04.220
Once you build
that work request,

00:24:04.220 --> 00:24:07.070
you can get an instance of
WorkManager and inquiries.

00:24:07.070 --> 00:24:11.960
Now, WorkManager will
take care of executing it.

00:24:11.960 --> 00:24:15.170
One of the important distinctive
features of WorkManager

00:24:15.170 --> 00:24:18.320
is that it has input
and output semantics.

00:24:18.320 --> 00:24:20.940
So your workers
can receive input,

00:24:20.940 --> 00:24:23.720
but they can also
output some data.

00:24:23.720 --> 00:24:26.270
You could observe this
data through WorkManager.

00:24:26.270 --> 00:24:31.070
But it was actually really
useful to chain your workers.

00:24:31.070 --> 00:24:33.930
So imagine you have an
application where user picks

00:24:33.930 --> 00:24:35.560
an image for their device.

00:24:35.560 --> 00:24:39.625
Now you want to run some image
processing on that picture.

00:24:39.625 --> 00:24:41.360
And then once it's
done, you want

00:24:41.360 --> 00:24:43.550
to upload it to your server.

00:24:43.550 --> 00:24:45.850
Now, these are two
different units of work.

00:24:45.850 --> 00:24:47.590
Like, you can process the image.

00:24:47.590 --> 00:24:49.590
Maybe you want to do it
when the device is idle.

00:24:49.590 --> 00:24:51.230
Or you can do it anytime.

00:24:51.230 --> 00:24:54.710
But to upload it to server,
you need internet connection.

00:24:54.710 --> 00:24:57.290
But you don't want to
wait the processing

00:24:57.290 --> 00:25:00.270
for the internet connection
because it doesn't need it.

00:25:00.270 --> 00:25:03.995
This is super easy to
implement in WorkManager.

00:25:03.995 --> 00:25:06.040
So we'll have two
different workers.

00:25:06.040 --> 00:25:07.940
They all have single
functionality.

00:25:07.940 --> 00:25:10.160
One of them does the
image processing.

00:25:10.160 --> 00:25:12.936
The other one does
the upload to server.

00:25:12.936 --> 00:25:16.175
OK, the helper function
that receives an image file

00:25:16.175 --> 00:25:19.450
and creates the process
image work request--

00:25:19.450 --> 00:25:22.520
so it prepares the input,
just uses the same builder

00:25:22.520 --> 00:25:25.370
to produce the request.

00:25:25.370 --> 00:25:26.540
And now we get that.

00:25:26.540 --> 00:25:29.300
Now we wanted our
network upload to wait

00:25:29.300 --> 00:25:30.740
for the internet connection.

00:25:30.740 --> 00:25:32.390
So we set the constraint.

00:25:32.390 --> 00:25:34.610
We say, OK, wait for
internet connection

00:25:34.610 --> 00:25:37.970
before trying to run
this work request.

00:25:37.970 --> 00:25:41.960
And then create the upload image
work using that constraint.

00:25:41.960 --> 00:25:43.960
Once we have them, you
can tell WorkManager,

00:25:43.960 --> 00:25:47.160
OK, begin with the
process image work.

00:25:47.160 --> 00:25:51.140
Once you are done, then run
the upload to server work.

00:25:51.140 --> 00:25:54.800
And now you enqueue both of
these as an atomic operation

00:25:54.800 --> 00:25:56.560
to the WorkManager.

00:25:56.560 --> 00:25:57.755
Now your device can restart.

00:25:57.755 --> 00:25:59.660
Anything can happen in between.

00:25:59.660 --> 00:26:01.370
We will take care
of running the two.

00:26:04.130 --> 00:26:06.500
You can also use
this API extensively.

00:26:06.500 --> 00:26:08.300
Like, you could run
image processing

00:26:08.300 --> 00:26:09.840
in parallel the same way.

00:26:09.840 --> 00:26:11.750
So if user pick
multiple photos, you

00:26:11.750 --> 00:26:14.200
want to process all
of them, but upload

00:26:14.200 --> 00:26:16.520
it to server while
some of them are done.

00:26:16.520 --> 00:26:19.250
You can easily do
that with WorkManager.

00:26:19.250 --> 00:26:23.510
We'll just use the same function
or create three work requests

00:26:23.510 --> 00:26:26.150
for each of the
images user picked.

00:26:26.150 --> 00:26:28.430
We create the upload
work in much the same way

00:26:28.430 --> 00:26:30.260
we did before.

00:26:30.260 --> 00:26:33.980
And now we say, OK, begin with
all these three work items.

00:26:33.980 --> 00:26:37.820
Once all of them are done,
then run the upload work.

00:26:37.820 --> 00:26:41.160
And then you enqueue that
as an atomic operation.

00:26:41.160 --> 00:26:44.700
And it takes care of running it.

00:26:44.700 --> 00:26:46.730
Another important
feature of Work Manager

00:26:46.730 --> 00:26:50.220
is that it is not just a wrapper
for JobScheduler or Firebase

00:26:50.220 --> 00:26:51.650
JobDispatcher.

00:26:51.650 --> 00:26:54.680
It's actually an
executor itself.

00:26:54.680 --> 00:26:57.410
So let's look at why
opportunistic execution is

00:26:57.410 --> 00:26:58.680
important.

00:26:58.680 --> 00:27:01.430
So if you're an application
where user can send an email,

00:27:01.430 --> 00:27:03.650
so user hits the
send button, you

00:27:03.650 --> 00:27:06.500
send the job info
to the JobScheduler

00:27:06.500 --> 00:27:08.360
or to the Firebase
JobDispatcher.

00:27:08.360 --> 00:27:12.350
And it will eventually call
you to execute it back.

00:27:12.350 --> 00:27:14.090
The problem here
is that you don't

00:27:14.090 --> 00:27:16.380
know how long it will take.

00:27:16.380 --> 00:27:19.430
Even if you're device currently
has network connection,

00:27:19.430 --> 00:27:22.430
it may take a couple of
minutes for JobScheduler

00:27:22.430 --> 00:27:23.300
to call you back.

00:27:23.300 --> 00:27:25.210
And you have no control over it.

00:27:25.210 --> 00:27:26.570
You just don't know.

00:27:26.570 --> 00:27:29.300
And it results in a
bad user experience.

00:27:29.300 --> 00:27:32.240
To work around that what
you usually do is you also

00:27:32.240 --> 00:27:33.890
have your own thread pool.

00:27:33.890 --> 00:27:35.930
Whenever a user
hits send, you try

00:27:35.930 --> 00:27:37.930
to run the same
thing there as well.

00:27:37.930 --> 00:27:39.800
And you take care
of the duplicating

00:27:39.800 --> 00:27:43.310
when the JobScheduler
calls you back.

00:27:43.310 --> 00:27:45.020
If you are using
WorkManager, you

00:27:45.020 --> 00:27:46.940
don't need to think about it.

00:27:46.940 --> 00:27:50.210
Because when you send the work
request to the WorkManager,

00:27:50.210 --> 00:27:52.660
it puts it into
its own database.

00:27:52.660 --> 00:27:54.950
Then it tells
JobScheduler, or whichever

00:27:54.950 --> 00:27:57.500
scheduler it has on
the device, OK, I

00:27:57.500 --> 00:28:00.860
need to be invoked when
these constraints are met.

00:28:00.860 --> 00:28:04.410
But it also checks those
constraints itself.

00:28:04.410 --> 00:28:06.470
And if they're already
ready, it will instantly

00:28:06.470 --> 00:28:08.686
start executing the job.

00:28:08.686 --> 00:28:12.500
And later on, if JobScheduler
comes in and asks to execute,

00:28:12.500 --> 00:28:16.010
now WorkManager knows
whether it is executed or not

00:28:16.010 --> 00:28:19.270
and handles the
request properly.

00:28:19.270 --> 00:28:21.170
To learn more about
WorkManager, please

00:28:21.170 --> 00:28:25.970
join us today at 5:30 in
the WorkManager session.

00:28:25.970 --> 00:28:29.340
All right, what's next?

00:28:29.340 --> 00:28:30.980
LUKAS BERGSTROM:
OK, so I think it's

00:28:30.980 --> 00:28:33.620
been a pretty great year
in Android app development.

00:28:33.620 --> 00:28:35.570
Hopefully you agree.

00:28:35.570 --> 00:28:39.680
We launched the set of great
new components last year.

00:28:39.680 --> 00:28:42.290
And we kept working on those
and iterating on those.

00:28:42.290 --> 00:28:45.315
We've launched three new
major components, WorkManager,

00:28:45.315 --> 00:28:48.140
Navigation, and
Paging since then.

00:28:48.140 --> 00:28:50.510
So does that mean we're done?

00:28:50.510 --> 00:28:51.680
Obviously not.

00:28:51.680 --> 00:28:53.370
We have a lot more to do.

00:28:53.370 --> 00:28:55.190
And the first thing
that we want to do

00:28:55.190 --> 00:28:58.460
is we want to make Architecture
Components the default way

00:28:58.460 --> 00:29:00.800
that people build Android apps.

00:29:00.800 --> 00:29:04.160
And that doesn't mean that
it's going to be required.

00:29:04.160 --> 00:29:06.500
But it does mean
that we want to make

00:29:06.500 --> 00:29:10.250
sure that as many
people as possible

00:29:10.250 --> 00:29:12.500
get Architecture Components,
regardless of how they

00:29:12.500 --> 00:29:13.940
get into Android development.

00:29:13.940 --> 00:29:16.130
So that means that
not only are we

00:29:16.130 --> 00:29:19.055
going to be building more tools
like the Navigation Editor

00:29:19.055 --> 00:29:22.820
into Android studio that
are sort of Architectural

00:29:22.820 --> 00:29:26.810
Components aware, but we'll also
be adding more templates that

00:29:26.810 --> 00:29:30.770
include things like view
models so that people starting

00:29:30.770 --> 00:29:35.210
a new project have the easiest
possible OnRamp into Android

00:29:35.210 --> 00:29:38.120
development.

00:29:38.120 --> 00:29:40.340
And in terms of
libraries, not only

00:29:40.340 --> 00:29:42.770
are we going to be building
more Architecture Components,

00:29:42.770 --> 00:29:44.810
and not only are we
going to be building

00:29:44.810 --> 00:29:48.050
in more of the core
Architecture Components

00:29:48.050 --> 00:29:52.130
goodness like lifecycle
awareness into Jetpack,

00:29:52.130 --> 00:29:55.700
but we want to look at
other Google APIs as well

00:29:55.700 --> 00:30:00.830
and see how we can make those
Architecture Components aware.

00:30:00.830 --> 00:30:03.140
So that, for example, if
you're calling another Google

00:30:03.140 --> 00:30:07.100
API that's asynchronous, it
already has that built in.

00:30:07.100 --> 00:30:09.920
So that you're kind of getting
Architecture Components

00:30:09.920 --> 00:30:13.140
benefits, whether you know
you're using it or not.

00:30:13.140 --> 00:30:15.500
And then finally, we've
heard from everybody

00:30:15.500 --> 00:30:18.140
that you want us to speak
with a single voice.

00:30:18.140 --> 00:30:21.200
You want us to give clear
and consistent guidance.

00:30:21.200 --> 00:30:23.750
So that means that in
terms of education--

00:30:23.750 --> 00:30:25.970
and that means not
just documentation.

00:30:25.970 --> 00:30:31.010
But it also means
sample apps, code labs,

00:30:31.010 --> 00:30:33.170
that all this stuff
is going to be

00:30:33.170 --> 00:30:34.760
refactored to kind
of be built on top

00:30:34.760 --> 00:30:36.300
of Architecture Components.

00:30:36.300 --> 00:30:39.830
So that whether you start with
the guide to app architecture

00:30:39.830 --> 00:30:43.460
or you just download
a sample MediaPlayer

00:30:43.460 --> 00:30:46.880
app and you start
customizing it, that you kind

00:30:46.880 --> 00:30:50.720
of, regardless of what your
on ramp in and development is,

00:30:50.720 --> 00:30:54.330
that we get you to the
best possible place.

00:30:54.330 --> 00:30:56.090
We know that we still
have some areas left

00:30:56.090 --> 00:30:58.100
to address in the core.

00:30:58.100 --> 00:31:00.000
And you can see
some of those here.

00:31:00.000 --> 00:31:03.020
So this is just to say that
we are definitely not going

00:31:03.020 --> 00:31:05.705
to stop investing in the
original set of Architecture

00:31:05.705 --> 00:31:07.430
Components.

00:31:07.430 --> 00:31:10.220
And there is some, not
just problem solving here,

00:31:10.220 --> 00:31:12.710
but some exciting stuff
that we can do around,

00:31:12.710 --> 00:31:16.340
how can we make Architecture
Components as idiomatic and fun

00:31:16.340 --> 00:31:19.670
to use as possible for
people using Kotlin?

00:31:19.670 --> 00:31:22.430
So there's a lot to be
done still in, I think,

00:31:22.430 --> 00:31:27.420
the core set of app architecture
and lifecycle problem areas.

00:31:27.420 --> 00:31:29.850
So we'll keep working there.

00:31:29.850 --> 00:31:33.057
But beyond that, I think
you'll see something

00:31:33.057 --> 00:31:34.640
interesting about
our trajectory if we

00:31:34.640 --> 00:31:37.370
look at all the components
we've launched to date.

00:31:37.370 --> 00:31:42.430
So last year, this set of
Architecture Components was--

00:31:42.430 --> 00:31:46.635
these are relatively small
pieces, relatively small APIs

00:31:46.635 --> 00:31:49.010
that are designed to be used
in a lot of different places

00:31:49.010 --> 00:31:50.570
in your app.

00:31:50.570 --> 00:31:54.560
And then if you look at Room
navigation and WorkManager,

00:31:54.560 --> 00:31:57.530
these are much larger
and richer APIs.

00:31:57.530 --> 00:32:01.070
But they're still
relatively self-contained.

00:32:01.070 --> 00:32:02.580
They solve a single problem.

00:32:02.580 --> 00:32:05.750
They do it really well.

00:32:05.750 --> 00:32:09.350
Paging also solves a single
problem and solves it well.

00:32:09.350 --> 00:32:13.760
But in this case, we took a
very specific use case, so lazy

00:32:13.760 --> 00:32:16.310
loading for recycler view.

00:32:16.310 --> 00:32:18.770
And we're actually, in
this case, orchestrating

00:32:18.770 --> 00:32:21.830
multiple Architecture
Components and pieces of Jetpack

00:32:21.830 --> 00:32:23.640
to solve that problem.

00:32:23.640 --> 00:32:26.040
So Paging is a little
bit higher level.

00:32:26.040 --> 00:32:30.650
It's not just here's your
object mapping layer.

00:32:30.650 --> 00:32:32.420
It actually takes
a very specific,

00:32:32.420 --> 00:32:34.730
I know I have a recycler
view with more data

00:32:34.730 --> 00:32:36.530
that I can fit in memory.

00:32:36.530 --> 00:32:39.530
And it uses multiple pieces
of Architecture Components

00:32:39.530 --> 00:32:41.480
to make that as
easy as possible.

00:32:41.480 --> 00:32:46.460
And we want to continue to
build more stuff like that.

00:32:46.460 --> 00:32:48.350
So we're not just
going to keep investing

00:32:48.350 --> 00:32:51.240
in the core areas of app
architecture and lifecycle.

00:32:51.240 --> 00:32:54.710
But we want to start solving
higher level problems

00:32:54.710 --> 00:32:59.380
and make more and more
as easy as possible.

00:32:59.380 --> 00:33:02.310
But I can't leave today
without thanking everybody

00:33:02.310 --> 00:33:03.900
that helped us get here.

00:33:03.900 --> 00:33:06.660
The reason that we were able
to have a really high quality

00:33:06.660 --> 00:33:08.940
bar for Architecture
Components was

00:33:08.940 --> 00:33:12.270
because a lot of people,
many of whom are here today,

00:33:12.270 --> 00:33:14.280
were really generous
with their time.

00:33:14.280 --> 00:33:16.500
And that includes not
just filing issues

00:33:16.500 --> 00:33:21.240
on the Issue Tracker, but also
testing pre-release components,

00:33:21.240 --> 00:33:24.270
having one-on-one
conversations with us

00:33:24.270 --> 00:33:27.180
to tell us what your biggest
problem areas with Android app

00:33:27.180 --> 00:33:29.160
development were.

00:33:29.160 --> 00:33:31.050
This has been critical
to us in making sure

00:33:31.050 --> 00:33:33.690
that we're focusing
on the right problems

00:33:33.690 --> 00:33:36.822
and delivering solutions that
are going to work for you.

00:33:36.822 --> 00:33:38.280
So I really have
to thank everybody

00:33:38.280 --> 00:33:40.048
in the community
that's been so helpful.

00:33:40.048 --> 00:33:41.006
YIGIT BOYAR: Thank you.

00:33:41.006 --> 00:33:42.910
[APPLAUSE]

00:33:44.338 --> 00:33:47.492
[MUSIC PLAYING]

