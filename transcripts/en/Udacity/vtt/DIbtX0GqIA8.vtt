WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.000
[Evans] This is definitely a subjective question,

00:00:02.000 --> 00:00:07.000
and it's kind of strange that a discipline like computer science is so poorly defined

00:00:07.000 --> 00:00:11.000
that if you ask many computer scientists what it is you'll get very different answers.

00:00:11.000 --> 00:00:17.000
But my answer to this is it is engineering, it is a science, and it's also a liberal art,

00:00:17.000 --> 00:00:20.000
that all 3 are true, and I'll explain why next.

00:00:20.000 --> 00:00:22.000
This is the way I tend to think about engineering

00:00:22.000 --> 00:00:26.000
is it's building big, complex structures that solve physical problems

00:00:26.000 --> 00:00:29.000
like getting cars across a bay of water.

00:00:29.000 --> 00:00:32.000
With that narrow view of building physical things,

00:00:32.000 --> 00:00:35.000
most of what we do in computing is not about building physical things,

00:00:35.000 --> 00:00:38.000
it's about building virtual things, it's about solving problems.

00:00:38.000 --> 00:00:42.000
A broader view of engineering views it as design under constraint.

00:00:42.000 --> 00:00:46.000
When you're building a bridge, the constraints are the laws of physics.

00:00:46.000 --> 00:00:49.000
You need the bridge to stand up, but you want to limit the cost of the bridge,

00:00:49.000 --> 00:00:53.000
the amount of material that you use, you want it to not sway too much in the wind.

00:00:53.000 --> 00:00:57.000
These are all the kinds of constraints that you have to think about in designing a bridge.

00:00:57.000 --> 00:01:00.000
When we build computer programs, we don't usually have to worry too much

00:01:00.000 --> 00:01:02.000
about the laws of physics.

00:01:02.000 --> 00:01:05.000
We've seen that they do affect us--that the speed it takes for light to travel

00:01:05.000 --> 00:01:07.000
affects how fast our programs will run--

00:01:07.000 --> 00:01:09.000
but for the most part when we're designing programs,

00:01:09.000 --> 00:01:12.000
this is not the main thing that we're thinking about.

00:01:12.000 --> 00:01:16.000
The main constraint that we have to worry about is the limitations of human minds.

00:01:16.000 --> 00:01:19.000
What we can do is limited by our creativity,

00:01:19.000 --> 00:01:22.000
but it's also limited by how much we can keep in mind at one time.

00:01:22.000 --> 00:01:26.000
The main tool that we have to solve this is abstraction.

00:01:26.000 --> 00:01:31.000
The point of abstraction is to allow us to limit what we have to keep in our mind

00:01:31.000 --> 00:01:34.000
to be able to solve problems by hiding those details

00:01:34.000 --> 00:01:36.000
and thinking about things at the right level

00:01:36.000 --> 00:01:39.000
and designing programs in a way that we can have a procedure

00:01:39.000 --> 00:01:41.000
that solves the problem that we want,

00:01:41.000 --> 00:01:44.000
and then we can forget about the details while we move on to the next part.

00:01:44.000 --> 00:01:48.000
That's all about using abstraction to overcome the limits of human minds

00:01:48.000 --> 00:01:52.000
in terms of how much we can keep in mind and understand at one time.

00:01:52.000 --> 00:01:55.000
So from that perspective, computer science is definitely about engineering.

00:01:55.000 --> 00:01:57.000
We certainly want to build things.

00:01:57.000 --> 00:01:59.000
We're not building things like bridges, and we're doing that under constraints,

00:01:59.000 --> 00:02:02.000
but the main constraints are not from the laws of physics--

00:02:02.000 --> 00:02:06.000
because we're not building physical things--but from the limits of our own minds.

00:02:06.000 --> 00:02:11.000
We tend to think about science as understanding nature through observation,

00:02:11.000 --> 00:02:15.000
and our favorite example of this is Sir Isaac Newton.

00:02:15.000 --> 00:02:17.000
If you can't recognize this, this is obviously Newton

00:02:17.000 --> 00:02:19.000
because he's sitting under an apple tree

00:02:19.000 --> 00:02:23.000
and the probably untrue story of him understanding gravity

00:02:23.000 --> 00:02:26.000
because of an apple falling on his head.

00:02:26.000 --> 00:02:31.000
In computer science we're mostly not focused on understanding nature,

00:02:31.000 --> 00:02:33.000
at least not in a very direct way.

00:02:33.000 --> 00:02:35.000
We're thinking about abstract things.

00:02:35.000 --> 00:02:37.000
We're writing programs to solve problems, but they're dealing with

00:02:37.000 --> 00:02:40.000
abstract representations of those problems.

00:02:40.000 --> 00:02:43.000
Certainly computing is used all over the place

00:02:43.000 --> 00:02:47.000
to build better models of the universe

00:02:47.000 --> 00:02:49.000
and to test those models,

00:02:49.000 --> 00:02:54.000
but that's a little different from saying that computer science itself is a science.

00:02:54.000 --> 00:02:56.000
But there is a lot of computing in nature.

00:02:56.000 --> 00:02:58.000
Certainly physical processes involve computation.

00:02:58.000 --> 00:03:02.000
The other big example today is really in biology.

00:03:02.000 --> 00:03:06.000
If you think about DNA as programming organisms,

00:03:06.000 --> 00:03:08.000
it's a very complex way of programming,

00:03:08.000 --> 00:03:11.000
but it's also very computational.

00:03:11.000 --> 00:03:15.000
And if you think about biology, biology is really all about computation today.

00:03:15.000 --> 00:03:18.000
So certainly if we want to understand nature better,

00:03:18.000 --> 00:03:21.000
both how human minds work--that's largely about computation--

00:03:21.000 --> 00:03:24.000
and how DNA produces biological organisms

00:03:24.000 --> 00:03:30.000
and how DNA evolves over time, that's really about understanding computation in nature.

00:03:30.000 --> 00:03:33.000
We didn't get to this too much in this class,

00:03:33.000 --> 00:03:38.000
but this question about universality, questions about what can be computed

00:03:38.000 --> 00:03:42.000
and how fast it can be computed are really fundamental questions about science.

00:03:42.000 --> 00:03:44.000
They are questions about our universe.

00:03:44.000 --> 00:03:47.000
They are abstract questions in the sense that we can form them

00:03:47.000 --> 00:03:49.000
as mathematical, precise questions,

00:03:49.000 --> 00:03:52.000
but they are also really questions about what are the limits

00:03:52.000 --> 00:03:55.000
and what are the possibilities in our universe.

00:03:55.000 --> 00:03:58.000
The final correct answer was liberal art.

00:03:58.000 --> 00:04:01.000
In some sense this is arguably the easiest one to defend,

00:04:01.000 --> 00:04:05.000
but it's probably the one that was most surprising to many of you.

00:04:05.000 --> 00:04:07.000
Understanding why computer science is a liberal art

00:04:07.000 --> 00:04:10.000
depends on actually understanding what the liberal arts are.

00:04:10.000 --> 00:04:13.000
Here's a picture of the medieval view of the liberal arts.

00:04:13.000 --> 00:04:19.000
There's grammar, rhetoric, dialect, which we think of as logic today.

00:04:19.000 --> 00:04:21.000
Those are the 3 that have to do with language,

00:04:21.000 --> 00:04:24.000
and then there are 4 that have to do with number.

00:04:24.000 --> 00:04:29.000
The 4 that have to do with number are arithmetic, geometry, music,

00:04:29.000 --> 00:04:34.000
which is number in time, and astronomy, which is number in time and space.

00:04:34.000 --> 00:04:36.000
So how do each of those relate to computing?

00:04:36.000 --> 00:04:39.000
We've certainly seen a lot with grammars.

00:04:39.000 --> 00:04:41.000
We've seen rules like this.

00:04:41.000 --> 00:04:45.000
Rhetoric is about using language to communicate between people,

00:04:45.000 --> 00:04:47.000
especially to persuade people.

00:04:47.000 --> 00:04:49.000
We've actually seen rhetoric a little bit.

00:04:49.000 --> 00:04:51.000
This is a little less clear,

00:04:51.000 --> 00:04:55.000
but we've seen it in terms of network protocols.

00:04:55.000 --> 00:04:59.000
What protocols are are ways of computers communicating with each other

00:04:59.000 --> 00:05:01.000
and making sure that they can understand each other.

00:05:01.000 --> 00:05:03.000
So arguably, that's a form of rhetoric.

00:05:03.000 --> 00:05:06.000
Logic is the art of thinking in the medieval view.

00:05:06.000 --> 00:05:10.000
We've certainly used logic all over the place in this class.

00:05:10.000 --> 00:05:15.000
All of our decision constructs are logical constructs,

00:05:15.000 --> 00:05:17.000
so we've certainly used a lot of logic.

00:05:17.000 --> 00:05:21.000
So those are the 3 traditional liberal arts, known as the trivium, focused on language.

00:05:21.000 --> 00:05:26.000
And then we have the quadrivium, which are the 4 focused on numbers.

00:05:26.000 --> 00:05:29.000
Arithmetic. We've certainly seen lots of arithmetic in this class,

00:05:29.000 --> 00:05:32.000
and we can do lots of arithmetic in Python.

00:05:32.000 --> 00:05:36.000
Geometry. We haven't used too much directly in this class.

00:05:36.000 --> 00:05:39.000
There certainly is lots of use of geometry in computing.

00:05:39.000 --> 00:05:41.000
The 2 that I'll mention most--

00:05:41.000 --> 00:05:44.000
In computer graphics that's all about understanding the geometry of light

00:05:44.000 --> 00:05:46.000
well enough to be able to simulate images

00:05:46.000 --> 00:05:48.000
and to be able to draw things on the screen.

00:05:48.000 --> 00:05:52.000
The other place where geometry comes up a lot is in networking,

00:05:52.000 --> 00:05:55.000
and we saw that a little bit in Unit 4.

00:05:55.000 --> 00:05:58.000
If we want to design a network, we care about the topology of the network--

00:05:58.000 --> 00:06:02.000
how things are connected--and that depends on understanding geometry.

00:06:02.000 --> 00:06:05.000
But we didn't get to either of those things too much in this class.

00:06:05.000 --> 00:06:08.000
Music, which is about number in time.

00:06:08.000 --> 00:06:13.000
We haven't really seen how computing relates to music very much in this class,

00:06:13.000 --> 00:06:16.000
but certainly recursion occurs all over the place in music.

00:06:16.000 --> 00:06:20.000
If you don't believe me, I would encourage you to read this book

00:06:20.000 --> 00:06:23.000
by Douglas Hofstadter called Godel, Escher, Bach.

00:06:23.000 --> 00:06:29.000
It's all about how the logic of computing relates to things in both the art of Escher

00:06:29.000 --> 00:06:31.000
and the music of Bach.

00:06:31.000 --> 00:06:34.000
And the final traditional liberal art was astronomy.

00:06:34.000 --> 00:06:37.000
We haven't seen that directly in this class either,

00:06:37.000 --> 00:06:40.000
but certainly almost all astronomy today depends on computing.

