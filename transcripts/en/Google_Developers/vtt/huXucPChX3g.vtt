WEBVTT
Kind: captions
Language: en

00:00:05.010 --> 00:00:05.690
COLT MCANLIS: Everybody.

00:00:05.690 --> 00:00:06.880
My name is Colt McAnlis.

00:00:06.880 --> 00:00:09.790
I'm a game developer advocate
here at Google, focusing on

00:00:09.790 --> 00:00:11.490
Native Client and Chrome.

00:00:11.490 --> 00:00:13.460
Thank you all for coming
to the Google Dev Day.

00:00:13.460 --> 00:00:16.770
We've got a lot of great talks
so far today and hopefully

00:00:16.770 --> 00:00:20.040
this will continue in our
processes to get you ready to

00:00:20.040 --> 00:00:22.330
use web gaming, I suppose
is the big thing.

00:00:22.330 --> 00:00:25.280
Here at GDC, there's a lot of
focus on console, but everyone

00:00:25.280 --> 00:00:26.740
is moving towards web gaming.

00:00:26.740 --> 00:00:29.190
And we understand that this is
an important trend in sort of

00:00:29.190 --> 00:00:31.470
the evolution of gaming
as a whole.

00:00:31.470 --> 00:00:33.600
And what we're going to talk
about today is best practices

00:00:33.600 --> 00:00:34.680
in developing those
web gaming.

00:00:34.680 --> 00:00:38.150
So being at Google, you sort of
have an interesting ability

00:00:38.150 --> 00:00:40.680
to look at the broad spectrum
of data and the number of

00:00:40.680 --> 00:00:44.220
developers out there on the web
doing some amazing things,

00:00:44.220 --> 00:00:47.030
and mine that data, look at it
from different angles, and

00:00:47.030 --> 00:00:49.320
sort of construct the best
practices document.

00:00:49.320 --> 00:00:51.260
And that's really what
this talk is about.

00:00:51.260 --> 00:00:54.590
This doc very specifically is
focused to developers who are

00:00:54.590 --> 00:00:59.070
not already multi-millionaires
at developing web games.

00:00:59.070 --> 00:01:01.470
If you're already if you're a
making millions and millions

00:01:01.470 --> 00:01:04.140
of dollars with your web game,
chances are you know

00:01:04.140 --> 00:01:05.670
everything that I'm about
to talk about.

00:01:05.670 --> 00:01:07.090
So feel free, check
your emails.

00:01:07.090 --> 00:01:08.420
Zone out.

00:01:08.420 --> 00:01:10.540
Figure out what parties you're
going to at GDC.

00:01:10.540 --> 00:01:12.890
Have fun with that.

00:01:12.890 --> 00:01:15.710
In mean time for everybody
else, we're going to talk

00:01:15.710 --> 00:01:17.820
today about developing a web
game in modern browsers.

00:01:17.820 --> 00:01:20.170
Now the interesting point
here is twofold.

00:01:20.170 --> 00:01:23.560
First off is I'm saying
in modern browsers.

00:01:23.560 --> 00:01:26.650
So I think we can all agree that
when we talk about web

00:01:26.650 --> 00:01:30.590
gaming, there's sort of this
threshold of minimum feature

00:01:30.590 --> 00:01:32.780
set that we're not willing
to go below.

00:01:32.780 --> 00:01:34.400
A lot of developers when you
talk about web gaming and they

00:01:34.400 --> 00:01:35.470
say well, what about ubiquity?

00:01:35.470 --> 00:01:36.980
What about reach?

00:01:36.980 --> 00:01:40.230
But at the same time, they're
not really able to make the

00:01:40.230 --> 00:01:42.870
experience of their game
translate to these older

00:01:42.870 --> 00:01:45.410
browsers that don't have
the same capabilities.

00:01:45.410 --> 00:01:48.460
So today, I want to make sure
that we're focusing things

00:01:48.460 --> 00:01:50.880
since you are at the Google
Developer Day, that we're

00:01:50.880 --> 00:01:52.310
actually talking about Chrome.

00:01:52.310 --> 00:01:54.680
Chrome is considered
a modern browser.

00:01:54.680 --> 00:01:57.700
It's a very important
linchpin in the

00:01:57.700 --> 00:01:58.580
pushing of things forward.

00:01:58.580 --> 00:02:01.490
Google has a lot of vested
interest in making sure that

00:02:01.490 --> 00:02:03.560
this is a platform that we can
continue to push the internet

00:02:03.560 --> 00:02:06.880
forward in positive ways, and
basically enrich the ecosystem

00:02:06.880 --> 00:02:07.910
for all of humanity.

00:02:07.910 --> 00:02:10.220
Because pretty much everyone
uses the internet nowadays.

00:02:10.220 --> 00:02:12.860
And if you don't use the
internet, hopefully

00:02:12.860 --> 00:02:14.000
we'll fix that soon.

00:02:14.000 --> 00:02:15.940
Anyhow, let's get started.

00:02:15.940 --> 00:02:17.720
So let's start from the top.

00:02:17.720 --> 00:02:19.910
If you're a console developer
and you've never shipped a web

00:02:19.910 --> 00:02:22.040
game, you have no idea
we're talking about.

00:02:22.040 --> 00:02:25.860
And you generally have no idea
what entails web games.

00:02:25.860 --> 00:02:27.510
So let's talk about
that for a minute.

00:02:27.510 --> 00:02:29.050
So first off, a web game
generally have

00:02:29.050 --> 00:02:29.850
some sort of client.

00:02:29.850 --> 00:02:33.190
The client is downloaded from a
server to the client to the

00:02:33.190 --> 00:02:36.050
end user's machine in a web
page that does some

00:02:36.050 --> 00:02:37.470
interesting things.

00:02:37.470 --> 00:02:39.960
On the end user's machine, it
usually does some sort of

00:02:39.960 --> 00:02:40.885
scripting and displays.

00:02:40.885 --> 00:02:43.650
This means code execution as
well as visual display--

00:02:43.650 --> 00:02:46.410
2D, 3D, or whatnot.

00:02:46.410 --> 00:02:48.010
In addition to that,
this is served--

00:02:48.010 --> 00:02:50.080
the client, including the
scripting data and all the

00:02:50.080 --> 00:02:51.630
information is to display--

00:02:51.630 --> 00:02:54.060
is served from some sort
of content server.

00:02:54.060 --> 00:02:55.260
This could be a web server or a

00:02:55.260 --> 00:02:56.950
scalable distributed network.

00:02:56.950 --> 00:02:58.690
And it also has some relational

00:02:58.690 --> 00:03:00.340
context to a database.

00:03:00.340 --> 00:03:02.610
This is because most people
nowadays in web gaming, they

00:03:02.610 --> 00:03:04.140
require you to log in.

00:03:04.140 --> 00:03:07.510
They store your saved game state
in the cloud somewhere--

00:03:07.510 --> 00:03:11.180
have you purchase an item, who's
your friends, have you

00:03:11.180 --> 00:03:13.480
invited this person,
what level are you.

00:03:13.480 --> 00:03:14.840
This information is
all stored in some

00:03:14.840 --> 00:03:15.970
sort of large database.

00:03:15.970 --> 00:03:18.190
And I could rattle off a bunch
of acronyms about what

00:03:18.190 --> 00:03:20.750
databases are and what databases
aren't, but we'll

00:03:20.750 --> 00:03:22.420
stick to just saying
that clients

00:03:22.420 --> 00:03:24.630
communicate with databases.

00:03:24.630 --> 00:03:26.400
Once you've got your content
server to distribute your

00:03:26.400 --> 00:03:29.040
content to your client side and
your database to sort of

00:03:29.040 --> 00:03:32.940
understand the relation to the
user and the universe that

00:03:32.940 --> 00:03:36.170
you're trying to generate, some
games also have a game

00:03:36.170 --> 00:03:36.990
play server.

00:03:36.990 --> 00:03:39.960
Now a game play server is really
the realm of what we

00:03:39.960 --> 00:03:41.790
call AAA niche gaming.

00:03:41.790 --> 00:03:44.550
So this is things like first
person shooters, real time

00:03:44.550 --> 00:03:47.650
strategy games, things that
run at 60 Hertz on some

00:03:47.650 --> 00:03:50.700
ungodly monitor that you need
some computer from the future

00:03:50.700 --> 00:03:52.900
to generally be able to run
on your local machine.

00:03:52.900 --> 00:03:55.340
These games effectively require
some piece of hardware

00:03:55.340 --> 00:03:57.990
running in some server farm
actually running the

00:03:57.990 --> 00:04:00.960
simulation of the game to keep
all of the clients in sync at

00:04:00.960 --> 00:04:02.740
the proper frequencies.

00:04:02.740 --> 00:04:04.330
Now some games require
this on the web.

00:04:04.330 --> 00:04:05.460
Some don't.

00:04:05.460 --> 00:04:07.950
But it's important to
point this out here.

00:04:07.950 --> 00:04:09.600
So once you've got this working,
sooner or later

00:04:09.600 --> 00:04:10.600
you're going to want
a social graph.

00:04:10.600 --> 00:04:12.670
This is the real power
of the web.

00:04:12.670 --> 00:04:15.020
When you start talking about
what's the difference between

00:04:15.020 --> 00:04:19.180
a web game and a console game
and a PC game that you go buy

00:04:19.180 --> 00:04:21.839
from a retailer, what you're
really looking at is that a

00:04:21.839 --> 00:04:25.040
web game gives you direct access
to a social graph in an

00:04:25.040 --> 00:04:26.740
immersive manner that
you can't get

00:04:26.740 --> 00:04:28.920
in those other relations.

00:04:28.920 --> 00:04:31.060
And then once you have all of
this, the final thing a web

00:04:31.060 --> 00:04:32.490
game does is monetize.

00:04:32.490 --> 00:04:34.920
At the end of the day, you
guys gotta make money.

00:04:34.920 --> 00:04:37.730
We've all got significant others
and mother-in-laws who

00:04:37.730 --> 00:04:39.800
say we should get real jobs
instead of making video games

00:04:39.800 --> 00:04:40.730
for a living.

00:04:40.730 --> 00:04:44.150
We want to prove them wrong by
monetizing effectively and

00:04:44.150 --> 00:04:45.860
making it rain with
dollar bills.

00:04:45.860 --> 00:04:47.293
That's sort of the goal.

00:04:47.293 --> 00:04:52.250
The good news here is that as
Google as a platform provider,

00:04:52.250 --> 00:04:57.110
we've actually got software
services in place to handle

00:04:57.110 --> 00:05:00.250
and address all of these needs
for a web game on your behalf.

00:05:00.250 --> 00:05:02.340
And the rest of the talk, we're
going to be talking

00:05:02.340 --> 00:05:04.650
about the best practices
in doing all of these

00:05:04.650 --> 00:05:05.670
items you see here.

00:05:05.670 --> 00:05:08.220
But we're going to do it from
the context of the Google

00:05:08.220 --> 00:05:10.750
services, mainly because of
well, obviously we want you to

00:05:10.750 --> 00:05:11.530
use our services.

00:05:11.530 --> 00:05:12.770
We think that they're
fantastic.

00:05:12.770 --> 00:05:16.050
But also, it just sort of gives
us a line in the sand as

00:05:16.050 --> 00:05:18.000
far as documentation
is concerned.

00:05:18.000 --> 00:05:20.900
We want to make sure that we can
provide the documentation

00:05:20.900 --> 00:05:22.970
for the ideas that we're
talking about.

00:05:22.970 --> 00:05:25.220
So then our content databases,
what we're going to talk about

00:05:25.220 --> 00:05:26.320
today is Google App Engine.

00:05:26.320 --> 00:05:29.550
It provides you both content
distribution for web pages and

00:05:29.550 --> 00:05:32.000
static data, dynamic data,
everything you need, as well

00:05:32.000 --> 00:05:33.150
as a relational database.

00:05:33.150 --> 00:05:35.010
You actually store your
table information,

00:05:35.010 --> 00:05:36.570
players and what not.

00:05:36.570 --> 00:05:38.210
For social graph, we've
got Google+.

00:05:38.210 --> 00:05:41.270
If you don't have a Google+
account, go get one now.

00:05:41.270 --> 00:05:43.270
Make sure you sign up by the
end of the talk so then you

00:05:43.270 --> 00:05:46.070
can follow me on Google+ where
I spend most of my time

00:05:46.070 --> 00:05:49.510
posting about web gaming and
Native Client development.

00:05:49.510 --> 00:05:51.970
And for monetization, we've
got this great integration

00:05:51.970 --> 00:05:55.030
point called Google Wallet which
is super easy to use.

00:05:55.030 --> 00:05:56.840
It has a lot of benefits that
we'll talk to you towards the

00:05:56.840 --> 00:05:57.730
end of the slide.

00:05:57.730 --> 00:06:00.850
In addition to these right here,
we've also got a couple

00:06:00.850 --> 00:06:02.380
others that you should be
interested in the we'll talk

00:06:02.380 --> 00:06:03.050
about today.

00:06:03.050 --> 00:06:04.440
The first is Google Analytics.

00:06:04.440 --> 00:06:08.130
Google Analytics is typically
designed as a way to track

00:06:08.130 --> 00:06:10.540
your users' movements and who
visits your website, where

00:06:10.540 --> 00:06:12.800
they come from, how they're
using your website, what's

00:06:12.800 --> 00:06:15.240
wrong, what's broken, what's
popular, and whatnot.

00:06:15.240 --> 00:06:17.580
But this could actually be
modified with a few APIs to

00:06:17.580 --> 00:06:19.080
work very well for games.

00:06:19.080 --> 00:06:20.480
We'll talk about how
you use that.

00:06:20.480 --> 00:06:21.910
And then finally is the
Chrome Web Store.

00:06:21.910 --> 00:06:26.640
Chrome Web Store is an amazing
sort of outlet that Google has

00:06:26.640 --> 00:06:29.350
launched about a year and a
half ago now that provides

00:06:29.350 --> 00:06:32.350
sort of a content discovery
portal for all things web.

00:06:32.350 --> 00:06:34.940
We've got an amazing plethora
of applications both

00:06:34.940 --> 00:06:36.280
games and not games.

00:06:36.280 --> 00:06:39.370
But if you're looking for an
amazing place for users to

00:06:39.370 --> 00:06:42.830
develop your content in a
curated, informative way,

00:06:42.830 --> 00:06:44.910
definitely check out the
Chrome Web Store.

00:06:44.910 --> 00:06:46.720
Now on this graph here you'll
notice that we don't really

00:06:46.720 --> 00:06:48.800
have a solution for
gameplay servers.

00:06:48.800 --> 00:06:52.210
And the only thing I can say
about that is stay tuned.

00:06:52.210 --> 00:06:53.010
So the rundown.

00:06:53.010 --> 00:06:55.440
So grab your coffee, grab your
laptop, grab your phone.

00:06:55.440 --> 00:06:56.790
Let's talk about what we're
going to do today.

00:06:56.790 --> 00:06:58.780
So we're going to talk about
content distribution,

00:06:58.780 --> 00:07:00.670
databases, proper
practices there.

00:07:00.670 --> 00:07:02.890
We're going to talk about login
and authentication.

00:07:02.890 --> 00:07:05.140
You'd actually be surprised
about how many problems there

00:07:05.140 --> 00:07:07.300
are with login and
authentication that make users

00:07:07.300 --> 00:07:08.360
drop off the radar.

00:07:08.360 --> 00:07:11.320
Then we're going to talk about
localization, rendering, web

00:07:11.320 --> 00:07:13.420
and platform, and
user metrics.

00:07:13.420 --> 00:07:14.700
These are all important
things.

00:07:14.700 --> 00:07:16.110
And then finally, we're going
to finish this off with

00:07:16.110 --> 00:07:17.340
monetization which--

00:07:17.340 --> 00:07:19.290
I put that at the end because
we all know you're only here

00:07:19.290 --> 00:07:20.030
to talk about monetization.

00:07:20.030 --> 00:07:23.020
The rest of this stuff
is icing on the cake.

00:07:23.020 --> 00:07:24.070
So let's talk about
serving content.

00:07:24.070 --> 00:07:26.420
Start at the beginning.

00:07:26.420 --> 00:07:28.910
So let's say all of your
data is served

00:07:28.910 --> 00:07:31.380
from some server somewhere.

00:07:31.380 --> 00:07:33.150
Your data is usually uploaded
to the web.

00:07:33.150 --> 00:07:35.250
That web creates the
information.

00:07:35.250 --> 00:07:36.030
It stores it.

00:07:36.030 --> 00:07:36.550
It scales it.

00:07:36.550 --> 00:07:37.370
It replicates it.

00:07:37.370 --> 00:07:39.460
You can see here are some
of standard items do you

00:07:39.460 --> 00:07:40.800
typically see on your server--

00:07:40.800 --> 00:07:44.420
HTML, JavaScript, images,
JSON files, ZIPs,

00:07:44.420 --> 00:07:46.270
sound files, and whatnot.

00:07:46.270 --> 00:07:48.010
What happens is that
the client--

00:07:48.010 --> 00:07:49.940
the user machine effectively--

00:07:49.940 --> 00:07:52.840
sits around and it will
generally do a page load or

00:07:52.840 --> 00:07:56.680
resource or load or from
JavaScript an XHttpRequest you

00:07:56.680 --> 00:07:57.920
can Google that and figure
out what the

00:07:57.920 --> 00:07:59.620
proper syntax is there--

00:07:59.620 --> 00:08:02.150
to fetch this data from
the internet or

00:08:02.150 --> 00:08:03.720
the server in general.

00:08:03.720 --> 00:08:05.320
The cool thing is
that Chrome--

00:08:05.320 --> 00:08:07.490
again, we're going to
focus on that--

00:08:07.490 --> 00:08:09.950
Chrome will automatically cache
anything given through

00:08:09.950 --> 00:08:10.980
this load for you.

00:08:10.980 --> 00:08:13.510
So if you actually do a page
load, Chrome will go ahead and

00:08:13.510 --> 00:08:16.090
grab the HTML and JavaScript
and JPGs and

00:08:16.090 --> 00:08:17.400
JSON data for you.

00:08:17.400 --> 00:08:19.600
If you need to grab your ZIP
files or your OGG datas,

00:08:19.600 --> 00:08:21.700
you're probably going through
some resource load or some

00:08:21.700 --> 00:08:25.510
XHttpRequest. And when you do
those, Chrome will cache that

00:08:25.510 --> 00:08:27.230
data as well.

00:08:27.230 --> 00:08:30.775
The good news about this is
that caching is automatic.

00:08:30.775 --> 00:08:32.720
You don't have to do anything
to take advantage of It.

00:08:32.720 --> 00:08:33.505
You grab your data.

00:08:33.505 --> 00:08:34.570
It's stored on the local disk.

00:08:34.570 --> 00:08:37.850
When the user requests that data
again, Chrome will check

00:08:37.850 --> 00:08:40.130
the local disk first. If it's
there, it'll grab it and load

00:08:40.130 --> 00:08:42.080
it up and use it.

00:08:42.080 --> 00:08:44.340
It it's timed out or if it
detects that there's some of

00:08:44.340 --> 00:08:46.770
the reason it needs, it'll go
back to the web and grab it

00:08:46.770 --> 00:08:47.060
from there.

00:08:47.060 --> 00:08:48.770
This is all handled
on your behalf.

00:08:48.770 --> 00:08:51.880
The bad news about this though
is that it is in fact handled

00:08:51.880 --> 00:08:54.740
on your behalf, which means that
any time during the day

00:08:54.740 --> 00:08:57.830
the user can either delete their
cache or go download 17

00:08:57.830 --> 00:08:58.950
gigs of other data.

00:08:58.950 --> 00:09:00.970
And that data will invalidate
the cache and

00:09:00.970 --> 00:09:02.070
push your stuff out.

00:09:02.070 --> 00:09:05.950
So really, you have no ability
to track when your data's

00:09:05.950 --> 00:09:08.270
going to be evicted, and how
that's going to relate to the

00:09:08.270 --> 00:09:10.520
end user experience.

00:09:10.520 --> 00:09:13.330
So the good news is modern
browsers actually implement a

00:09:13.330 --> 00:09:15.430
specific file store API.

00:09:15.430 --> 00:09:19.310
The file store API allows you
to write to a persistent

00:09:19.310 --> 00:09:22.570
obfuscated sandbox section
of the user's hard drive.

00:09:22.570 --> 00:09:24.790
Which means that when you
actually grab this data from

00:09:24.790 --> 00:09:28.280
the web, you can actually store
it somewhere so that you

00:09:28.280 --> 00:09:31.340
control the caching, so that
then you directly control the

00:09:31.340 --> 00:09:32.810
user's experience with
the caching.

00:09:32.810 --> 00:09:33.850
And that's very important.

00:09:33.850 --> 00:09:36.520
If you've got 14 gigabytes of
data sitting around, you're

00:09:36.520 --> 00:09:38.960
going to want to know how the
user is loading it and when

00:09:38.960 --> 00:09:40.710
they're loading so that you
can optimize for their

00:09:40.710 --> 00:09:41.500
experience.

00:09:41.500 --> 00:09:43.090
At the end of the day, they're
the guys give you the money.

00:09:43.090 --> 00:09:46.270
You gotta make it
right for them.

00:09:46.270 --> 00:09:47.610
So let's talk about scaling.

00:09:47.610 --> 00:09:50.090
So let's say you've made in the
most amazing game ever.

00:09:50.090 --> 00:09:53.120
It's called catfightpig.com.

00:09:53.120 --> 00:09:53.500
Whatever.

00:09:53.500 --> 00:09:54.820
I don't know.

00:09:54.820 --> 00:09:55.850
And you make this game.

00:09:55.850 --> 00:09:56.790
You put it up on the web.

00:09:56.790 --> 00:09:59.820
And then all of a sudden, you
get a million billion 100,000

00:09:59.820 --> 00:10:03.530
people that decide to download
your game and play and run it.

00:10:03.530 --> 00:10:05.710
Well, the problem is that
you've just went viral.

00:10:05.710 --> 00:10:08.480
And if you don't have a proper
scaling solution on your

00:10:08.480 --> 00:10:10.990
server side to handle the
scaling the just happened on

00:10:10.990 --> 00:10:13.560
the client side, your viral
ability is going to go through

00:10:13.560 --> 00:10:14.860
the floor really quick.

00:10:14.860 --> 00:10:17.360
So what happens is you need to
move to something like a

00:10:17.360 --> 00:10:19.710
distributable content
distribution server.

00:10:19.710 --> 00:10:22.510
So you need to find some way,
use some service out there to

00:10:22.510 --> 00:10:24.510
actually replicate your content
across all of these

00:10:24.510 --> 00:10:26.990
different servers so that it can
be handed to the clients

00:10:26.990 --> 00:10:28.130
as they request it.

00:10:28.130 --> 00:10:29.650
Now there's some great services
out there, for

00:10:29.650 --> 00:10:33.910
example Google App Engine which
will handle replication

00:10:33.910 --> 00:10:37.680
as well as regional replication
on your behalf.

00:10:37.680 --> 00:10:41.570
That means that say someone in
France is accessing your data,

00:10:41.570 --> 00:10:44.700
and you've uploaded it to
servers here in California.

00:10:44.700 --> 00:10:47.050
They're still going to get fast
access speeds to that

00:10:47.050 --> 00:10:50.280
data because Google's handled
all the back end of making

00:10:50.280 --> 00:10:53.790
sure that it exists on a web
server that's near that user

00:10:53.790 --> 00:10:55.640
so they get it at the
correct speeds.

00:10:55.640 --> 00:10:57.530
The good thing is you don't
have to worry about that.

00:10:57.530 --> 00:11:00.510
If you've just rented some web
server sitting somewhere in

00:11:00.510 --> 00:11:02.740
someone's basement, you're not
going to get the same ability.

00:11:02.740 --> 00:11:05.530
So international customers or
customers that may not have

00:11:05.530 --> 00:11:08.500
direct access to that guy's
basement, Bill's basement

00:11:08.500 --> 00:11:12.490
we'll call it, are going to
get a lower feature set.

00:11:12.490 --> 00:11:14.430
So when you're serving this
data, it's important to think

00:11:14.430 --> 00:11:16.740
about what the costs associated
with it are.

00:11:16.740 --> 00:11:18.820
Hosting data has a cost. And
let's talk about how it's

00:11:18.820 --> 00:11:19.670
being used.

00:11:19.670 --> 00:11:22.800
So today, typically developers
use loose files.

00:11:22.800 --> 00:11:23.750
They define--

00:11:23.750 --> 00:11:27.310
and this is sort of defined as
a result of the way that HTML

00:11:27.310 --> 00:11:28.540
and JavaScript works.

00:11:28.540 --> 00:11:29.570
You can simply go in there.

00:11:29.570 --> 00:11:30.420
You define an image.

00:11:30.420 --> 00:11:31.500
You define a JavaScript link.

00:11:31.500 --> 00:11:36.320
You define these as an exact
path to a resource on the web.

00:11:36.320 --> 00:11:39.640
So what happens is the browser
will effectively issue

00:11:39.640 --> 00:11:42.340
asynchronous loads for all
of these web resources.

00:11:42.340 --> 00:11:43.400
So it'll go out to
the internet.

00:11:43.400 --> 00:11:44.640
It'll say hey, please
give me this thing.

00:11:44.640 --> 00:11:46.710
Let me know once you've
received it.

00:11:46.710 --> 00:11:48.190
Now this is fantastic.

00:11:48.190 --> 00:11:50.610
This mean that the web browser
and the client are sort of

00:11:50.610 --> 00:11:54.010
optimizing the load process
based on your behalf, sending

00:11:54.010 --> 00:11:56.260
all this stuff out
and getting them.

00:11:56.260 --> 00:11:58.030
And of course, when it does
receive it, it puts it in the

00:11:58.030 --> 00:11:59.840
Chrome cache, which is
again good for you.

00:11:59.840 --> 00:12:02.100
Of course, we talked about the
Chrome cache before and all

00:12:02.100 --> 00:12:04.580
the benefits and downsides
of that.

00:12:04.580 --> 00:12:09.010
Now anyone who's shipped a game
on the PC or on console

00:12:09.010 --> 00:12:11.830
knows that archiving is a
much, much better way to

00:12:11.830 --> 00:12:12.970
handle this.

00:12:12.970 --> 00:12:15.840
Because of the fact that any
time you read from a resource

00:12:15.840 --> 00:12:16.980
or a medium--

00:12:16.980 --> 00:12:20.160
be it hard drive or CD or
even the internet--

00:12:20.160 --> 00:12:23.340
you're going to induce a lot
of bandwidth incurrence.

00:12:23.340 --> 00:12:24.750
So you're going to say
give me this load.

00:12:24.750 --> 00:12:27.290
It's going to take 10 seconds,
20 seconds, a minute, two

00:12:27.290 --> 00:12:28.310
minutes, whatever.

00:12:28.310 --> 00:12:29.960
You want to reduce that
amount of time.

00:12:29.960 --> 00:12:32.870
Now if you have tons and tons
and tons and tons of files,

00:12:32.870 --> 00:12:36.330
you may have to be blocking some
files, loading others in

00:12:36.330 --> 00:12:37.070
different orders.

00:12:37.070 --> 00:12:38.370
It just gets into madness.

00:12:38.370 --> 00:12:40.290
So what most developers do is
they'll actually zip all of

00:12:40.290 --> 00:12:42.260
this data up, or they'll archive
the information.

00:12:42.260 --> 00:12:44.560
They put all of their loose
files into a single archive,

00:12:44.560 --> 00:12:47.150
and then they download
that archive.

00:12:47.150 --> 00:12:49.900
Now once you do this though,
you have to note that the

00:12:49.900 --> 00:12:51.970
archiving of this information
is not going to come through

00:12:51.970 --> 00:12:53.000
the same paths.

00:12:53.000 --> 00:12:55.050
What you want to be doing to
make sure that this archive

00:12:55.050 --> 00:12:56.530
comes down properly
is store it in the

00:12:56.530 --> 00:12:58.390
persistent file store.

00:12:58.390 --> 00:13:00.500
And then you're going to want to
modify your runtime code so

00:13:00.500 --> 00:13:03.340
that it checks the persistent
file store for the existence

00:13:03.340 --> 00:13:05.490
of the zip first before actually
communicating with

00:13:05.490 --> 00:13:06.700
the rest of their system.

00:13:06.700 --> 00:13:07.930
So this is a benefit.

00:13:07.930 --> 00:13:10.940
This means that you are now
controlling how the assets are

00:13:10.940 --> 00:13:13.010
bundled, how they're
distributed, how they get to

00:13:13.010 --> 00:13:15.370
the user's machine, and how the
user machine responds to

00:13:15.370 --> 00:13:16.390
having them.

00:13:16.390 --> 00:13:17.710
This gives you a
lot of control.

00:13:17.710 --> 00:13:20.890
Again, this is important because
it optimizes for the

00:13:20.890 --> 00:13:21.930
user's experience.

00:13:21.930 --> 00:13:25.400
You can stream data in, you can
stream it out, et cetera.

00:13:25.400 --> 00:13:28.870
Now one of the bad sides of
archiving is twofold.

00:13:28.870 --> 00:13:31.240
First off is that you sort of
lose the ability to just

00:13:31.240 --> 00:13:32.830
randomly grab files
from the internet.

00:13:32.830 --> 00:13:34.500
You have to grab these
larger blobs.

00:13:34.500 --> 00:13:36.930
And these larger blobs then
sometimes take more time, so

00:13:36.930 --> 00:13:38.370
you have to make different
loading screens and

00:13:38.370 --> 00:13:40.310
asynchronous results and
all these other things.

00:13:40.310 --> 00:13:43.330
So you want to move towards
something called segmenting.

00:13:43.330 --> 00:13:45.090
Effectively, the idea behind
this is it you're not going to

00:13:45.090 --> 00:13:47.600
just create one large zip file
for all of your assets.

00:13:47.600 --> 00:13:50.440
You're going to create many
smaller archives.

00:13:50.440 --> 00:13:52.560
And these archives are going
to be bundle based upon

00:13:52.560 --> 00:13:54.370
different parameters
and metrics.

00:13:54.370 --> 00:13:57.500
For instance, you could say that
your original zip file is

00:13:57.500 --> 00:13:58.720
only five megs.

00:13:58.720 --> 00:14:01.330
That zip file contains
everything like the main menu

00:14:01.330 --> 00:14:03.790
and the starting guide so the
user can load your game and

00:14:03.790 --> 00:14:06.910
see a spinning character and do
their character creation.

00:14:06.910 --> 00:14:08.960
Meanwhile, it's actually
streaming in the other

00:14:08.960 --> 00:14:10.090
archive behind it.

00:14:10.090 --> 00:14:12.480
So this allows your user to get
into the game immediately,

00:14:12.480 --> 00:14:14.860
and then spend time doing
something instead of waiting

00:14:14.860 --> 00:14:17.090
for the loading bar to get
all their data in there.

00:14:17.090 --> 00:14:21.900
Another reason to segment your
assets is due to monetization.

00:14:21.900 --> 00:14:25.120
So let's say that your
particular game where you sell

00:14:25.120 --> 00:14:28.210
chunks of game content in
one gigabyte bursts.

00:14:28.210 --> 00:14:30.920
So chapter five, chapter
six, chapter seven.

00:14:30.920 --> 00:14:33.210
And there's a large demand for
each one of those from a

00:14:33.210 --> 00:14:34.510
monetization standpoint.

00:14:34.510 --> 00:14:35.610
What you're going to want to do
is you're going to want to

00:14:35.610 --> 00:14:38.370
segment each of those in two
separate monetization

00:14:38.370 --> 00:14:42.090
categories so that you don't
stream that data to the user

00:14:42.090 --> 00:14:43.990
until they've actually
paid you for it.

00:14:43.990 --> 00:14:47.070
Again, hosting and streaming
cost something.

00:14:47.070 --> 00:14:49.610
So you want to optimize the
content that you're streaming

00:14:49.610 --> 00:14:52.180
to the user based upon whether
or not they've paid you.

00:14:52.180 --> 00:14:54.600
You don't want to have a 15
gigabyte game, stream it all

00:14:54.600 --> 00:14:56.650
of the user, and only
have 2% of those

00:14:56.650 --> 00:14:57.700
users actually convert.

00:14:57.700 --> 00:14:59.060
That means you're going to be
wasting a lot of money.

00:14:59.060 --> 00:15:01.060
It doesn't make sense.

00:15:01.060 --> 00:15:05.400
With this though, you're going
to need some sort of manifest

00:15:05.400 --> 00:15:08.270
file because the final cool
thing about archiving and some

00:15:08.270 --> 00:15:11.330
sort of segmented set up is
you actually need a way to

00:15:11.330 --> 00:15:14.880
define what zips are invalid
and not invalid from the

00:15:14.880 --> 00:15:16.230
persistent file store.

00:15:16.230 --> 00:15:18.995
So the user will go grab a zip
from the net, they'll store it

00:15:18.995 --> 00:15:21.570
to the local persistent store,
and then you go upload a new

00:15:21.570 --> 00:15:23.930
zip because you've made balance
changes or whatnot.

00:15:23.930 --> 00:15:26.930
Now the user needs the ability
to query some sort of file

00:15:26.930 --> 00:15:28.960
that says whether or not that
zip is out of date.

00:15:28.960 --> 00:15:30.600
So that way, they say hey,
this is out of date.

00:15:30.600 --> 00:15:32.800
We need to go fetch it from
the server and update our

00:15:32.800 --> 00:15:34.190
local cache view.

00:15:34.190 --> 00:15:36.270
So basically you want to segment
all of your stuff

00:15:36.270 --> 00:15:38.860
based upon game resources,
monetization resources, and

00:15:38.860 --> 00:15:41.530
then create some sort of
manifest file that allows the

00:15:41.530 --> 00:15:44.910
client machine to keep
up with that data.

00:15:44.910 --> 00:15:47.040
Now let's talk about Google
App Engine specifically.

00:15:47.040 --> 00:15:49.020
Let's just focus on that for a
minute and say that that's

00:15:49.020 --> 00:15:50.970
where you're hosting
your concept.

00:15:50.970 --> 00:15:52.140
So you can store your segmented

00:15:52.140 --> 00:15:53.130
binary archives here.

00:15:53.130 --> 00:15:54.320
That's fantastic.

00:15:54.320 --> 00:15:56.910
This allows you to carefully
control your server costs.

00:15:56.910 --> 00:16:00.160
Again, this is a metric that
matters to you because how

00:16:00.160 --> 00:16:02.150
you're serving your data
directly relates to how much

00:16:02.150 --> 00:16:04.970
it costs you to serve
that data.

00:16:04.970 --> 00:16:07.620
Google App Engine allows you
to store any asset that's

00:16:07.620 --> 00:16:12.170
under 32 megabytes HTML style
or sort of direct store.

00:16:12.170 --> 00:16:14.500
Which means you just upload it
and it's no big deal and it's

00:16:14.500 --> 00:16:16.400
stored just like
any other file.

00:16:16.400 --> 00:16:19.110
It's sort of seamless
integration for you.

00:16:19.110 --> 00:16:21.430
You can read the documentation
on how exactly that works.

00:16:21.430 --> 00:16:24.150
For anything above 32 megabytes
though, you have to

00:16:24.150 --> 00:16:26.140
store it from a different
file store and that's

00:16:26.140 --> 00:16:27.110
the blobstore API.

00:16:27.110 --> 00:16:29.070
Now it's still hosted on Google
App Engine, but you

00:16:29.070 --> 00:16:31.130
have to use a separate
API to access it.

00:16:31.130 --> 00:16:32.690
And this is again really
important.

00:16:32.690 --> 00:16:35.710
This sort of forces you to
optimize how you're getting

00:16:35.710 --> 00:16:38.630
your data, because there may
be tiered costs available.

00:16:38.630 --> 00:16:41.060
There may be specifics streaming
solutions you need

00:16:41.060 --> 00:16:41.960
to be aware of.

00:16:41.960 --> 00:16:44.400
This is important stuff.

00:16:44.400 --> 00:16:46.560
Also for that, you need
to set the browser

00:16:46.560 --> 00:16:47.900
cache expiration date.

00:16:47.900 --> 00:16:51.330
So any of this binary data
that's served from Google App

00:16:51.330 --> 00:16:53.900
Engine, when it hits the
client, the client's

00:16:53.900 --> 00:16:55.770
effectively going to
say here's how long

00:16:55.770 --> 00:16:57.140
this data is valid.

00:16:57.140 --> 00:16:59.380
Here's how long I think you
should keep this around.

00:16:59.380 --> 00:17:02.850
So the cache then has this large
amazing metric that says

00:17:02.850 --> 00:17:06.050
hey, all of these items in the
cache, they've expired, they

00:17:06.050 --> 00:17:09.030
can be expelled to bring
new data in.

00:17:09.030 --> 00:17:13.200
You can actually set the browser
time for that file.

00:17:13.200 --> 00:17:15.380
And if you click that link
there, you can actually set it

00:17:15.380 --> 00:17:16.619
to be some larger time.

00:17:16.619 --> 00:17:18.880
I think the default is
actually 10 minutes.

00:17:18.880 --> 00:17:21.800
So that means for a user playing
your game, let's say

00:17:21.800 --> 00:17:24.000
there's 56 hours of game play.

00:17:24.000 --> 00:17:27.089
If you don't set this particular
header for the data

00:17:27.089 --> 00:17:29.600
that's served to your client,
that means that the client,

00:17:29.600 --> 00:17:32.440
the browser, Chrome, the cache,
will say that after 10

00:17:32.440 --> 00:17:34.620
minutes, all that data can be
invalidated and flushed to

00:17:34.620 --> 00:17:35.190
something else.

00:17:35.190 --> 00:17:37.090
Now if you're using the
persistent file store, this

00:17:37.090 --> 00:17:38.710
shouldn't necessarily
be a big deal.

00:17:38.710 --> 00:17:41.300
But in some cases it's
still smart to set

00:17:41.300 --> 00:17:43.730
that expiration date.

00:17:43.730 --> 00:17:46.060
This brings us to a public
service announcement.

00:17:46.060 --> 00:17:50.880
Do not use the existence of data
on the user's machine to

00:17:50.880 --> 00:17:54.680
represent that the user has
purchased that data.

00:17:54.680 --> 00:17:57.230
So anyone in here who has
handled any sort of problems

00:17:57.230 --> 00:18:00.990
with piracy for video games
knows this to be true.

00:18:00.990 --> 00:18:04.190
Effectively, if a user purchases
your item and then

00:18:04.190 --> 00:18:08.060
refunds that purchase and the
item's data has been streamed

00:18:08.060 --> 00:18:11.410
to them and stored on disk and
the user who loads your game

00:18:11.410 --> 00:18:13.770
up, what happens?

00:18:13.770 --> 00:18:17.070
If your code actually goes
through and says, oh the sword

00:18:17.070 --> 00:18:18.610
of Antioch exists
on your desk.

00:18:18.610 --> 00:18:20.390
You must have access to it.

00:18:20.390 --> 00:18:22.300
Then the user could effectively
buy all the items,

00:18:22.300 --> 00:18:24.540
get them all downloaded, return
all the items. You

00:18:24.540 --> 00:18:26.580
don't get any money, but they
get all the free stuff.

00:18:26.580 --> 00:18:27.300
That's not good.

00:18:27.300 --> 00:18:28.840
You want to make sure that
you don't do it that way.

00:18:28.840 --> 00:18:29.870
So public service
announcement.

00:18:29.870 --> 00:18:31.915
Do not use the existence of
the data on the disc that

00:18:31.915 --> 00:18:34.310
you've streamed to the user to
represent the fact that the

00:18:34.310 --> 00:18:35.860
user has bought the item.

00:18:35.860 --> 00:18:36.590
Just don't do it.

00:18:36.590 --> 00:18:39.870
It's madness.

00:18:39.870 --> 00:18:41.120
Let's talk about databases.

00:18:43.200 --> 00:18:45.360
This is again correlated
databases, so

00:18:45.360 --> 00:18:48.130
not like binary databases.

00:18:48.130 --> 00:18:51.600
So App Engine has relational
databases using

00:18:51.600 --> 00:18:53.230
the GQL query language.

00:18:53.230 --> 00:18:55.470
And if you click on the GQL
link, it'll take you to a nice

00:18:55.470 --> 00:18:58.080
amazing page that talks about
the syntax, how to use it, how

00:18:58.080 --> 00:18:58.680
not to use it.

00:18:58.680 --> 00:19:01.310
It also gives you great in-depth
examples about how to

00:19:01.310 --> 00:19:03.570
get started using it and all
these amazing things.

00:19:03.570 --> 00:19:05.540
As far as app Engine is
concerned, it really gives you

00:19:05.540 --> 00:19:08.710
the trifecta of hosting data,
hosting content, and also

00:19:08.710 --> 00:19:11.040
giving you database.

00:19:11.040 --> 00:19:13.990
The cool thing too is it
auto-scales to handle demand.

00:19:13.990 --> 00:19:16.590
This is the most important
thing.

00:19:16.590 --> 00:19:19.650
Let's say that you go a year and
a half of having your app

00:19:19.650 --> 00:19:21.490
online and nobody
downloads it.

00:19:21.490 --> 00:19:25.540
Then one day, you add in a cat
with a really cool pink wizard

00:19:25.540 --> 00:19:27.490
hat, then all of a sudden
the entire internet has

00:19:27.490 --> 00:19:28.760
to have your game.

00:19:28.760 --> 00:19:31.190
When the entire internet starts
knocking on your door,

00:19:31.190 --> 00:19:33.440
the servers for Google App
Engine will scale up

00:19:33.440 --> 00:19:35.340
dynamically to handle
that balance load.

00:19:35.340 --> 00:19:37.140
You don't have to do anything.

00:19:37.140 --> 00:19:38.620
If you've rented your
own servers, this

00:19:38.620 --> 00:19:39.950
is a massive problem.

00:19:39.950 --> 00:19:42.530
All of a sudden you need to
employ five IT guys and six

00:19:42.530 --> 00:19:45.480
more server racks and buy all
this hardware that then in

00:19:45.480 --> 00:19:47.220
another month you
may not need.

00:19:47.220 --> 00:19:49.220
So you've invested a lot of
sunk cost into something

00:19:49.220 --> 00:19:51.980
that's pretty much seasonal.

00:19:51.980 --> 00:19:53.250
The fact that App
Engine handles

00:19:53.250 --> 00:19:55.230
that for you is amazing.

00:19:55.230 --> 00:19:58.090
Of course, the cost is based
upon performance here.

00:19:58.090 --> 00:20:01.060
So this means that as more users
are using your service

00:20:01.060 --> 00:20:03.560
and monetizing through you
service, of course the cost

00:20:03.560 --> 00:20:04.240
goes up a little bit.

00:20:04.240 --> 00:20:06.410
The goal is to make sure that
the ratio between these two is

00:20:06.410 --> 00:20:09.280
always set in your favor.

00:20:09.280 --> 00:20:11.690
And to do this, to make sure
of this the first thing you

00:20:11.690 --> 00:20:12.940
need to do is make
sure the set the

00:20:12.940 --> 00:20:15.380
cache-time for any GET responses.

00:20:15.380 --> 00:20:17.440
And now a GET response on the
internet for those of you

00:20:17.440 --> 00:20:19.150
haven't used it, you
get effectively a

00:20:19.150 --> 00:20:21.540
POST and GET reset--

00:20:21.540 --> 00:20:26.410
a POST and GET message is
defined as either querying

00:20:26.410 --> 00:20:29.520
data from some database or
server or page versus setting

00:20:29.520 --> 00:20:31.820
data to that server or
database or page.

00:20:31.820 --> 00:20:34.170
Now again, a GET effectively
is a pull request.

00:20:34.170 --> 00:20:36.450
So what's occurring here
is that you're pulling

00:20:36.450 --> 00:20:38.340
information from Google
App Engine.

00:20:38.340 --> 00:20:41.690
And what's happening is when you
requests that data, Google

00:20:41.690 --> 00:20:44.340
App Engine will go find
that data, say OK,

00:20:44.340 --> 00:20:45.490
this result has occurred.

00:20:45.490 --> 00:20:48.670
I'm going to cache this away
in case this user or a next

00:20:48.670 --> 00:20:51.690
user or someone else goes and
tries to fetch the same data.

00:20:51.690 --> 00:20:54.000
If it finds it in its cache
automatically, it'll go ahead

00:20:54.000 --> 00:20:55.610
and return that data for you.

00:20:55.610 --> 00:20:58.920
But you need to set the
cache-time for that.

00:20:58.920 --> 00:21:02.190
Otherwise much like the Chrome
cache in the client's machine,

00:21:02.190 --> 00:21:03.740
it'll evict it based
upon duration.

00:21:03.740 --> 00:21:05.630
So here's how to do
that in Python.

00:21:05.630 --> 00:21:08.240
Again, there's great links on
the intertubes about how to do

00:21:08.240 --> 00:21:09.150
this directly.

00:21:09.150 --> 00:21:10.280
So we create a date object.

00:21:10.280 --> 00:21:13.580
We set it to a specific age
way, way in the future.

00:21:13.580 --> 00:21:16.170
And then in our response packet
that Google App Engine

00:21:16.170 --> 00:21:18.850
provides to the client, we
actually set the maximum age

00:21:18.850 --> 00:21:21.400
for that data to some
large metric.

00:21:21.400 --> 00:21:23.120
So this allows the clients
to then cache it on

00:21:23.120 --> 00:21:23.810
their side, as well.

00:21:23.810 --> 00:21:25.890
Which is good because then the
client says hey, I'm going to

00:21:25.890 --> 00:21:26.780
query the same data.

00:21:26.780 --> 00:21:28.010
I don't even have to
go to the internet.

00:21:28.010 --> 00:21:30.860
I just grab it locally.

00:21:30.860 --> 00:21:33.290
This brings us to the next point
is using Memcache which

00:21:33.290 --> 00:21:34.840
is on the server side of that.

00:21:34.840 --> 00:21:36.690
Click the link, get
more information.

00:21:36.690 --> 00:21:39.510
Memcache is effectively intended
for fast access to

00:21:39.510 --> 00:21:40.510
cache results of queries.

00:21:40.510 --> 00:21:43.110
Now again, you've got 100
million users all hitting your

00:21:43.110 --> 00:21:45.800
Google App Engine instance at
one time, all querying data,

00:21:45.800 --> 00:21:47.250
all grabbing it from different
directions.

00:21:47.250 --> 00:21:50.250
It would be great if you were
able to analyze that and

00:21:50.250 --> 00:21:52.940
figure out what the most common
things are and then

00:21:52.940 --> 00:21:54.320
optimize different
sets for that.

00:21:54.320 --> 00:21:56.710
Now if you don't have that
ability your or the stuff is

00:21:56.710 --> 00:21:58.910
just too far across the map,
then you want to use something

00:21:58.910 --> 00:22:01.010
called Memcache.

00:22:01.010 --> 00:22:02.360
And Memcache works like this.

00:22:02.360 --> 00:22:05.770
Effectively you test whether or
not the Memcache has some

00:22:05.770 --> 00:22:06.970
specific data.

00:22:06.970 --> 00:22:09.880
If it has the data, then
you return that data.

00:22:09.880 --> 00:22:12.710
So let's say the user says I
want to find out how many

00:22:12.710 --> 00:22:15.960
people are playing the game
right now in Argentina.

00:22:15.960 --> 00:22:19.030
And you store that
in into Memcache.

00:22:19.030 --> 00:22:20.750
It's already there, so you
return the number of people

00:22:20.750 --> 00:22:22.130
playing the game in Argentina.

00:22:22.130 --> 00:22:23.970
If it doesn't exist--
if the data hasn't

00:22:23.970 --> 00:22:25.180
been stored in Memcache--

00:22:25.180 --> 00:22:27.540
then you actually get the data,
find out how many people

00:22:27.540 --> 00:22:30.100
are playing, store it into
Memcache, and then return it

00:22:30.100 --> 00:22:30.800
to the user.

00:22:30.800 --> 00:22:32.560
So this means the next person
that comes through the says

00:22:32.560 --> 00:22:34.880
hey, I'm in Argentina, find the
number of people playing,

00:22:34.880 --> 00:22:36.110
it'll return the
proper result.

00:22:36.110 --> 00:22:38.460
And of course, there's a lot of
amazing things behind the

00:22:38.460 --> 00:22:41.050
scenes about what happens when
that data changes without them

00:22:41.050 --> 00:22:42.410
knowing about it, things
like that.

00:22:42.410 --> 00:22:44.360
We aren't going to
get into that.

00:22:44.360 --> 00:22:45.840
Click the link, learn more.

00:22:45.840 --> 00:22:46.525
Expand your horizons.

00:22:46.525 --> 00:22:49.510
Learn some new stuff today.

00:22:49.510 --> 00:22:53.320
So most of your clients will
again as we talked about have

00:22:53.320 --> 00:22:54.740
some sort of networked
component.

00:22:54.740 --> 00:22:56.870
You're going to want to
communicate with other players

00:22:56.870 --> 00:22:58.140
is the basic multiplayer
thing.

00:22:58.140 --> 00:22:58.840
You're on the internet.

00:22:58.840 --> 00:23:00.060
You want to play with
other people.

00:23:00.060 --> 00:23:02.080
Social is more fun.

00:23:02.080 --> 00:23:03.310
So there's one technique
to do.

00:23:03.310 --> 00:23:05.870
This is called polling, which
is effectively where each

00:23:05.870 --> 00:23:08.560
client that's connected to a
service will actually poll the

00:23:08.560 --> 00:23:10.490
server and say hey, has
anything changed.

00:23:10.490 --> 00:23:12.430
If something's changed, the
server pushes the data to the

00:23:12.430 --> 00:23:14.130
client through the request
process, and

00:23:14.130 --> 00:23:15.470
everyone moves forward.

00:23:15.470 --> 00:23:19.030
The problem with this is that
for low latency games, games

00:23:19.030 --> 00:23:22.260
where things only update once
every 5 minutes, 10 minutes,

00:23:22.260 --> 00:23:24.490
30 seconds, something like that,
you're going to spend a

00:23:24.490 --> 00:23:27.040
lot of time asking the server
for things effectively

00:23:27.040 --> 00:23:29.490
clogging your pipe,
upping your cost,

00:23:29.490 --> 00:23:31.550
et cetera, et cetera.

00:23:31.550 --> 00:23:34.130
And this can be avoided by using
something on Google App

00:23:34.130 --> 00:23:35.740
Engine called the Channel API.

00:23:35.740 --> 00:23:38.720
The Channel API effectively
allows your client to

00:23:38.720 --> 00:23:42.330
communicate the server and open
a pipe that stays open.

00:23:42.330 --> 00:23:44.990
So then the server when data
does change, like the number

00:23:44.990 --> 00:23:47.560
of players in Argentina, that
when that does change, the

00:23:47.560 --> 00:23:49.730
server tells the client hey,
this data has changed.

00:23:49.730 --> 00:23:51.440
I need you to update
on your side.

00:23:51.440 --> 00:23:53.910
This allows your client your
server to communicate only

00:23:53.910 --> 00:23:55.310
when they have to.

00:23:55.310 --> 00:23:56.970
And this is a good,
good thing.

00:23:56.970 --> 00:23:59.700
Because this means that your
overhead for communication is

00:23:59.700 --> 00:24:02.530
low, the amount of cost
spent on transfer and

00:24:02.530 --> 00:24:02.865
bandwidth is low.

00:24:02.865 --> 00:24:04.930
This Is a fantastic thing.

00:24:04.930 --> 00:24:07.110
One of the downsides with the
Channel API right now is that

00:24:07.110 --> 00:24:09.060
it can only communicate
with JavaScript.

00:24:09.060 --> 00:24:11.470
So this is really highlighted
and designed for

00:24:11.470 --> 00:24:12.910
web games in general.

00:24:12.910 --> 00:24:15.310
For those of you who want to
communicate with the Channel

00:24:15.310 --> 00:24:19.250
API on Google App Engine and
using C++ or some other sort

00:24:19.250 --> 00:24:22.130
of language, it's worth noting
that the Channel API is

00:24:22.130 --> 00:24:26.360
actually based upon a protocol
called XMPP.

00:24:26.360 --> 00:24:28.310
And effectively it wraps all
the communication and

00:24:28.310 --> 00:24:30.720
handshaking up into JavaScript
and provides a JavaScript

00:24:30.720 --> 00:24:31.600
library to you.

00:24:31.600 --> 00:24:34.490
Now if you are so inclined that
you would like to use

00:24:34.490 --> 00:24:37.980
this technology, feel free to
actually deconstruct what the

00:24:37.980 --> 00:24:39.680
JavaScript is wrapping and
figure out the proper

00:24:39.680 --> 00:24:41.520
handshakes and message
passing.

00:24:41.520 --> 00:24:42.900
That's up to you.

00:24:42.900 --> 00:24:45.630
I have talked with some people
and don't see any particular

00:24:45.630 --> 00:24:47.080
wrappers for different languages
in the pipe.

00:24:47.080 --> 00:24:48.530
But if there's a lot of
user demand, maybe

00:24:48.530 --> 00:24:49.260
we can change that.

00:24:49.260 --> 00:24:50.410
So email me.

00:24:50.410 --> 00:24:52.340
I'm here to help.

00:24:52.340 --> 00:24:53.490
Login and authentication.

00:24:53.490 --> 00:24:55.770
This is a pain point.

00:24:55.770 --> 00:25:00.220
So how many of you in here got
wanted to play a game and then

00:25:00.220 --> 00:25:03.970
as soon as it asks you to log
in or create an account, you

00:25:03.970 --> 00:25:06.000
just shut the game off.

00:25:06.000 --> 00:25:07.090
That's barrier zero.

00:25:07.090 --> 00:25:09.050
Like man, I just want
to play this game.

00:25:09.050 --> 00:25:10.130
Why do you need my data?

00:25:10.130 --> 00:25:11.430
I don't want to give
you my information.

00:25:11.430 --> 00:25:13.560
I'm afraid what you're going to
do with it or I don't want

00:25:13.560 --> 00:25:14.550
to get spammed.

00:25:14.550 --> 00:25:16.630
So let's talk about best
practices for login and

00:25:16.630 --> 00:25:18.560
authentication.

00:25:18.560 --> 00:25:20.020
So everyone's seen this.

00:25:20.020 --> 00:25:21.520
This is a standard login.

00:25:21.520 --> 00:25:22.330
Please login.

00:25:22.330 --> 00:25:24.940
If you don't have an account,
click here to create one.

00:25:24.940 --> 00:25:28.130
The problem is, your website
may have that, but so every

00:25:28.130 --> 00:25:29.020
other site on the internet.

00:25:29.020 --> 00:25:31.070
Everyone says I want to
create your login.

00:25:31.070 --> 00:25:32.180
I want to create an account.

00:25:32.180 --> 00:25:34.480
I want to hold user information,
et cetera.

00:25:34.480 --> 00:25:36.240
This is not beneficial
for the user.

00:25:36.240 --> 00:25:38.120
The user does not want
to come to your page

00:25:38.120 --> 00:25:38.900
to create an account.

00:25:38.900 --> 00:25:40.410
That's not the reason
they're there.

00:25:40.410 --> 00:25:41.960
The reason they're there
is to play your game.

00:25:41.960 --> 00:25:44.530
And you want to reduce the
barrier to that, because that

00:25:44.530 --> 00:25:46.070
means you'll get more money.

00:25:46.070 --> 00:25:48.860
So the goal here is rather than
asking the user to create

00:25:48.860 --> 00:25:52.350
an account, allow them to use an
existing account to login.

00:25:52.350 --> 00:25:54.720
And there's some great
technologies out there that

00:25:54.720 --> 00:25:55.170
allow this.

00:25:55.170 --> 00:25:56.185
One of them is OpenID.

00:25:56.185 --> 00:25:58.540
I'm going to talk about OpenID
here for a second.

00:25:58.540 --> 00:26:00.710
OpenID effectively
allows you--

00:26:00.710 --> 00:26:02.810
it's effectively
a decentralized

00:26:02.810 --> 00:26:04.030
authentication service.

00:26:04.030 --> 00:26:08.080
So the user can effectively use
multiple different logins

00:26:08.080 --> 00:26:09.410
to access your account.

00:26:09.410 --> 00:26:11.900
And effectively what occurs here
is the user will click

00:26:11.900 --> 00:26:14.340
their given account provider
that they want--

00:26:14.340 --> 00:26:16.840
Google, Yahoo, Blogger,
something like that.

00:26:16.840 --> 00:26:17.950
They'll click sign in.

00:26:17.950 --> 00:26:21.100
Sign in auto-direct the user
to another page handled by

00:26:21.100 --> 00:26:22.430
those providers.

00:26:22.430 --> 00:26:24.920
Authentication will occur
on their side.

00:26:24.920 --> 00:26:27.610
You will then get a proper
result saying did they pass or

00:26:27.610 --> 00:26:28.130
did they fail.

00:26:28.130 --> 00:26:29.950
So you don't even have to handle
all the handshaking.

00:26:29.950 --> 00:26:32.380
All you have to do is provide
the link, the information, let

00:26:32.380 --> 00:26:33.490
them let them handle it.

00:26:33.490 --> 00:26:34.830
This is fantastic.

00:26:34.830 --> 00:26:36.770
This means you get ti take all
of those different dialogues

00:26:36.770 --> 00:26:37.580
and bring them down.

00:26:37.580 --> 00:26:40.840
So the user can use something
they already have to login.

00:26:40.840 --> 00:26:41.710
Reduction of barriers.

00:26:41.710 --> 00:26:43.870
It's what we're all about.

00:26:43.870 --> 00:26:47.140
Now how this works with your
side though is that when the

00:26:47.140 --> 00:26:49.500
user logs in with one of these
other services or through

00:26:49.500 --> 00:26:52.240
OpenID, it's going to hand you
an authentication key.

00:26:52.240 --> 00:26:55.030
It's going to say here's
the GUID for this user.

00:26:55.030 --> 00:26:59.330
Now it's important that you do
not pass this user ID around

00:26:59.330 --> 00:27:00.190
sort of willynilly.

00:27:00.190 --> 00:27:01.990
This is a very important
concept here.

00:27:01.990 --> 00:27:04.200
So you're going to have your
relational data table here,

00:27:04.200 --> 00:27:05.650
and you're going to receive
that auth key.

00:27:05.650 --> 00:27:07.360
The problem is you're also going
to receive the auth key

00:27:07.360 --> 00:27:09.540
probably for a number of other
providers as well.

00:27:09.540 --> 00:27:11.810
So let's say you really want
to go the gamut here.

00:27:11.810 --> 00:27:14.090
You're allow the user to use
login their Google+ ID, with

00:27:14.090 --> 00:27:16.620
their Facebook ID, with their
Apple ID, and all these other

00:27:16.620 --> 00:27:17.460
sorts of things.

00:27:17.460 --> 00:27:20.660
You're going to have unique
IDs populating this table.

00:27:20.660 --> 00:27:22.570
So the question is there, if
you're going to hand those

00:27:22.570 --> 00:27:24.350
keys around, which one
do you pass around?

00:27:24.350 --> 00:27:25.370
Is the first one they uses?

00:27:25.370 --> 00:27:26.480
Is it the last one they use?

00:27:26.480 --> 00:27:29.560
It is some MD5 hash of all
the things concatenated.

00:27:29.560 --> 00:27:30.200
No.

00:27:30.200 --> 00:27:31.360
The better way to do
this is to actually

00:27:31.360 --> 00:27:32.650
create a user game key.

00:27:32.650 --> 00:27:35.200
So the first time the user logs
into your service, if

00:27:35.200 --> 00:27:38.180
their unique ID in some way,
shape, or form doesn't exist

00:27:38.180 --> 00:27:40.070
already in the database, go
ahead and create one and

00:27:40.070 --> 00:27:41.710
create a new user key.

00:27:41.710 --> 00:27:43.650
You want to use that
user key everywhere

00:27:43.650 --> 00:27:44.710
else in your database.

00:27:44.710 --> 00:27:47.630
So if you've got your primary
player information, the number

00:27:47.630 --> 00:27:51.070
of games they have, their
friends list, this should all

00:27:51.070 --> 00:27:54.030
be sorted by the game key that's
unique to your game,

00:27:54.030 --> 00:27:57.180
not the key that's unique to
their authentication provider.

00:27:57.180 --> 00:27:59.600
It's very important for you.

00:27:59.600 --> 00:28:01.670
In addition to this, this
is actually sort of an

00:28:01.670 --> 00:28:04.370
interesting concept that people
go back and forth on.

00:28:04.370 --> 00:28:06.690
On one side you, want to reduce
the barrier to the user

00:28:06.690 --> 00:28:09.110
logging into your service
because you want to make sure

00:28:09.110 --> 00:28:10.970
to make sure that they get
there, they get to play in the

00:28:10.970 --> 00:28:13.610
game, and they get the service
benefits from logging in that

00:28:13.610 --> 00:28:14.840
you provide for them.

00:28:14.840 --> 00:28:17.830
On the other side though, you
want to create a massive

00:28:17.830 --> 00:28:18.920
amount of security.

00:28:18.920 --> 00:28:22.380
I think one of the constant news
articles you have always

00:28:22.380 --> 00:28:24.430
showing up on the internet
is my account

00:28:24.430 --> 00:28:26.490
got hacked by blank.

00:28:26.490 --> 00:28:28.000
People are constantly losing
their accounts.

00:28:28.000 --> 00:28:29.490
They're constantly
losing their game

00:28:29.490 --> 00:28:30.810
progress, their servers.

00:28:30.810 --> 00:28:34.250
And within in-app purchase being
sort of where it is and

00:28:34.250 --> 00:28:38.490
the dominating force it has in
the monetization realm right

00:28:38.490 --> 00:28:41.400
now, you want to make sure that
users have a secure way

00:28:41.400 --> 00:28:44.160
of logging into your game and
keeping their content secure,

00:28:44.160 --> 00:28:46.990
so that their sister or their
brother or their angry ex

00:28:46.990 --> 00:28:49.500
doesn't go and do something
malicious.

00:28:49.500 --> 00:28:52.860
So one way to do this is
two-step security How this

00:28:52.860 --> 00:28:55.580
works is that the user logs in
with their first ID, so their

00:28:55.580 --> 00:28:56.850
username and the password.

00:28:56.850 --> 00:29:00.150
And they're then prompted to
enter a verification code

00:29:00.150 --> 00:29:02.150
generated by some application.

00:29:02.150 --> 00:29:04.180
Now this application could come
in many forms. It could

00:29:04.180 --> 00:29:08.830
be a key ring that has
information associated to it.

00:29:08.830 --> 00:29:10.840
It can come from your mobile
phone, et cetera, et cetera.

00:29:10.840 --> 00:29:13.770
But the purpose is that the user
has to then authenticate

00:29:13.770 --> 00:29:17.400
with a random number that's
generated on some time series.

00:29:17.400 --> 00:29:20.770
So for you or random person to
access someone else's account

00:29:20.770 --> 00:29:23.400
that has two-step authentication
set up, you not

00:29:23.400 --> 00:29:25.400
only have to have their
username, but you have to have

00:29:25.400 --> 00:29:27.790
their password as well, and you
have to have their mobile

00:29:27.790 --> 00:29:31.910
phone and be able to get access
in their mobile phone

00:29:31.910 --> 00:29:33.980
to that program that actually
provides this key.

00:29:33.980 --> 00:29:36.970
Now this is pretty good security
across the board.

00:29:36.970 --> 00:29:40.700
The good news is for you that
you can set up this service on

00:29:40.700 --> 00:29:43.840
your web server and on your
account for free and use it

00:29:43.840 --> 00:29:46.390
for free, and provide it
to your users for free.

00:29:46.390 --> 00:29:48.350
Really there's no reason
to not allow this.

00:29:48.350 --> 00:29:49.710
Now don't force it.

00:29:49.710 --> 00:29:51.820
Allow your users to decide
if they want it or not.

00:29:51.820 --> 00:29:53.680
But there's no reason
to not do it.

00:29:53.680 --> 00:29:55.000
In fact there's a great link
here at the bottom.

00:29:55.000 --> 00:29:57.740
If you click that, it'll take to
page that has a JavaScript

00:29:57.740 --> 00:30:00.280
implementation, a server side
implementation, and actually

00:30:00.280 --> 00:30:03.060
shows you how to put the whole
thing together within like 20

00:30:03.060 --> 00:30:03.870
minutes of work.

00:30:03.870 --> 00:30:05.100
Now that's fantastic.

00:30:05.100 --> 00:30:07.890
And the cool thing is they can
use their existing Google

00:30:07.890 --> 00:30:10.540
authenticator application on
their iPhone or their Android

00:30:10.540 --> 00:30:12.035
phone, so they could
use your service.

00:30:12.035 --> 00:30:14.210
It's a great thing to do.

00:30:14.210 --> 00:30:15.860
Localization.

00:30:15.860 --> 00:30:17.180
This is a big one.

00:30:17.180 --> 00:30:18.170
Console developers.

00:30:18.170 --> 00:30:21.520
Let's see your hands if you've
ever ran into problems with

00:30:21.520 --> 00:30:22.640
localization.

00:30:22.640 --> 00:30:23.260
Everyone.

00:30:23.260 --> 00:30:23.900
Exactly.

00:30:23.900 --> 00:30:26.320
It's not a big deal.

00:30:26.320 --> 00:30:27.500
Localizing matters.

00:30:27.500 --> 00:30:29.890
And this should matter more as
a web game than any sort of

00:30:29.890 --> 00:30:32.220
console developer or any
PC developer has

00:30:32.220 --> 00:30:33.670
ever told you before.

00:30:33.670 --> 00:30:36.380
There are big markets
internationally.

00:30:36.380 --> 00:30:39.970
We've seen some games monetize
horribly in the States that

00:30:39.970 --> 00:30:42.530
completely blew up in Europe.

00:30:42.530 --> 00:30:44.310
Like David Hasselhoff.

00:30:44.310 --> 00:30:47.440
No one bought this guy's musical
album in America.

00:30:47.440 --> 00:30:50.750
But for some reason,
he's a pop diva in

00:30:50.750 --> 00:30:51.740
Europe and in Germany.

00:30:51.740 --> 00:30:52.480
I don't get.

00:30:52.480 --> 00:30:53.330
I didn't like his music.

00:30:53.330 --> 00:30:54.210
I listened to it.

00:30:54.210 --> 00:30:57.420
It wasn't for me, but
hey, I'm this guy.

00:30:57.420 --> 00:31:00.860
So the fact is that if you're
going actually take your game

00:31:00.860 --> 00:31:03.100
and move it into these markets
to try to capitalize on the

00:31:03.100 --> 00:31:06.330
monetization opportunities
there, the first step you need

00:31:06.330 --> 00:31:07.830
to look at is language.

00:31:07.830 --> 00:31:11.370
Your game has a certain amount
of strings or certain amount

00:31:11.370 --> 00:31:13.850
of text that's being prompted
to the user.

00:31:13.850 --> 00:31:14.610
You've got menus.

00:31:14.610 --> 00:31:15.420
You got dialogues.

00:31:15.420 --> 00:31:16.680
You've got item descriptions.

00:31:16.680 --> 00:31:17.930
You've got cost description.

00:31:17.930 --> 00:31:19.190
You have quest understandings.

00:31:19.190 --> 00:31:21.620
You've got a lot of text.

00:31:21.620 --> 00:31:23.150
If you want to move into these
other markets, you need to

00:31:23.150 --> 00:31:25.470
communicate in their language
because not everyone speaks

00:31:25.470 --> 00:31:27.360
the language that you speak.

00:31:27.360 --> 00:31:29.340
The problem is that all the
languages don't act the same.

00:31:29.340 --> 00:31:32.130
For instance, the first problem
is the languages all

00:31:32.130 --> 00:31:33.470
read in different directions.

00:31:33.470 --> 00:31:37.080
So let's say you've created
this amazing storyline and

00:31:37.080 --> 00:31:40.300
your UI designer came through
created amazing UI for this

00:31:40.300 --> 00:31:43.170
for the storyline to present it
to the user and display it.

00:31:43.170 --> 00:31:45.810
The problem is when you put it
in Japanese, Japanese reads

00:31:45.810 --> 00:31:47.080
vertically instead
of horizontally.

00:31:47.080 --> 00:31:49.170
So what happens now?

00:31:49.170 --> 00:31:52.100
How does the UI stand
up to that?

00:31:52.100 --> 00:31:54.350
This sort of forces you to go
back and change your UI layout

00:31:54.350 --> 00:31:57.170
based upon the languages
that are available.

00:31:57.170 --> 00:32:00.610
In addition that, long words
and phrases are a problem.

00:32:00.610 --> 00:32:03.630
How the language is translated
in your language, English for

00:32:03.630 --> 00:32:06.170
example, to other languages,
German, may

00:32:06.170 --> 00:32:06.940
be completely different.

00:32:06.940 --> 00:32:10.670
Like what's 3 words or 15
characters in English maybe 37

00:32:10.670 --> 00:32:11.570
characters in German.

00:32:11.570 --> 00:32:14.060
A great story about this
is in-app purchase.

00:32:14.060 --> 00:32:17.370
So the in-app purchase guys had
originally created some

00:32:17.370 --> 00:32:21.180
specific UI and specific
dialogue, and had a specific

00:32:21.180 --> 00:32:24.960
window size and had it all
scaling and working perfectly.

00:32:24.960 --> 00:32:27.820
But when that data was
auto-translated to German,

00:32:27.820 --> 00:32:31.170
what happened was the text
actually pushed the buy button

00:32:31.170 --> 00:32:33.430
off the side of the
screen and you

00:32:33.430 --> 00:32:34.940
couldn't resize the window.

00:32:34.940 --> 00:32:36.820
So what happened was if you were
trying to buy this item

00:32:36.820 --> 00:32:38.930
in Germany, you couldn't buy it
because the buy button was

00:32:38.930 --> 00:32:40.840
completely gone.

00:32:40.840 --> 00:32:42.770
This is the type of problems
that you need to be thinking

00:32:42.770 --> 00:32:44.120
about with your UI.

00:32:44.120 --> 00:32:45.860
Of course, word wrap and
everything was implemented

00:32:45.860 --> 00:32:46.510
very quickly.

00:32:46.510 --> 00:32:48.570
And then everyone was able to
purchase, but the problem is

00:32:48.570 --> 00:32:50.810
that this is real.

00:32:50.810 --> 00:32:51.940
So how you do then.

00:32:51.940 --> 00:32:52.750
So let's say OK, cool.

00:32:52.750 --> 00:32:54.500
I want to localize my product.

00:32:54.500 --> 00:32:57.420
The first step is detecting
the user's language.

00:32:57.420 --> 00:32:59.670
In JavaScript, you can use a
nifty little function here

00:32:59.670 --> 00:33:00.750
navigator.language.

00:33:00.750 --> 00:33:02.360
Simple and easy to use.

00:33:02.360 --> 00:33:05.010
The problem is that this
actually isn't

00:33:05.010 --> 00:33:06.380
changeable by the user.

00:33:06.380 --> 00:33:09.310
So if the user actually goes
into their browser and checks

00:33:09.310 --> 00:33:12.820
the language in their browser,
it doesn't change the result

00:33:12.820 --> 00:33:13.780
of navigator.language.

00:33:13.780 --> 00:33:15.430
This is actually a common
problem that

00:33:15.430 --> 00:33:17.000
everyone deals with.

00:33:17.000 --> 00:33:20.070
What it does change, though,
is it changes is the

00:33:20.070 --> 00:33:23.850
HTTPaccept header when you're
doing a GET or SET response.

00:33:23.850 --> 00:33:26.750
So there's kind of a work around
in hack, but I'm giving

00:33:26.750 --> 00:33:28.365
a fast pass here so you
don't have to deal

00:33:28.365 --> 00:33:29.790
with the same problem.

00:33:29.790 --> 00:33:32.380
So what you can do it this is
knowing that the GET and SET

00:33:32.380 --> 00:33:34.520
requests actually have the real
language that the user

00:33:34.520 --> 00:33:37.910
has set in their browser, you
could actually poll a server

00:33:37.910 --> 00:33:39.260
and get the result back
and that'll have the

00:33:39.260 --> 00:33:40.430
real language in it.

00:33:40.430 --> 00:33:42.030
And here's how to do that.

00:33:42.030 --> 00:33:43.670
There's a great website
up there called

00:33:43.670 --> 00:33:45.850
ajaxhttpheaders.appspot.com.

00:33:45.850 --> 00:33:46.890
He's a very generous guy.

00:33:46.890 --> 00:33:49.430
You can click the link at the
bottom to go his post about

00:33:49.430 --> 00:33:50.650
how he did all this stuff.

00:33:50.650 --> 00:33:52.780
But effectively, you
send off an AJAX

00:33:52.780 --> 00:33:55.000
request to that location.

00:33:55.000 --> 00:33:57.755
When you get your response,
you query for a specific

00:33:57.755 --> 00:33:58.860
Accept-Language.

00:33:58.860 --> 00:34:01.310
And that's going to have the two
digit code that actually

00:34:01.310 --> 00:34:03.370
responds to the user's
language.

00:34:03.370 --> 00:34:05.550
Once you get that two digit
code, you can then pass that

00:34:05.550 --> 00:34:08.699
off your localization process
and that will then define

00:34:08.699 --> 00:34:11.159
which table you pull
strings from.

00:34:11.159 --> 00:34:13.429
The link at the bottom by the
way has the source code for

00:34:13.429 --> 00:34:15.600
the client side JavaScript
function which you're looking

00:34:15.600 --> 00:34:18.909
at here, as well as the server
side code which is posted at

00:34:18.909 --> 00:34:20.500
ajaxhttpheaders.

00:34:20.500 --> 00:34:23.090
And I think he actually has
a jQuery module as well.

00:34:23.090 --> 00:34:25.510
So if you're trying to
detect the language,

00:34:25.510 --> 00:34:28.150
navigator.language works well,
but this is actually sort of

00:34:28.150 --> 00:34:30.659
the definitive thing.

00:34:30.659 --> 00:34:33.360
Now the cool thing is-- and I
feel this isn't really a best

00:34:33.360 --> 00:34:35.300
practice, but this is important
to point this out as

00:34:35.300 --> 00:34:36.570
a tool chain process--

00:34:36.570 --> 00:34:38.500
is that there are some
tools to actually do

00:34:38.500 --> 00:34:39.610
translation for you.

00:34:39.610 --> 00:34:41.969
Most the time for game
development, you usually get

00:34:41.969 --> 00:34:45.639
all your strings in a file,
outsource that to some firm in

00:34:45.639 --> 00:34:49.120
Dublin usually is the case, and
they'll charge you some

00:34:49.120 --> 00:34:51.300
money and they'll give you back
everything translated.

00:34:51.300 --> 00:34:52.500
This doesn't always work.

00:34:52.500 --> 00:34:54.610
Like sometimes you need to
iterate on things, you don't

00:34:54.610 --> 00:34:55.639
have time to translating
or you don't

00:34:55.639 --> 00:34:56.830
have a budget to translate.

00:34:56.830 --> 00:34:58.980
There's some really cool tools
that Google provides that

00:34:58.980 --> 00:35:00.100
allows you to fix that.

00:35:00.100 --> 00:35:01.910
The first is Google Translate.

00:35:01.910 --> 00:35:04.190
So you can type in some stuff
on one side, convert it the

00:35:04.190 --> 00:35:05.050
other language on the other.

00:35:05.050 --> 00:35:05.990
This is easy.

00:35:05.990 --> 00:35:08.650
Copy, paste, you're
good to go.

00:35:08.650 --> 00:35:10.780
This doesn't work in situations
though where

00:35:10.780 --> 00:35:12.490
there's sort of live chat.

00:35:12.490 --> 00:35:13.890
So let's say you've got a
chat window up and I'm

00:35:13.890 --> 00:35:16.170
communicating to someone
who's speaking Spanish.

00:35:16.170 --> 00:35:17.870
I need the ability to
take my string and

00:35:17.870 --> 00:35:19.520
convert it to their language.

00:35:19.520 --> 00:35:22.700
Google Translate provides an API
where you can put in your

00:35:22.700 --> 00:35:25.065
language, put in what language
you want it to go to, and

00:35:25.065 --> 00:35:30.560
it'll return a packet with the
proper translated strength.

00:35:30.560 --> 00:35:33.810
In addition to that, it also
provide a detect function.

00:35:33.810 --> 00:35:35.650
So let's say the user is using
a language and they haven't

00:35:35.650 --> 00:35:37.980
specified it properly
or whatnot.

00:35:37.980 --> 00:35:40.470
Let the string get passed into
Google Translate API, and

00:35:40.470 --> 00:35:43.080
Google Translate will sort of
parse through its massive

00:35:43.080 --> 00:35:45.450
database of languages and words
and return to you what

00:35:45.450 --> 00:35:46.940
the language is.

00:35:46.940 --> 00:35:49.460
Now again this is fantastic
because you can use it sort of

00:35:49.460 --> 00:35:50.840
at a tool level.

00:35:50.840 --> 00:35:53.430
You could actually say write a
little application that will

00:35:53.430 --> 00:35:55.710
take all of your table strings
written in your source

00:35:55.710 --> 00:35:59.670
language like English, and for
each string send off a query

00:35:59.670 --> 00:36:00.920
to Google Translate
and it'll give you

00:36:00.920 --> 00:36:02.450
the translated string.

00:36:02.450 --> 00:36:04.670
This works, although
it takes some time.

00:36:04.670 --> 00:36:07.700
So the better solution is
actually to use an amazing

00:36:07.700 --> 00:36:10.010
product called Translator
Toolkit.

00:36:10.010 --> 00:36:12.420
And Translator Toolkit is free
for anyone to go and use.

00:36:12.420 --> 00:36:15.190
Translator Toolkit allows
you to upload a file--

00:36:15.190 --> 00:36:19.010
XML, HTML, CSV, things like
that-- and it'll actually

00:36:19.010 --> 00:36:21.400
translate the whole thing for
you just in one shot go.

00:36:21.400 --> 00:36:23.070
So this is actually the tool
you want to be using.

00:36:23.070 --> 00:36:25.020
If you've got all of your
strings segmented into

00:36:25.020 --> 00:36:27.490
different sections, you can take
each one of those files,

00:36:27.490 --> 00:36:31.000
upload it to Google Translator,
the Toolkit, hit

00:36:31.000 --> 00:36:32.160
the button, and it'll
push it out.

00:36:32.160 --> 00:36:35.120
Now the cool thing is here is it
actually allows you to step

00:36:35.120 --> 00:36:37.990
through each one of the items
that it's translated.

00:36:37.990 --> 00:36:41.550
So you can actually see Hello,
world see example blahblahblah

00:36:41.550 --> 00:36:43.770
actually gets translated
into this over here.

00:36:43.770 --> 00:36:46.300
I hope the Native Client team
does not mind me using their

00:36:46.300 --> 00:36:47.640
page for example purposes.

00:36:47.640 --> 00:36:50.795
So definitely use these tools
if you're doing translation.

00:36:50.795 --> 00:36:52.630
Let's talk about display
and rendering.

00:36:52.630 --> 00:36:53.340
So we've got a game.

00:36:53.340 --> 00:36:54.750
We've talked about the
server side aspects.

00:36:54.750 --> 00:36:55.810
Let's talk about the
client side.

00:36:55.810 --> 00:36:56.390
The client side.

00:36:56.390 --> 00:36:57.970
You're going to display
your game.

00:36:57.970 --> 00:37:00.130
Let's talk about what
that means.

00:37:00.130 --> 00:37:02.220
First off is this
is a modern web.

00:37:02.220 --> 00:37:03.130
We have to face it.

00:37:03.130 --> 00:37:05.370
If we really want people to
take gaming on the web

00:37:05.370 --> 00:37:07.910
seriously and take all of the
skill sets that we've

00:37:07.910 --> 00:37:10.980
acclimated over the past 30
years of gaming on PC and

00:37:10.980 --> 00:37:14.610
gaming on consoles, we have to
talk about the GPU being used

00:37:14.610 --> 00:37:16.420
in a web page and in
a web browser.

00:37:16.420 --> 00:37:17.860
And the good news is,
we've got this.

00:37:17.860 --> 00:37:21.190
We've got technologies like
OpenGL in Native Client.

00:37:21.190 --> 00:37:24.150
We've got technologies like
WebGL, and we also have

00:37:24.150 --> 00:37:25.840
technologies like
Hardware-Accelerated Canvas.

00:37:25.840 --> 00:37:27.490
We'll talk about that
in a minute.

00:37:27.490 --> 00:37:29.260
The important thing here those
is I'm sure you've all heard

00:37:29.260 --> 00:37:31.600
the news that with these
technologies, you need to be

00:37:31.600 --> 00:37:34.960
aware that some of the driver
implementations may not be

00:37:34.960 --> 00:37:36.630
secure, may not be safe.

00:37:36.630 --> 00:37:39.340
This means that potential
malicious users can write some

00:37:39.340 --> 00:37:42.490
sort of code, a GPU-specific
code, that when a user loads

00:37:42.490 --> 00:37:45.700
it on the local machine does
something nasty and gnarly.

00:37:45.700 --> 00:37:48.030
For the most part, the teams
work in the modern browsers to

00:37:48.030 --> 00:37:50.280
fix these, update these, and
make that sure these patches

00:37:50.280 --> 00:37:50.820
are proper.

00:37:50.820 --> 00:37:53.000
For the stuff they just can't
fix, there's actually a

00:37:53.000 --> 00:37:54.560
presented blacklisted drivers.

00:37:54.560 --> 00:37:57.630
They say that if you try to load
this content and you have

00:37:57.630 --> 00:37:59.640
this driver on your
machine, nah.

00:37:59.640 --> 00:38:00.420
Not going to happen.

00:38:00.420 --> 00:38:00.910
Why?

00:38:00.910 --> 00:38:03.950
Because the security risk is
more important than the

00:38:03.950 --> 00:38:04.530
content viewing.

00:38:04.530 --> 00:38:06.700
Now this is really important.

00:38:06.700 --> 00:38:07.640
Think of you.

00:38:07.640 --> 00:38:09.820
You are a developer and you put
content on the web, and

00:38:09.820 --> 00:38:13.410
you put a game on the web and
the user goes to that site and

00:38:13.410 --> 00:38:15.690
potentially is available for
some sort of hack or

00:38:15.690 --> 00:38:16.950
something going on.

00:38:16.950 --> 00:38:18.740
That's not good, because they're
going to come back and

00:38:18.740 --> 00:38:21.130
say that it's your problem, not
the web browser's problem

00:38:21.130 --> 00:38:22.380
or the malicious person's
problem or

00:38:22.380 --> 00:38:23.520
someone else's problem.

00:38:23.520 --> 00:38:24.350
So you like this.

00:38:24.350 --> 00:38:27.020
You want to make sure that you
can detect if they have a

00:38:27.020 --> 00:38:29.430
blacklisted driver, respond
to it early.

00:38:29.430 --> 00:38:30.980
Here's I do that.

00:38:30.980 --> 00:38:32.120
It's she really simple.

00:38:32.120 --> 00:38:33.300
You take this little
snippet of code.

00:38:33.300 --> 00:38:36.140
Effectively all you're doing in
JavaScript is you get the

00:38:36.140 --> 00:38:39.660
canvas element and you try to
create a WebGL context.

00:38:39.660 --> 00:38:42.890
If the WebGL context fails,
chances are the user either

00:38:42.890 --> 00:38:46.390
has inadequate resources to
run the game, which you

00:38:46.390 --> 00:38:48.490
wouldn't want them to be able to
run it anyway, or they have

00:38:48.490 --> 00:38:49.650
a blacklisted driver.

00:38:49.650 --> 00:38:52.460
In either case, running this
little script right here

00:38:52.460 --> 00:38:54.560
before you start caching
or loading or doing any

00:38:54.560 --> 00:38:57.210
processing is of vital
importance because you can

00:38:57.210 --> 00:38:59.390
then tell the user hey,
something's wrong.

00:38:59.390 --> 00:39:00.570
Go update, go do something.

00:39:00.570 --> 00:39:01.850
Does need to.

00:39:01.850 --> 00:39:04.030
In addition here-- you can
actually see something else--

00:39:04.030 --> 00:39:07.330
is that if this passes, you can
actually do other tests

00:39:07.330 --> 00:39:12.320
here like does your hardware
support this max texture size?

00:39:12.320 --> 00:39:13.930
Which is also really
important.

00:39:13.930 --> 00:39:16.360
You have to scale to make sure
that the hardware which is not

00:39:16.360 --> 00:39:19.160
homogeneous can play well
with your game.

00:39:19.160 --> 00:39:22.330
Now most internet users aren't
going to like this because

00:39:22.330 --> 00:39:24.340
this means that I have to create
different versions of

00:39:24.340 --> 00:39:26.730
my product for different
tiers of performance.

00:39:26.730 --> 00:39:29.300
But in reality, PC developers
have had

00:39:29.300 --> 00:39:30.280
this problem for years.

00:39:30.280 --> 00:39:31.390
This is nothing new to us.

00:39:31.390 --> 00:39:32.950
We've been dealing with
this a long time.

00:39:32.950 --> 00:39:34.980
And the same problems and
the same solutions

00:39:34.980 --> 00:39:35.740
have existed there.

00:39:35.740 --> 00:39:38.430
This is a well-documented thing
about how to deal with.

00:39:38.430 --> 00:39:40.520
So I suggest if this is an
issue that you're worried

00:39:40.520 --> 00:39:43.870
about, definitely read up
on the documentation.

00:39:43.870 --> 00:39:45.060
Now the next thing you
need to be concerned

00:39:45.060 --> 00:39:46.610
with is sandbox rendering.

00:39:46.610 --> 00:39:50.550
Now you have to understand that
again with these drivers

00:39:50.550 --> 00:39:53.350
and the security issues
involved that we don't

00:39:53.350 --> 00:39:55.760
actually allow the script code
that's being executed to go

00:39:55.760 --> 00:39:57.000
right to the driver
and right to the

00:39:57.000 --> 00:39:57.970
graphics processing unit.

00:39:57.970 --> 00:40:00.640
This could expose a whole slew
of problems. So instead what

00:40:00.640 --> 00:40:04.600
occurs is we actually put all
of the processing and direct

00:40:04.600 --> 00:40:07.020
correlation with the APIs in
a separate process that's

00:40:07.020 --> 00:40:07.790
running somewhere else.

00:40:07.790 --> 00:40:10.770
So you got your main Chrome
process and you've got a

00:40:10.770 --> 00:40:11.600
rendering process.

00:40:11.600 --> 00:40:15.170
All of the data is then pushed
into an RPC buffer.

00:40:15.170 --> 00:40:18.030
That RPC buffer will get the
commands and then some time in

00:40:18.030 --> 00:40:20.450
the future, push them to
the render process.

00:40:20.450 --> 00:40:22.730
And what this means you're sort
of creating a frame of

00:40:22.730 --> 00:40:24.830
buffering and a frame of latency
in getting all this

00:40:24.830 --> 00:40:26.830
through the pipe.

00:40:26.830 --> 00:40:29.580
To dig into this a little bit
deeper, you have to be wary

00:40:29.580 --> 00:40:31.270
and the reason this is the
problem is you're got to get

00:40:31.270 --> 00:40:33.280
something called
a render stall.

00:40:33.280 --> 00:40:34.930
Basically what happens is you're
going to do some work.

00:40:34.930 --> 00:40:36.020
You're going to draw some
objects, you're going to

00:40:36.020 --> 00:40:38.660
update some vertex buffers, and
you're going to fill in

00:40:38.660 --> 00:40:40.830
your entire RPC buffer.

00:40:40.830 --> 00:40:43.470
So that when you go to try and
do something that pushes in

00:40:43.470 --> 00:40:44.665
that RPC buffer, it's
going to block.

00:40:44.665 --> 00:40:46.420
It's going to say I've
got no more room.

00:40:46.420 --> 00:40:48.940
What's going to happen there is
even though you're not done

00:40:48.940 --> 00:40:51.280
with your frame and you have
all this other stuff to do,

00:40:51.280 --> 00:40:54.030
it's going to insert a
sync FLUSH command,

00:40:54.030 --> 00:40:55.370
effectively a glFinish.

00:40:55.370 --> 00:40:57.390
What a sync FLUSH command's
going to do is it's going to

00:40:57.390 --> 00:40:59.560
wait for that entire buffer
to be consumed

00:40:59.560 --> 00:41:00.950
by the render process.

00:41:00.950 --> 00:41:03.270
And it's going to block your
calling application until that

00:41:03.270 --> 00:41:04.630
work is done.

00:41:04.630 --> 00:41:06.420
So what's going to happen
is you will be

00:41:06.420 --> 00:41:07.450
chugging along fine.

00:41:07.450 --> 00:41:10.440
You'll see that the timing
observation for draw objects

00:41:10.440 --> 00:41:12.200
and update VBs is pretty
much consistent.

00:41:12.200 --> 00:41:14.190
And then all of a sudden,
you're going to hit 30

00:41:14.190 --> 00:41:15.860
milliseconds draw
object frame.

00:41:15.860 --> 00:41:17.290
And this is not ideal, because
you're going to

00:41:17.290 --> 00:41:18.010
try to drill down.

00:41:18.010 --> 00:41:20.850
You're going to be like why is
this one draw object taking so

00:41:20.850 --> 00:41:23.140
long, and if I move it around
it's not in the same spot and

00:41:23.140 --> 00:41:23.500
oh, my God.

00:41:23.500 --> 00:41:24.360
What's happening?

00:41:24.360 --> 00:41:26.280
What's happening is it has
nothing to do with the way

00:41:26.280 --> 00:41:27.140
you're calling the API.

00:41:27.140 --> 00:41:29.380
It has everything to do with
what API's doing on the back

00:41:29.380 --> 00:41:31.270
end that you have very
little control over.

00:41:31.270 --> 00:41:32.945
But you do have some control.

00:41:32.945 --> 00:41:35.290
And This is really important.

00:41:35.290 --> 00:41:38.270
Swap buffers at the end of a
frame for rendering in WebGL

00:41:38.270 --> 00:41:41.270
or OpenGL ES 2.0 in Native
Client will actually kick off

00:41:41.270 --> 00:41:42.740
a glFinish call on
your behalf.

00:41:42.740 --> 00:41:45.850
And what this does is it
actually force the RPC buffer

00:41:45.850 --> 00:41:47.600
to get flushed for you.

00:41:47.600 --> 00:41:52.180
Now the intent here is can we
insert flushes ahead of time

00:41:52.180 --> 00:41:54.990
to make sure that we never hit
one of these sync flushes.

00:41:54.990 --> 00:41:57.070
So to do this, effectively what
you have to do is you

00:41:57.070 --> 00:42:00.240
have to figure out the optimal
places to insert a glFlush

00:42:00.240 --> 00:42:02.650
command in your rendering
process.

00:42:02.650 --> 00:42:05.660
This will allow you to do some
drawing, flush the buffer, do

00:42:05.660 --> 00:42:08.020
some more drawing, and flush
the buffer again.

00:42:08.020 --> 00:42:10.600
This will keep you from ever
hitting the sync flush if you

00:42:10.600 --> 00:42:11.140
do it right.

00:42:11.140 --> 00:42:14.140
You may hit it every now again
in periods of high bandwidth

00:42:14.140 --> 00:42:15.920
or high amount of processing
churn.

00:42:15.920 --> 00:42:18.720
But the goal is to analyze your
system, figure out where

00:42:18.720 --> 00:42:22.820
the heavy points are, in insert
these manual flushes in

00:42:22.820 --> 00:42:27.530
strategic positions to reduce
and keep that pipeline moving

00:42:27.530 --> 00:42:28.720
as efficient as possible.

00:42:28.720 --> 00:42:30.520
Think of it like a factory.

00:42:30.520 --> 00:42:31.950
Like you're trying to build
cars, you're trying to keep

00:42:31.950 --> 00:42:33.580
everything going through smooth
so that there's no

00:42:33.580 --> 00:42:36.560
pipeline bottlenecks.

00:42:36.560 --> 00:42:37.450
So canvas rendering.

00:42:37.450 --> 00:42:40.170
I talked about this.

00:42:40.170 --> 00:42:43.410
The latest versions of Chrome
actually have GPU accelerated

00:42:43.410 --> 00:42:44.810
campus rendering.

00:42:44.810 --> 00:42:48.160
I believe this is unveiled
as default in Chrome 17.

00:42:48.160 --> 00:42:49.440
It might be Chrome 16.

00:42:49.440 --> 00:42:51.060
Fact check me on that.

00:42:51.060 --> 00:42:53.200
But what this means is that
you as a developer can

00:42:53.200 --> 00:42:56.030
actually just use the same
canvas commands--

00:42:56.030 --> 00:42:58.860
draw, tesselate, do all
these other things--

00:42:58.860 --> 00:43:01.100
and behind the scenes Chrome
will actually go through and

00:43:01.100 --> 00:43:02.710
use the GPU on your behalf.

00:43:02.710 --> 00:43:05.820
This is amazing because this
means that all of the concept

00:43:05.820 --> 00:43:08.690
and all of the nuances of
managing texture state,

00:43:08.690 --> 00:43:10.690
setting data, and doing all this
other stuff is handled

00:43:10.690 --> 00:43:11.890
behind the scenes
on your behalf.

00:43:11.890 --> 00:43:12.320
That's great.

00:43:12.320 --> 00:43:13.820
That means you can just make
your game and focus

00:43:13.820 --> 00:43:14.750
on making your game.

00:43:14.750 --> 00:43:16.210
It's definitely hand-free
usage.

00:43:16.210 --> 00:43:17.280
It's behind the scenes.

00:43:17.280 --> 00:43:20.110
And the user most importantly
can toggle this with a flag.

00:43:20.110 --> 00:43:23.750
So if by some chance they've got
a beefier CPU than they do

00:43:23.750 --> 00:43:27.580
a GPU, the user can then go in
toggle, turnoff hardware

00:43:27.580 --> 00:43:30.570
accelerated canvas, and go
back to the CPU path.

00:43:30.570 --> 00:43:33.290
We see this commonly in
notebooks or netbooks that may

00:43:33.290 --> 00:43:35.980
have like six cores sitting
around but still have an

00:43:35.980 --> 00:43:41.560
integrated graphics chip that
can't run Shader Model 1.1.

00:43:41.560 --> 00:43:41.880
Cool.

00:43:41.880 --> 00:43:43.780
So you've got all this stuff
working forward.

00:43:43.780 --> 00:43:44.880
You've got this game
environment.

00:43:44.880 --> 00:43:45.600
You've got it all set up.

00:43:45.600 --> 00:43:47.080
Let's talk about the platform
environment.

00:43:47.080 --> 00:43:48.920
So now that you're doing a web
game, let's talk about some

00:43:48.920 --> 00:43:51.040
things you have to
be aware of.

00:43:51.040 --> 00:43:53.470
Users will tab away
from your game.

00:43:53.470 --> 00:43:55.780
If you're running in a browser,
users consistently

00:43:55.780 --> 00:43:58.680
tab across to check their
email, during a loading

00:43:58.680 --> 00:44:02.210
screen, or they get a chat, or
Groupon pops up and says, oh

00:44:02.210 --> 00:44:05.260
my gosh, there's an amazing
cat for sale in Southern

00:44:05.260 --> 00:44:05.860
California.

00:44:05.860 --> 00:44:08.240
Like there's different reasons
for you to tab away.

00:44:08.240 --> 00:44:10.160
You can detect this, and this
is an important thing.

00:44:10.160 --> 00:44:12.720
You can actually listen for the
visibilitychange event in

00:44:12.720 --> 00:44:13.630
JavaScript.

00:44:13.630 --> 00:44:15.200
And that visibilitychange
event will give you a

00:44:15.200 --> 00:44:17.490
notification when the user
has tabbed away.

00:44:17.490 --> 00:44:19.590
And you need to respond
according to this so.

00:44:19.590 --> 00:44:21.450
So for instance, you need to
pause the game first off.

00:44:21.450 --> 00:44:23.240
If the player's in a multiplayer
match or doing

00:44:23.240 --> 00:44:25.980
something important, you don't
want them tabbing away to

00:44:25.980 --> 00:44:27.530
cause a problem in the game.

00:44:27.530 --> 00:44:29.340
You want to make sure that you
pause properly and make sure

00:44:29.340 --> 00:44:30.720
everything's kosher.

00:44:30.720 --> 00:44:33.170
You can also reduce or
turn off volume.

00:44:33.170 --> 00:44:34.160
This depends on your game.

00:44:34.160 --> 00:44:36.580
Some people just choose to
reduce the volume so you kind

00:44:36.580 --> 00:44:38.000
of notice that you're
still playing a game

00:44:38.000 --> 00:44:39.290
and aware of it.

00:44:39.290 --> 00:44:41.450
If you turn off the volume,
sometimes it's easy for the

00:44:41.450 --> 00:44:43.910
user to forget they're
playing.

00:44:43.910 --> 00:44:47.170
It's also worth noting that
setInterval during the time

00:44:47.170 --> 00:44:50.260
that the user is a way will
actually slow down to about a

00:44:50.260 --> 00:44:53.000
1,000 milliseconds, so about one
second pulses for anything

00:44:53.000 --> 00:44:54.110
using setInterval.

00:44:54.110 --> 00:44:55.880
If you're using
RequestAnimationFrame, it will

00:44:55.880 --> 00:44:56.810
stop completely.

00:44:56.810 --> 00:44:59.150
So make sure that you're aware
of these things in JavaScript.

00:44:59.150 --> 00:45:00.610
If you're using either
setInterval or

00:45:00.610 --> 00:45:03.180
RequestAnimationFrame and the
user tabs away, these things

00:45:03.180 --> 00:45:03.690
will occur.

00:45:03.690 --> 00:45:06.180
And you need to respond
accordingly to them.

00:45:06.180 --> 00:45:07.250
Bugs in the wild.

00:45:07.250 --> 00:45:10.310
So users will run your product,
and they will run

00:45:10.310 --> 00:45:12.760
your product on their machine in
their environment on their

00:45:12.760 --> 00:45:15.920
particular test harnesses with
their particular installation

00:45:15.920 --> 00:45:18.600
configurations and extensions
and pop-ups and everything

00:45:18.600 --> 00:45:19.670
else that's all there.

00:45:19.670 --> 00:45:21.280
And they're going to hit
a bug sooner or later.

00:45:21.280 --> 00:45:22.870
It's just the configuration
world.

00:45:22.870 --> 00:45:25.780
Your job is to detect this on
their machine and get the

00:45:25.780 --> 00:45:27.880
information back in an
appropriate way so that you

00:45:27.880 --> 00:45:30.015
can update your product to
be a better product.

00:45:30.015 --> 00:45:32.330
Again all going back to
optimizing for the end user

00:45:32.330 --> 00:45:33.550
experience.

00:45:33.550 --> 00:45:34.750
So you can detect this.

00:45:34.750 --> 00:45:37.560
So if the user has an error
that's thrown, you can use

00:45:37.560 --> 00:45:38.670
window.onerror.

00:45:38.670 --> 00:45:42.310
Or if you're using any browser
that implements v8, which is

00:45:42.310 --> 00:45:47.520
Chrome's JavaScript virtual
machine, you can actually use

00:45:47.520 --> 00:45:49.970
Error.captureStackTrace and
this will give you a full

00:45:49.970 --> 00:45:51.650
stack trace to where
the error is.

00:45:51.650 --> 00:45:53.530
Once you detect this, you need
to respond accordingly.

00:45:53.530 --> 00:45:55.180
You need to gather
information.

00:45:55.180 --> 00:45:58.330
So it's not just enough
sometimes to get your stack.

00:45:58.330 --> 00:46:00.370
You actually need to gather
other information like the

00:46:00.370 --> 00:46:03.690
game specific or game
state, the operating

00:46:03.690 --> 00:46:04.860
system, the player ID.

00:46:04.860 --> 00:46:07.650
Maybe this one player keeps
getting crashes, and you need

00:46:07.650 --> 00:46:10.700
to correlate that
with who it is.

00:46:10.700 --> 00:46:13.210
In addition to that, there's two
really cool things here,

00:46:13.210 --> 00:46:16.690
window.performance and
chrome.tabs.captureVisibleTab.

00:46:16.690 --> 00:46:18.910
These are excellent useful
resources as well, because it

00:46:18.910 --> 00:46:21.140
allows you give a
bigger picture.

00:46:21.140 --> 00:46:24.270
For instance, what if the reason
that the game keeps

00:46:24.270 --> 00:46:26.100
crashing on this user's machine
is because they have

00:46:26.100 --> 00:46:29.350
some extension installed that
allows them to arbitrarily

00:46:29.350 --> 00:46:32.520
break point JavaScript or make
everything in a floating point

00:46:32.520 --> 00:46:33.020
integer or something.

00:46:33.020 --> 00:46:34.750
Who knows?

00:46:34.750 --> 00:46:36.710
Querying these things allow
you to get better

00:46:36.710 --> 00:46:38.170
visibility in that.

00:46:38.170 --> 00:46:40.380
Once you get the information--
so you detected it, you've

00:46:40.380 --> 00:46:41.740
gathered your information,
and now you need to

00:46:41.740 --> 00:46:42.550
get it back to you.

00:46:42.550 --> 00:46:44.100
And there's two primary
ways to do this.

00:46:44.100 --> 00:46:45.790
The first of course is you
just spin up a thread and

00:46:45.790 --> 00:46:47.020
shoot off an email to yourself,

00:46:47.020 --> 00:46:48.720
which is fine and dandy.

00:46:48.720 --> 00:46:50.880
Of course, you have to worry
about what that means to send

00:46:50.880 --> 00:46:52.085
an email from the user's
account and

00:46:52.085 --> 00:46:53.680
all this other stuff.

00:46:53.680 --> 00:46:54.860
You can also upload it.

00:46:54.860 --> 00:46:58.990
And there's two nice little
software solutions called

00:46:58.990 --> 00:47:00.790
jsErrLog and jdrop.

00:47:00.790 --> 00:47:01.580
Click the links.

00:47:01.580 --> 00:47:02.140
Check those out.

00:47:02.140 --> 00:47:04.350
Basically those allow you to
sort of upload some sort of

00:47:04.350 --> 00:47:07.360
JSONized string data to a server
database somewhere, and

00:47:07.360 --> 00:47:10.440
then you can come back at your
convenience and scrub through

00:47:10.440 --> 00:47:13.570
the number of crashes for that
day, rank them, implement them

00:47:13.570 --> 00:47:18.190
into your bug system, and
respond accordingly.

00:47:18.190 --> 00:47:19.730
Now here's an interesting
point.

00:47:19.730 --> 00:47:21.310
And a lot of people don't--

00:47:21.310 --> 00:47:22.700
they sort of understand
this, but it's a

00:47:22.700 --> 00:47:23.850
nuance that they miss--

00:47:23.850 --> 00:47:25.250
is that you make sure
that your error

00:47:25.250 --> 00:47:26.310
reporting is stable.

00:47:26.310 --> 00:47:29.410
The most annoying thing I've
ever had to debug is my

00:47:29.410 --> 00:47:30.560
debugging code.

00:47:30.560 --> 00:47:33.150
Like my I'm finding a crash
that's being caused by

00:47:33.150 --> 00:47:36.190
something that I can't use
because my code that's trying

00:47:36.190 --> 00:47:37.350
to detect the crash
is actually the

00:47:37.350 --> 00:47:38.720
thing causing the crash.

00:47:38.720 --> 00:47:40.960
Like it's a sort of Inception,
[UNINTELLIGIBLE]

00:47:40.960 --> 00:47:42.040
all the way down.

00:47:42.040 --> 00:47:43.850
So make sure your error
reporting is stable.

00:47:43.850 --> 00:47:48.090
When you do detect a user, it's
sort of best practices to

00:47:48.090 --> 00:47:50.640
tell the user that you've
detected this and display it

00:47:50.640 --> 00:47:53.250
to the user in some very
friendly methodology.

00:47:53.250 --> 00:47:56.370
Make sure that you communicate
that it's not their fault.

00:47:56.370 --> 00:47:58.440
Nothing's more annoying than a
game that tells me that I'm

00:47:58.440 --> 00:47:59.630
playing it wrong.

00:47:59.630 --> 00:48:01.060
Your users don't like that.

00:48:01.060 --> 00:48:02.540
Definitely avoid technical
language.

00:48:02.540 --> 00:48:04.160
When Chrome crashes,
what do get?

00:48:04.160 --> 00:48:06.140
You get a little funny
icon that kind of

00:48:06.140 --> 00:48:06.865
brightens your day.

00:48:06.865 --> 00:48:08.720
And it says hey, something's
crashed.

00:48:08.720 --> 00:48:11.940
Sometimes it says ah, snap
or he's dead, Jim.

00:48:11.940 --> 00:48:12.450
It makes humor.

00:48:12.450 --> 00:48:15.600
It makes light of the fact that
your data is somehow no

00:48:15.600 --> 00:48:17.860
longer there but don't worry.

00:48:17.860 --> 00:48:20.360
Grass will still grow, babies
will still laugh, and we will

00:48:20.360 --> 00:48:23.950
recover your data at a
point in the future.

00:48:23.950 --> 00:48:25.570
Once you display it,
make sure that you

00:48:25.570 --> 00:48:27.070
respect your user's privacy.

00:48:27.070 --> 00:48:29.810
Ensure that the user knows what
you're gathering, what

00:48:29.810 --> 00:48:32.000
you're returning as far as
your data's concern.

00:48:32.000 --> 00:48:33.520
And allow the user to opt-out.

00:48:33.520 --> 00:48:35.260
This is just sort of
a nice thing to do.

00:48:35.260 --> 00:48:37.050
Allow the user to say
you what, I know

00:48:37.050 --> 00:48:37.810
what the problem was.

00:48:37.810 --> 00:48:39.020
I was trying to hack
you system.

00:48:39.020 --> 00:48:40.310
Please don't use this
information.

00:48:40.310 --> 00:48:41.800
Or hey, I know what
the problem is.

00:48:41.800 --> 00:48:42.860
It's this other plug-in.

00:48:42.860 --> 00:48:44.060
Don't send the information
around.

00:48:44.060 --> 00:48:46.590
Allow them to opt-out.

00:48:46.590 --> 00:48:48.090
Once you've got your JavaScript
data, it's

00:48:48.090 --> 00:48:50.370
important to minify
and obfuscate it.

00:48:50.370 --> 00:48:51.440
This is actually really
important.

00:48:51.440 --> 00:48:54.050
So your JavaScript code will
actually take up a large chunk

00:48:54.050 --> 00:48:55.180
of your memory footprint.

00:48:55.180 --> 00:48:58.770
And you want to reduce sort of
duplicate characters and white

00:48:58.770 --> 00:49:01.930
spaces and other things so that
it's transferred to the

00:49:01.930 --> 00:49:04.410
user in the most efficient
methodology possible for

00:49:04.410 --> 00:49:06.260
JavaScript.

00:49:06.260 --> 00:49:09.120
The closure compile offers this
as well as obfuscation.

00:49:09.120 --> 00:49:11.820
So this will actually allow your
code to be obfuscated to

00:49:11.820 --> 00:49:14.330
a level that a standard human
being just taking a look at

00:49:14.330 --> 00:49:16.400
the code won't be able to
actually detect what's going

00:49:16.400 --> 00:49:17.620
on inside of it.

00:49:17.620 --> 00:49:19.510
They'll need to spend some time

00:49:19.510 --> 00:49:23.000
deobfuscating it to get there.

00:49:23.000 --> 00:49:25.530
plovr, I think is the proper
way to do this is sort of a

00:49:25.530 --> 00:49:27.150
front end to the closure
compiler.

00:49:27.150 --> 00:49:28.270
Definitely take a
look at that.

00:49:28.270 --> 00:49:31.210
And HTML5 boiler plate also
contains some really amazing

00:49:31.210 --> 00:49:34.460
tools for minimization and
obfuscation that you should be

00:49:34.460 --> 00:49:37.290
looking at if you're writing
content in JavaScript that is

00:49:37.290 --> 00:49:40.200
performance and size heavy.

00:49:40.200 --> 00:49:40.890
User metrics.

00:49:40.890 --> 00:49:42.130
Now we're getting into
the cool stuff.

00:49:42.130 --> 00:49:46.200
So you should know who your
players are and you should be

00:49:46.200 --> 00:49:48.260
using Google Analytics
to do this.

00:49:48.260 --> 00:49:51.100
Now Google Analytics as I've
said before is traditionally a

00:49:51.100 --> 00:49:54.260
web service that allows you to
track who's visiting your

00:49:54.260 --> 00:49:56.630
site, where they're coming from,
what pages get the most

00:49:56.630 --> 00:49:58.750
traffic, et cetera, et
cetera, et cetera.

00:49:58.750 --> 00:50:00.380
But you can also kickoff custom

00:50:00.380 --> 00:50:01.750
events, and this is amazing.

00:50:01.750 --> 00:50:04.470
This means that from JavaScript,
you can kick off

00:50:04.470 --> 00:50:08.220
an event that's attached to
something going on your game.

00:50:08.220 --> 00:50:11.560
So you can say every time a
user, any user finishes level

00:50:11.560 --> 00:50:14.240
two I'm going to report that to
Google Analytics and keep

00:50:14.240 --> 00:50:15.420
that data around.

00:50:15.420 --> 00:50:18.080
Now I don't have a slide for it,
but the tools for Google

00:50:18.080 --> 00:50:19.610
Analytics are actually
really amazing.

00:50:19.610 --> 00:50:22.560
They're kind of from the future
in terms of ability to

00:50:22.560 --> 00:50:25.370
analyze data and look at it
for specific spikes and

00:50:25.370 --> 00:50:26.790
reasons that you need.

00:50:26.790 --> 00:50:28.980
So if you save things like
finish level 2, finish the

00:50:28.980 --> 00:50:32.560
game, how many users chatted,
how many users joined a group,

00:50:32.560 --> 00:50:34.310
how many users kicked
a chicken.

00:50:34.310 --> 00:50:35.400
This is important information.

00:50:35.400 --> 00:50:37.440
If you put chickens and you
allow a user to kick a

00:50:37.440 --> 00:50:39.510
chicken, you should probably
figure out how many users are

00:50:39.510 --> 00:50:41.770
actually doing that thing so you
can figure out whether or

00:50:41.770 --> 00:50:43.680
not you need to make it
a quest or an upgrade.

00:50:43.680 --> 00:50:47.470
Like hey, you've kicked
a million chickens.

00:50:47.470 --> 00:50:49.160
Halo 3 did a great
job of this.

00:50:49.160 --> 00:50:51.620
And this is actually one of the
first documented sort of

00:50:51.620 --> 00:50:52.650
in the wild publications.

00:50:52.650 --> 00:50:55.140
What you're looking at
here is a heat map.

00:50:55.140 --> 00:50:57.790
What happened was the designers
of Halo 3 during the

00:50:57.790 --> 00:51:00.600
early testing days started
logging every

00:51:00.600 --> 00:51:01.990
place that a user died.

00:51:01.990 --> 00:51:05.180
So any time a player died, they
put that point in space.

00:51:05.180 --> 00:51:08.350
And then they would generate
these heat maps of specific

00:51:08.350 --> 00:51:10.160
multiplayer maps every day.

00:51:10.160 --> 00:51:13.040
And what you see here is in the
red, that's where all the

00:51:13.040 --> 00:51:14.160
deaths occur.

00:51:14.160 --> 00:51:16.270
You can see in the blue,
not so many deaths.

00:51:16.270 --> 00:51:18.140
Now you can take this
information and then

00:51:18.140 --> 00:51:21.120
correlate, hey, see
these red areas?

00:51:21.120 --> 00:51:22.530
That's where all
the action is.

00:51:22.530 --> 00:51:24.280
Why is all the action there?

00:51:24.280 --> 00:51:27.120
Is there some sort of power up,
or is it a choke point, or

00:51:27.120 --> 00:51:29.710
is it a strategic interest You
can then take this information

00:51:29.710 --> 00:51:32.170
and go back to redesign
how your game works

00:51:32.170 --> 00:51:33.430
based upon this data.

00:51:33.430 --> 00:51:36.760
And you can do this through
Google Analytics kicking off

00:51:36.760 --> 00:51:38.480
these custom events.

00:51:38.480 --> 00:51:39.220
So the high points.

00:51:39.220 --> 00:51:40.100
What do you want to track?

00:51:40.100 --> 00:51:40.750
So let's say cool.

00:51:40.750 --> 00:51:41.360
You buy into it.

00:51:41.360 --> 00:51:41.900
You're going to use it.

00:51:41.900 --> 00:51:43.040
What are you going to track?

00:51:43.040 --> 00:51:44.880
You should use Google Analytics
for the number of

00:51:44.880 --> 00:51:46.920
daily, weekly, and monthly users
that are actually using

00:51:46.920 --> 00:51:47.840
your product.

00:51:47.840 --> 00:51:50.410
You should track the number of
players coming from what site.

00:51:50.410 --> 00:51:52.860
You should know whether or not
you're getting more players

00:51:52.860 --> 00:51:56.180
from Rock, Paper, Shotgun versus
Kotaku, and know how to

00:51:56.180 --> 00:51:57.920
respond accordingly to that.

00:51:57.920 --> 00:52:01.130
You should definitely know how
many players actually click

00:52:01.130 --> 00:52:01.750
the buy button.

00:52:01.750 --> 00:52:02.860
That's super important.

00:52:02.860 --> 00:52:05.290
Because you should also know
how many players actually

00:52:05.290 --> 00:52:06.510
complete the buy button.

00:52:06.510 --> 00:52:07.980
This is an important metric.

00:52:07.980 --> 00:52:10.580
This tells you how many people
are dropping off inside of the

00:52:10.580 --> 00:52:11.650
monetization process.

00:52:11.650 --> 00:52:13.590
How many do were willing to
buy the product versus how

00:52:13.590 --> 00:52:16.090
many people actually do.

00:52:16.090 --> 00:52:18.510
Now for some things, Google
Analytics doesn't work well.

00:52:18.510 --> 00:52:20.520
And in these cases, you should
probably propagate data back

00:52:20.520 --> 00:52:21.720
to your own server.

00:52:21.720 --> 00:52:23.960
For some in-game events,
this is probably the

00:52:23.960 --> 00:52:25.030
best way to do it.

00:52:25.030 --> 00:52:28.180
Like number of crashes, bugs,
specific errors, or anything

00:52:28.180 --> 00:52:30.280
that may need some specific
processing that Google

00:52:30.280 --> 00:52:33.280
Analytics isn't best
suited for.

00:52:33.280 --> 00:52:34.130
AB testing.

00:52:34.130 --> 00:52:35.820
This is a great thing you
should all be doing.

00:52:35.820 --> 00:52:37.560
Now web developers know this.

00:52:37.560 --> 00:52:40.960
They know that there is a secret
sauce to a better game.

00:52:40.960 --> 00:52:42.770
And it comes from the fact
that there's a direct

00:52:42.770 --> 00:52:45.230
disconnect between game
developers and users.

00:52:45.230 --> 00:52:46.740
This is just the
way of things.

00:52:46.740 --> 00:52:51.100
As a game developer, I super
think that this amazing quest

00:52:51.100 --> 00:52:53.700
where I take a chicken and wear
it as a hat for three

00:52:53.700 --> 00:52:56.450
hours is the most amazing,
visceral experience that every

00:52:56.450 --> 00:52:58.170
player will ever go
through ever.

00:52:58.170 --> 00:53:00.540
In reality, only two people play
this game, me and my mom

00:53:00.540 --> 00:53:02.090
because I told her to play
it and give me feedback.

00:53:02.090 --> 00:53:04.800
Now why I'm getting feedback
from my mom on a quest, that's

00:53:04.800 --> 00:53:05.330
a different talk.

00:53:05.330 --> 00:53:06.510
We'll talk about that later.

00:53:06.510 --> 00:53:09.740
But the important thing is that
in order to connect with

00:53:09.740 --> 00:53:12.370
my user which is the person
playing the game, I need a

00:53:12.370 --> 00:53:15.370
different way to get
that information.

00:53:15.370 --> 00:53:19.230
AB testing is the process of
issuing a separate build to a

00:53:19.230 --> 00:53:22.450
percentage of your users in such
a way that you can then

00:53:22.450 --> 00:53:25.530
track the results to determine
what your proper outcome is.

00:53:25.530 --> 00:53:28.700
So for instance, the most simple
version of this is

00:53:28.700 --> 00:53:30.680
currently our buy button
when you want to

00:53:30.680 --> 00:53:31.930
buy an item is red.

00:53:31.930 --> 00:53:34.000
What if we change
it to be blue?

00:53:34.000 --> 00:53:36.540
Does that have any effect on
the amount of people that

00:53:36.540 --> 00:53:37.890
monetize our game?

00:53:37.890 --> 00:53:38.740
Let's find out.

00:53:38.740 --> 00:53:41.820
Let's make a build with a blue
button, issue it to 50% of the

00:53:41.820 --> 00:53:42.540
people that log in today.

00:53:42.540 --> 00:53:44.360
50% of people keep
the red button.

00:53:44.360 --> 00:53:46.280
Did we see any change?

00:53:46.280 --> 00:53:49.720
If not, if so what does
that mean to you?

00:53:49.720 --> 00:53:50.840
This allows you to
make changes that

00:53:50.840 --> 00:53:51.680
optimize your outcome.

00:53:51.680 --> 00:53:54.330
Because it's not just as simple
as what kind of button

00:53:54.330 --> 00:53:54.850
color it is.

00:53:54.850 --> 00:53:56.540
But it's also based
upon region.

00:53:56.540 --> 00:53:59.340
Like do people in Germany
buy the same way

00:53:59.340 --> 00:54:00.500
as people in America?

00:54:00.500 --> 00:54:02.650
Could I change my layout
to optimize

00:54:02.650 --> 00:54:03.850
for that region better?

00:54:03.850 --> 00:54:06.380
You can actually create multiple
versions of your game

00:54:06.380 --> 00:54:08.850
and your front end effectively
based upon region.

00:54:08.850 --> 00:54:12.290
Like maybe in Japan, your game
needs more happy happy fun

00:54:12.290 --> 00:54:12.770
time music.

00:54:12.770 --> 00:54:15.460
You don't know that until you
issue AB testing to get to

00:54:15.460 --> 00:54:17.320
that information.

00:54:17.320 --> 00:54:17.680
All right.

00:54:17.680 --> 00:54:20.230
The thing you've all been
waiting for-- monetization.

00:54:20.230 --> 00:54:23.370
Our deep dark scientists here at
Google have taken a look at

00:54:23.370 --> 00:54:25.410
monetization and what's been
working for games.

00:54:25.410 --> 00:54:28.380
And in an anonymous fashion,
we're going to sort of report

00:54:28.380 --> 00:54:30.190
some of the things that you
should be looking at if you're

00:54:30.190 --> 00:54:32.210
developing web games today.

00:54:32.210 --> 00:54:34.440
So the first off is that
monetization is a dark art.

00:54:34.440 --> 00:54:37.080
What works for one game does
not work for every game.

00:54:37.080 --> 00:54:39.800
And you need to make sure you
understand that first off.

00:54:39.800 --> 00:54:42.350
You can't just grab a game and
say I'm going to monetize like

00:54:42.350 --> 00:54:42.990
they're monetizing.

00:54:42.990 --> 00:54:46.120
It has a lot to do with how
integrated it is with your

00:54:46.120 --> 00:54:48.930
game, with your product, and
with your environment.

00:54:48.930 --> 00:54:51.470
So with that being said, you
need to make sure that you're

00:54:51.470 --> 00:54:53.240
holding the user's hand.

00:54:53.240 --> 00:54:55.570
For instance, we go through
this entire process of

00:54:55.570 --> 00:54:57.800
teaching the user how to play
the game, and we never teach

00:54:57.800 --> 00:54:59.640
them how to purchase an item.

00:54:59.640 --> 00:55:03.850
We've actually seen that the
games that include purchase in

00:55:03.850 --> 00:55:08.800
the tutorial monetize on average
about 30% better than

00:55:08.800 --> 00:55:10.390
those who don't.

00:55:10.390 --> 00:55:12.300
That's amazing.

00:55:12.300 --> 00:55:14.390
Just showing the user how to--

00:55:14.390 --> 00:55:15.830
give them some free credits.

00:55:15.830 --> 00:55:18.960
Let them buy something during
the tutorial to show them the

00:55:18.960 --> 00:55:20.950
store so that they're
not afraid of it.

00:55:20.950 --> 00:55:22.150
Show them what the
benefits are.

00:55:22.150 --> 00:55:23.420
Allow them to browse around.

00:55:23.420 --> 00:55:25.420
We've got some other cool
statistics that show the user

00:55:25.420 --> 00:55:28.280
who do buy during that process
are tons more sticky.

00:55:28.280 --> 00:55:31.320
We'll share that information
at a different time.

00:55:31.320 --> 00:55:34.180
Most importantly with this is
why they should purchase.

00:55:34.180 --> 00:55:36.840
Getting them early in this
process and showing them how

00:55:36.840 --> 00:55:38.270
they should purchase
allows them to also

00:55:38.270 --> 00:55:39.800
see why it's available.

00:55:39.800 --> 00:55:41.810
Most of the time users play a
game, they don't have any

00:55:41.810 --> 00:55:44.150
bearing or understanding about
what's available and why they

00:55:44.150 --> 00:55:44.910
care about it.

00:55:44.910 --> 00:55:47.700
For instance, I never knew there
was a sword of Antioch

00:55:47.700 --> 00:55:49.440
that was worth 50-50 power.

00:55:49.440 --> 00:55:52.400
It allowed me to assault
chickens from here until the

00:55:52.400 --> 00:55:54.370
Great Gates of Nagral.

00:55:54.370 --> 00:55:56.580
But now that I do know, I
want to buy that sword.

00:55:56.580 --> 00:55:58.046
Getting them in there
and showing them

00:55:58.046 --> 00:56:00.270
that item is important.

00:56:00.270 --> 00:56:02.180
This is a great graph.

00:56:02.180 --> 00:56:03.050
This is an amazing graph.

00:56:03.050 --> 00:56:05.110
And if you've been reading
anything on monetization in

00:56:05.110 --> 00:56:06.740
games recently, you should
already know

00:56:06.740 --> 00:56:07.710
the outcome of this.

00:56:07.710 --> 00:56:10.320
What this shows is three
line points.

00:56:10.320 --> 00:56:13.250
This is from a particular
product that launched a full

00:56:13.250 --> 00:56:15.390
version that you could
buy up front.

00:56:15.390 --> 00:56:18.390
So you pay $5.99 and you get the
full version, and a free

00:56:18.390 --> 00:56:19.770
version at the same time.

00:56:19.770 --> 00:56:22.490
So they said pay $5
or don't pay $5.

00:56:22.490 --> 00:56:23.770
I don't really care.

00:56:23.770 --> 00:56:25.950
It also provided in-app purchase
so that you can

00:56:25.950 --> 00:56:28.480
actually purchase items
in the game.

00:56:28.480 --> 00:56:31.350
So you're looking at this
time line here.

00:56:31.350 --> 00:56:33.620
In the blue on the bottom,
you're actually looking at the

00:56:33.620 --> 00:56:34.280
full purchase.

00:56:34.280 --> 00:56:37.160
So this is just the amount of
money that came from buying

00:56:37.160 --> 00:56:39.260
the game, just without
anything else.

00:56:39.260 --> 00:56:40.270
Just buy the game up front.

00:56:40.270 --> 00:56:41.670
You can see that in the blue.

00:56:41.670 --> 00:56:45.910
The green is the amount of money
made from the people who

00:56:45.910 --> 00:56:48.490
bought the full game--
so upfront price--

00:56:48.490 --> 00:56:50.120
as well as in-app purchase.

00:56:50.120 --> 00:56:52.090
So they bought the game, they
spent $5, and then they spend

00:56:52.090 --> 00:56:56.370
an additional $10 or $11
buying upgraded items.

00:56:56.370 --> 00:56:59.070
The pink or the orange depending
on what your monitor

00:56:59.070 --> 00:57:01.990
color is and how this gets
compressed on YouTube is

00:57:01.990 --> 00:57:05.630
actually the total input
from the free app

00:57:05.630 --> 00:57:07.210
just for in-app purchase.

00:57:07.210 --> 00:57:09.210
Which means these people didn't
buy up front version.

00:57:09.210 --> 00:57:11.340
They just spent all of their
money in the game actually

00:57:11.340 --> 00:57:13.670
buying items. It's through
the roof in a

00:57:13.670 --> 00:57:14.400
couple different places.

00:57:14.400 --> 00:57:16.840
But in general, it just
over-monetizes everything.

00:57:16.840 --> 00:57:18.620
And the reason for this
can be twofold.

00:57:18.620 --> 00:57:21.040
Number one, it could be that the
number of users who got in

00:57:21.040 --> 00:57:23.730
the door to buy the item
were much larger.

00:57:23.730 --> 00:57:27.250
So let's say that the free
version to in-app purchase had

00:57:27.250 --> 00:57:29.190
3x to 4x the number of users.

00:57:29.190 --> 00:57:31.720
Or the users just felt more
generous because they didn't

00:57:31.720 --> 00:57:33.680
already pay $5 to get
the application.

00:57:33.680 --> 00:57:36.140
But the point of this graph--
and we're seeing other results

00:57:36.140 --> 00:57:36.990
show this--

00:57:36.990 --> 00:57:40.120
is that making your game free to
play, some content free to

00:57:40.120 --> 00:57:44.140
play with some form of in-app
purchase for content expansion

00:57:44.140 --> 00:57:46.510
is definitely the way to go.

00:57:46.510 --> 00:57:48.250
Now once you do this though,
you're going to ask yourself

00:57:48.250 --> 00:57:51.300
what kind of virtual goods
should I be selling?

00:57:51.300 --> 00:57:53.340
If we're going to embrace this
in-app purchase thing, what

00:57:53.340 --> 00:57:53.870
should I be doing?

00:57:53.870 --> 00:57:56.970
There's a great graph by
Flurry that's online.

00:57:56.970 --> 00:57:57.450
Go grab it.

00:57:57.450 --> 00:57:58.110
Take a look at it.

00:57:58.110 --> 00:58:00.730
Which actually shows the
breakdown of durable goods and

00:58:00.730 --> 00:58:01.830
who's buying what.

00:58:01.830 --> 00:58:05.010
So first off, we notice that
personalization items through

00:58:05.010 --> 00:58:06.850
in-app purchase are
only about 2%.

00:58:06.850 --> 00:58:10.580
So only about 2% of transactions
in this graph are

00:58:10.580 --> 00:58:14.290
for hey, I would like to buy
that shiny chicken hat that

00:58:14.290 --> 00:58:16.010
clucks any time I get next
to someone else who

00:58:16.010 --> 00:58:17.210
has a chicken hat.

00:58:17.210 --> 00:58:18.600
Only about 2%.

00:58:18.600 --> 00:58:21.900
About 30% are durable items.
These are effectively items

00:58:21.900 --> 00:58:24.610
that you buy and then keep the
rest of your gaming existence.

00:58:24.610 --> 00:58:28.340
So the sword of Antioch that I
then keep until I'm level 90.

00:58:28.340 --> 00:58:29.950
Only about 30% buy that.

00:58:29.950 --> 00:58:32.550
Where the big money is actually
in consumable goods.

00:58:32.550 --> 00:58:34.730
And basically consumable
goods are goods that

00:58:34.730 --> 00:58:36.690
have a limited lifespan.

00:58:36.690 --> 00:58:40.890
So pay $0.99 to get a speed
boost for the next hour.

00:58:40.890 --> 00:58:44.750
Or also included in this item
is virtual currency.

00:58:44.750 --> 00:58:47.720
So pay $5 to get 200 coins.

00:58:47.720 --> 00:58:50.120
And then the coins can then be
used to purchase other items

00:58:50.120 --> 00:58:51.220
in the game.

00:58:51.220 --> 00:58:53.610
Virtual currency is considered
a consumable good.

00:58:53.610 --> 00:58:55.830
And as you can see, that whole
section of consumables--

00:58:55.830 --> 00:58:57.540
so limited lifetime objects--

00:58:57.540 --> 00:59:01.400
are actually dominating how
people are buying nowadays.

00:59:01.400 --> 00:59:03.240
So let's talk about virtual
currency for a second.

00:59:03.240 --> 00:59:05.840
So if you have virtual currency,
the numbers actually

00:59:05.840 --> 00:59:08.350
show that you should have a
multiple currency system.

00:59:08.350 --> 00:59:10.290
Not a multiple virtual currency,
but a multiple

00:59:10.290 --> 00:59:11.160
currency system.

00:59:11.160 --> 00:59:13.800
So you should be able to allow
your users to effectively buy

00:59:13.800 --> 00:59:17.750
premium currency from in-app
purchases, and then also have

00:59:17.750 --> 00:59:20.510
some sort of grind currency
from game play.

00:59:20.510 --> 00:59:23.830
So I play this level, I
kick a chicken, the

00:59:23.830 --> 00:59:25.550
chicken drops one bronze.

00:59:25.550 --> 00:59:25.840
Cool.

00:59:25.840 --> 00:59:26.680
I got a bronze.

00:59:26.680 --> 00:59:31.430
But then I can go and
buy for $5 100 gold.

00:59:31.430 --> 00:59:34.140
And really the metric here this
starts getting cool is

00:59:34.140 --> 00:59:36.650
that you allow trading
between currencies.

00:59:36.650 --> 00:59:41.380
So I can turn my 100 gold into
5,000 copper or vice-versa.

00:59:41.380 --> 00:59:44.100
And this creates this really
interesting dynamic that the

00:59:44.100 --> 00:59:46.720
user feels like they're smart
because they feel like they're

00:59:46.720 --> 00:59:47.460
in control.

00:59:47.460 --> 00:59:50.380
They can either spend $5 to get
the item or they can go

00:59:50.380 --> 00:59:52.820
grind for five hours to get
the same item and the same

00:59:52.820 --> 00:59:54.860
cost and then translate between
the two to buy more

00:59:54.860 --> 00:59:56.570
items. This is really cool.

00:59:56.570 --> 00:59:58.660
Empowering your user and letting
them know that they're

00:59:58.660 --> 01:00:01.420
in control and they feel smart
is the best way to monetize

01:00:01.420 --> 01:00:03.480
and keep players coming back.

01:00:03.480 --> 01:00:05.500
It also enables instant
gratification.

01:00:05.500 --> 01:00:09.650
So if I go to buy an item and
I don't have enough virtual

01:00:09.650 --> 01:00:12.160
currency sitting around, you
should probably allow the user

01:00:12.160 --> 01:00:14.280
to buy that item without
virtual currency.

01:00:14.280 --> 01:00:16.370
Nothing's more annoying than
saying I want to buy this

01:00:16.370 --> 01:00:18.740
sword, but before I can actually
pay you for it, I

01:00:18.740 --> 01:00:22.080
have to go buy 100 coin
points and then go

01:00:22.080 --> 01:00:22.920
back and buy the sword.

01:00:22.920 --> 01:00:23.320
No.

01:00:23.320 --> 01:00:25.850
What you should say is hey, you
don't have enough credits

01:00:25.850 --> 01:00:26.750
available to you.

01:00:26.750 --> 01:00:30.240
Would you like to buy this sword
for face value at $7.99.

01:00:30.240 --> 01:00:32.430
And this is also a great point
that once you present this to

01:00:32.430 --> 01:00:34.750
the user, you actually have
a chance to upsell.

01:00:34.750 --> 01:00:36.020
You've now got their
attention.

01:00:36.020 --> 01:00:38.790
Hey, you don't have enough
points to buy this.

01:00:38.790 --> 01:00:42.280
You can either buy it for $7.99
or what you could do is

01:00:42.280 --> 01:00:43.970
buy 1,000 credits and
we'll give you the

01:00:43.970 --> 01:00:46.490
sword for 50% off.

01:00:46.490 --> 01:00:48.120
That's an interesting
correlation.

01:00:48.120 --> 01:00:49.820
You now have the user's
attention.

01:00:49.820 --> 01:00:53.280
It's tied to an object they
want, and they see value in a

01:00:53.280 --> 01:00:54.720
different proposition.

01:00:54.720 --> 01:00:57.186
That's really cool and you
should take advantage of that.

01:00:57.186 --> 01:01:00.150
You should also take advantage
of simplified purchase flow.

01:01:00.150 --> 01:01:03.260
So when the user wants to buy
your item, you should make it

01:01:03.260 --> 01:01:05.270
as easy as possible
for them to do so.

01:01:05.270 --> 01:01:07.380
So leverage in-app
payment APIs.

01:01:07.380 --> 01:01:09.860
Rather than directing the user
to some other site that they

01:01:09.860 --> 01:01:11.640
then have to go through that
site and get through that

01:01:11.640 --> 01:01:14.010
purchase flow in and then get an
item and then come back and

01:01:14.010 --> 01:01:15.750
enter a key code, that
just doesn't work.

01:01:15.750 --> 01:01:18.190
You should be using
in-app APIs.

01:01:18.190 --> 01:01:20.460
And some of these things
have great features.

01:01:20.460 --> 01:01:23.440
So for example, you get access
to millions of credit cards

01:01:23.440 --> 01:01:25.180
for these APIs.

01:01:25.180 --> 01:01:26.910
You have powerful fraud
engines that

01:01:26.910 --> 01:01:27.960
exist on the back side.

01:01:27.960 --> 01:01:29.360
Plug and play purchase
flow through

01:01:29.360 --> 01:01:30.630
JavaScript and whatnot.

01:01:30.630 --> 01:01:32.050
And you get to play
in a few clicks.

01:01:32.050 --> 01:01:34.390
And Google Wallet provides
all of these things.

01:01:34.390 --> 01:01:36.920
So with Google Wallet, you can
actually issue JavaScript

01:01:36.920 --> 01:01:41.030
commands to a server, allow the
user to buy items. You get

01:01:41.030 --> 01:01:43.570
access to anyone who's got
availability of a credit card

01:01:43.570 --> 01:01:44.780
existing in Google Wallet.

01:01:44.780 --> 01:01:47.050
We've already got fraud engines
set up, purchase flow,

01:01:47.050 --> 01:01:48.340
and all this other stuff.

01:01:48.340 --> 01:01:49.210
Use Google Wallet.

01:01:49.210 --> 01:01:51.190
You should definitely leverage
this as opposed to forcing the

01:01:51.190 --> 01:01:54.400
user to go through some
third party site.

01:01:54.400 --> 01:01:57.350
So let's talk about the high
points here or the takeaways

01:01:57.350 --> 01:01:58.540
or take outs.

01:01:58.540 --> 01:02:01.270
So first off, bundle your assets
into segment archives.

01:02:01.270 --> 01:02:02.160
Really important.

01:02:02.160 --> 01:02:05.740
Set your proper caching times
for both data and query stuff

01:02:05.740 --> 01:02:07.370
on Google App Engine.

01:02:07.370 --> 01:02:10.070
Provide a single login for your
users so that they don't

01:02:10.070 --> 01:02:12.600
have to create multiple sessions
or multiple users.

01:02:12.600 --> 01:02:14.420
Localize your content
properly.

01:02:14.420 --> 01:02:15.620
Super important there.

01:02:15.620 --> 01:02:18.220
Be able to detect your GPU
blacklisted and performance

01:02:18.220 --> 01:02:20.240
problems and alert
the user early.

01:02:20.240 --> 01:02:23.130
Nothing's more annoying than a
user spending an hour trying

01:02:23.130 --> 01:02:25.710
to get a game to run to finally
be told through

01:02:25.710 --> 01:02:28.710
frustration that they can't
play the application.

01:02:28.710 --> 01:02:31.540
Make sure that you detect and
fetch bugs in a wild.

01:02:31.540 --> 01:02:33.180
You need to be able to know
what's going on in the

01:02:33.180 --> 01:02:34.770
universe that you can fix
it and create a better

01:02:34.770 --> 01:02:35.840
experience.

01:02:35.840 --> 01:02:38.390
You should also make sure that
when the user tabs away that

01:02:38.390 --> 01:02:40.150
you detect that and
respond properly.

01:02:40.150 --> 01:02:43.740
You should track the data of
your users so you can optimize

01:02:43.740 --> 01:02:45.470
your game for their
experience.

01:02:45.470 --> 01:02:47.530
And you should choose a
monetization metric

01:02:47.530 --> 01:02:48.410
that fits your game.

01:02:48.410 --> 01:02:50.580
It's probably one of the most
important points there.

01:02:50.580 --> 01:02:52.680
And if you do, once you have
chosen that monetization

01:02:52.680 --> 01:02:55.060
method if you do you choose
a path that focuses on

01:02:55.060 --> 01:02:58.110
consumable goods, make sure you
focus on consumable and

01:02:58.110 --> 01:03:00.260
durable because that's where the
largest portion of the pie

01:03:00.260 --> 01:03:02.150
is for in-app purchase.

01:03:02.150 --> 01:03:04.230
And then finally, for in-app
purchase, definitely use the

01:03:04.230 --> 01:03:05.080
Google Wallet API.

01:03:05.080 --> 01:03:05.870
It's available.

01:03:05.870 --> 01:03:06.620
It's usable.

01:03:06.620 --> 01:03:08.740
It's quick to get started and
it's amazing what kind of

01:03:08.740 --> 01:03:10.610
power it gives you.

01:03:10.610 --> 01:03:13.810
So in general, it takes lots of
work to develop a game that

01:03:13.810 --> 01:03:15.340
has nothing to do
with your game.

01:03:15.340 --> 01:03:17.720
A lot of the things we talked
about had nothing to do with

01:03:17.720 --> 01:03:21.580
path finding or play balancing
or how to properly get a sword

01:03:21.580 --> 01:03:23.230
to whack a demon, like
nothing of that.

01:03:23.230 --> 01:03:24.790
This is all back end stuff.

01:03:24.790 --> 01:03:27.070
And because of that, you should
be leveraging services

01:03:27.070 --> 01:03:27.800
that make it easy.

01:03:27.800 --> 01:03:30.420
You want to be spending time
optimizing your game, not

01:03:30.420 --> 01:03:32.280
spending time optimizing
these other services.

01:03:32.280 --> 01:03:35.240
The fantastic thing is Google's
got a lot of services

01:03:35.240 --> 01:03:37.400
that we have available for
you to get started.

01:03:37.400 --> 01:03:38.110
Definitely use them.

01:03:38.110 --> 01:03:40.060
Definitely take advantage of
them, and make sure you get

01:03:40.060 --> 01:03:41.300
your game the best it can be.

01:03:41.300 --> 01:03:45.790
So a big thanks to Pong Yang
and Fred Sauer, as well as

01:03:45.790 --> 01:03:47.740
Chrome Developer Relations
for input on this talk.

01:03:47.740 --> 01:03:49.630
Thank you very much.

01:03:49.630 --> 01:03:51.510
Hit me up with any questions you
have. I'm available here.

