WEBVTT
Kind: captions
Language: en

00:00:09.610 --> 00:00:10.180
Hello.

00:00:10.180 --> 00:00:10.920
Hello.

00:00:10.920 --> 00:00:12.440
Is this working?

00:00:12.440 --> 00:00:14.380
It's going to be
slightly complicated

00:00:14.380 --> 00:00:16.140
holding both this and this.

00:00:16.140 --> 00:00:18.195
So if I start holding
this up to my mouth,

00:00:18.195 --> 00:00:21.150
just someone wave at me.

00:00:21.150 --> 00:00:24.950
So as developers, our bounds
and our responsibilities

00:00:24.950 --> 00:00:27.930
in the industry have
changed all the time.

00:00:27.930 --> 00:00:30.280
And if you think back
to the start of the web,

00:00:30.280 --> 00:00:32.850
it was just text on a screen.

00:00:32.850 --> 00:00:36.634
And our goal was to have that
text be read by someone else.

00:00:36.634 --> 00:00:38.300
And that was, actually,
quite difficult,

00:00:38.300 --> 00:00:41.340
because there wasn't really
anyone else on the internet.

00:00:41.340 --> 00:00:44.010
But then we got more
and more developers

00:00:44.010 --> 00:00:45.400
working on the internet.

00:00:45.400 --> 00:00:46.370
And we had to compete.

00:00:46.370 --> 00:00:48.410
We wanted to compete
with other developers

00:00:48.410 --> 00:00:51.020
to show that we were
better than they were.

00:00:51.020 --> 00:00:55.310
And we did this by putting
our pages in outer space

00:00:55.310 --> 00:01:01.320
and centering things and moving
things from side to side.

00:01:01.320 --> 00:01:03.450
We really liked the
moving bits on the web.

00:01:03.450 --> 00:01:07.251
So we added a whole
bunch of them.

00:01:07.251 --> 00:01:10.640
Make it look like there's loads
of complicated stuff going on.

00:01:10.640 --> 00:01:13.130
Because the more complicated
it looks, the more complicated

00:01:13.130 --> 00:01:14.170
it must've been.

00:01:14.170 --> 00:01:16.340
And that makes us
better developers.

00:01:16.340 --> 00:01:18.760
We discovered JavaScript
at this point.

00:01:18.760 --> 00:01:24.910
And we used JavaScript to create
gray dialogues on the screen.

00:01:24.910 --> 00:01:26.630
But then we looked around.

00:01:26.630 --> 00:01:30.030
And we realized that the
internet had been infiltrated.

00:01:30.030 --> 00:01:34.080
It had been infiltrated
by normal people.

00:01:34.080 --> 00:01:38.630
And it was like our parents
had been away for 10 years.

00:01:38.630 --> 00:01:41.106
And we'd been all
having this great party.

00:01:41.106 --> 00:01:43.605
And all of a sudden they phoned
and said, we're coming home.

00:01:43.605 --> 00:01:47.240
And we're like, oh my god,
look at the mess we've made.

00:01:47.240 --> 00:01:49.110
We need to clean this up.

00:01:49.110 --> 00:01:50.250
And we did.

00:01:50.250 --> 00:01:52.190
Usability became a big deal.

00:01:52.190 --> 00:01:55.580
The GIFs, the marquees,
no longer cool.

00:01:55.580 --> 00:01:59.090
We started thinking about
readability, semantics,

00:01:59.090 --> 00:02:00.570
accessibility.

00:02:00.570 --> 00:02:03.590
It was a real back-to-basics
move for the web.

00:02:03.590 --> 00:02:05.840
We got a new browser
war at this point,

00:02:05.840 --> 00:02:08.590
with more budgets
and bigger explosions

00:02:08.590 --> 00:02:10.310
then the last browser war.

00:02:10.310 --> 00:02:12.870
And Netscape was killed
off in the first scene.

00:02:12.870 --> 00:02:15.120
But some of the new
characters were pretty good.

00:02:15.120 --> 00:02:18.890
Here we had the Chromes,
the Firefoxes, the Safaris.

00:02:18.890 --> 00:02:20.440
A new generation
of developers had

00:02:20.440 --> 00:02:24.390
to care about this platform
and browser compatibility.

00:02:24.390 --> 00:02:26.530
We started using
JavaScript properly.

00:02:26.530 --> 00:02:28.870
CSS became more powerful.

00:02:28.870 --> 00:02:32.380
And then our testing
surface area exploded.

00:02:32.380 --> 00:02:34.860
This happened.

00:02:34.860 --> 00:02:38.540
Now we had to care about the
different interactions and user

00:02:38.540 --> 00:02:41.250
experience of all these
different devices.

00:02:41.250 --> 00:02:44.510
And this is pretty
much where we are now,

00:02:44.510 --> 00:02:48.060
except GIFs are cool
again as long as they're

00:02:48.060 --> 00:02:53.410
three megabytes in size and
they're of a cat doing a thing.

00:02:53.410 --> 00:02:56.840
But until fairly recently,
we'd taken an odd stance

00:02:56.840 --> 00:02:58.960
when it comes to
graphical performance.

00:02:58.960 --> 00:03:02.070
Our goal was usable.

00:03:02.070 --> 00:03:05.520
Not good, usable.

00:03:05.520 --> 00:03:08.720
On machines that could
draw 3D worlds fast enough

00:03:08.720 --> 00:03:11.620
to respond to gaming
controls in real time,

00:03:11.620 --> 00:03:15.290
we were happy for our
2D, fairly static pages

00:03:15.290 --> 00:03:18.115
to perform just a little
bit better than unusable.

00:03:21.370 --> 00:03:23.400
Well, that's not
good enough anymore.

00:03:23.400 --> 00:03:26.040
Facebook did an experiment
where they artificially

00:03:26.040 --> 00:03:30.480
decreased the performance
of their mobile app.

00:03:30.480 --> 00:03:33.120
They decreased the frame rate.

00:03:33.120 --> 00:03:35.250
It was still usable,
just not as smooth.

00:03:35.250 --> 00:03:37.850
And when they did this,
they saw a significant drop

00:03:37.850 --> 00:03:39.300
in engagement.

00:03:39.300 --> 00:03:41.890
If you're not caring about
graphics performance,

00:03:41.890 --> 00:03:45.630
then your users are going
to go to someone who does.

00:03:45.630 --> 00:03:47.450
And this wasn't
possible until recently,

00:03:47.450 --> 00:03:49.530
because the browsers
didn't really

00:03:49.530 --> 00:03:52.490
let us deliver fluid
user experiences.

00:03:52.490 --> 00:03:53.990
But they've all
made a leap forward,

00:03:53.990 --> 00:03:57.890
all of the browsers, IE,
Chrome, Firefox, Safari.

00:03:57.890 --> 00:04:00.489
But as developers, we still
have to meet them halfway.

00:04:00.489 --> 00:04:02.280
There's a few things
we have to do in order

00:04:02.280 --> 00:04:04.940
to deliver this fluid
user experience.

00:04:04.940 --> 00:04:06.530
And DevTools are here to help.

00:04:06.530 --> 00:04:08.660
We saw Paul Irish talking
about this earlier.

00:04:08.660 --> 00:04:10.900
The Timeline shows you
all of the stuff that's

00:04:10.900 --> 00:04:14.350
going on in the background
as Chrome builds up a page.

00:04:14.350 --> 00:04:15.690
But what are all these steps?

00:04:15.690 --> 00:04:16.890
What do they mean?

00:04:16.890 --> 00:04:18.500
And what causes them to happen?

00:04:18.500 --> 00:04:21.469
How does the browser
get from data to pixels?

00:04:24.310 --> 00:04:26.720
Well, in the beginning,
there is nothing.

00:04:26.720 --> 00:04:28.720
And then like a burst
tap, the browser

00:04:28.720 --> 00:04:32.510
is sprayed with HTML
text from the internet.

00:04:32.510 --> 00:04:35.620
And it will convert that
text into a tree of elements

00:04:35.620 --> 00:04:39.680
that we know as the Document
Object Model, the DOM.

00:04:39.680 --> 00:04:42.000
This step in the
process is-- I'm

00:04:42.000 --> 00:04:44.410
sure you know already--
called parsing.

00:04:44.410 --> 00:04:48.320
And this will show up in the
timeline there, parse HTML.

00:04:48.320 --> 00:04:50.690
You'll see this as the
page initially loads.

00:04:50.690 --> 00:04:53.810
But you'll also see it if
you pass an HTML string

00:04:53.810 --> 00:04:57.220
to a particular
JavaScript interface.

00:04:57.220 --> 00:04:58.780
It's like inner HTML.

00:04:58.780 --> 00:05:01.200
You'll see parsing
happening there.

00:05:01.200 --> 00:05:02.920
We haven't drawn
anything at this point.

00:05:02.920 --> 00:05:04.694
The screen is still blank.

00:05:04.694 --> 00:05:06.360
At this point, the
browser needs to know

00:05:06.360 --> 00:05:08.260
what these elements
look like and where

00:05:08.260 --> 00:05:09.610
they appear on the page.

00:05:09.610 --> 00:05:12.420
And this starts with
a style calculation.

00:05:12.420 --> 00:05:15.980
This looks at the CSS
cascade, the style attributes,

00:05:15.980 --> 00:05:18.560
your font tags-- if
you're from the '90s--

00:05:18.560 --> 00:05:21.890
and it works out which
styles apply to each element.

00:05:21.890 --> 00:05:23.705
And this event shows
up on the timeline.

00:05:23.705 --> 00:05:26.950
We saw Paul talking about this
earlier, recalculate style.

00:05:26.950 --> 00:05:30.120
You'll see this whenever
you load a CSS file,

00:05:30.120 --> 00:05:33.660
when you change the style object
on an element, when you change

00:05:33.660 --> 00:05:37.875
a class name, or when you
move the DOM tree around.

00:05:37.875 --> 00:05:40.250
Some of these elements didn't
get their style calculated.

00:05:40.250 --> 00:05:42.420
This paragraph
here and this div,

00:05:42.420 --> 00:05:44.310
they didn't get their
style calculated.

00:05:44.310 --> 00:05:46.990
And this is because when
we looked at this div,

00:05:46.990 --> 00:05:49.585
it turned out to
be display:none.

00:05:49.585 --> 00:05:51.710
And this is where the
browser will make a shortcut.

00:05:51.710 --> 00:05:53.450
Because there's
no point thinking

00:05:53.450 --> 00:05:55.000
about the styles
of these elements,

00:05:55.000 --> 00:05:58.420
because they have no impact on
the visual output of the page.

00:05:58.420 --> 00:06:01.220
So it will shortcut
at that point.

00:06:01.220 --> 00:06:04.231
We haven't drawn anything
at this point, of course.

00:06:04.231 --> 00:06:06.730
Because although we know which
styles apply to each element,

00:06:06.730 --> 00:06:09.770
we don't know how those styles
interact with each other.

00:06:09.770 --> 00:06:12.390
We don't know the size and
position of each element.

00:06:12.390 --> 00:06:13.930
To do this, we
create another tree

00:06:13.930 --> 00:06:16.870
internally in the
browser, a render tree.

00:06:16.870 --> 00:06:19.530
And this knows where
everything sits on the page

00:06:19.530 --> 00:06:21.450
and how big it is.

00:06:21.450 --> 00:06:23.740
This process is called
layout, and that

00:06:23.740 --> 00:06:25.720
appears in the timeline as well.

00:06:25.720 --> 00:06:28.120
Changing the DOM
causes a layout.

00:06:28.120 --> 00:06:30.570
Style changes may
cause a layout.

00:06:30.570 --> 00:06:34.390
If you change the border size of
something, you'll get a layout.

00:06:34.390 --> 00:06:36.700
But if you change
the background color,

00:06:36.700 --> 00:06:39.090
that doesn't impact where
things appear on the page.

00:06:39.090 --> 00:06:41.065
So you don't get a layout there.

00:06:41.065 --> 00:06:43.510
But even things like
resizing the browser,

00:06:43.510 --> 00:06:47.189
that's going to cause
a layout to happen.

00:06:47.189 --> 00:06:48.980
You'll notice that
these trees are similar.

00:06:48.980 --> 00:06:51.680
But they're not
exactly the same.

00:06:51.680 --> 00:06:55.950
For instance, this heading
here has a render object.

00:06:55.950 --> 00:06:57.930
But there's also a
child render object

00:06:57.930 --> 00:06:59.860
that doesn't appear in the DOM.

00:06:59.860 --> 00:07:02.800
And in this case, this
is a CSS pseudo element,

00:07:02.800 --> 00:07:07.400
like Before or After, that will
create itself a render object.

00:07:07.400 --> 00:07:08.840
We see this video element here.

00:07:08.840 --> 00:07:12.539
This video element has an
element in the render tree.

00:07:12.539 --> 00:07:14.080
But in the render
tree there's always

00:07:14.080 --> 00:07:17.990
this series of render objects
that aren't in the DOM.

00:07:17.990 --> 00:07:20.120
I feel like a
weatherman doing this.

00:07:20.120 --> 00:07:20.950
It's great.

00:07:20.950 --> 00:07:22.920
So this is the video
element shadow DOM.

00:07:22.920 --> 00:07:24.390
These are the
elements that make up

00:07:24.390 --> 00:07:26.940
the slider, the volume
control, et cetera.

00:07:30.310 --> 00:07:32.880
Also, we have this
div here, which

00:07:32.880 --> 00:07:34.980
doesn't appear in the
render tree at all.

00:07:34.980 --> 00:07:37.130
And as I said before,
it's display:none.

00:07:37.130 --> 00:07:39.360
It has no visual
impact on the page.

00:07:39.360 --> 00:07:42.790
So it doesn't go
into the render tree.

00:07:42.790 --> 00:07:45.847
We still haven't actually
drawn anything yet, of course.

00:07:45.847 --> 00:07:47.430
At some point, the
browser will decide

00:07:47.430 --> 00:07:50.520
that an area of the screen is
showing the wrong thing, which

00:07:50.520 --> 00:07:52.070
could mean it's blank.

00:07:52.070 --> 00:07:53.774
Or you've updated part of it.

00:07:53.774 --> 00:07:55.190
And what the browser
will do then,

00:07:55.190 --> 00:07:57.385
is it will identify
the render objects that

00:07:57.385 --> 00:07:58.970
form part of that page.

00:07:58.970 --> 00:08:02.010
And it will create
drawing instructions,

00:08:02.010 --> 00:08:05.380
create pixels for that data,
and send them off to the GPU.

00:08:05.380 --> 00:08:06.840
And they appear on the screen.

00:08:06.840 --> 00:08:08.690
And that process is "paint."

00:08:08.690 --> 00:08:12.250
And it'll show you how much was
painted and when it happened.

00:08:12.250 --> 00:08:14.500
Paint, of course,
by visual changes,

00:08:14.500 --> 00:08:18.290
that can be triggered by DOM
changes, style changes, layout

00:08:18.290 --> 00:08:19.330
changes.

00:08:19.330 --> 00:08:24.550
But even just highlighting text
on the page, or hover effects,

00:08:24.550 --> 00:08:26.730
they're going to cause
paints to happen.

00:08:26.730 --> 00:08:29.300
And that's a lot of stuff
for the browser to do.

00:08:29.300 --> 00:08:30.760
And we know how to measure it.

00:08:30.760 --> 00:08:33.049
But how fast should it be?

00:08:33.049 --> 00:08:34.280
We want it to be instant.

00:08:34.280 --> 00:08:37.570
But how fast is instant?

00:08:37.570 --> 00:08:41.240
The consensus is you want to
update the screen within 100

00:08:41.240 --> 00:08:43.010
milliseconds of interaction.

00:08:43.010 --> 00:08:44.810
This is an article I see cited.

00:08:44.810 --> 00:08:47.620
This is the United
States Department

00:08:47.620 --> 00:08:49.940
of Defense design
criteria standard, which

00:08:49.940 --> 00:08:53.020
I hope is easier to say in
Korean than it is in English.

00:08:53.020 --> 00:08:54.990
These figures are from 1999.

00:08:54.990 --> 00:08:58.480
So maybe expectations
are a bit higher now.

00:08:58.480 --> 00:09:01.490
But 100 milliseconds still
feels right to respond

00:09:01.490 --> 00:09:03.330
to a user interaction.

00:09:03.330 --> 00:09:05.180
Let's have a look at an example.

00:09:05.180 --> 00:09:07.580
So here I've got these
rainbow colors here.

00:09:07.580 --> 00:09:11.880
And if I click on them, they
change to a different color,

00:09:11.880 --> 00:09:13.430
the opposite color in the hue.

00:09:13.430 --> 00:09:16.704
And the code for that's
really, really simple.

00:09:16.704 --> 00:09:18.370
All I'm doing is I'm
looping through all

00:09:18.370 --> 00:09:20.630
of these, all the
elements that are here,

00:09:20.630 --> 00:09:22.100
assigning them a color.

00:09:22.100 --> 00:09:24.220
And then on click
it's going to swap

00:09:24.220 --> 00:09:27.350
the color to the opposite hue.

00:09:27.350 --> 00:09:28.660
It's pretty quick.

00:09:28.660 --> 00:09:33.540
But if we look at our mobile,
it's really, really sluggish.

00:09:33.540 --> 00:09:36.130
It feels really, really slow.

00:09:36.130 --> 00:09:38.790
Mobile phones are
slower than desktop,

00:09:38.790 --> 00:09:40.690
but they're not that slow.

00:09:40.690 --> 00:09:43.160
This isn't caused by poor
hardware performance.

00:09:43.160 --> 00:09:45.520
This is an event issue.

00:09:45.520 --> 00:09:49.210
You see, with mobile
phones you can pinch zoom.

00:09:49.210 --> 00:09:53.490
But you can also double
tap to zoom into some text.

00:09:53.490 --> 00:09:55.000
And this is a
problem, because it

00:09:55.000 --> 00:09:58.040
means on every tap
we have to wait.

00:09:58.040 --> 00:10:01.050
We have to wait to see if
you're going to double tap.

00:10:01.050 --> 00:10:03.720
And that wait is
300 milliseconds.

00:10:03.720 --> 00:10:05.210
And that's there.

00:10:05.210 --> 00:10:08.680
So if we're saying 100
milliseconds feels instant,

00:10:08.680 --> 00:10:11.840
you are already three times
over that before you even

00:10:11.840 --> 00:10:15.940
get a chance to run any
code, which is a big problem.

00:10:15.940 --> 00:10:19.570
We could fix this by instead
of using click, or as well

00:10:19.570 --> 00:10:23.742
as using click, we
could use touchend.

00:10:23.742 --> 00:10:24.450
And that's great.

00:10:24.450 --> 00:10:27.450
Oh, it loads faster, excellent.

00:10:27.450 --> 00:10:31.120
But at the end of scroll,
ah, we wouldn't expect that.

00:10:31.120 --> 00:10:34.430
Because that's still a touchend.

00:10:34.430 --> 00:10:36.070
This is how it works
in most browsers.

00:10:36.070 --> 00:10:39.180
This is how it works
on iOS, the old Android

00:10:39.180 --> 00:10:41.180
browser, and Firefox.

00:10:41.180 --> 00:10:44.600
Chrome won't fire a touchend
if scrolling happens.

00:10:44.600 --> 00:10:47.450
But I think we're
going to switch

00:10:47.450 --> 00:10:49.240
to doing the same
thing as everyone

00:10:49.240 --> 00:10:51.440
else just to be consistent.

00:10:51.440 --> 00:10:53.880
Everyone's doing it right
according to the specification.

00:10:53.880 --> 00:10:57.450
The specification is
really, really vague.

00:10:57.450 --> 00:11:00.680
Microsoft's Pointer Event
spec does the right thing.

00:11:00.680 --> 00:11:02.370
It specifies what should happen.

00:11:02.370 --> 00:11:05.790
And it says, if
scrolling takes place,

00:11:05.790 --> 00:11:07.090
you don't fire a pointer up.

00:11:07.090 --> 00:11:10.350
Because the events are being
taken over by the hardware.

00:11:10.350 --> 00:11:12.640
Unfortunately, there's not
a lot of support for this.

00:11:12.640 --> 00:11:14.500
And even then, we'd
only be able to use

00:11:14.500 --> 00:11:17.550
this when we're dealing
with events in JavaScript.

00:11:17.550 --> 00:11:19.960
What if the user's just
clicking on a check

00:11:19.960 --> 00:11:22.250
box or an input or a link?

00:11:22.250 --> 00:11:25.360
We want that to
be faster as well.

00:11:25.360 --> 00:11:27.460
This library is really great.

00:11:27.460 --> 00:11:29.880
It's by the "Financial
Times," called Fastclick.

00:11:29.880 --> 00:11:32.530
And what that does is it uses
a series of touch listeners.

00:11:32.530 --> 00:11:35.400
But also analyzes how far the
page is scrolled in between

00:11:35.400 --> 00:11:38.170
or how far the user's
finger is moved in between.

00:11:38.170 --> 00:11:39.780
And it will try and
fire click events

00:11:39.780 --> 00:11:42.841
as soon as it can at the
expense of double tap.

00:11:42.841 --> 00:11:44.840
You lose the double-tap
gesture, but your clicks

00:11:44.840 --> 00:11:47.060
become a whole lot faster.

00:11:47.060 --> 00:11:49.870
Alternatively, if you have
a viewport on your page

00:11:49.870 --> 00:11:53.300
and it's fixed, double
tap doesn't mean anything,

00:11:53.300 --> 00:11:54.460
because you can't zoom.

00:11:54.460 --> 00:11:57.330
So we get rid of the
300-millisecond delay,

00:11:57.330 --> 00:11:59.060
which is great.

00:11:59.060 --> 00:12:03.830
This only works in Chrome on
Android and Firefox on Android.

00:12:03.830 --> 00:12:05.520
But even then,
pinch zooming feels

00:12:05.520 --> 00:12:07.450
like a really nice
accessibility feature.

00:12:07.450 --> 00:12:10.962
And it's something
people expect of the web.

00:12:10.962 --> 00:12:12.920
At the moment, in Chrome,
we're looking at ways

00:12:12.920 --> 00:12:15.220
that we can get rid of
that 300-millisecond delay,

00:12:15.220 --> 00:12:17.980
even on pages with
some degree of zooming.

00:12:17.980 --> 00:12:19.880
We're hoping to land
that later this year.

00:12:19.880 --> 00:12:22.850
But in the meantime,
the "Financial Times"

00:12:22.850 --> 00:12:26.560
Fastclick script is
absolutely brilliant.

00:12:26.560 --> 00:12:28.190
So 100 milliseconds
feels instant.

00:12:28.190 --> 00:12:31.300
And anything over
that, not so much.

00:12:31.300 --> 00:12:32.362
What about this?

00:12:32.362 --> 00:12:35.250
This is some snow,
where it animates

00:12:35.250 --> 00:12:38.310
one frame every
100 milliseconds.

00:12:38.310 --> 00:12:42.070
Here's a touch action, where
this square updates every 100

00:12:42.070 --> 00:12:43.620
milliseconds.

00:12:43.620 --> 00:12:45.920
100 milliseconds is not
good enough for animation.

00:12:45.920 --> 00:12:50.710
And it's not good enough for
continual touch feedback.

00:12:50.710 --> 00:12:52.570
If we see our apps
performing like this,

00:12:52.570 --> 00:12:58.870
we must ask, what the frames
per second is going on here?

00:12:58.870 --> 00:13:00.630
And in that case, it was 10.

00:13:00.630 --> 00:13:02.495
10 frames per
second was going on.

00:13:02.495 --> 00:13:05.532
And if that's not
good enough, what is?

00:13:05.532 --> 00:13:06.990
You'll have to
excuse me, because I

00:13:06.990 --> 00:13:10.250
get to nerd out about
frame rates a bit.

00:13:10.250 --> 00:13:12.620
When cinema with
audio was introduced,

00:13:12.620 --> 00:13:14.280
a standard emerged
that frames should

00:13:14.280 --> 00:13:18.980
be 42 milliseconds apart, which
makes it 24 frames per second.

00:13:18.980 --> 00:13:21.430
Film, a series of stills
where the light is

00:13:21.430 --> 00:13:24.960
shone through the
film, 24 was picked

00:13:24.960 --> 00:13:27.370
because film was
quite expensive.

00:13:27.370 --> 00:13:29.720
And they wanted to go
as low as possible.

00:13:29.720 --> 00:13:31.880
So 24 isn't good.

00:13:31.880 --> 00:13:35.880
It was just decided that that's
one better than unwatchable.

00:13:35.880 --> 00:13:39.000
And things stayed like that for
90 years, "The Hobbit" being

00:13:39.000 --> 00:13:41.485
the first mainstream
film to change that.

00:13:41.485 --> 00:13:43.640
That went up to 48
frames per second.

00:13:43.640 --> 00:13:45.160
Meanwhile, this was happening.

00:13:45.160 --> 00:13:49.100
People were getting
color TVs in the homes.

00:13:49.100 --> 00:13:54.260
And in CRT screens, it's
created by an electron

00:13:54.260 --> 00:13:56.890
gun, which sounds really sci-fi.

00:13:56.890 --> 00:13:59.010
And it looks really
sci-fi as well.

00:13:59.010 --> 00:14:00.690
That's a TV electron gun.

00:14:00.690 --> 00:14:04.010
It beams a picture starting from
the top, scans to the bottom

00:14:04.010 --> 00:14:05.370
and then restarts.

00:14:05.370 --> 00:14:08.897
And it did that 60 times
a second here and the US.

00:14:08.897 --> 00:14:10.980
In a lot of the rest of
the world, it was 50 times

00:14:10.980 --> 00:14:11.717
a second.

00:14:11.717 --> 00:14:13.300
That's the refresh
rate of the screen.

00:14:13.300 --> 00:14:16.050
And it's also the
maximum frame rate.

00:14:16.050 --> 00:14:19.640
50 and 60 were chosen because
it depended on the power supply

00:14:19.640 --> 00:14:21.140
frequency of the country.

00:14:21.140 --> 00:14:24.190
And back when the
first TVs were out,

00:14:24.190 --> 00:14:25.830
it was much cheaper
to make them if you

00:14:25.830 --> 00:14:27.980
could rely on the power
supply as the timer

00:14:27.980 --> 00:14:30.020
rather than building
that into the TV.

00:14:30.020 --> 00:14:32.690
So that's where the
difference comes from.

00:14:32.690 --> 00:14:36.510
So some TV shows would go up to
the 50 or 60 frames per second.

00:14:36.510 --> 00:14:39.050
Some TV shows would choose to
miss out every other frame.

00:14:39.050 --> 00:14:40.870
And it would make them
look more like film

00:14:40.870 --> 00:14:44.210
because it would be at 30
or 25 frames per second.

00:14:44.210 --> 00:14:47.620
And this is why "The Hobbit,"
at 48 frames per second,

00:14:47.620 --> 00:14:50.880
felt like a cheap soap opera
or a computer game to people.

00:14:50.880 --> 00:14:54.030
Because it's what they
associate that frame rate with.

00:14:54.030 --> 00:14:56.280
Computer monitors could be
driven at different refresh

00:14:56.280 --> 00:14:56.830
rates.

00:14:56.830 --> 00:14:59.560
50, 60, quite
painful on the eyes.

00:14:59.560 --> 00:15:04.520
We tended to drive them
at 75, 100, even 120.

00:15:04.520 --> 00:15:06.620
We don't use CRTs anymore.

00:15:06.620 --> 00:15:08.480
We use flat screens.

00:15:08.480 --> 00:15:10.130
Not as good for cats
to sit on top of,

00:15:10.130 --> 00:15:12.160
but better for our eyes.

00:15:12.160 --> 00:15:15.145
These screens don't scan in
the same way as CRT screens.

00:15:15.145 --> 00:15:18.630
A higher refresh rate
isn't really beneficial.

00:15:18.630 --> 00:15:20.810
60 is the most common
one we see now.

00:15:20.810 --> 00:15:22.880
You'll encounter the
odd projector or screen

00:15:22.880 --> 00:15:24.390
that wants to be at 75.

00:15:24.390 --> 00:15:27.230
And some laptops
will go down to 50

00:15:27.230 --> 00:15:29.110
when they're running
on battery power.

00:15:29.110 --> 00:15:32.050
So when we want smooth
motion, that's our goal.

00:15:32.050 --> 00:15:34.905
We want to deliver a new
frame for every refresh

00:15:34.905 --> 00:15:37.400
of the screen.

00:15:37.400 --> 00:15:41.150
And at 60 hertz, that's
16.67 milliseconds.

00:15:41.150 --> 00:15:42.430
That's our deadline.

00:15:42.430 --> 00:15:44.930
And that's not long
to edit the DOM,

00:15:44.930 --> 00:15:47.650
calculate style, layout, paint.

00:15:47.650 --> 00:15:49.870
And on the mobile, you've
got less processing power.

00:15:49.870 --> 00:15:52.280
So that feels like less time.

00:15:52.280 --> 00:15:54.690
However, most instances
of animation on the web

00:15:54.690 --> 00:15:56.790
are shooting
themselves in the foot.

00:15:56.790 --> 00:15:58.790
They're not starting
their work early enough.

00:15:58.790 --> 00:16:00.420
Or they're overworking
the browser.

00:16:05.225 --> 00:16:06.600
Let's see, here's
our refreshers,

00:16:06.600 --> 00:16:10.700
each one of them 16.67
milliseconds long.

00:16:10.700 --> 00:16:13.470
Say our frame takes 10
milliseconds to construct.

00:16:13.470 --> 00:16:14.830
That's great.

00:16:14.830 --> 00:16:16.430
That will appear in
the next refresh.

00:16:16.430 --> 00:16:18.070
That's when the
user will see it.

00:16:18.070 --> 00:16:21.340
But when do we start
building the next frame?

00:16:21.340 --> 00:16:23.310
We could go as soon as possible.

00:16:23.310 --> 00:16:27.450
This is the code for
that, set timeout, 0.

00:16:27.450 --> 00:16:29.230
And that looks like this.

00:16:29.230 --> 00:16:32.260
And that work goes
into the refreshes.

00:16:32.260 --> 00:16:35.510
However, some of the frames
we created never actually

00:16:35.510 --> 00:16:37.320
ended up on the screen.

00:16:37.320 --> 00:16:39.010
We were making too many of them.

00:16:39.010 --> 00:16:41.880
And this is going to be using
too much of the CPU, which

00:16:41.880 --> 00:16:45.037
means too much the battery
on devices with battery.

00:16:45.037 --> 00:16:46.620
And at some point,
another application

00:16:46.620 --> 00:16:49.190
is going to come along
and go, do you mind?

00:16:49.190 --> 00:16:51.710
I would quite like
a go on the CPU now.

00:16:51.710 --> 00:16:54.150
And the scheduler will
block what you're doing

00:16:54.150 --> 00:16:55.810
and let this other
app have a go.

00:16:55.810 --> 00:16:58.500
And you will drop frames.

00:16:58.500 --> 00:17:00.102
So this is wrong.

00:17:00.102 --> 00:17:00.810
What could we do?

00:17:00.810 --> 00:17:04.010
We could do setTimeout, 16.667.

00:17:04.010 --> 00:17:07.540
This is pretty much
what jQuery does.

00:17:07.540 --> 00:17:10.349
setTimeout and
setInterval only promise

00:17:10.349 --> 00:17:12.040
that your function
is going to be called

00:17:12.040 --> 00:17:14.839
after the number of
milliseconds you give it.

00:17:14.839 --> 00:17:19.190
And it's rounded to an internal
timer that isn't very accurate.

00:17:19.190 --> 00:17:22.040
So the first four
frames turn out fine.

00:17:22.040 --> 00:17:23.440
But we're out of sync.

00:17:23.440 --> 00:17:26.130
The work is starting later
and later into the refresh

00:17:26.130 --> 00:17:28.000
until here, when we miss.

00:17:28.000 --> 00:17:29.130
We miss our deadline.

00:17:29.130 --> 00:17:30.630
That is going to
go into the refresh

00:17:30.630 --> 00:17:33.280
after we have skipped a frame.

00:17:33.280 --> 00:17:35.705
But this is still 58
frames per second, roughly.

00:17:35.705 --> 00:17:37.150
And that's pretty good.

00:17:39.730 --> 00:17:42.460
When it comes to
orange juice, who

00:17:42.460 --> 00:17:45.150
prefers orange juice with
bits of orange in it,

00:17:45.150 --> 00:17:48.700
like, little bits of orange?

00:17:48.700 --> 00:17:50.770
One guy, Alex, OK.

00:17:50.770 --> 00:17:54.070
Who prefers their
orange juice smooth?

00:17:54.070 --> 00:17:57.640
We've got lots of people with no
opinion on orange juice at all.

00:17:57.640 --> 00:17:58.420
That's fine.

00:17:58.420 --> 00:18:00.296
I prefer it smooth.

00:18:00.296 --> 00:18:01.920
I had this debate
with someone at work.

00:18:01.920 --> 00:18:04.280
And they said,
no, I like to have

00:18:04.280 --> 00:18:07.825
an orange juice that I can chew.

00:18:07.825 --> 00:18:09.200
They're going to
be over the moon

00:18:09.200 --> 00:18:10.800
when they discover oranges.

00:18:10.800 --> 00:18:13.302
It's everything they want.

00:18:13.302 --> 00:18:17.560
But imagine you're
drinking a glass of milk.

00:18:17.560 --> 00:18:19.370
And when you're drinking
a glass of milk,

00:18:19.370 --> 00:18:22.150
a lumpy bit goes
into your mouth.

00:18:22.150 --> 00:18:23.700
It's not expected.

00:18:23.700 --> 00:18:25.450
It's not nice.

00:18:25.450 --> 00:18:26.640
Well, that's like animation.

00:18:26.640 --> 00:18:31.280
Animation is like smooth
orange juice, milk and farts.

00:18:31.280 --> 00:18:34.540
Lumps are unexpected
and unpleasant.

00:18:34.540 --> 00:18:37.240
We don't want them.

00:18:37.240 --> 00:18:39.522
Have a look at this.

00:18:39.522 --> 00:18:41.480
This snow is animating
at half the refresh rate

00:18:41.480 --> 00:18:44.132
of the screen, which is
30 frames per second.

00:18:44.132 --> 00:18:46.590
And you study the motion of
some of the bigger bits of snow

00:18:46.590 --> 00:18:48.820
as they come down the screen.

00:18:48.820 --> 00:18:50.580
It's pretty consistent.

00:18:50.580 --> 00:18:54.200
If we go to use setInterval
this is how jQuery does it.

00:18:54.200 --> 00:18:56.180
If you follow the
bits of snow down

00:18:56.180 --> 00:19:00.640
it's kind of juttery and
jerky as we're getting out

00:19:00.640 --> 00:19:02.030
of sync with the refresh rate.

00:19:02.030 --> 00:19:04.690
This is a higher frame
rate than we saw before.

00:19:04.690 --> 00:19:08.280
But it looks worse
because it's uneven.

00:19:08.280 --> 00:19:10.350
It's uneven because
58 frames per second

00:19:10.350 --> 00:19:12.295
does not divide into 60 hertz.

00:19:12.295 --> 00:19:15.120
It doesn't divide into the
refresh rate of the screen.

00:19:15.120 --> 00:19:16.730
The highest possible
frame rate is

00:19:16.730 --> 00:19:19.730
less important than
staying divisible

00:19:19.730 --> 00:19:22.540
by the screen's refresh rate.

00:19:22.540 --> 00:19:24.010
So how do we solve this?

00:19:24.010 --> 00:19:25.440
It was mentioned earlier.

00:19:25.440 --> 00:19:27.710
We want to use
requestAnimationFrame.

00:19:27.710 --> 00:19:29.310
But this is how it works.

00:19:29.310 --> 00:19:32.070
It will make sure your
JavaScript is called right

00:19:32.070 --> 00:19:34.060
at the start of the
refresh of the screen.

00:19:34.060 --> 00:19:38.130
And this gives you the
full 16.67 milliseconds

00:19:38.130 --> 00:19:39.260
to get your frame ready.

00:19:39.260 --> 00:19:40.890
It gives you the
best possible chance

00:19:40.890 --> 00:19:43.410
of making the next refresh.

00:19:43.410 --> 00:19:46.920
And that's how this looks,
yeah, completely smooth,

00:19:46.920 --> 00:19:50.070
hitting 60 frames per
second and freeing

00:19:50.070 --> 00:19:53.860
up the CPU to other
processes in between.

00:19:53.860 --> 00:19:56.750
The support for
requestAnimationFrame

00:19:56.750 --> 00:19:57.680
is pretty good.

00:19:57.680 --> 00:19:59.810
It's been on desktop
browsers for a while.

00:19:59.810 --> 00:20:03.860
It's kind of new to Internet
Explorer and Safari.

00:20:03.860 --> 00:20:07.250
The story on mobile is
pretty much the same.

00:20:07.250 --> 00:20:09.730
It's more recent on some
browsers than others.

00:20:09.730 --> 00:20:12.260
But you can polyfill
it really easily.

00:20:12.260 --> 00:20:14.640
And it is just dealing
with vendor prefixes

00:20:14.640 --> 00:20:18.100
and then falling back to
set timeouts at the end.

00:20:18.100 --> 00:20:19.750
All you need to do
here is use Date.now

00:20:19.750 --> 00:20:22.860
as your timer and
everything's OK.

00:20:22.860 --> 00:20:26.540
As I said, jQuery does
things the wrong way.

00:20:26.540 --> 00:20:28.370
It does things the lumpy way.

00:20:28.370 --> 00:20:31.030
But a small
extension fixes that.

00:20:31.030 --> 00:20:32.890
And if you're doing
animation with jQuery

00:20:32.890 --> 00:20:35.800
and you're not using this,
you're kind of doing it wrong.

00:20:35.800 --> 00:20:38.874
Because this tiny little bit of
code will make your animation

00:20:38.874 --> 00:20:41.040
a whole lot smoother by
using requestAnimationFrame.

00:20:43.710 --> 00:20:46.410
The reason jQuery just
doesn't do this by default

00:20:46.410 --> 00:20:49.720
is because people have
written code like this.

00:20:49.720 --> 00:20:51.360
So here we've got a carousel.

00:20:51.360 --> 00:20:53.930
And the carousel is
moving every five seconds

00:20:53.930 --> 00:20:56.050
onto the next item.

00:20:56.050 --> 00:20:59.600
And then inside, we're
starting an animation.

00:20:59.600 --> 00:21:02.580
setInterval will
run all the time,

00:21:02.580 --> 00:21:04.400
no matter what's
happening in the browser,

00:21:04.400 --> 00:21:07.230
no matter if you're in another
tab or another desktop,

00:21:07.230 --> 00:21:08.700
that setInterval
is going to run.

00:21:08.700 --> 00:21:10.990
Whereas requestAnimationFrame
is smarter.

00:21:10.990 --> 00:21:14.300
It won't run if the user's in
another tab or somewhere else.

00:21:14.300 --> 00:21:15.500
It'll save the CPU.

00:21:15.500 --> 00:21:18.130
Because the user's not
going to see the result.

00:21:18.130 --> 00:21:20.380
However, when you
mix the two, we're

00:21:20.380 --> 00:21:22.620
calling the next carousel
item every five seconds

00:21:22.620 --> 00:21:24.420
while the user's in another tab.

00:21:24.420 --> 00:21:26.850
These animations
are being requested

00:21:26.850 --> 00:21:28.710
but never actually happen.

00:21:28.710 --> 00:21:31.000
And then the user comes
back into the tab.

00:21:31.000 --> 00:21:34.930
20 animations try and start
at once, and the page breaks.

00:21:34.930 --> 00:21:37.400
So don't write code like this.

00:21:37.400 --> 00:21:41.990
If you're wanting animations to
happen every so many seconds,

00:21:41.990 --> 00:21:44.320
don't schedule the next
one until the previous one

00:21:44.320 --> 00:21:45.220
has finished.

00:21:45.220 --> 00:21:48.500
Because that means the
user can be in another tab.

00:21:48.500 --> 00:21:50.480
And it'll just wait.

00:21:50.480 --> 00:21:52.610
It'll just wait until
the user returns in order

00:21:52.610 --> 00:21:56.550
to continue the animation
or start on the next one.

00:21:56.550 --> 00:21:59.230
The idea of syncing
frames to refresh rates

00:21:59.230 --> 00:22:00.920
isn't particularly new.

00:22:00.920 --> 00:22:03.330
We were talking about
films and TV before.

00:22:03.330 --> 00:22:05.460
And there was the
same problem there.

00:22:05.460 --> 00:22:11.640
So in Korea we were
running at 60 hertz on TVs.

00:22:11.640 --> 00:22:13.660
Modern laptops are also
running at 60 hertz.

00:22:13.660 --> 00:22:16.990
But we want to watch modern
TV shows and films on there.

00:22:16.990 --> 00:22:19.830
And they run at 24
frames per second.

00:22:19.830 --> 00:22:22.670
24 doesn't divide into 60.

00:22:22.670 --> 00:22:26.180
So how did we
display films on TVs?

00:22:26.180 --> 00:22:28.510
The solution was to do this.

00:22:28.510 --> 00:22:31.226
This is called 3:2 pulldown.

00:22:31.226 --> 00:22:32.850
This means that the
odd numbered frames

00:22:32.850 --> 00:22:34.450
are on screen for
three refreshes.

00:22:34.450 --> 00:22:37.390
And the even ones are on
screen for two refreshes.

00:22:37.390 --> 00:22:38.970
The odd-numbered
frames are on screen

00:22:38.970 --> 00:22:41.290
50% longer than the even ones.

00:22:41.290 --> 00:22:42.570
And this is noticeable.

00:22:42.570 --> 00:22:44.470
This is really noticeable.

00:22:44.470 --> 00:22:48.490
Next time you watch a TV show
or a film on your laptop,

00:22:48.490 --> 00:22:51.700
watch out for the smooth
pans across the countryside.

00:22:51.700 --> 00:22:53.770
The motion is really,
really juttery.

00:22:53.770 --> 00:22:57.220
You can see this effect of
the frames being on the screen

00:22:57.220 --> 00:22:58.480
for a different length.

00:22:58.480 --> 00:23:02.300
And once you notice it,
you can not unnotice it.

00:23:02.300 --> 00:23:05.960
I might have spoiled watching
films on your laptop for you.

00:23:05.960 --> 00:23:07.800
But hey, it gets worse.

00:23:07.800 --> 00:23:10.770
Your TV, if it's a
reasonably modern TV,

00:23:10.770 --> 00:23:12.460
probably supports 24 hertz.

00:23:12.460 --> 00:23:16.350
It will go natively
into that refresh rate.

00:23:16.350 --> 00:23:19.930
But the application
that's feeding it video

00:23:19.930 --> 00:23:21.850
might not tell it to
go into that mode.

00:23:21.850 --> 00:23:23.420
And you get the
same problem again.

00:23:23.420 --> 00:23:25.390
I know Netflix on
the PS3 is something.

00:23:25.390 --> 00:23:28.040
It drives me mad, because
yeah, all the shows

00:23:28.040 --> 00:23:31.510
are displaying at the
wrong refresh rate.

00:23:31.510 --> 00:23:33.930
We had a different
problem in the UK

00:23:33.930 --> 00:23:35.860
because we're on
a 50-hertz screen.

00:23:35.860 --> 00:23:39.860
And once again, we want to show
film at 24 frames per second.

00:23:39.860 --> 00:23:45.122
24 doesn't divide into
50, but it nearly does.

00:23:45.122 --> 00:23:49.630
"Ghostbusters II," in the
UK, is five minutes shorter

00:23:49.630 --> 00:23:51.520
than it is here.

00:23:51.520 --> 00:23:53.400
Not because you
have extra scenes.

00:23:53.400 --> 00:23:56.160
We just play the film quicker.

00:23:56.160 --> 00:23:59.430
We go from 24 frames
per second to 25.

00:23:59.430 --> 00:24:01.870
And that divides into 50 nicely.

00:24:01.870 --> 00:24:04.070
Everyone speaks a little
bit higher pitched,

00:24:04.070 --> 00:24:08.770
but you don't really
notice it so much.

00:24:08.770 --> 00:24:10.620
So what we've
talked about so far

00:24:10.620 --> 00:24:13.950
is all software rendering stuff.

00:24:13.950 --> 00:24:16.846
And I want to show the
difference between software

00:24:16.846 --> 00:24:18.220
rendering and
hardware rendering.

00:24:18.220 --> 00:24:20.011
So we're going to
compare Internet Explorer

00:24:20.011 --> 00:24:22.930
6 to what we see
in Chrome today.

00:24:22.930 --> 00:24:26.480
So I've got a virtual
machine booting up.

00:24:26.480 --> 00:24:27.900
That looks like it's working.

00:24:27.900 --> 00:24:30.660
So browsers discovered how
they could do things in the GPU

00:24:30.660 --> 00:24:31.350
recently.

00:24:31.350 --> 00:24:34.450
And what that resulted--
sorry, hang on.

00:24:34.450 --> 00:24:35.760
It did this to me before.

00:24:44.380 --> 00:24:46.630
OK, so we might skip this demo.

00:24:46.630 --> 00:24:47.130
Hang on.

00:24:59.290 --> 00:25:00.730
I'm kidding, of course.

00:25:00.730 --> 00:25:02.320
I'm just joking.

00:25:02.320 --> 00:25:03.880
But this is a
really good example

00:25:03.880 --> 00:25:05.950
of the difference between
hardware and software

00:25:05.950 --> 00:25:08.070
rendering.

00:25:08.070 --> 00:25:12.050
In Windows XP, the screen
is a single canvas.

00:25:12.050 --> 00:25:15.320
The Window Manager knows about
every pixel on the screen,

00:25:15.320 --> 00:25:16.690
but nothing more.

00:25:16.690 --> 00:25:20.240
The graphical representation
is completely flat.

00:25:20.240 --> 00:25:23.210
So if you wanted to move
a window, say this one,

00:25:23.210 --> 00:25:26.460
you would click and drag across.

00:25:26.460 --> 00:25:29.280
Windows will redraw it
by taking these pixels

00:25:29.280 --> 00:25:32.060
and copying them to
the new location.

00:25:32.060 --> 00:25:34.510
And then it identifies
areas of the screen that

00:25:34.510 --> 00:25:36.480
are now displaying
the wrong thing.

00:25:36.480 --> 00:25:38.707
So it would pick up
these free rectangles.

00:25:38.707 --> 00:25:40.790
And what it will do is it
will send a message down

00:25:40.790 --> 00:25:44.210
to the application now
responsible for those

00:25:44.210 --> 00:25:46.290
and tells it to
redraw this area.

00:25:46.290 --> 00:25:48.420
So in the case of
this rectangle here,

00:25:48.420 --> 00:25:51.520
it says, hey, Control Panel,
you need to redraw that bit.

00:25:51.520 --> 00:25:53.080
And it does.

00:25:53.080 --> 00:25:56.010
However, with the case of
these other two rectangles,

00:25:56.010 --> 00:25:58.836
the message goes to
Internet Explorer.

00:25:58.836 --> 00:26:01.140
But Internet
Explorer has crashed.

00:26:01.140 --> 00:26:02.950
So it can't deal
with the message.

00:26:02.950 --> 00:26:04.920
So those pixels
stay on the screen.

00:26:04.920 --> 00:26:07.020
And that's why you
can paint the window

00:26:07.020 --> 00:26:08.180
across a screen like that.

00:26:08.180 --> 00:26:10.040
That's how that effect happens.

00:26:10.040 --> 00:26:12.670
This is software
rendering, a single canvas

00:26:12.670 --> 00:26:17.350
of pixels where the CPU
adjusts it pixel by pixel.

00:26:17.350 --> 00:26:21.310
Things changed in modern
operating systems like Vista

00:26:21.310 --> 00:26:26.140
but also OSX and many
Linux desktop managers.

00:26:26.140 --> 00:26:29.340
The desktop isn't a single
flat canvas, but rather

00:26:29.340 --> 00:26:33.510
a whole series of canvases all
stored together in the GPU.

00:26:33.510 --> 00:26:36.400
In this system, moving a
window is really, really easy,

00:26:36.400 --> 00:26:38.840
because the graphics
card knows what

00:26:38.840 --> 00:26:41.510
every window looks
like in its entirety.

00:26:41.510 --> 00:26:45.010
To move a window, the CPU
just says to the GPU, hey,

00:26:45.010 --> 00:26:47.720
you know that thing
you already know about?

00:26:47.720 --> 00:26:48.930
Put it over here.

00:26:48.930 --> 00:26:51.150
It's a very small instruction.

00:26:51.150 --> 00:26:53.170
And the GPU takes the
care of the rest of it.

00:26:53.170 --> 00:26:54.790
And once it knows
all the positions,

00:26:54.790 --> 00:26:56.820
it composites them
together into the picture

00:26:56.820 --> 00:26:59.370
you see on the screen.

00:26:59.370 --> 00:27:02.340
If you work in Photoshop,
software rendering

00:27:02.340 --> 00:27:04.840
is like a flattened PSD.

00:27:04.840 --> 00:27:06.800
If you want to
move something you

00:27:06.800 --> 00:27:09.180
have to redraw what
was underneath it,

00:27:09.180 --> 00:27:12.310
whereas hardware rendering
is like a layered PSD.

00:27:12.310 --> 00:27:14.230
Moving stuff around is
really, really easy.

00:27:16.900 --> 00:27:18.750
The web used to
be a flat canvas,

00:27:18.750 --> 00:27:20.800
but more and more is
moving to the GPU.

00:27:20.800 --> 00:27:21.894
And it's about time.

00:27:21.894 --> 00:27:23.310
Because it turns
out, the graphics

00:27:23.310 --> 00:27:26.990
processing unit, pretty
good at processing graphics.

00:27:26.990 --> 00:27:30.495
We just haven't
really been using it.

00:27:30.495 --> 00:27:32.370
Once the web browser
knows where everything's

00:27:32.370 --> 00:27:35.610
going to go on the
page, it then decides

00:27:35.610 --> 00:27:39.020
that particular elements
deserve to be drawn separately

00:27:39.020 --> 00:27:40.950
from the rest.

00:27:40.950 --> 00:27:43.330
And once it does that, it'll
draw them all separately

00:27:43.330 --> 00:27:45.530
and then join them together
in an operation called

00:27:45.530 --> 00:27:46.030
compositing.

00:27:46.030 --> 00:27:48.100
And that will appear
in the Timeline.

00:27:48.100 --> 00:27:50.510
So here we have two paints
and then a composite

00:27:50.510 --> 00:27:53.130
to bring them all together.

00:27:53.130 --> 00:27:56.151
You can tell which
elements have GPU layers.

00:27:56.151 --> 00:27:58.150
Once again, Paul Irish
showed this this morning.

00:27:58.150 --> 00:28:01.650
You would go into the
cog there and turn

00:28:01.650 --> 00:28:03.610
on Show composited
layer borders.

00:28:03.610 --> 00:28:06.010
And you get this orange
border on everything

00:28:06.010 --> 00:28:07.990
that's being accelerated.

00:28:07.990 --> 00:28:09.830
And this is updated
in real time, as well.

00:28:09.830 --> 00:28:13.290
You can see, also,
this grid over the top.

00:28:13.290 --> 00:28:15.480
That's the tiles that
are sent to the GPU.

00:28:15.480 --> 00:28:18.730
So each one of
those is a GPU tile.

00:28:18.730 --> 00:28:24.030
So we can see here, this is just
part of the background layer.

00:28:24.030 --> 00:28:26.010
But when we click it
to spin it around,

00:28:26.010 --> 00:28:28.870
we can see it gets a border as
that transformation happens.

00:28:28.870 --> 00:28:31.590
So that shows things
on the GPU changing.

00:28:31.590 --> 00:28:35.340
So what effect do
these layers have?

00:28:35.340 --> 00:28:37.380
So here's a demo
where I've got lots

00:28:37.380 --> 00:28:40.570
of these blobs moving
around in a circle.

00:28:40.570 --> 00:28:42.580
And the first thing
we need to ask here

00:28:42.580 --> 00:28:44.730
is, what the frames
per second is going on?

00:28:44.730 --> 00:28:47.950
Because it's not looking great.

00:28:47.950 --> 00:28:50.910
Here's what the timeline says.

00:28:50.910 --> 00:28:53.610
Every frame's taking
over 100 milliseconds.

00:28:53.610 --> 00:28:55.510
It's pretty terrible.

00:28:55.510 --> 00:28:57.500
This is happening
the Windows XP way.

00:28:57.500 --> 00:29:00.000
We're seeing these
full, large paints

00:29:00.000 --> 00:29:01.190
covering the whole canvas.

00:29:01.190 --> 00:29:03.050
Every time it changes,
the whole thing

00:29:03.050 --> 00:29:06.290
is being cleared and redrawn.

00:29:06.290 --> 00:29:08.660
The animation itself
is being driven by CSS.

00:29:08.660 --> 00:29:10.020
There's no JavaScript involved.

00:29:10.020 --> 00:29:13.302
We're animating top and left.

00:29:13.302 --> 00:29:15.010
Each blob animates
with a delay to create

00:29:15.010 --> 00:29:17.140
that kind of snake effect.

00:29:17.140 --> 00:29:20.690
But what if we added
translateZ, the magic hack?

00:29:20.690 --> 00:29:23.380
What if we added that to
every segment of the snake,

00:29:23.380 --> 00:29:26.090
with the appropriate
prefix, of course?

00:29:26.090 --> 00:29:28.880
We go from this to this.

00:29:28.880 --> 00:29:32.090
It's a vast improvement
with that one line.

00:29:32.090 --> 00:29:33.690
The timeline agrees as well.

00:29:33.690 --> 00:29:37.400
Those massive paints are being
replaced with composites.

00:29:37.400 --> 00:29:39.960
And most of our effort's
going into recalculate style

00:29:39.960 --> 00:29:41.620
and layout now.

00:29:41.620 --> 00:29:44.160
This is working more
like Vista and OSX.

00:29:44.160 --> 00:29:46.268
All the CPU is
saying is, hey, you

00:29:46.268 --> 00:29:48.540
know those blobs that I
told you about earlier?

00:29:48.540 --> 00:29:49.780
Move them over here.

00:29:49.780 --> 00:29:51.630
And it all happens on the GPU.

00:29:51.630 --> 00:29:54.209
These slides are all
just built in HTML.

00:29:54.209 --> 00:29:56.000
And they run smoothly
because it's all just

00:29:56.000 --> 00:29:59.050
a series of fades and
transitions, all the stuff

00:29:59.050 --> 00:30:01.912
that the GPU can do natively.

00:30:01.912 --> 00:30:06.610
So yeah, things like
Rotate, Scale, Skew, Fade,

00:30:06.610 --> 00:30:10.170
that's all possible
just purely on the GPU.

00:30:10.170 --> 00:30:12.890
So translateZ, we've seen
this a couple of times today.

00:30:12.890 --> 00:30:15.510
It makes moving
stuff around faster.

00:30:15.510 --> 00:30:21.150
Well, that's a little bean
from the can of Jake's Tipz.

00:30:21.150 --> 00:30:22.790
But look closer.

00:30:22.790 --> 00:30:26.190
The Best-Before date is today.

00:30:26.190 --> 00:30:28.230
And my partner and I
have a little argument

00:30:28.230 --> 00:30:29.010
when this happens.

00:30:29.010 --> 00:30:31.760
Because as far as
I can tell, she

00:30:31.760 --> 00:30:33.590
seems to think
that food is fine.

00:30:33.590 --> 00:30:34.920
It is perfect.

00:30:34.920 --> 00:30:40.220
And then when midnight strikes
on this date, it is now poison.

00:30:40.220 --> 00:30:43.490
And if you so much as touch
it, your face will fall off

00:30:43.490 --> 00:30:47.230
and wasps will fly out
of your neck or whatever.

00:30:47.230 --> 00:30:48.800
But no, it's just
best before then.

00:30:48.800 --> 00:30:50.850
It's probably still OK.

00:30:50.850 --> 00:30:53.930
This is what performance
tips are like.

00:30:53.930 --> 00:30:56.670
If you just blindly
use them in a project,

00:30:56.670 --> 00:30:58.590
things might go wrong.

00:30:58.590 --> 00:31:03.090
So when people say something
is faster than something else,

00:31:03.090 --> 00:31:04.340
give it a smell first.

00:31:04.340 --> 00:31:08.550
Because it might have gone off,
as many rules have already.

00:31:08.550 --> 00:31:10.460
Don't trust performance rules.

00:31:10.460 --> 00:31:12.866
Use the dev tools to
see what's going on.

00:31:12.866 --> 00:31:16.690
On the Chrome team we say
tools, not rules, which rhymes.

00:31:16.690 --> 00:31:18.684
So it must be true.

00:31:18.684 --> 00:31:20.350
But they're a great
way to discover ways

00:31:20.350 --> 00:31:22.240
that you might be
overworking the browser

00:31:22.240 --> 00:31:24.670
or ways the browser might
be overworking itself

00:31:24.670 --> 00:31:26.280
that you can hack around.

00:31:26.280 --> 00:31:27.880
If you find
something, the browser

00:31:27.880 --> 00:31:32.340
being slow when you don't think
it should be, report bugs.

00:31:32.340 --> 00:31:34.160
I know it's annoying.

00:31:34.160 --> 00:31:35.860
And reporting a
bug probably isn't

00:31:35.860 --> 00:31:38.110
going to help your
current project,

00:31:38.110 --> 00:31:40.850
because you need
to ship tomorrow.

00:31:40.850 --> 00:31:44.430
But it might save
your next project.

00:31:44.430 --> 00:31:48.670
So translate says it got
us to 30 frames per second,

00:31:48.670 --> 00:31:50.640
which is not great.

00:31:50.640 --> 00:31:53.280
But it's OK.

00:31:53.280 --> 00:31:55.477
But not only is it less
than 60 frames per second,

00:31:55.477 --> 00:31:56.935
I've got this button
in the middle.

00:31:56.935 --> 00:31:59.610
And when I click
this button, it's

00:31:59.610 --> 00:32:03.300
going to run some JavaScript.

00:32:03.300 --> 00:32:06.850
And while that JavaScript is
running, the animation stops.

00:32:10.930 --> 00:32:15.979
This is because the layout
and style recalculations that

00:32:15.979 --> 00:32:18.020
are going on here, they
happen on the same thread

00:32:18.020 --> 00:32:18.950
as JavaScript.

00:32:18.950 --> 00:32:23.070
So when JavaScript happens,
the animation can't run.

00:32:23.070 --> 00:32:24.900
We're currently
animating top and left.

00:32:24.900 --> 00:32:27.610
If we switch this
out for a transform,

00:32:27.610 --> 00:32:29.280
we get the same effect.

00:32:29.280 --> 00:32:31.637
We go from this to this.

00:32:31.637 --> 00:32:33.470
And I don't know if you
can tell from there,

00:32:33.470 --> 00:32:34.870
but the difference
is astounding.

00:32:34.870 --> 00:32:38.180
We've gone from 30 frames
per second down to 60.

00:32:38.180 --> 00:32:39.970
But not only are we
down to 60, we're

00:32:39.970 --> 00:32:41.980
barely touching
the system at all.

00:32:41.980 --> 00:32:47.830
It's taken 1.2 milliseconds
to move 300 objects around.

00:32:47.830 --> 00:32:49.994
That's great.

00:32:49.994 --> 00:32:51.410
So the calculate
style and layout,

00:32:51.410 --> 00:32:55.350
they were on the same thread as
JavaScript, as we saw before.

00:32:55.350 --> 00:32:59.036
But composites don't happen on
the same thread as JavaScript.

00:32:59.036 --> 00:33:00.410
So if we go back
to the example--

00:33:00.410 --> 00:33:03.000
I'm going to click
this button again--

00:33:03.000 --> 00:33:04.700
the JavaScript
there is still slow.

00:33:04.700 --> 00:33:06.570
It's still going to
take a while to run.

00:33:06.570 --> 00:33:08.140
But it doesn't
disrupt the animation.

00:33:08.140 --> 00:33:12.230
The animation's happening
on a different thread.

00:33:12.230 --> 00:33:15.850
That particular tip, that
could change in the future,

00:33:15.850 --> 00:33:17.070
like all of these tips can.

00:33:17.070 --> 00:33:18.930
We might start moving
more drawing stuff

00:33:18.930 --> 00:33:22.020
off the main thread,
free more stuff up.

00:33:22.020 --> 00:33:24.480
But this stuff applies
to mobile, as well.

00:33:24.480 --> 00:33:28.210
So we can see, from just
animating top and left--

00:33:28.210 --> 00:33:31.060
and now we're a CSS
animation-- the difference is

00:33:31.060 --> 00:33:33.400
absolutely huge.

00:33:33.400 --> 00:33:35.580
Actually, animating
these transforms

00:33:35.580 --> 00:33:38.870
gives us another advantage.

00:33:38.870 --> 00:33:41.430
So on the left, I'm
animating top and left.

00:33:41.430 --> 00:33:43.976
On the right, I'm
animating using Transform.

00:33:43.976 --> 00:33:45.350
And we can see,
with a transform,

00:33:45.350 --> 00:33:49.220
it can glide between the
pixels, whereas top and left

00:33:49.220 --> 00:33:51.160
snaps from pixel to pixel.

00:33:51.160 --> 00:33:55.280
Much smoother if you
can use transforms.

00:33:55.280 --> 00:33:58.040
Unfortunately, this
isn't true in Firefox.

00:33:58.040 --> 00:34:00.420
In Firefox, if you
use Translate 3D,

00:34:00.420 --> 00:34:02.870
it's still going to snap
from pixel to pixel.

00:34:02.870 --> 00:34:05.892
And they do this
deliberately for reasons

00:34:05.892 --> 00:34:07.100
they haven't explained to me.

00:34:07.100 --> 00:34:09.155
But there is a
ticket open for it.

00:34:09.155 --> 00:34:11.630
But you can hack around it.

00:34:11.630 --> 00:34:16.089
If you add a very, very
small rotate, it fixes it.

00:34:16.089 --> 00:34:18.510
It means it can glide
between the pixels.

00:34:18.510 --> 00:34:19.670
And it works beautifully.

00:34:19.670 --> 00:34:23.370
So if you're wanting smooth
animations in Firefox,

00:34:23.370 --> 00:34:25.750
do that for whatever reason
and bug them about it.

00:34:25.750 --> 00:34:28.449
Because it's stupid
that we have to do that.

00:34:28.449 --> 00:34:30.630
So these layer things
are great, right?

00:34:30.630 --> 00:34:32.630
They seem like
this magic bullet.

00:34:35.440 --> 00:34:37.610
Let's take away some of
these expensive styles.

00:34:37.610 --> 00:34:39.489
Let's get rid of the shadow.

00:34:39.489 --> 00:34:42.520
Let's get rid of
the rounded corners.

00:34:42.520 --> 00:34:44.210
And let's make the
colors alternate.

00:34:44.210 --> 00:34:46.360
So we're going to this.

00:34:46.360 --> 00:34:47.655
That's working fine.

00:34:47.655 --> 00:34:50.120
But if we take a
look on mobile, we

00:34:50.120 --> 00:34:52.110
can see when these
colors change there's

00:34:52.110 --> 00:34:53.780
a huge pause in the animation.

00:34:53.780 --> 00:34:56.560
There's a huge bit of jank.

00:34:56.560 --> 00:35:00.150
And if we remove translateZ,
if we take that out of the mix,

00:35:00.150 --> 00:35:01.640
it turns to this.

00:35:01.640 --> 00:35:03.349
It's still not a
great frame rate,

00:35:03.349 --> 00:35:04.890
but it's much more
consistent than it

00:35:04.890 --> 00:35:06.348
is on the left,
where it's stopping

00:35:06.348 --> 00:35:09.550
every time the colors change.

00:35:09.550 --> 00:35:11.980
What's going on here?

00:35:11.980 --> 00:35:13.820
Remote debugging can show us.

00:35:13.820 --> 00:35:16.090
And we can see, this is
where the pause is happening,

00:35:16.090 --> 00:35:17.061
this huge spike.

00:35:17.061 --> 00:35:18.810
And this is where the
colors are changing.

00:35:18.810 --> 00:35:21.310
And we can see,
each of those blobs,

00:35:21.310 --> 00:35:24.660
each of those squares in this
example has to be repainted.

00:35:24.660 --> 00:35:27.930
And that's a lot of effort.

00:35:27.930 --> 00:35:30.270
On desktop it's not
too bad, because it's

00:35:30.270 --> 00:35:31.920
got a good relationship
with the GPU.

00:35:31.920 --> 00:35:33.750
It can get this stuff
done really fast.

00:35:33.750 --> 00:35:37.230
But on mobile, redrawing
all of this stuff

00:35:37.230 --> 00:35:39.350
separately and
uploading it to the GPU

00:35:39.350 --> 00:35:42.600
is actually slower than just
redrawing the whole thing.

00:35:42.600 --> 00:35:44.360
If we redraw the
whole thing, as I say,

00:35:44.360 --> 00:35:46.210
we've not got a
great frame rate.

00:35:46.210 --> 00:35:47.155
But it's consistent.

00:35:47.155 --> 00:35:49.030
It'll stay at the same
frame rate throughout.

00:35:53.750 --> 00:35:56.040
So we've seen this
translateZ trick

00:35:56.040 --> 00:35:58.757
to make layers on the GPU.

00:35:58.757 --> 00:35:59.840
But that's not everything.

00:35:59.840 --> 00:36:02.634
That's not everything that
can create these layers.

00:36:02.634 --> 00:36:04.300
Here are some of the
things that trigger

00:36:04.300 --> 00:36:07.830
layers in Safari
and Chrome today.

00:36:07.830 --> 00:36:10.990
3D transforms, which
translateZ is one of them.

00:36:10.990 --> 00:36:16.830
But also, translate 3D,
rotate 3D, rotate X, rotate Y.

00:36:16.830 --> 00:36:22.670
Animating or transitioning
using CSS, a transform property,

00:36:22.670 --> 00:36:25.160
an opacity property,
or a filter property

00:36:25.160 --> 00:36:27.090
for the duration
of the animation

00:36:27.090 --> 00:36:30.340
that will become a GPU layer.

00:36:30.340 --> 00:36:32.610
Flash and Silverlight,
to sandbox them,

00:36:32.610 --> 00:36:34.710
that will be drawn
completely independently

00:36:34.710 --> 00:36:37.440
and then composited
in afterwards.

00:36:37.440 --> 00:36:41.200
Canvas, for the canvas'
hardware accelerated,

00:36:41.200 --> 00:36:45.260
that will be drawn on
its own, as will video

00:36:45.260 --> 00:36:46.475
for the same reasons.

00:36:46.475 --> 00:36:47.741
Fixed position elements.

00:36:47.741 --> 00:36:49.740
Something we're experimenting
with at the moment

00:36:49.740 --> 00:36:53.620
is we're going to make
them their own GPU

00:36:53.620 --> 00:36:55.721
layer on retina devices.

00:36:55.721 --> 00:36:57.970
But at that moment, as you
saw in Paul's demo earlier,

00:36:57.970 --> 00:37:02.920
you can put translateZ on these
things and speed them up a lot.

00:37:02.920 --> 00:37:04.815
These can all change
in the future.

00:37:04.815 --> 00:37:07.190
This stuff, we're going to be
switching these things out,

00:37:07.190 --> 00:37:09.398
whatever's going to give
the best performance on most

00:37:09.398 --> 00:37:11.254
of the sites today.

00:37:11.254 --> 00:37:12.170
Don't trust the rules.

00:37:12.170 --> 00:37:13.380
Use composited borders.

00:37:13.380 --> 00:37:15.850
Actually see what's going on
on your page, on your phone

00:37:15.850 --> 00:37:18.050
and on your desktop.

00:37:18.050 --> 00:37:19.887
WebKit Nightly,
in the dev tools,

00:37:19.887 --> 00:37:21.720
they've got a really
cool feature, actually,

00:37:21.720 --> 00:37:23.540
where it will list
all of the layers.

00:37:23.540 --> 00:37:26.160
And it'll tell you
why they're a layer.

00:37:26.160 --> 00:37:27.360
It's not always accurate.

00:37:27.360 --> 00:37:28.720
But it's quite a nice feature.

00:37:28.720 --> 00:37:32.670
This is something we'll be
getting in Chrome as well.

00:37:32.670 --> 00:37:34.650
So these rules will
change with time.

00:37:34.650 --> 00:37:37.120
But there's one that won't.

00:37:37.120 --> 00:37:40.802
Anything on top of a layer
will become a layer as well.

00:37:40.802 --> 00:37:42.510
And that kind of makes
sense, because you

00:37:42.510 --> 00:37:44.650
can't layer something
on top of a layer

00:37:44.650 --> 00:37:47.600
without it being a layer itself.

00:37:47.600 --> 00:37:51.570
But this can have quite a
large impact on the page.

00:37:51.570 --> 00:37:55.200
So here I'm going to turn
on composited layer borders.

00:37:55.200 --> 00:37:58.300
And this square at the top,
I'm going to give this a 3D

00:37:58.300 --> 00:38:00.540
transform.

00:38:00.540 --> 00:38:03.160
So just a one pixel
in the y direction.

00:38:03.160 --> 00:38:06.780
And as I do that, you
can see, there it goes.

00:38:06.780 --> 00:38:11.100
It gets the orange border to
show that it's now a GPU layer.

00:38:11.100 --> 00:38:13.910
Now, all the rest of
the text down the page

00:38:13.910 --> 00:38:15.780
is position relative.

00:38:15.780 --> 00:38:18.390
So that means that it's
higher in the rendering

00:38:18.390 --> 00:38:19.720
stack than the boxes.

00:38:19.720 --> 00:38:22.240
So the box will
appear underneath it.

00:38:22.240 --> 00:38:24.290
And as I move that
box down the page,

00:38:24.290 --> 00:38:26.860
we can see this text
goes onto the GPU

00:38:26.860 --> 00:38:31.200
and then once the intersect
ends, goes off the GPU.

00:38:31.200 --> 00:38:32.990
So this is all using
extra GPU memory

00:38:32.990 --> 00:38:34.890
because it's
intersecting with or it's

00:38:34.890 --> 00:38:38.522
appearing on top of something,
which is also on the GPU.

00:38:38.522 --> 00:38:40.230
And this can end up
consuming more memory

00:38:40.230 --> 00:38:41.430
than you maybe intended.

00:38:41.430 --> 00:38:42.930
So it's great to
look at the borders

00:38:42.930 --> 00:38:45.780
and see what's actually
going onto the GPU.

00:38:45.780 --> 00:38:48.080
Because this actually
affects rendering, as well.

00:38:48.080 --> 00:38:51.756
If we take a closer look,
you can see the text here.

00:38:51.756 --> 00:38:52.880
You see the color fringing.

00:38:52.880 --> 00:38:55.770
So on one edge, it
looks orangey brown.

00:38:55.770 --> 00:38:57.880
And on the other
edge it looks blue.

00:38:57.880 --> 00:38:59.950
This is subpixel
antialiasing, and it

00:38:59.950 --> 00:39:04.980
makes text look really
sharp on LCD screens.

00:39:04.980 --> 00:39:09.670
But as I move this box down,
when the intersect happens we

00:39:09.670 --> 00:39:11.970
drop down to grayscale
antialiasing.

00:39:11.970 --> 00:39:14.640
Subpixel antialiasing
can't be done

00:39:14.640 --> 00:39:17.020
as part of a
composite operation.

00:39:17.020 --> 00:39:20.615
So we fall back to just
black and white antialiasing.

00:39:20.615 --> 00:39:22.490
You might have seen this
happen accidentally,

00:39:22.490 --> 00:39:25.070
like when an animation triggers,
you see the text rendering

00:39:25.070 --> 00:39:25.850
change.

00:39:25.850 --> 00:39:28.110
This is why that's happening.

00:39:28.110 --> 00:39:29.590
If you've got a
GPU layer and you

00:39:29.590 --> 00:39:34.370
want to retain the
superior text rendering

00:39:34.370 --> 00:39:38.060
of subpixel antialiasing, if
you give it a solid background

00:39:38.060 --> 00:39:42.250
color, you get the effect
back even if it's on the GPU.

00:39:42.250 --> 00:39:45.900
So by solid background,
I mean no opacity.

00:39:45.900 --> 00:39:46.810
It could be an image.

00:39:46.810 --> 00:39:47.970
It could be a gradient.

00:39:47.970 --> 00:39:51.030
As long as there's no
transparent pixels.

00:39:51.030 --> 00:39:53.670
And remember, things
like border radius,

00:39:53.670 --> 00:39:55.500
they introduce transplant
pixels, as well.

00:39:55.500 --> 00:39:58.370
So if I add a border on
here, the other side,

00:39:58.370 --> 00:40:02.950
we've dropped back down
to grayscale antialiasing.

00:40:02.950 --> 00:40:05.520
Unfortunately, Chrome
is more cautious

00:40:05.520 --> 00:40:08.400
when it comes to CSS animation.

00:40:08.400 --> 00:40:10.730
When an element is
animating with CSS,

00:40:10.730 --> 00:40:12.930
it will take everything
that could potentially

00:40:12.930 --> 00:40:15.370
appear on top of it
right now, and it

00:40:15.370 --> 00:40:17.120
will promote it to a GPU layer.

00:40:17.120 --> 00:40:19.510
And this can have
quite a bad effect

00:40:19.510 --> 00:40:21.550
on the amount of GPU
memory you're using.

00:40:21.550 --> 00:40:24.470
Even if it doesn't intersect,
we see these things, down here,

00:40:24.470 --> 00:40:26.870
are going onto the GPU, as well.

00:40:26.870 --> 00:40:29.470
Because of this, if you've
got an animating element

00:40:29.470 --> 00:40:32.600
it's best to move it to the
top of the rendering stack.

00:40:32.600 --> 00:40:35.950
And you can do it simply
with something like z-index.

00:40:35.950 --> 00:40:38.140
As soon as I do
z-index 1, OK, it's

00:40:38.140 --> 00:40:39.630
appeared on top of the text.

00:40:39.630 --> 00:40:41.750
But all the rest of
the page has stopped

00:40:41.750 --> 00:40:45.390
getting a GPU layer
per paragraph.

00:40:45.390 --> 00:40:47.930
And that can really improve
the speed of things.

00:40:47.930 --> 00:40:50.100
Because we've seen the
benefits of layers so far.

00:40:50.100 --> 00:40:54.050
And we've seen some places
where they can be slower.

00:40:54.050 --> 00:40:55.990
But just having too
many of these layers

00:40:55.990 --> 00:40:58.600
can cause a real problem,
not so much on desktop,

00:40:58.600 --> 00:41:00.240
but definitely on mobile.

00:41:00.240 --> 00:41:01.660
This is the Guardian website.

00:41:01.660 --> 00:41:04.211
And it runs at 60
frames per second.

00:41:04.211 --> 00:41:06.460
I was filming this with a
30-frames-per-second camera.

00:41:06.460 --> 00:41:08.940
So it doesn't look
quite as fast as it is.

00:41:08.940 --> 00:41:10.440
But we can see,
from dev tools, it's

00:41:10.440 --> 00:41:12.440
running at 60 frames per second.

00:41:12.440 --> 00:41:17.134
And the GPU memory it's using
is very little, 20 megabytes.

00:41:17.134 --> 00:41:17.800
So that's great.

00:41:17.800 --> 00:41:20.610
We want scrolling at
60 frames per second.

00:41:20.610 --> 00:41:24.570
But if in remote
debug tools, I'm

00:41:24.570 --> 00:41:27.090
going to turn every
element into its own layer.

00:41:27.090 --> 00:41:31.110
So just everything that's on
the page, as soon as I hit zero,

00:41:31.110 --> 00:41:33.620
every element
becomes a GPU layer.

00:41:33.620 --> 00:41:36.150
So I'm scrolling, and
everything's fine.

00:41:36.150 --> 00:41:37.030
Everything's fine.

00:41:37.030 --> 00:41:38.500
I hit zero.

00:41:38.500 --> 00:41:41.260
And the scrolling
just absolutely dies.

00:41:41.260 --> 00:41:44.230
And it's actually worse when
you see this in real life

00:41:44.230 --> 00:41:45.239
than this recording.

00:41:45.239 --> 00:41:46.280
And we can see this here.

00:41:46.280 --> 00:41:49.450
We've gone down to like 25
frames per second from 60.

00:41:49.450 --> 00:41:53.004
And we can see why it's hitting
the top of the GPU limit.

00:41:53.004 --> 00:41:54.920
And then things are
having to swap in and out.

00:41:54.920 --> 00:41:57.086
And that's where we're
dropping all of these frames.

00:41:59.390 --> 00:42:02.620
Forcing something
onto its own GPU layer

00:42:02.620 --> 00:42:06.730
is like drinking a cheap beer.

00:42:06.730 --> 00:42:09.780
There are some things that I'm
better at after I drink beer,

00:42:09.780 --> 00:42:12.009
like talking to
people and stuff.

00:42:12.009 --> 00:42:13.550
I find that quite
difficult normally.

00:42:13.550 --> 00:42:16.190
A couple of beers, things
are getting better.

00:42:16.190 --> 00:42:19.590
But when I have a few more
beers, talking to people

00:42:19.590 --> 00:42:21.594
becomes a lot more
difficult again.

00:42:21.594 --> 00:42:23.010
In fact, it becomes
more difficult

00:42:23.010 --> 00:42:25.690
than it was before I
had any beer at all.

00:42:25.690 --> 00:42:28.220
And that's what
layering is like.

00:42:28.220 --> 00:42:29.830
Your desktop
machines, especially

00:42:29.830 --> 00:42:32.460
the high-end MacBooks
that I see so many of us

00:42:32.460 --> 00:42:35.770
have, they can really
hold the drink.

00:42:35.770 --> 00:42:38.900
They can drink all through the
night, and it's not a big deal.

00:42:38.900 --> 00:42:42.810
Your phone, I'm sorry,
it's a lightweight.

00:42:42.810 --> 00:42:46.190
A couple of these, and it
slurs all over the place.

00:42:46.190 --> 00:42:47.770
It can't do scrolling.

00:42:47.770 --> 00:42:50.806
It becomes awful.

00:42:50.806 --> 00:42:53.180
There are no magic rules around
this layering stuff, none

00:42:53.180 --> 00:42:55.740
that will stand
the test of time.

00:42:55.740 --> 00:42:57.900
They can make transforming
and fading quicker.

00:42:57.900 --> 00:43:00.850
But just don't trust
performance rules.

00:43:00.850 --> 00:43:01.726
Test what's going on.

00:43:01.726 --> 00:43:03.224
Test what's going
on in the browser.

00:43:03.224 --> 00:43:05.510
But always test what's going
on on the phone, as well,

00:43:05.510 --> 00:43:06.676
with the different hardware.

00:43:09.090 --> 00:43:12.360
So to summarize all
of that, you need

00:43:12.360 --> 00:43:14.220
to care about
rendering performance

00:43:14.220 --> 00:43:15.420
if you're not already.

00:43:15.420 --> 00:43:17.730
Because if you don't,
someone's going

00:43:17.730 --> 00:43:20.020
to come out with a product
that does a similar thing.

00:43:20.020 --> 00:43:22.270
But they're going to care
about rendering performance.

00:43:22.270 --> 00:43:24.980
And that's where
the users will go.

00:43:24.980 --> 00:43:27.440
Care about performance
by getting rid

00:43:27.440 --> 00:43:29.210
of this 300-millisecond delay.

00:43:29.210 --> 00:43:31.190
As a browser, we're
working on it.

00:43:31.190 --> 00:43:32.670
And we're going
to fix that soon.

00:43:32.670 --> 00:43:37.710
But existing browsers, like iOS
and older versions of Chrome,

00:43:37.710 --> 00:43:39.450
use the "Financial
Times" Fastclick,

00:43:39.450 --> 00:43:41.920
because it'll just make
it so much snappier.

00:43:41.920 --> 00:43:44.540
People have this impression
that the mobile web is slow.

00:43:44.540 --> 00:43:46.000
I'm pretty convinced
most of it is

00:43:46.000 --> 00:43:47.675
down to this
300-millisecond delay,

00:43:47.675 --> 00:43:49.550
because it makes everything
feel so sluggish.

00:43:49.550 --> 00:43:53.170
But it's stupidly,
deliberately sluggish

00:43:53.170 --> 00:43:55.690
to wait for the double tap.

00:43:55.690 --> 00:43:58.610
If you're doing animation,
use requestAnimationFrame.

00:43:58.610 --> 00:44:01.430
Give yourself the whole 16
milliseconds to prepare.

00:44:01.430 --> 00:44:03.342
And if you're using
CSS animation,

00:44:03.342 --> 00:44:04.300
you get the same thing.

00:44:04.300 --> 00:44:08.050
It runs through the same timer.

00:44:08.050 --> 00:44:09.511
Use GPU layering
to your advantage.

00:44:09.511 --> 00:44:11.760
If you've got something
that's doing simple transforms

00:44:11.760 --> 00:44:14.210
or moves around a lot,
give it translateZ

00:44:14.210 --> 00:44:15.680
or use CSS animations.

00:44:15.680 --> 00:44:18.140
And that will become a layer.

00:44:18.140 --> 00:44:20.550
But be aware of
times when, if you're

00:44:20.550 --> 00:44:23.330
updating the contents
of something frequently,

00:44:23.330 --> 00:44:25.720
having that as a GPU layer
could be killing performance,

00:44:25.720 --> 00:44:28.070
on your phone, especially.

00:44:28.070 --> 00:44:29.910
And avoid too many
GPU layers, as well,

00:44:29.910 --> 00:44:31.950
either on purpose
or accidentally

00:44:31.950 --> 00:44:34.330
by having your intersectional
animations that

00:44:34.330 --> 00:44:36.580
run underneath other elements.

00:44:36.580 --> 00:44:38.650
Watch out for that.

00:44:38.650 --> 00:44:41.430
And with that, I think
I'm out of time, as well.

00:44:41.430 --> 00:44:42.920
So thank you very much.

00:44:42.920 --> 00:44:43.520
Cheers.

00:44:43.520 --> 00:44:59.086
[APPLAUSE]

