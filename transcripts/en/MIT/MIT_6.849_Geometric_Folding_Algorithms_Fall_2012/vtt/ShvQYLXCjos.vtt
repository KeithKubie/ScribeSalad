WEBVTT
Kind: captions
Language: en

00:00:03.179 --> 00:00:05.470
PROFESSOR: So we are honored
to have Professor Tomohiro

00:00:05.470 --> 00:00:09.490
Tachi here today visiting
from the University of Tokyo.

00:00:09.490 --> 00:00:13.370
We first met in
SIGGRAPH 2006, which

00:00:13.370 --> 00:00:16.810
was in Boston, big
graphics conference,

00:00:16.810 --> 00:00:18.640
when he was a PhD student.

00:00:18.640 --> 00:00:21.800
And Tomohiro has very
quickly become a star

00:00:21.800 --> 00:00:24.290
in the area of
computational origami,

00:00:24.290 --> 00:00:27.950
and it's really exciting to see
in particular his perspective

00:00:27.950 --> 00:00:30.030
coming from an
architecture background

00:00:30.030 --> 00:00:31.631
and how that
influences his work.

00:00:31.631 --> 00:00:33.630
He's going to talk about
lots of exciting things

00:00:33.630 --> 00:00:37.190
in the context of architectural
origami for our grand finale

00:00:37.190 --> 00:00:37.690
lecture.

00:00:37.690 --> 00:00:39.962
So please welcome Tomohiro.

00:00:39.962 --> 00:00:42.560
[APPLAUSE]

00:00:42.560 --> 00:00:45.570
PROFESSOR: Thank
you very much, Eric.

00:00:45.570 --> 00:00:49.540
So I'm Tomohiro Tachi from
the University of Tokyo,

00:00:49.540 --> 00:00:53.110
and I'm going to talk about
architecture origami, which

00:00:53.110 --> 00:00:55.750
is architectural form
design systems based

00:00:55.750 --> 00:00:58.010
in computational origami.

00:00:58.010 --> 00:01:01.650
So first, introduction.

00:01:01.650 --> 00:01:06.960
I have been doing origami as a
hobby, as well as my research.

00:01:06.960 --> 00:01:13.140
Well, it was before my research
started that I began folding.

00:01:13.140 --> 00:01:18.980
These are examples of folding
using a traditional way

00:01:18.980 --> 00:01:26.480
of box pleating or
a 3D curved surface.

00:01:26.480 --> 00:01:30.730
This is pure origami,
and there is also

00:01:30.730 --> 00:01:33.860
applied origami,
which is applying

00:01:33.860 --> 00:01:36.400
origami for
engineering purposes.

00:01:36.400 --> 00:01:40.930
For example, we can
use sheet folding

00:01:40.930 --> 00:01:48.590
for manufacturing a
3D surface or use it

00:01:48.590 --> 00:01:52.220
for increasing the
structure's stiffness.

00:01:52.220 --> 00:01:58.050
These are examples of
a formed 3D surface

00:01:58.050 --> 00:02:01.600
from a sheet of metal.

00:02:01.600 --> 00:02:05.850
We can use a dynamic
property of origami

00:02:05.850 --> 00:02:09.940
for deployable
structure, such as this

00:02:09.940 --> 00:02:16.910
is folding of solar panels
used for spatial structures.

00:02:16.910 --> 00:02:20.940
A good thing about origami is
that unlike the truss structure

00:02:20.940 --> 00:02:24.280
or scissors structure,
you can form basically

00:02:24.280 --> 00:02:26.730
a continuous surface,
and that continuity

00:02:26.730 --> 00:02:32.980
is preserved all the way
of the transformation.

00:02:32.980 --> 00:02:37.060
So this makes
origami potentially

00:02:37.060 --> 00:02:39.880
useful for adaptive
environment, which

00:02:39.880 --> 00:02:44.600
includes context customized
design or personal design

00:02:44.600 --> 00:02:49.380
so that you can make some
kind of origami structures

00:02:49.380 --> 00:02:54.850
that fit customized to your
body or customised to the design

00:02:54.850 --> 00:02:56.300
context.

00:02:56.300 --> 00:03:01.490
And you can, of course, do
fabrication oriented design

00:03:01.490 --> 00:03:07.020
so that you can efficiently
use the material

00:03:07.020 --> 00:03:11.370
to build the 3D
structure that you want.

00:03:11.370 --> 00:03:15.990
What I'm proposing with
the architectural origami,

00:03:15.990 --> 00:03:18.960
it's different from
origami architecture.

00:03:18.960 --> 00:03:23.670
I have been using the word
"origami architecture," which

00:03:23.670 --> 00:03:27.895
might mean the application
of origami to design.

00:03:32.980 --> 00:03:37.160
So this is the direction
of application.

00:03:37.160 --> 00:03:40.350
We start from some kind
of shape or pattern

00:03:40.350 --> 00:03:45.810
and see how it is folded
or see the behavior

00:03:45.810 --> 00:03:52.070
by simulating, or directly
applying in physical world.

00:03:52.070 --> 00:03:59.460
But that can result in
very restricted design

00:03:59.460 --> 00:04:02.120
because origami is
very constrained,

00:04:02.120 --> 00:04:04.950
and that would
just result in just

00:04:04.950 --> 00:04:08.820
a copy of some known
origami pattern to design.

00:04:08.820 --> 00:04:14.860
Or sometimes, there are lots
of origami inspired designs

00:04:14.860 --> 00:04:19.709
that don't use any of the
origami properties that

00:04:19.709 --> 00:04:22.860
might be useful for
engineering purpose.

00:04:22.860 --> 00:04:25.960
So what I am proposing
with the word

00:04:25.960 --> 00:04:30.400
"architectural origami" is
that origami theory for design

00:04:30.400 --> 00:04:33.800
and a design system
that uses that.

00:04:33.800 --> 00:04:37.880
So the idea is in
this direction.

00:04:37.880 --> 00:04:41.820
We want to get some kind
of designed property,

00:04:41.820 --> 00:04:48.910
like how it behaves in
3D or in time, also,

00:04:48.910 --> 00:04:59.360
and we want to extract the
characteristics of origami

00:04:59.360 --> 00:05:05.630
and obtain the solution from
that required condition,

00:05:05.630 --> 00:05:07.730
and also design
contexts that are

00:05:07.730 --> 00:05:12.600
given by the design purpose.

00:05:12.600 --> 00:05:13.740
This is the outline.

00:05:13.740 --> 00:05:16.750
First is Origamizer.

00:05:16.750 --> 00:05:21.490
I'm going to talk about
basically the software I've

00:05:21.490 --> 00:05:24.630
been developing, the systems.

00:05:24.630 --> 00:05:25.380
One is Origamizer.

00:05:46.400 --> 00:05:53.370
Some of you have
attended Eric's class,

00:05:53.370 --> 00:05:57.680
so the theoretic side of
the Origamizer altorithm,

00:05:57.680 --> 00:06:03.710
but I'm going to talk
about the software itself

00:06:03.710 --> 00:06:06.780
and the algorithm that
efficiently works.

00:06:06.780 --> 00:06:09.740
So first, Origamizer.

00:06:09.740 --> 00:06:14.780
This is the software is
available on my web page.

00:06:14.780 --> 00:06:17.255
It's freely available.

00:06:21.780 --> 00:06:23.210
It's about origami design.

00:06:23.210 --> 00:06:27.870
This is my oldest
work as research.

00:06:27.870 --> 00:06:36.130
We had a tree method or
circle river packing method

00:06:36.130 --> 00:06:39.190
developed by Meguro
and Lang, which

00:06:39.190 --> 00:06:46.590
is using stick figure for
representing the model

00:06:46.590 --> 00:06:52.590
and designed by packing
circles and rivers.

00:06:52.590 --> 00:06:57.320
I think Jason has
talked in the class.

00:06:57.320 --> 00:07:02.290
So this is existing
method for origami design,

00:07:02.290 --> 00:07:05.520
and what I wanted
to do is make 3D

00:07:05.520 --> 00:07:08.470
instead of this
kind of 1D figure.

00:07:08.470 --> 00:07:12.760
So this is what we can get
from the circle river packing

00:07:12.760 --> 00:07:17.650
method, and with Origamizer
or Freeform Origami,

00:07:17.650 --> 00:07:22.382
we can get this kind of 3D form.

00:07:22.382 --> 00:07:24.340
You can say that what
you see is what you fold.

00:07:30.900 --> 00:07:38.540
In this case, what you see is
not what you fold, actually.

00:07:38.540 --> 00:07:43.060
So I manually designed
something like that.

00:07:43.060 --> 00:07:45.760
It's a laptop PC.

00:07:45.760 --> 00:07:48.090
Well, I think it's the
most complicated one.

00:07:48.090 --> 00:07:53.450
So for example, you can see
there is an RGB output here

00:07:53.450 --> 00:07:57.710
and USB outputs here, and
this is the touch pad,

00:07:57.710 --> 00:08:00.950
and this is keyboard.

00:08:00.950 --> 00:08:02.930
Good thing about that
is the function key

00:08:02.930 --> 00:08:07.940
is a little bit narrower
than the normal key here.

00:08:07.940 --> 00:08:11.760
Anyway, this is what
I've been working on.

00:08:11.760 --> 00:08:16.810
Well, I think it
was my hobby, but I

00:08:16.810 --> 00:08:22.590
was trying to make some kind of
box pleating to make anything.

00:08:22.590 --> 00:08:26.040
And also, this is more
three dimensional figure.

00:08:29.900 --> 00:08:37.000
The body is represented
basically by blocks of cubes.

00:08:37.000 --> 00:08:45.270
And I did more purely geometric
things with concave vertex.

00:08:45.270 --> 00:08:49.520
This was very important for me.

00:08:49.520 --> 00:08:54.150
It's very easy to make a
convex polyhedron with paper.

00:08:54.150 --> 00:08:58.130
Just wrapping paper
will result in folding.

00:08:58.130 --> 00:09:04.130
But it's very hard to
make concave vertex.

00:09:04.130 --> 00:09:12.710
When I finished this model, I
thought everything is possible,

00:09:12.710 --> 00:09:18.470
so I did a software
to do this for me.

00:09:21.410 --> 00:09:25.070
The program is to realize
arbitrarily given polyhedra

00:09:25.070 --> 00:09:29.040
surface with a developable
surface by folding.

00:09:31.610 --> 00:09:33.700
The geometric constraints
is, of course,

00:09:33.700 --> 00:09:37.215
developability so that it can
be folded from a sheet of paper.

00:09:40.180 --> 00:09:42.650
In this case, we forget
about continuous motion

00:09:42.650 --> 00:09:45.980
from a sheet of paper
to the resulting state.

00:09:45.980 --> 00:09:51.640
We believe that physically
it exists, so it works.

00:09:54.640 --> 00:09:59.550
It can be applied in engineering
sense for fabrication

00:09:59.550 --> 00:10:02.630
by folding and bending.

00:10:02.630 --> 00:10:06.630
We put arbitrary polyhedron
and get the crease pattern,

00:10:06.630 --> 00:10:09.640
and by only folding
this part, you

00:10:09.640 --> 00:10:15.130
get the folded state that's the
same as this arbitrarily given

00:10:15.130 --> 00:10:17.730
polyhedron.

00:10:17.730 --> 00:10:20.640
The idea is to use tuck.

00:10:20.640 --> 00:10:32.150
This is a given polyhedron, and
this grey area is our tucks.

00:10:32.150 --> 00:10:35.860
By folding a tuck, it's hidden.

00:10:35.860 --> 00:10:40.160
It's flat folded and it's hidden
behind a polyhedron's surface,

00:10:40.160 --> 00:10:43.960
like in this movie.

00:10:43.960 --> 00:10:46.560
When it's in developed
state, it forms

00:10:46.560 --> 00:10:51.470
a plane with a
surface polyhedron.

00:10:51.470 --> 00:10:54.760
This is good because we can
make a negative curvature

00:10:54.760 --> 00:11:00.270
vertex, a concave or
negative curvature vertex.

00:11:07.730 --> 00:11:15.470
The basic algorithm is to
start from making the problem

00:11:15.470 --> 00:11:22.070
into laying out the surface
polygons onto a plane.

00:11:22.070 --> 00:11:27.660
By properly aligning, we can get
the edge tucking molecule that

00:11:27.660 --> 00:11:32.180
folds the edge to edge and
vertex tucking molecule which

00:11:32.180 --> 00:11:39.060
folds vertices to vertex, and
we can pack them and tesselate

00:11:39.060 --> 00:11:43.750
the surface with these elements.

00:11:43.750 --> 00:11:47.692
We can parameterize
this configuration,

00:11:47.692 --> 00:11:53.640
and we can solve it by
solving non-linear equation

00:11:53.640 --> 00:11:55.930
and inequality conditions.

00:11:55.930 --> 00:11:57.750
That's the basic idea.

00:11:57.750 --> 00:12:01.790
What we have is
geometric constraints,

00:12:01.790 --> 00:12:06.540
which are represented
by equations.

00:12:06.540 --> 00:12:09.130
So these are the
equations, where

00:12:09.130 --> 00:12:14.140
this one represents the
total sum, sums up 2 pi,

00:12:14.140 --> 00:12:24.010
and this shows that this forms
a closed loop for each vertex.

00:12:24.010 --> 00:12:29.090
We assign these conditions
for each vertex,

00:12:29.090 --> 00:12:34.770
and we solve that by two
step linear mapping, which

00:12:34.770 --> 00:12:41.530
is basically solving this
equation and this equation.

00:12:41.530 --> 00:12:46.040
Good thing about that is
that it becomes linear,

00:12:46.040 --> 00:12:49.480
which means that
you can pre-compute

00:12:49.480 --> 00:12:56.000
and you can go around
the solution space.

00:12:56.000 --> 00:13:00.990
I will show you later
the design system.

00:13:12.130 --> 00:13:17.790
I don't go into details, but
there are several inequality

00:13:17.790 --> 00:13:22.745
conditions, which are
for making crease pattern

00:13:22.745 --> 00:13:30.430
and for making it to fit into 3D
configuration of the polyhedron

00:13:30.430 --> 00:13:36.150
and tuck property,
which is assumed

00:13:36.150 --> 00:13:42.820
place of the tuck that's hidden.

00:13:42.820 --> 00:13:43.790
So this is a system.

00:13:46.980 --> 00:13:51.280
You put the input
here in this window,

00:13:51.280 --> 00:13:58.500
and you have the layout
of the surface polygons,

00:13:58.500 --> 00:14:00.530
and then you get the
crease pattern like that.

00:14:04.560 --> 00:14:07.580
It automatically generates
the crease pattern,

00:14:07.580 --> 00:14:14.080
and here you see it's
edited in real time.

00:14:14.080 --> 00:14:15.340
By the way, this is real time.

00:14:21.920 --> 00:14:26.130
The linear equations
are represented

00:14:26.130 --> 00:14:34.790
by linear equations, so you can
pre-compute the linear matrix

00:14:34.790 --> 00:14:40.135
and then you can calculate the
configuration interactively.

00:14:42.720 --> 00:14:46.515
You can also do some
kind of boundary editing.

00:14:46.515 --> 00:14:47.901
Do you have questions?

00:14:47.901 --> 00:14:48.484
AUDIENCE: Yes.

00:14:48.484 --> 00:14:51.890
Does this maximize the amout
of paper on the outside?

00:14:51.890 --> 00:14:56.910
PROFESSOR: It's about
maximizing the size

00:14:56.910 --> 00:15:00.240
of the model with respect
to the paper size.

00:15:00.240 --> 00:15:00.770
It's not.

00:15:04.670 --> 00:15:06.890
Yes, you can, of
course, implement

00:15:06.890 --> 00:15:09.280
some kind of optimization
onto the program,

00:15:09.280 --> 00:15:17.510
but I keep it more free so that
the software user can search

00:15:17.510 --> 00:15:21.855
within the solution space that
satisfies these origamizing

00:15:21.855 --> 00:15:22.355
conditions.

00:15:25.510 --> 00:15:30.730
So this is a series of
results that are folded.

00:15:34.870 --> 00:15:38.000
This is how to fold
an origami bunny.

00:15:38.000 --> 00:15:41.620
First thing you do is
to get crease pattern

00:15:41.620 --> 00:15:44.670
using Origamizer,
and then fold along

00:15:44.670 --> 00:15:50.410
the given crease
pattern like this.

00:15:55.460 --> 00:15:57.880
Interesting thing
about that is that it's

00:15:57.880 --> 00:16:00.460
changing the
lighting conditions.

00:16:00.460 --> 00:16:02.630
It starts from
natural light and it

00:16:02.630 --> 00:16:05.640
becomes into artificial light.

00:16:05.640 --> 00:16:07.885
It takes about 10
hours or something.

00:16:10.740 --> 00:16:11.940
And it's done.

00:16:11.940 --> 00:16:16.935
And I have this one.

00:16:16.935 --> 00:16:20.400
[APPLAUSE]

00:16:25.360 --> 00:16:29.440
There are two existing
models, not one,

00:16:29.440 --> 00:16:31.745
so it's very easy to reproduce.

00:16:40.060 --> 00:16:44.380
One thing that I'm
doing with Eric

00:16:44.380 --> 00:16:48.370
is to prove that
anything is possible.

00:16:48.370 --> 00:16:53.280
The software is a little
bit approximation,

00:16:53.280 --> 00:16:56.650
or it doesn't work
in some cases,

00:16:56.650 --> 00:17:02.520
so we are doing really
make it possible.

00:17:02.520 --> 00:17:04.900
This is the part
of the Origamizer,

00:17:04.900 --> 00:17:08.109
so if you have questions
for Origamizer.

00:17:08.109 --> 00:17:09.183
Yes?

00:17:09.183 --> 00:17:12.850
AUDIENCE: So for the
input of the model

00:17:12.850 --> 00:17:16.894
that you can use, does it
take [INAUDIBLE], the format?

00:17:16.894 --> 00:17:19.023
AUDIENCE: It's polygons.

00:17:19.023 --> 00:17:20.931
AUDIENCE: What's the
file format that you

00:17:20.931 --> 00:17:23.859
have to import in in order to--

00:17:23.859 --> 00:17:27.300
PROFESSOR: Format of 3D input.

00:17:27.300 --> 00:17:34.770
It's basically OBJ file that
this particular software

00:17:34.770 --> 00:17:37.360
accepts, but basically,
it's OK if it's

00:17:37.360 --> 00:17:42.900
a polyhedral surface with
actually any topology

00:17:42.900 --> 00:17:48.110
because you can basically assign
the boundary of paper onto it

00:17:48.110 --> 00:17:51.420
so that it always
becomes a disk.

00:17:51.420 --> 00:17:53.814
Yes?

00:17:53.814 --> 00:17:57.742
AUDIENCE: You mentioned that
earlier on in the process,

00:17:57.742 --> 00:18:01.179
you need to properly lay out
the polygons onto the plane.

00:18:01.179 --> 00:18:03.143
What constitutes proper layout?

00:18:08.460 --> 00:18:16.460
PROFESSOR: Your question
is, what is a proper layout?

00:18:16.460 --> 00:18:22.610
This is basically given
by these conditions.

00:18:28.700 --> 00:18:36.230
In an intuitive way, if
you lay out polygons,

00:18:36.230 --> 00:18:42.290
I want to fold this line onto
this line with, actually,

00:18:42.290 --> 00:18:46.590
a single line, so
you have to keep

00:18:46.590 --> 00:18:50.220
this symmetric
against some line.

00:18:50.220 --> 00:18:52.825
So that gives a constraint.

00:18:58.530 --> 00:19:04.000
This is the basic equations
that you have to solve,

00:19:04.000 --> 00:19:08.360
and there are several
others, such as the boundary

00:19:08.360 --> 00:19:12.170
should be convex because
we don't want to end up

00:19:12.170 --> 00:19:18.770
in some kind of very
complex boundary.

00:19:18.770 --> 00:19:22.110
If it's foldable
form a convex paper,

00:19:22.110 --> 00:19:24.740
then it's foldable
from a square,

00:19:24.740 --> 00:19:27.910
so that's the
convexity of paper.

00:19:27.910 --> 00:19:32.195
No intersection, of
course, between polygons.

00:19:35.240 --> 00:19:38.840
It's a little bit difficult,
but when you place crease lines,

00:19:38.840 --> 00:19:42.900
then it might hit
adjacent crease lines.

00:19:42.900 --> 00:19:47.680
That's pretty bad, so
you have to avoid that.

00:19:47.680 --> 00:19:51.890
Also, you have to fit
to the 3D surface.

00:19:51.890 --> 00:19:55.970
Sometimes a tuck
that's coming inside

00:19:55.970 --> 00:20:05.000
is bad, so you have
to adjust that,

00:20:05.000 --> 00:20:08.346
and in order to do that,
you need a condition.

00:20:08.346 --> 00:20:10.542
AUDIENCE: Did you find
that you were moving around

00:20:10.542 --> 00:20:13.714
where the edges of
the [INAUDIBLE] model,

00:20:13.714 --> 00:20:18.106
or can you just start
anywhere and randomly come up

00:20:18.106 --> 00:20:19.082
with a solution?

00:20:22.822 --> 00:20:24.030
PROFESSOR: It's how to solve?

00:20:24.030 --> 00:20:24.655
AUDIENCE: Yeah.

00:20:24.655 --> 00:20:30.790
Does it get a lot harder
as the polygons increase?

00:20:30.790 --> 00:20:36.770
PROFESSOR: It's not a step by
step approach to laying out

00:20:36.770 --> 00:20:38.700
one piece at a
time, but it's more

00:20:38.700 --> 00:20:44.700
like solving all the equations
all at the same time using

00:20:44.700 --> 00:20:47.700
big vector equation.

00:20:47.700 --> 00:20:50.154
AUDIENCE: Maybe what he means
is, is it numerically well

00:20:50.154 --> 00:20:52.970
conditioned?

00:20:52.970 --> 00:20:54.320
PROFESSOR: No.

00:20:54.320 --> 00:20:58.396
That's why we need
extra work for proving.

00:20:58.396 --> 00:21:00.020
AUDIENCE: That it's
always [INAUDIBLE].

00:21:02.900 --> 00:21:04.950
PROFESSOR: That's a question.

00:21:04.950 --> 00:21:11.900
Well, it's not always.

00:21:11.900 --> 00:21:13.960
There are sometimes
that produces

00:21:13.960 --> 00:21:20.310
some kind of over constrained
part and free part.

00:21:20.310 --> 00:21:23.280
AUDIENCE: Also, are the tucks
under mechanical tension?

00:21:23.280 --> 00:21:27.000
Does it want to stay tucked
or does it want to come apart?

00:21:29.770 --> 00:21:31.530
PROFESSOR: Physical
property of the tuck.

00:21:31.530 --> 00:21:33.884
AUDIENCE: Yes.

00:21:33.884 --> 00:21:35.300
PROFESSOR: Because
of the crimping

00:21:35.300 --> 00:21:44.160
that's done to each of these
vertices to fit the curvature,

00:21:44.160 --> 00:21:47.230
it stays in this form.

00:21:47.230 --> 00:21:50.740
You don't have any
glues or crimps here.

00:21:50.740 --> 00:21:57.791
This is actually a good
property of this design method.

00:21:57.791 --> 00:21:58.290
Yes?

00:22:02.406 --> 00:22:03.780
AUDIENCE: To
approximate a curve,

00:22:03.780 --> 00:22:09.850
you're breaking it down into
smaller straight edge segments.

00:22:09.850 --> 00:22:12.932
Is that useful or plannable
as to what the lower bound is

00:22:12.932 --> 00:22:19.610
to how granular you make
the curve approximation?

00:22:19.610 --> 00:22:24.310
PROFESSOR: About the
condition for the input.

00:22:28.330 --> 00:22:32.530
In this system, I
don't give any kind

00:22:32.530 --> 00:22:39.440
of numerical upper
boundary for the regularity

00:22:39.440 --> 00:22:44.220
of triangles or something.

00:22:44.220 --> 00:22:47.820
But I think it's good if
we can do for anything,

00:22:47.820 --> 00:22:53.010
so that's why I'm working
with Eric on proving.

00:23:00.276 --> 00:23:04.590
AUDIENCE: Is there a Mac
version of the program?

00:23:04.590 --> 00:23:05.755
PROFESSOR: Mac version?

00:23:05.755 --> 00:23:11.970
No, it's still
Windows version only.

00:23:11.970 --> 00:23:21.295
It's written with cross platform
library, so sometime in future.

00:23:28.340 --> 00:23:33.840
So let's move on to the next
topic and software, which

00:23:33.840 --> 00:23:34.920
is Freeform Origami.

00:23:38.470 --> 00:23:42.960
So the objective
of Freeform Origami

00:23:42.960 --> 00:23:52.270
is that we don't want to
spend too much time to make

00:23:52.270 --> 00:23:56.960
this kind of 3D
form, and also, we

00:23:56.960 --> 00:24:02.810
want some kind of conditions,
not only developability.

00:24:02.810 --> 00:24:07.840
We want some condition
that most origami has.

00:24:10.560 --> 00:24:13.380
This is flat
foldability so that it

00:24:13.380 --> 00:24:17.820
folds flat, and also
transformability or elastic

00:24:17.820 --> 00:24:18.790
properties.

00:24:18.790 --> 00:24:23.400
We want to use these good
properties from origami

00:24:23.400 --> 00:24:28.840
while we want to make some
kind of freeform surface.

00:24:28.840 --> 00:24:34.030
So the approach here is start
from existing origami models

00:24:34.030 --> 00:24:39.970
and then modify that
to a different shape

00:24:39.970 --> 00:24:47.000
while keeping the
origami conditions

00:24:47.000 --> 00:24:51.520
with direct, straightforward
user interface.

00:24:51.520 --> 00:25:03.970
Here, I used triangular mesh for
representing the origami model,

00:25:03.970 --> 00:25:08.490
and we represent
the origami models

00:25:08.490 --> 00:25:14.070
by the vertex
coordinates of the model.

00:25:14.070 --> 00:25:19.730
These variables are constrained
by developability and flat

00:25:19.730 --> 00:25:27.720
foldability This is a very
direct way of implementing

00:25:27.720 --> 00:25:30.765
origami deformation.

00:25:34.520 --> 00:25:37.060
First thing we want to
keep is developability,

00:25:37.060 --> 00:25:40.315
which is that you can fold
from a sheet of paper.

00:25:43.190 --> 00:25:45.770
In engineering sense,
it means that it

00:25:45.770 --> 00:25:48.840
can be manufactured from
a sheet material, which

00:25:48.840 --> 00:25:51.860
is very nice, by folding
and bending only.

00:25:55.930 --> 00:25:59.660
The condition is
globally represented

00:25:59.660 --> 00:26:03.800
that there exists some
isometric mapping to a plane,

00:26:03.800 --> 00:26:07.250
but if the surface is
a topological disk,

00:26:07.250 --> 00:26:14.590
it can be represented by a
local condition of every point.

00:26:14.590 --> 00:26:20.610
So every point on the surface,
the Gauss curvature is zero.

00:26:20.610 --> 00:26:26.980
Actually, we are thinking
of a non-smooth surface,

00:26:26.980 --> 00:26:32.110
but we are thinking of a
piecewise linear surface, which

00:26:32.110 --> 00:26:35.590
allows variation.

00:26:35.590 --> 00:26:39.610
Smooth developer surface is only
allowed to be in these forms,

00:26:39.610 --> 00:26:44.280
but we have lots of
different form variations

00:26:44.280 --> 00:26:45.140
if we allow creases.

00:26:51.520 --> 00:26:55.380
Even in this case, we have
to think about Gauss area,

00:26:55.380 --> 00:26:57.980
and it's very easy
to define Gauss area

00:26:57.980 --> 00:27:08.810
for a C2 version of surface
by multiplying curvatures,

00:27:08.810 --> 00:27:16.280
but for polyhedra case, we
use instead Gauss area, which

00:27:16.280 --> 00:27:23.290
is represented by this, which
is 2 pi minus sum of angles

00:27:23.290 --> 00:27:25.520
around the vertex.

00:27:25.520 --> 00:27:28.950
It's a very simple
way to express

00:27:28.950 --> 00:27:32.070
that it's folded from a plane.

00:27:32.070 --> 00:27:35.320
This sums up to 2 pi.

00:27:35.320 --> 00:27:39.790
This is what you can
use for developability.

00:27:39.790 --> 00:27:43.420
We want to also have flat
foldability for the surface.

00:27:46.940 --> 00:27:54.570
This is applicable for
compactly packaging a surface

00:27:54.570 --> 00:27:57.800
from 3D to 2D and from 2D to 3D.

00:28:00.680 --> 00:28:04.580
It's also represented
by isometric condition,

00:28:04.580 --> 00:28:06.270
like in developability.

00:28:06.270 --> 00:28:10.270
And also, we have a little bit
of layering condition, which

00:28:10.270 --> 00:28:18.190
is actually NP
complete, which is hard,

00:28:18.190 --> 00:28:24.110
but for practical purposes,
we can avoid that.

00:28:26.930 --> 00:28:29.200
The first one is isometry.

00:28:29.200 --> 00:28:32.190
That can be
similarly represented

00:28:32.190 --> 00:28:40.510
by angle condition, which is
called Kawasaki's theorem, so

00:28:40.510 --> 00:28:46.240
that the alternating sum
of each vertex is zero.

00:28:46.240 --> 00:28:50.600
And the layer ordering
is NP complete,

00:28:50.600 --> 00:28:57.660
but we can use, for example,
sufficient condition given

00:28:57.660 --> 00:29:01.940
by Kawasaki or
empirical condition,

00:29:01.940 --> 00:29:09.040
which basically given for
each local adjacent angle,

00:29:09.040 --> 00:29:11.500
so it's very easy to implement.

00:29:11.500 --> 00:29:15.350
And it works, so we forget
about NP complete part.

00:29:19.030 --> 00:29:21.740
And also, we can give
several constraints.

00:29:21.740 --> 00:29:23.750
For example, this
fold doesn't want

00:29:23.750 --> 00:29:28.190
to fold so that it
forms a planar surface,

00:29:28.190 --> 00:29:36.300
or you can fix the point
to a point in 3D space,

00:29:36.300 --> 00:29:41.600
or we can make some
edge to be rigid.

00:29:44.270 --> 00:29:49.440
So we have these coordinates,
and these are the variables

00:29:49.440 --> 00:29:52.825
to represent the configuration,
and be assign developability,

00:29:52.825 --> 00:29:54.720
flat foldability, or
other constraints.

00:29:58.260 --> 00:30:03.000
This forms an
under-determined system,

00:30:03.000 --> 00:30:07.820
which means that it gives you
a multi-dimensional solution

00:30:07.820 --> 00:30:08.950
space.

00:30:08.950 --> 00:30:11.530
Within the solution
space, we move.

00:30:11.530 --> 00:30:16.520
We transform the
surface so that you

00:30:16.520 --> 00:30:21.190
will get the always
valid solution.

00:30:21.190 --> 00:30:24.760
That's the method
we are applying.

00:30:24.760 --> 00:30:30.920
In order to solve
that, we can use

00:30:30.920 --> 00:30:36.360
the Jacobian of the constraints
and calculate it numerically.

00:30:39.130 --> 00:30:47.210
So for each step, it's a given
assumed transformation mold,

00:30:47.210 --> 00:30:51.790
and this gives you a
valid transformation mold

00:30:51.790 --> 00:30:55.515
by using the generalized
inverse or pseudo inverse.

00:30:59.850 --> 00:31:03.420
You can implement
software like this.

00:31:09.640 --> 00:31:13.990
The top is what happens
with Freeform Origami.

00:31:13.990 --> 00:31:17.130
This is a crease
pattern of the paper

00:31:17.130 --> 00:31:21.620
and this is the folded
pattern when it's X-rayed.

00:31:21.620 --> 00:31:24.510
You can see that if
you drag this point up,

00:31:24.510 --> 00:31:27.660
then all the crease pattern
and the flat folded pattern

00:31:27.660 --> 00:31:30.640
changes at the same time.

00:31:30.640 --> 00:31:31.880
This is for comparison.

00:31:31.880 --> 00:31:37.210
This is kind of a simulation.

00:31:37.210 --> 00:31:44.200
In this case, the model cannot
change the crease pattern,

00:31:44.200 --> 00:31:48.635
which makes a less flexible
motion for origami.

00:31:57.540 --> 00:32:03.541
So we want to do some
mesh modification

00:32:03.541 --> 00:32:09.290
because if you change
the crease pattern, then

00:32:09.290 --> 00:32:14.920
it will end up being
degenerate triangles,

00:32:14.920 --> 00:32:19.860
so that we need to do some kind
of edge collapse operation.

00:32:19.860 --> 00:32:25.000
However, in order to do that,
we have several conditions.

00:32:25.000 --> 00:32:27.380
We have to keep
Maekawa's theorem

00:32:27.380 --> 00:32:31.350
if the surface is
flat foldable, and we

00:32:31.350 --> 00:32:34.860
use that for doing
edge collapsing

00:32:34.860 --> 00:32:37.180
and mesh modification.

00:32:37.180 --> 00:32:42.360
You see these patterns
change, and these

00:32:42.360 --> 00:32:48.350
are getting very
degenerate triangles

00:32:48.350 --> 00:32:53.190
that are removed
by this operation.

00:32:53.190 --> 00:32:55.540
This is interesting
because you will end up

00:32:55.540 --> 00:32:56.740
in different patterns.

00:33:00.070 --> 00:33:05.950
This part is similar to diamond
pattern or Yoshimura pattern,

00:33:05.950 --> 00:33:12.480
and this part is kept the
same as Miura-Ori pattern.

00:33:16.340 --> 00:33:21.350
Mesh modification
enables to transform

00:33:21.350 --> 00:33:23.730
to produce more
variations for pattern.

00:33:26.270 --> 00:33:31.690
From now, I will show some
examples of Freeform Origami.

00:33:31.690 --> 00:33:35.740
First one is starting
from Miura-Ori.

00:33:35.740 --> 00:33:38.570
I think it's well known.

00:33:38.570 --> 00:33:45.860
This is actually very old,
you can see from napkin folds.

00:33:45.860 --> 00:33:49.870
For paper models, I think you
can see pictures from Bauhaus.

00:33:52.990 --> 00:33:56.170
Anyway, this is
called Miura-Ori,

00:33:56.170 --> 00:34:00.650
and it gives you
expansive motion,

00:34:00.650 --> 00:34:04.810
and also it can be
compactly packaged

00:34:04.810 --> 00:34:08.850
and it's developable, of course.

00:34:08.850 --> 00:34:15.929
So this is a variation of that,
and this is another example.

00:34:24.190 --> 00:34:26.565
This model is called
Melting Ice Cream.

00:34:30.429 --> 00:34:37.745
The idea is that using a
variation of Miura-Ori,

00:34:37.745 --> 00:34:47.719
it forms a 3D surface that
is irregular and asymmetric,

00:34:47.719 --> 00:34:53.179
while it can be folded flat
so that you can roll it up,

00:34:53.179 --> 00:34:56.159
carry out.

00:34:56.159 --> 00:34:57.510
This is a model.

00:35:04.050 --> 00:35:06.320
This is another example.

00:35:06.320 --> 00:35:09.720
Here, I wanted to start
from regular Miura-Ori

00:35:09.720 --> 00:35:16.740
and then to transform into
a more free form surface.

00:35:19.910 --> 00:35:23.620
You can also generalize
Ron Resch pattern.

00:35:23.620 --> 00:35:28.220
This is one of Ron Resch's
designed triangular

00:35:28.220 --> 00:35:30.820
tessellations.

00:35:30.820 --> 00:35:35.890
Good thing about
this is that it forms

00:35:35.890 --> 00:35:38.790
a kind of composite
surface when its folded.

00:35:38.790 --> 00:35:43.980
So it's composed with
top surface and tucks

00:35:43.980 --> 00:35:49.440
inside, just like this
bunny, but it's more flexible

00:35:49.440 --> 00:35:54.870
and you can fold from
a sheet to the 3D form.

00:35:54.870 --> 00:35:59.990
In order to design this,
we assigned the condition

00:35:59.990 --> 00:36:07.870
that in 3D state, these three
vertices form one vertex.

00:36:07.870 --> 00:36:11.470
That's extra constraints
to enable generalization

00:36:11.470 --> 00:36:12.790
of Ron Resch pattern.

00:36:12.790 --> 00:36:15.810
So for example, you
can get this kind

00:36:15.810 --> 00:36:24.890
of asymmetric polyhedral surface
with this generalized pattern,

00:36:24.890 --> 00:36:28.710
or this form with this pattern.

00:36:28.710 --> 00:36:32.350
Each triangle has
different shapes.

00:36:32.350 --> 00:36:36.730
A little bit of
differentiated shape.

00:36:36.730 --> 00:36:41.920
Or you can just apply to
some regular triangular mesh

00:36:41.920 --> 00:36:53.320
and then get some nice
crumpled paper like that.

00:36:53.320 --> 00:36:59.390
I think this is a good way
for using this software.

00:36:59.390 --> 00:37:01.310
You can design crumpled paper.

00:37:04.010 --> 00:37:06.748
It's very hard to crumple
paper in real life.

00:37:10.010 --> 00:37:12.600
If you feel it's very
difficult, then you

00:37:12.600 --> 00:37:15.280
can use this software
to crumple up paper.

00:37:18.250 --> 00:37:23.030
This is a generalized version
of Yoshimura pattern or diamond

00:37:23.030 --> 00:37:29.560
pattern that you can use for a
kind of shell-like structure.

00:37:29.560 --> 00:37:35.075
This is another pattern
called waterbomb pattern.

00:37:47.890 --> 00:37:54.910
It's supposed to be
playing the puffer fish

00:37:54.910 --> 00:37:56.986
motion by [INAUDIBLE].

00:37:59.650 --> 00:38:06.020
Anyway, this type of pattern
is called waterbomb pattern.

00:38:06.020 --> 00:38:13.320
I think the oldest known
is by Shuzo Fujimoto.

00:38:13.320 --> 00:38:15.995
It's kind of a flexible pattern.

00:38:19.750 --> 00:38:21.620
Because it's flat
foldable, it can

00:38:21.620 --> 00:38:25.260
be used for
deployable structure,

00:38:25.260 --> 00:38:30.260
and because of the
elastic property

00:38:30.260 --> 00:38:34.230
that the folding gives, you
can use for textured material

00:38:34.230 --> 00:38:38.820
or cloth folding.

00:38:38.820 --> 00:38:42.930
This is an example
of deformation.

00:38:42.930 --> 00:38:45.890
This is the normal
waterbomb pattern.

00:38:48.760 --> 00:38:52.830
This is based on triangles.

00:38:52.830 --> 00:38:59.120
This one forms more planar
surface when it's in 3D,

00:38:59.120 --> 00:39:00.800
and this is some generalization.

00:39:04.810 --> 00:39:06.940
This is the folded form.

00:39:06.940 --> 00:39:10.850
I think it's a little
bit too small to show.

00:39:15.540 --> 00:39:22.660
This is the pattern,
and you fold it

00:39:22.660 --> 00:39:26.550
into a kind of a
butterfly shape,

00:39:26.550 --> 00:39:31.660
and it forms a hyperbolic
paraboloidal shape,

00:39:31.660 --> 00:39:36.480
but it's a subtle shape.

00:39:36.480 --> 00:39:39.930
This is another way to make
a [INAUDIBLE] in paper,

00:39:39.930 --> 00:39:41.710
and this exists.

00:39:49.260 --> 00:39:52.756
This was Freeform Origami.

00:39:52.756 --> 00:39:55.410
Do you have any questions
about Freeform Origami?

00:39:59.971 --> 00:40:02.554
AUDIENCE: Why can't you solve
directly for the final shape

00:40:02.554 --> 00:40:06.380
that you want?

00:40:06.380 --> 00:40:09.790
PROFESSOR: The question
is, why do I not

00:40:09.790 --> 00:40:17.910
search for the 3D shape
instead of gradually changing?

00:40:17.910 --> 00:40:27.710
This is because the
constraints are non-linear,

00:40:27.710 --> 00:40:33.460
and that makes it possible that
the solution doesn't exist.

00:40:33.460 --> 00:40:37.440
If you do it
continuously, then it

00:40:37.440 --> 00:40:40.290
is always true that you
get the right answer.

00:40:53.450 --> 00:40:54.680
This is a demonstration.

00:40:59.030 --> 00:41:03.660
This is good because
basically, you

00:41:03.660 --> 00:41:08.160
can interact with the
geometry of the origami

00:41:08.160 --> 00:41:11.155
to find some new results.

00:41:18.010 --> 00:41:24.020
It's more similar to when you
design with paper, like when

00:41:24.020 --> 00:41:28.430
you interact with real
material, but this

00:41:28.430 --> 00:41:36.540
gives more flexible change
of material than simulation.

00:41:36.540 --> 00:41:41.790
I wanted to make that kind
of interaction possible,

00:41:41.790 --> 00:41:48.620
so this moves like that, and
that changes the pattern.

00:42:03.560 --> 00:42:09.060
That's the reason I
do it in this way,

00:42:09.060 --> 00:42:13.420
solve the equation
by deformation.

00:42:17.730 --> 00:42:18.450
Any questions?

00:42:21.342 --> 00:42:22.842
AUDIENCE: I'm just
curious, how long

00:42:22.842 --> 00:42:28.220
did it take you to develop
both this and the Origamizer?

00:42:28.220 --> 00:42:32.290
PROFESSOR: The time for
developing the software.

00:42:32.290 --> 00:42:37.940
Well, it's always continuing.

00:42:37.940 --> 00:42:39.800
I'm always containing
developing,

00:42:39.800 --> 00:42:41.490
so it's very hard to say.

00:42:45.610 --> 00:42:47.560
I don't know.

00:42:47.560 --> 00:42:51.550
I think basically it starts
to work in half a year,

00:42:51.550 --> 00:42:54.620
and then polish a lot of times.

00:42:59.900 --> 00:43:02.467
AUDIENCE: Did you want
to show the demo one?

00:43:02.467 --> 00:43:03.050
PROFESSOR: No.

00:43:03.050 --> 00:43:04.050
Not yet.

00:43:13.350 --> 00:43:18.290
So then we talk about
the rigid origami.

00:43:20.852 --> 00:43:21.776
Question?

00:43:21.776 --> 00:43:24.548
AUDIENCE: I might not
understand it correctly,

00:43:24.548 --> 00:43:28.435
but in either of these programs,
or is there a program that

00:43:28.435 --> 00:43:32.510
exists that allows the
user to design dynamically

00:43:32.510 --> 00:43:35.790
like this curved crease origami?

00:43:38.690 --> 00:43:44.320
PROFESSOR: So curved crease
origami is quite hard.

00:43:44.320 --> 00:43:53.130
I have tried with this software,
and it works for some cases,

00:43:53.130 --> 00:43:56.970
and it doesn't work
for most of the cases

00:43:56.970 --> 00:44:02.030
because there are too
much degrees of freedom.

00:44:02.030 --> 00:44:14.470
If you simulate curve folding by
very thin quadrilateral strips,

00:44:14.470 --> 00:44:19.230
so that's a future work
so that the software

00:44:19.230 --> 00:44:25.010
can work with curve folding.

00:44:25.010 --> 00:44:28.840
If it's a coarse
approximation, then it works.

00:44:36.410 --> 00:44:38.835
So rigid origami.

00:44:45.090 --> 00:44:50.905
This is the closest part
of computational origami

00:44:50.905 --> 00:44:51.730
to architecture.

00:44:55.530 --> 00:45:00.140
So rigid origami is
plates and hinges model

00:45:00.140 --> 00:45:04.740
for origami like this.

00:45:04.740 --> 00:45:14.990
So each rigid panel is
connected to adjacent panel

00:45:14.990 --> 00:45:19.670
with a rotational
hinge, one axis hinge.

00:45:22.570 --> 00:45:28.450
The panels do not deform, and it
produces a synchronized motion.

00:45:28.450 --> 00:45:34.390
So that's a model
when you want to apply

00:45:34.390 --> 00:45:39.980
origami's dynamic
features to some designs.

00:45:43.960 --> 00:45:54.370
And this is a comparison, and
this illustrates the energy

00:45:54.370 --> 00:45:58.860
that's caused by the
distortion of facets.

00:45:58.860 --> 00:46:03.060
For example, this model
falls to this state,

00:46:03.060 --> 00:46:10.750
but there is no path that gives
you zero energy deformation.

00:46:10.750 --> 00:46:15.500
But this is rigid
foldable, which

00:46:15.500 --> 00:46:18.855
keeps each of the
faces not deforming.

00:46:22.230 --> 00:46:26.520
And it's useful for a
self deployable structure

00:46:26.520 --> 00:46:30.760
or architectural structure
that is very large.

00:46:30.760 --> 00:46:34.990
You can substitute
panels with thick panels.

00:46:34.990 --> 00:46:37.170
I will talk in the last part.

00:46:40.990 --> 00:46:41.910
So like this.

00:46:49.062 --> 00:46:49.770
So rigid origami.

00:47:05.610 --> 00:47:13.300
Here, we want to apply rigid
origami to design purposes.

00:47:13.300 --> 00:47:17.200
In order to do that, we
want to think about first

00:47:17.200 --> 00:47:21.570
to also generalize
rigid foldability

00:47:21.570 --> 00:47:30.560
to different shapes, and also
to generalize into cylinders

00:47:30.560 --> 00:47:39.295
and other topology, like
compound structures.

00:47:42.860 --> 00:47:48.505
Before that, I would like to
show example of rigid folding.

00:47:52.850 --> 00:47:57.382
This is the
simulation of folding.

00:47:57.382 --> 00:48:00.340
AUDIENCE: Could you play
the lower left again?

00:48:00.340 --> 00:48:05.280
PROFESSOR: So this is
a triangulated model

00:48:05.280 --> 00:48:12.760
of a tesselation
designed by Ray Schamp.

00:48:12.760 --> 00:48:14.550
This is a waterbomb
tessellation.

00:48:19.900 --> 00:48:23.910
So first thing we want to
do is to simulate folding

00:48:23.910 --> 00:48:31.840
to understand the geometry, the
kinematics of rigid origami.

00:48:36.470 --> 00:48:39.900
This can be represented.

00:48:39.900 --> 00:48:43.410
First easy representation
is a truss model,

00:48:43.410 --> 00:48:50.610
which you basically use vertex
coordinates as the variables

00:48:50.610 --> 00:48:52.930
and then constrain them
with rigid bars that

00:48:52.930 --> 00:48:57.050
are connected to vertices.

00:48:57.050 --> 00:48:59.500
And this one is
different representation

00:48:59.500 --> 00:49:01.690
that uses folding angle.

00:49:01.690 --> 00:49:05.780
This is a more direct
way, and I have a software

00:49:05.780 --> 00:49:09.630
called Rigid Origami
Simulator which basically

00:49:09.630 --> 00:49:15.700
is based on this constraint
and representation.

00:49:15.700 --> 00:49:20.210
The configuration is
represented by folding angles,

00:49:20.210 --> 00:49:25.270
and then the folding angles
are constrained at each vertex

00:49:25.270 --> 00:49:31.470
by this equation, which
is a three by three matrix

00:49:31.470 --> 00:49:34.780
form, which actually
gives nine equations,

00:49:34.780 --> 00:49:39.475
but only three of
them are independent.

00:49:43.070 --> 00:49:48.490
We have three equations
for each vertex.

00:49:48.490 --> 00:49:52.760
That will give also
under-determined system

00:49:52.760 --> 00:50:00.040
so that you can simulate folding
using also generalized inverse

00:50:00.040 --> 00:50:02.720
so that you can search
within the solution space

00:50:02.720 --> 00:50:13.290
by giving some pieces kind of
a force that's asserted to each

00:50:13.290 --> 00:50:16.270
of the edges, and
then this results

00:50:16.270 --> 00:50:19.320
in the deformation
that is valid.

00:50:24.610 --> 00:50:26.570
In generic case,
because there are

00:50:26.570 --> 00:50:30.190
three constraints
for each vertex

00:50:30.190 --> 00:50:39.340
and one variable for each edge,
we have this degree of freedom.

00:50:43.960 --> 00:50:47.480
First way to design
rigid origami is

00:50:47.480 --> 00:50:57.960
to use this information from
Euler's polyhedral formula,

00:50:57.960 --> 00:51:02.750
we can say that any triangular
mesh-- well, not any.

00:51:02.750 --> 00:51:09.960
It's a generic triangular mesh--
produces a degree of freedom,

00:51:09.960 --> 00:51:15.330
which is number of edges
on the boundary minus 3.

00:51:15.330 --> 00:51:18.810
So for example, in this
[? hyper ?] triangular model,

00:51:18.810 --> 00:51:24.120
this gives one degree of
freedom because the boundary

00:51:24.120 --> 00:51:27.840
edges are four.

00:51:27.840 --> 00:51:31.490
And we can generalize
it to cases

00:51:31.490 --> 00:51:33.550
where there are holes also.

00:51:38.000 --> 00:51:41.670
With this idea, you can make
hexagonal tripod shell, which

00:51:41.670 --> 00:51:48.510
is using six edged,
hexagonal boundary,

00:51:48.510 --> 00:51:53.110
so that the degree
of freedom is three,

00:51:53.110 --> 00:51:58.870
and then we pin joint three
of the vertices, which

00:51:58.870 --> 00:51:59.830
gives nine constraints.

00:52:02.690 --> 00:52:08.960
Because of the rigid body
degree of freedom, which is six,

00:52:08.960 --> 00:52:14.630
we have nine degrees of
freedom of transformation,

00:52:14.630 --> 00:52:17.600
and then that's our
constraint by nine,

00:52:17.600 --> 00:52:23.610
so it produces static structure.

00:52:23.610 --> 00:52:26.710
By changing the position
of these points,

00:52:26.710 --> 00:52:30.410
you can get the different forms.

00:52:30.410 --> 00:52:36.670
For example, this is the
shape, triangular form.

00:52:36.670 --> 00:52:45.430
The position of these pods
changes the overall shape,

00:52:45.430 --> 00:52:49.805
and it's static when it's
fixed, it's all pin joint.

00:52:59.360 --> 00:53:00.300
This is an example.

00:53:03.090 --> 00:53:11.820
If you change the
position of the leg,

00:53:11.820 --> 00:53:14.500
then you get the
different shapes,

00:53:14.500 --> 00:53:17.430
3D configuration like this.

00:53:20.410 --> 00:53:30.540
This is one way to build
rigid origami structures.

00:53:30.540 --> 00:53:45.940
This is quite obvious result.

00:53:45.940 --> 00:53:49.830
Theoretically, it's more
interesting to think about

00:53:49.830 --> 00:53:53.010
the one that you cannot
imagine the transformation,

00:53:53.010 --> 00:53:57.010
for example, quadrilateral mesh.

00:53:57.010 --> 00:54:04.900
So for quadrilateral
mesh, each vertex

00:54:04.900 --> 00:54:10.560
has also three constraints
so that this itself

00:54:10.560 --> 00:54:14.330
forms a one DOF structure.

00:54:14.330 --> 00:54:21.920
Think about when you form a
mesh with this, like Miura-Ori.

00:54:21.920 --> 00:54:31.700
Basically, if you define
this folding angle,

00:54:31.700 --> 00:54:34.200
then all the folding
angles here are defined.

00:54:37.930 --> 00:54:42.010
If you have another
degree for vertex,

00:54:42.010 --> 00:54:47.610
then everything is
here defined, and you

00:54:47.610 --> 00:54:52.420
want to have another
vertex here that

00:54:52.420 --> 00:54:55.130
is defined by this
folding angle.

00:54:55.130 --> 00:55:00.809
Then you will have a problem
here because this folding angle

00:55:00.809 --> 00:55:02.225
and this folding
angle contradict.

00:55:05.530 --> 00:55:14.360
In general, it contradicts so
that you cannot make an array

00:55:14.360 --> 00:55:20.040
of folding by
quadrilateral mesh.

00:55:20.040 --> 00:55:22.980
However, as you can
see from this figure,

00:55:22.980 --> 00:55:26.430
there exist examples
like Miura-Ori

00:55:26.430 --> 00:55:29.710
that give one degree
of freedom motion.

00:55:29.710 --> 00:55:36.380
This is actually a very
interesting thing happening.

00:55:36.380 --> 00:55:40.700
And also, this is great
because all the constraints

00:55:40.700 --> 00:55:42.170
are redundant.

00:55:42.170 --> 00:55:47.250
You can remove this part, so you
can put a hole in the center,

00:55:47.250 --> 00:55:52.490
but still, it results
in the same motion.

00:55:52.490 --> 00:55:57.900
You can design more
freely with this kind

00:55:57.900 --> 00:56:01.700
of robust, redundant
constraint structure.

00:56:04.970 --> 00:56:13.760
What I want to do is to
generalize this to a freeform.

00:56:13.760 --> 00:56:16.510
We start from Miura-Ori
and also start

00:56:16.510 --> 00:56:20.480
from this pattern, which is
not a developable surface,

00:56:20.480 --> 00:56:24.100
but also gives one
degree of freedom motion

00:56:24.100 --> 00:56:31.230
with redundant constraints in
its quadrilateral mesh design.

00:56:31.230 --> 00:56:36.345
These can be generalized to
rigid, non-symmetric forms.

00:56:44.060 --> 00:56:46.290
Miura-Ori is
something like that,

00:56:46.290 --> 00:56:57.110
and we can extract the
property of rigid folding

00:56:57.110 --> 00:56:58.590
by looking at these vertex.

00:57:03.520 --> 00:57:06.550
If it's a flat
foldable vertex, it's

00:57:06.550 --> 00:57:13.140
a degree four vertex
with flat foldability,

00:57:13.140 --> 00:57:16.620
and this gives a
folding motion where

00:57:16.620 --> 00:57:20.940
the opposite folding
angle are the same

00:57:20.940 --> 00:57:24.110
and these are the
same, and also,

00:57:24.110 --> 00:57:29.870
that the folding angle
here and here are related.

00:57:29.870 --> 00:57:33.300
If you look at the tangent
of half of the angle,

00:57:33.300 --> 00:57:37.660
then it's linearly related.

00:57:37.660 --> 00:57:42.690
This is very useful because if
you find one configuration that

00:57:42.690 --> 00:57:48.710
works, then you will have
continuous folding that works.

00:57:51.800 --> 00:57:56.330
In this way, you can
make sufficient condition

00:57:56.330 --> 00:58:02.450
for making a quadrilateral
mesh rigid foldable.

00:58:02.450 --> 00:58:10.360
This is easy to get because it's
only the finite folding motion.

00:58:10.360 --> 00:58:15.070
So the continuous folding
motion from a sheet

00:58:15.070 --> 00:58:19.270
to the folded
state is guaranteed

00:58:19.270 --> 00:58:26.065
by one 3D configuration that
satisfies these conditions.

00:58:29.210 --> 00:58:31.690
In order to get one
configuration that

00:58:31.690 --> 00:58:36.640
satisfies this configuration,
we can use the Freeform Origami,

00:58:36.640 --> 00:58:42.650
so it's very easy
for us to do that.

00:58:42.650 --> 00:58:46.230
This is an example
of rigid origami

00:58:46.230 --> 00:58:53.000
that's using
redundant constraints.

00:58:53.000 --> 00:58:56.760
It produces one degree
of freedom motion

00:58:56.760 --> 00:59:00.410
and it's very light because
this part and this part

00:59:00.410 --> 00:59:04.080
counterbalance the gravity.

00:59:08.520 --> 00:59:09.590
This is another example.

00:59:16.430 --> 00:59:20.975
Quadrilateral mesh can be
a rigid folding motion.

00:59:32.680 --> 00:59:36.340
You can apply to something
like curve folding.

00:59:36.340 --> 00:59:39.200
It's rigid foldable
curve folding.

00:59:39.200 --> 00:59:43.300
This is kind of
contradictory, but we

00:59:43.300 --> 00:59:47.760
can rationalize curve folding
into quadrilateral mesh.

00:59:47.760 --> 00:59:54.130
Then you can produce one degree
of freedom motion like that.

00:59:54.130 --> 00:59:59.620
Another example with
thickness is here.

00:59:59.620 --> 01:00:06.160
It's interesting that it's
one degree of freedom motion

01:00:06.160 --> 01:00:11.260
so that every motion is
coded in the pattern here.

01:00:14.670 --> 01:00:18.150
Another example is
using Eggbox pattern.

01:00:22.340 --> 01:00:24.740
This actually has
the same property

01:00:24.740 --> 01:00:31.200
as the Miura-Ori vertex or flat
foldable degree for vertex,

01:00:31.200 --> 01:00:36.540
so that you can
use the same idea

01:00:36.540 --> 01:00:40.110
to produce rigid
foldable variations.

01:00:42.750 --> 01:00:46.960
You can actually combine
with origami structure

01:00:46.960 --> 01:00:53.740
if you define this
mountain fold, valley fold,

01:00:53.740 --> 01:00:56.340
and also add complementary
mountain fold

01:00:56.340 --> 01:01:05.320
and complementary valley
fold, defined here.

01:01:05.320 --> 01:01:12.070
If you use that kind of
extension of the origami,

01:01:12.070 --> 01:01:20.950
then you will get
design variations

01:01:20.950 --> 01:01:26.740
that combine origami.

01:01:26.740 --> 01:01:29.010
This part is origami
vertex but this is not.

01:01:31.580 --> 01:01:36.660
This can have positive
Gaussian curvature

01:01:36.660 --> 01:01:40.230
while this part is zero
Gaussian curvature.

01:01:40.230 --> 01:01:41.880
The interesting
point is that you

01:01:41.880 --> 01:01:45.250
can develop the
flat folded state

01:01:45.250 --> 01:01:50.460
or actually, in this case, it's
two flat folded states because

01:01:50.460 --> 01:01:57.190
in this case, it's
not totally developed,

01:01:57.190 --> 01:02:02.510
but complementary
fold lines are folded.

01:02:02.510 --> 01:02:05.850
So that's why I call it
bidirectionally flat foldable

01:02:05.850 --> 01:02:10.669
planar quadrilateral mesh, and
that can be rigidity foldable.

01:02:10.669 --> 01:02:11.460
This is an example.

01:02:28.180 --> 01:02:31.480
This was about a
disk, and we can

01:02:31.480 --> 01:02:34.380
develop into a
cylindrical structure.

01:02:34.380 --> 01:02:43.460
And cylinder is not trivial
because, for example, this

01:02:43.460 --> 01:02:45.680
is known origami
pattern, but this

01:02:45.680 --> 01:02:47.380
doesn't transform
to this pattern

01:02:47.380 --> 01:02:53.725
because this is has a
different number or edges.

01:02:53.725 --> 01:02:58.790
You cannot produce this kind
of motion in rigid folding

01:02:58.790 --> 01:03:01.550
mechanism.

01:03:01.550 --> 01:03:07.940
You can see what's the problem
by looking at this kind of disk

01:03:07.940 --> 01:03:10.700
surface that is
rigidly foldable,

01:03:10.700 --> 01:03:15.220
and it forms a
cylinder at one state

01:03:15.220 --> 01:03:20.740
but it doesn't produce in
a continuous motion that

01:03:20.740 --> 01:03:24.540
fix this loop.

01:03:24.540 --> 01:03:26.380
But there exists.

01:03:26.380 --> 01:03:35.220
So the idea is to mirror reflect
one part of Miura-Ori vertex.

01:03:35.220 --> 01:03:41.200
Actually, you can see from the
origami model by Thoki Yenn.

01:03:41.200 --> 01:03:43.060
It's called Flip Flop.

01:03:43.060 --> 01:03:44.435
It's a very interesting model.

01:03:47.770 --> 01:03:56.740
You can develop more generalized
origami cylinders like these.

01:03:56.740 --> 01:04:01.690
I think this is rigid
foldable cylinders.

01:04:01.690 --> 01:04:05.700
Since it's using
quadrilateral panels,

01:04:05.700 --> 01:04:09.500
it similarly produces one
degree of freedom motion.

01:04:09.500 --> 01:04:13.250
And you can see, for
example, like that.

01:04:13.250 --> 01:04:14.600
This is the motion produced.

01:04:17.410 --> 01:04:22.900
Any part produces
the whole motion.

01:04:28.960 --> 01:04:33.180
And also, you can make some
kind of design variations.

01:04:33.180 --> 01:04:37.185
This is using grasshopper
on rhinoceros.

01:04:40.320 --> 01:04:47.010
This is the given shape, the
section, and from the section,

01:04:47.010 --> 01:04:52.410
you can make a rigid
foldable cylinder and also

01:04:52.410 --> 01:04:54.200
composite structures like this.

01:04:59.000 --> 01:05:01.150
So we can make
composite structures

01:05:01.150 --> 01:05:06.765
like this, so it's great
that it fills the space.

01:05:10.480 --> 01:05:14.390
It tessellates while
preserving the one

01:05:14.390 --> 01:05:15.640
degree of freedom motion.

01:05:20.020 --> 01:05:25.050
This is an implementation
with thick panels.

01:05:25.050 --> 01:05:29.950
Think I have got the
cylindrical tessellation model.

01:05:32.530 --> 01:05:40.180
This is a tessellated model,
which moves like that.

01:05:40.180 --> 01:05:46.573
It's kind of a volume that
flattens into two states,

01:05:46.573 --> 01:05:49.490
and it's good that
it's rigidly foldable

01:05:49.490 --> 01:05:51.600
and it's one degree
of freedom mechanism.

01:05:59.480 --> 01:06:00.800
I want to generalize more.

01:06:05.990 --> 01:06:08.800
This is symmetric.

01:06:08.800 --> 01:06:13.740
There exists one axis that
repeats the unit structure.

01:06:13.740 --> 01:06:19.950
I want to make it more general.

01:06:19.950 --> 01:06:22.870
I like the asymmetry
than symmetry.

01:06:22.870 --> 01:06:28.720
I think you do also.

01:06:28.720 --> 01:06:34.130
But you have to think about
the conditions around a hole,

01:06:34.130 --> 01:06:39.990
and actually, this is
a difficult condition

01:06:39.990 --> 01:06:45.760
to be solved then
the disk version.

01:06:45.760 --> 01:06:53.620
However, you can do that
by fixing the first loop,

01:06:53.620 --> 01:06:56.800
then you know that this
part is rigid foldable,

01:06:56.800 --> 01:07:01.600
so you can continue
deformation from there.

01:07:01.600 --> 01:07:04.550
This is kind of
sufficient condition,

01:07:04.550 --> 01:07:09.220
but useful for designing
something like this.

01:07:09.220 --> 01:07:13.080
It's more free form.

01:07:13.080 --> 01:07:17.360
For example, this
is also one degree

01:07:17.360 --> 01:07:20.430
of freedom rigid
foldable cylinder.

01:07:24.930 --> 01:07:27.600
This is an example folded.

01:07:37.210 --> 01:07:38.220
It folds like that.

01:07:46.740 --> 01:07:49.010
This is also an example.

01:07:49.010 --> 01:07:54.290
This forms a torus
when it's unfolded.

01:07:58.170 --> 01:08:01.155
Or this type of structure.

01:08:04.449 --> 01:08:05.490
So it's also cylindrical.

01:08:08.250 --> 01:08:13.220
And for kind of
architectural image.

01:08:15.840 --> 01:08:20.830
This is a rigid
origami for cylinder.

01:08:20.830 --> 01:08:31.520
And how to implement rigid
origami to real model,

01:08:31.520 --> 01:08:37.510
because in architecture
design or any other designs,

01:08:37.510 --> 01:08:45.779
we want some kind of
finite thickness model.

01:08:45.779 --> 01:08:48.720
There's no ideal origami.

01:08:48.720 --> 01:08:53.770
Well, probably
Origamido can produce.

01:08:53.770 --> 01:09:00.819
Anyway, we want some thick
panels and rotating hinges

01:09:00.819 --> 01:09:02.410
to produce rigid origami.

01:09:06.180 --> 01:09:09.250
This is the typical
way to do that.

01:09:09.250 --> 01:09:13.500
So you put the hinge
on the valley side.

01:09:13.500 --> 01:09:22.800
The main problem of this one
is that each vertex, there

01:09:22.800 --> 01:09:27.700
are several fold lines that
are joining at the vertex,

01:09:27.700 --> 01:09:33.600
but this will no
longer be concurrent.

01:09:33.600 --> 01:09:38.040
But rigid origami mechanism
assumes that the fold lines are

01:09:38.040 --> 01:09:46.870
concurrent, which means
that it includes translation

01:09:46.870 --> 01:09:49.910
constraints and it
increases the number

01:09:49.910 --> 01:09:52.140
of constraints for each vertex.

01:09:52.140 --> 01:09:56.070
So previously, it was
three constraints there,

01:09:56.070 --> 01:09:59.610
but it becomes six constraints
because it includes

01:09:59.610 --> 01:10:03.210
transformation,
which is very bad,

01:10:03.210 --> 01:10:08.080
but there is asymmetric
vertex that allows that.

01:10:08.080 --> 01:10:11.170
So using asymmetry, you can
make something like that.

01:10:11.170 --> 01:10:19.070
Also, there is a way that you
can slide the hinge like that,

01:10:19.070 --> 01:10:24.950
but there is a problem
in the case like this.

01:10:24.950 --> 01:10:32.500
The problem of sliding is in
global accumulation of errors.

01:10:32.500 --> 01:10:37.780
So what I do is instead
of shifting hinge,

01:10:37.780 --> 01:10:45.100
you can trim the volume
of the vertex valley

01:10:45.100 --> 01:10:47.380
side of the model.

01:10:50.040 --> 01:10:53.590
This is actually very easy.

01:10:53.590 --> 01:10:58.660
You assume that this
folds to pi minus delta,

01:10:58.660 --> 01:11:04.500
and you can just
remove this part

01:11:04.500 --> 01:11:09.010
according to this
maximum folding angle.

01:11:09.010 --> 01:11:18.590
And you can define this point
by offsetting the edges, which

01:11:18.590 --> 01:11:24.800
is basically calculating
with a straight skeleton.

01:11:24.800 --> 01:11:29.830
This also can be applied
to constant thickness

01:11:29.830 --> 01:11:35.710
panels, which is more
easy to be manufactured,

01:11:35.710 --> 01:11:38.240
only with three axis
milling machine.

01:11:42.420 --> 01:11:48.610
This is a thick panel,
thick rigid origami

01:11:48.610 --> 01:11:49.560
using this method.

01:11:52.300 --> 01:11:57.490
This is an example using
a constant thickness model

01:11:57.490 --> 01:12:02.970
where no error is
accumulated, like this model,

01:12:02.970 --> 01:12:05.600
a slideable hinge.

01:12:05.600 --> 01:12:09.690
This is implemented by
using grasshopper again.

01:12:09.690 --> 01:12:14.670
Grasshopper is a good tool
to implement something

01:12:14.670 --> 01:12:22.250
that does not require iterative
optimization calculation,

01:12:22.250 --> 01:12:31.840
but it's very good for forward
calculation of geometry.

01:12:31.840 --> 01:12:34.220
That calculates the
pattern, and then you

01:12:34.220 --> 01:12:37.690
can lay out the pattern.

01:12:37.690 --> 01:12:43.040
This is a cloth, and
we put the thick panels

01:12:43.040 --> 01:12:48.050
on both sides of the cloth to
make a rigid foldable structure

01:12:48.050 --> 01:12:49.830
like this.

01:12:49.830 --> 01:12:52.120
In the center, there
is a cloth that

01:12:52.120 --> 01:12:55.355
represents the ideal origami.

01:12:58.690 --> 01:12:59.975
This is what happens.

01:13:05.260 --> 01:13:11.090
I would like to give an
example of rigid origami

01:13:11.090 --> 01:13:13.750
design for architecture.

01:13:13.750 --> 01:13:22.260
So this example is that we
are given existing building

01:13:22.260 --> 01:13:27.880
openings, and we want to connect
these openings temporarily.

01:13:31.890 --> 01:13:38.070
I want that to be compactly
folded to fit to this facade,

01:13:38.070 --> 01:13:43.150
but because this is
quite large like that,

01:13:43.150 --> 01:13:45.770
you cannot make from
a flexible material.

01:13:45.770 --> 01:13:54.620
That will be a problem if
you make it as a structure.

01:13:54.620 --> 01:13:57.240
So in order to solve
that kind of problem,

01:13:57.240 --> 01:14:04.190
we can use freeform origami to
design to fit the condition.

01:14:04.190 --> 01:14:12.650
So these red lines are the
openings of two buildings that

01:14:12.650 --> 01:14:23.410
are actually not parallel,
and the sizes are different.

01:14:23.410 --> 01:14:28.130
But still, you can connect
it on freefrom origami,

01:14:28.130 --> 01:14:32.600
and also, you can keep the
boundary to fit on the ground,

01:14:32.600 --> 01:14:37.220
and then you can get
these form variations

01:14:37.220 --> 01:14:45.275
and you can choose one of them
and calculate the paneling

01:14:45.275 --> 01:14:45.775
patterns.

01:14:48.690 --> 01:14:54.450
This is a rendering
representation,

01:14:54.450 --> 01:14:57.270
but basically, you can
make this kind of structure

01:14:57.270 --> 01:15:02.825
that can connect to buildings.

01:15:06.910 --> 01:15:08.762
Thank you very much.

01:15:08.762 --> 01:15:17.610
[APPLAUSE]

01:15:17.610 --> 01:15:27.680
This was more hand craft thing.

01:15:27.680 --> 01:15:34.310
I did this with
Dukes there, and we

01:15:34.310 --> 01:15:41.560
wanted to test
the metal folding,

01:15:41.560 --> 01:15:46.030
whether curved folding is
useful for manufacturing things.

01:15:46.030 --> 01:15:51.050
I think that's
true, but this model

01:15:51.050 --> 01:15:57.815
required a lot of hammering
and it wasn't so easy.

01:16:01.450 --> 01:16:04.930
I think you can
have a way to make

01:16:04.930 --> 01:16:08.460
it more easily constructed.

01:16:08.460 --> 01:16:11.735
So this is a table
just by folding

01:16:11.735 --> 01:16:15.110
a sheet of metal or chair.

01:16:19.070 --> 01:16:20.500
This one?

01:16:20.500 --> 01:16:26.375
So this one is a
combination of four papers.

01:16:31.490 --> 01:16:35.440
In this case, I did
not restrict to be

01:16:35.440 --> 01:16:37.360
foldable from one
sheet of paper.

01:16:41.190 --> 01:16:46.260
Well, for design,
I do not do that.

01:16:46.260 --> 01:16:48.550
You can only find
it by simulating

01:16:48.550 --> 01:16:54.890
and see the collision.

01:16:54.890 --> 01:16:59.160
Basically, there will
be no local collision

01:16:59.160 --> 01:17:03.320
for this quadrilateral
mesh, but there

01:17:03.320 --> 01:17:07.730
might be some global collisions
where this and this part

01:17:07.730 --> 01:17:09.768
are colliding.

01:17:09.768 --> 01:17:13.254
AUDIENCE: For example,
for Ron Resch pattern.

01:17:13.254 --> 01:17:16.830
PROFESSOR: Ron Resch pattern.

01:17:16.830 --> 01:17:19.340
I only do a local
collision test,

01:17:19.340 --> 01:17:25.540
which is between facets
that are adjacent,

01:17:25.540 --> 01:17:31.020
which still works for
that kind of good model.

01:17:43.160 --> 01:17:47.850
I think I will show
all of the things here.

01:17:47.850 --> 01:17:48.380
Like that.

01:17:56.439 --> 01:17:57.730
PROFESSOR: Any other questions?

01:18:03.230 --> 01:18:03.730
All right.

01:18:03.730 --> 01:18:04.030
Thanks again.

01:18:04.030 --> 01:18:05.321
PROFESSOR: Thank you very much.

01:18:05.321 --> 01:18:08.280
[APPLAUSE]

