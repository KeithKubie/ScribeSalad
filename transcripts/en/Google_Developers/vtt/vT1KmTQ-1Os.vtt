WEBVTT
Kind: captions
Language: en

00:00:07.060 --> 00:00:07.450
Hi.

00:00:07.450 --> 00:00:08.650
My name is Seth Ladd.

00:00:08.650 --> 00:00:11.260
I'm a developer advocate with
the Google Chrome team.

00:00:11.260 --> 00:00:12.990
Today, we're going to learn
about structured web

00:00:12.990 --> 00:00:15.330
programming with Dart,
the new open source

00:00:15.330 --> 00:00:17.820
web programming platform.

00:00:17.820 --> 00:00:20.340
Our goal is to help developers
from all platforms build

00:00:20.340 --> 00:00:22.920
complex, high performance
client apps

00:00:22.920 --> 00:00:24.470
for the modern web.

00:00:24.470 --> 00:00:27.010
That's a mouthful, let's
break it down.

00:00:27.010 --> 00:00:30.890
"All platforms" means that
developers from Android, iOS,

00:00:30.890 --> 00:00:34.940
Java, .NET, C#, C++, et cetera,
not just endemic web

00:00:34.940 --> 00:00:38.100
developers, should all be
building for the web.

00:00:38.100 --> 00:00:42.110
"Complex" means more features,
more functionality, more HTML5

00:00:42.110 --> 00:00:44.880
goodness, all integrated
into your app.

00:00:44.880 --> 00:00:47.910
There's a tremendous wealth of
new web platform features,

00:00:47.910 --> 00:00:52.320
from file systems to WebGL, to
CSS3 that your modern app can

00:00:52.320 --> 00:00:53.950
take advantage of.

00:00:53.950 --> 00:00:56.160
"High performance"
is easy to spot.

00:00:56.160 --> 00:01:00.750
60 frames a second, zero jank,
zero hitching, zero latency.

00:01:00.750 --> 00:01:04.580
And of course fast computational
execution.

00:01:04.580 --> 00:01:07.760
"Client apps" means we want to
see more business logic, more

00:01:07.760 --> 00:01:11.600
functionality living and running
inside of the browser.

00:01:11.600 --> 00:01:15.140
Modern web apps use the server
as a JSON restful endpoint,

00:01:15.140 --> 00:01:17.180
with the business logic
and functionality

00:01:17.180 --> 00:01:19.340
living in the client.

00:01:19.340 --> 00:01:22.910
"Modern web" means the rising
number of HTML5 browsers.

00:01:22.910 --> 00:01:24.980
Dart targets the modern browser,
which essentially

00:01:24.980 --> 00:01:28.410
means only IE9 and above, and
the latest releases of Chrome,

00:01:28.410 --> 00:01:32.070
Safari, Firefox, Opera, and
of course, the mobile web

00:01:32.070 --> 00:01:35.110
browsers like Mobile Safari
and Chrome for Android.

00:01:35.110 --> 00:01:37.770
This presentation will cover
an introduction to the Dart

00:01:37.770 --> 00:01:39.660
platform and its motivations.

00:01:39.660 --> 00:01:41.910
We'll look at the Dart language,
the different Dart

00:01:41.910 --> 00:01:44.810
runtimes and tools, and finish
up with a look at the Dart

00:01:44.810 --> 00:01:46.750
community and the
future of Dart.

00:01:46.750 --> 00:01:47.930
Let's get started.

00:01:47.930 --> 00:01:51.720
Let's begin with a high level
look at the Dart project.

00:01:51.720 --> 00:01:54.320
Very importantly, Dart
is open source.

00:01:54.320 --> 00:01:57.040
The project is under a
BSD-style license.

00:01:57.040 --> 00:02:00.140
We launched the project in
October, 2011, and you can

00:02:00.140 --> 00:02:03.640
find the code at
dart.googlecode.com.

00:02:03.640 --> 00:02:06.060
We have a contributing guide
to help you send patches.

00:02:06.060 --> 00:02:07.390
We've already received
fixes and

00:02:07.390 --> 00:02:09.110
features from the community.

00:02:09.110 --> 00:02:11.200
Dart is much more than
just a language.

00:02:11.200 --> 00:02:13.220
Dart comes batteries included.

00:02:13.220 --> 00:02:15.380
Along with the language,
Dart also ships a

00:02:15.380 --> 00:02:17.110
wide variety of libraries.

00:02:17.110 --> 00:02:19.350
We have a core set of classes
and interfaces for

00:02:19.350 --> 00:02:21.600
functionality like dates
collections, and

00:02:21.600 --> 00:02:22.900
the built-in types.

00:02:22.900 --> 00:02:27.770
We also ship libraries for the
DOM, JSON, UTF, URI, Math,

00:02:27.770 --> 00:02:29.700
Crypto, and more.

00:02:29.700 --> 00:02:32.150
Dart can run on its own virtual
machine, either on the

00:02:32.150 --> 00:02:34.600
command line or in a browser.

00:02:34.600 --> 00:02:37.180
We ship a Dart editor, a
lightweight editor that

00:02:37.180 --> 00:02:39.410
understands Dart programs
with features like

00:02:39.410 --> 00:02:41.500
refactoring and debugging.

00:02:41.500 --> 00:02:44.420
We have a custom build of
Chromium with an embedded Dart

00:02:44.420 --> 00:02:46.890
VM, affectionately
called Dartium.

00:02:46.890 --> 00:02:50.100
This is great for fast
development iterations.

00:02:50.100 --> 00:02:53.200
And most importantly, Dart
compiles to JavaScript.

00:02:53.200 --> 00:02:56.330
Dart programs work across the
entire modern web thanks to

00:02:56.330 --> 00:02:57.870
this compiler.

00:02:57.870 --> 00:03:00.700
Compiling to logical, sane, and
performant JavaScript is

00:03:00.700 --> 00:03:03.180
incredibly important
for the project.

00:03:03.180 --> 00:03:05.820
Dart runs on the client
as well as the server.

00:03:05.820 --> 00:03:08.680
Dart runs in web browsers when
compiled to JavaScript, or

00:03:08.680 --> 00:03:11.990
directly in browsers that have
the Dart VM embedded.

00:03:11.990 --> 00:03:15.250
Dart runs on the server via the
standalone VM, which runs

00:03:15.250 --> 00:03:18.960
on the command line and can
interact with sockets, files,

00:03:18.960 --> 00:03:22.280
directories, and even
run a web server.

00:03:22.280 --> 00:03:24.750
We've seen how developers really
like the power of using

00:03:24.750 --> 00:03:27.720
the same language for both
client and server, and we

00:03:27.720 --> 00:03:30.720
believe that an end-to-end Dart
solution will be quite

00:03:30.720 --> 00:03:31.610
compelling.

00:03:31.610 --> 00:03:34.170
Incredibly important is to
remember the Dart targets the

00:03:34.170 --> 00:03:35.970
entire modern web.

00:03:35.970 --> 00:03:38.950
We can do this with our Dart
to JavaScript compiler.

00:03:38.950 --> 00:03:41.880
Using this compiler, you can
convert your Dart app into

00:03:41.880 --> 00:03:46.030
modern JavaScript, essentially
ES5 for modern web clients

00:03:46.030 --> 00:03:49.000
running on desktops,
laptops and mobile.

00:03:49.000 --> 00:03:52.180
Dart is built explicitly
for modern web apps.

00:03:52.180 --> 00:03:55.590
These are rich client apps
that are offline-capable.

00:03:55.590 --> 00:03:58.460
These modern web apps strive for
a constant 60 frames per

00:03:58.460 --> 00:04:02.940
second, and are written for
browsers that support ES5+.

00:04:02.940 --> 00:04:04.870
Modern web apps use
the vast number of

00:04:04.870 --> 00:04:07.520
advanced HTML5 features.

00:04:07.520 --> 00:04:09.660
We're not talking about
interactive sites and pages,

00:04:09.660 --> 00:04:13.840
but immersive, fast, modern
apps that users demand.

00:04:13.840 --> 00:04:15.810
It's important to understand
that Dart is still in

00:04:15.810 --> 00:04:17.260
technology preview.

00:04:17.260 --> 00:04:19.790
We launched this project early
to get feedback from the

00:04:19.790 --> 00:04:21.940
community to help
us prioritize.

00:04:21.940 --> 00:04:24.350
We're still building out the
platform and adding features

00:04:24.350 --> 00:04:26.010
and functionality.

00:04:26.010 --> 00:04:28.610
You should expect changes ahead
as we refactor, but part

00:04:28.610 --> 00:04:31.130
of the fun is to be part
of something early.

00:04:31.130 --> 00:04:32.900
Your feedback counts
as we work hard

00:04:32.900 --> 00:04:35.220
towards a stable release.

00:04:35.220 --> 00:04:38.400
We've just looked at a broad
overview of the Dart project.

00:04:38.400 --> 00:04:40.710
Now, let's look at the
motivations and philosophy for

00:04:40.710 --> 00:04:42.380
the project.

00:04:42.380 --> 00:04:44.410
As we know, web development
is good.

00:04:44.410 --> 00:04:47.740
You can experience very fast
iterative development with the

00:04:47.740 --> 00:04:50.220
Reload button acting
as your compiler.

00:04:50.220 --> 00:04:52.960
You can make a small change,
reload, and see the results

00:04:52.960 --> 00:04:54.310
right there.

00:04:54.310 --> 00:04:56.610
The web is platform independent,
with seemingly

00:04:56.610 --> 00:04:58.130
every device with
a screen these

00:04:58.130 --> 00:05:00.310
days using a web browser.

00:05:00.310 --> 00:05:04.060
The runtimes themselves are
getting faster and faster.

00:05:04.060 --> 00:05:06.585
And modern web browsers
are on the rise.

00:05:06.585 --> 00:05:09.010
I like to track how many people
can play Angry Birds in

00:05:09.010 --> 00:05:11.330
their browser, because that
game requires a fast

00:05:11.330 --> 00:05:14.580
JavaScript engine, hardware
accelerated graphics and an

00:05:14.580 --> 00:05:16.310
app cache for offline.

00:05:16.310 --> 00:05:18.790
I checked Global Stat Counter
the other day, so take this

00:05:18.790 --> 00:05:21.970
with a grain of salt, but
something like 70% of desktop,

00:05:21.970 --> 00:05:24.700
laptop, and notebook web users
could play Angry Birds in

00:05:24.700 --> 00:05:25.850
their browser.

00:05:25.850 --> 00:05:28.370
That's hundreds and hundreds and
hundreds and hundreds of

00:05:28.370 --> 00:05:31.650
millions of active users
of modern web browsers.

00:05:31.650 --> 00:05:32.880
Impressive.

00:05:32.880 --> 00:05:35.790
However, we believe it should
be easier to build the apps

00:05:35.790 --> 00:05:37.210
users envision.

00:05:37.210 --> 00:05:39.740
We think it should be easier
to understand the program

00:05:39.740 --> 00:05:40.810
structure of web apps.

00:05:40.810 --> 00:05:43.860
If you think about it, how
do you even know where a

00:05:43.860 --> 00:05:45.590
JavaScript program
even starts?

00:05:45.590 --> 00:05:47.530
Where is the main method?

00:05:47.530 --> 00:05:50.110
We think that it's taken far
too long for decent tool

00:05:50.110 --> 00:05:52.850
support to arrive for
web developers.

00:05:52.850 --> 00:05:55.390
Developers should have access
to tools that help them find

00:05:55.390 --> 00:05:58.970
errors and bugs earlier in
the development cycle.

00:05:58.970 --> 00:06:01.650
We think it should be easier
to integrate code across

00:06:01.650 --> 00:06:04.350
different frameworks, allowing
developers to build more

00:06:04.350 --> 00:06:07.230
complex applications
more easily.

00:06:07.230 --> 00:06:09.810
And we think it should be easier
to work with larger

00:06:09.810 --> 00:06:13.140
teams, where you can't just tell
someone where to find a

00:06:13.140 --> 00:06:16.130
method or what parameters
to pass in.

00:06:16.130 --> 00:06:19.180
We think it should be easier to
meet the new user demands

00:06:19.180 --> 00:06:22.640
of lickable, beautiful, full
functionality applications

00:06:22.640 --> 00:06:25.650
that exploit all the
capabilities of their device.

00:06:25.650 --> 00:06:28.130
We think it should be easier
to sidestep the almost 15

00:06:28.130 --> 00:06:31.920
years of cruft that has built
up in the platform.

00:06:31.920 --> 00:06:34.500
Certainly one of the web's
greatest strengths is that the

00:06:34.500 --> 00:06:37.890
original web page still renders
in today's browsers.

00:06:37.890 --> 00:06:41.010
However, for developers, there
are a lot of dark corners and

00:06:41.010 --> 00:06:43.000
alleyways that we
should avoid.

00:06:43.000 --> 00:06:44.740
There's too many old wives
tales out there

00:06:44.740 --> 00:06:46.380
that no longer apply.

00:06:46.380 --> 00:06:48.770
What would it look like if we
could follow the golden path

00:06:48.770 --> 00:06:51.370
more clearly?

00:06:51.370 --> 00:06:54.430
So innovation is essential for
the growth of the web.

00:06:54.430 --> 00:06:57.110
We think that Dart fills a
vacuum and provides an option

00:06:57.110 --> 00:07:00.630
for non-endemic developers who
want to build for the web, as

00:07:00.630 --> 00:07:02.890
well as existing web developers
that want to scale

00:07:02.890 --> 00:07:05.940
up to bigger, more
complex apps.

00:07:05.940 --> 00:07:08.010
I remember a great quote
that came out around

00:07:08.010 --> 00:07:09.240
the launch of Dart.

00:07:09.240 --> 00:07:12.640
"No one has a monopoly on
innovation." Think about the

00:07:12.640 --> 00:07:16.430
full title of the web, "the open
web platform." That first

00:07:16.430 --> 00:07:19.330
word, "open," means that anyone
can introduce a new

00:07:19.330 --> 00:07:22.030
feature or functionality to the
web, and have a chance to

00:07:22.030 --> 00:07:24.790
prove its technical merit and
show how the web is enhanced

00:07:24.790 --> 00:07:26.930
by this new feature.

00:07:26.930 --> 00:07:29.210
For example, there are features
of the web today that

00:07:29.210 --> 00:07:31.310
no-one can imagine
the web without.

00:07:31.310 --> 00:07:33.840
The canvas was originally
unilaterally added to the web

00:07:33.840 --> 00:07:37.090
by Safari to some outcry, but
today it's enabled some killer

00:07:37.090 --> 00:07:38.490
games and apps.

00:07:38.490 --> 00:07:41.060
With more developers building
more full-featured, awesome

00:07:41.060 --> 00:07:43.700
apps for the modern
web, we all win.

00:07:43.700 --> 00:07:46.580
Let's now look at the
Dart language.

00:07:46.580 --> 00:07:48.330
You can learn Dart quickly.

00:07:48.330 --> 00:07:51.550
Dart as a class-based, single
inheritance, object oriented

00:07:51.550 --> 00:07:53.150
language with interfaces.

00:07:53.150 --> 00:07:55.910
You can yawn right there, which
is exactly the point.

00:07:55.910 --> 00:07:57.520
Dart is familiar.

00:07:57.520 --> 00:08:00.130
It is designed to be
recognizable to an army of

00:08:00.130 --> 00:08:02.030
existing developers out there.

00:08:02.030 --> 00:08:05.090
Everyone from the JavaScript
developer that loves functions

00:08:05.090 --> 00:08:08.060
and hasn't seen a type before
all the way to the Java

00:08:08.060 --> 00:08:10.170
developers that love building
abstract class

00:08:10.170 --> 00:08:12.380
factory class factors.

00:08:12.380 --> 00:08:15.140
Dart is a language for
existing developers.

00:08:15.140 --> 00:08:17.480
We got dinged a bit when Dart
first launched, because some

00:08:17.480 --> 00:08:20.030
people were expecting the
next best Haskell.

00:08:20.030 --> 00:08:22.930
We wanted more than five users,
so we designed Dart to

00:08:22.930 --> 00:08:25.460
be something that you can learn
and be productive with

00:08:25.460 --> 00:08:27.710
with just a short
amount of time.

00:08:27.710 --> 00:08:29.650
Here's an example of
some Dart code.

00:08:29.650 --> 00:08:33.720
We're showing variables, lists,
iterations, final, and

00:08:33.720 --> 00:08:35.850
even string interpolation.

00:08:35.850 --> 00:08:38.280
Even with all these features,
I think most developers can

00:08:38.280 --> 00:08:39.470
grok this code.

00:08:39.470 --> 00:08:42.179
You're seeing the use of a
list literal, the for in

00:08:42.179 --> 00:08:45.490
iteration loop, and one of my
favorite features, string

00:08:45.490 --> 00:08:47.400
interpolation.

00:08:47.400 --> 00:08:50.565
Going a little deeper, here's
an example of Dart functions

00:08:50.565 --> 00:08:52.250
and closures.

00:08:52.250 --> 00:08:54.950
Even though Dart has class
syntax and semantics, you

00:08:54.950 --> 00:08:56.430
don't have to use them.

00:08:56.430 --> 00:08:58.460
If you're comfortable with
functions, you can

00:08:58.460 --> 00:09:00.180
use them with Dart.

00:09:00.180 --> 00:09:04.340
Looking at this code, the type
dev here sets up a function

00:09:04.340 --> 00:09:07.370
alias, allowing our tools to
better support when we pass

00:09:07.370 --> 00:09:08.555
around functions.

00:09:08.555 --> 00:09:11.520
Anytime we can help our tools,
the more chances that we can

00:09:11.520 --> 00:09:15.090
be warned about potential
problems and bugs early.

00:09:15.090 --> 00:09:17.680
The make adder function is a
top level function which

00:09:17.680 --> 00:09:21.520
creates a closure around
N and returns a

00:09:21.520 --> 00:09:25.020
function of type pattern.

00:09:25.020 --> 00:09:28.320
The main method creates a new
adder function that adds two

00:09:28.320 --> 00:09:29.840
to a number.

00:09:29.840 --> 00:09:32.930
Dart's functions and closures
make it easy to compose

00:09:32.930 --> 00:09:35.160
programs without classes.

00:09:35.160 --> 00:09:37.170
Even though you don't have
to use classes, there are

00:09:37.170 --> 00:09:40.060
situations where you're really
glad you have them.

00:09:40.060 --> 00:09:43.510
For example, today, it's very
difficult to share code across

00:09:43.510 --> 00:09:45.190
JavaScript frameworks.

00:09:45.190 --> 00:09:47.470
It's clear that many developers
think in classes

00:09:47.470 --> 00:09:50.080
and want to work with classes,
and most of the major

00:09:50.080 --> 00:09:54.620
JavaScript libraries provide
a way to emulate classes.

00:09:54.620 --> 00:09:57.690
Here, you are looking at four
different ways to make a class

00:09:57.690 --> 00:10:05.270
with MoodTools, Prototype,
Dojo, and ExJS.

00:10:05.270 --> 00:10:08.050
A class from one library cannot
be shared with a class

00:10:08.050 --> 00:10:09.530
from another library.

00:10:09.530 --> 00:10:12.400
This limits the ability to
compose systems with multiple

00:10:12.400 --> 00:10:14.500
libraries and frameworks.

00:10:14.500 --> 00:10:17.410
In Dart, you can share and
structure code across

00:10:17.410 --> 00:10:19.960
libraries and frameworks thanks
to class and interface

00:10:19.960 --> 00:10:22.550
semantics built right
into the language.

00:10:22.550 --> 00:10:26.280
Here, you are looking at
a simple point class.

00:10:26.280 --> 00:10:30.480
A favorite feature is the
constructor arguments sugar.

00:10:30.480 --> 00:10:36.030
The this.x and this.y
constructor arguments desugars

00:10:36.030 --> 00:10:40.380
into this.x equals x, and this.y
equals y, a common

00:10:40.380 --> 00:10:43.300
pattern in most constructors.

00:10:43.300 --> 00:10:47.060
On the right is an example of
a panel class from framework

00:10:47.060 --> 00:10:51.720
A, and a menu class from
framework B that cleanly

00:10:51.720 --> 00:10:55.350
extends the panel from framework
A. This is an

00:10:55.350 --> 00:10:58.590
example of two separate
libraries sharing code and

00:10:58.590 --> 00:11:00.300
building on one another.

00:11:00.300 --> 00:11:02.680
This leads to more code reuse.

00:11:02.680 --> 00:11:06.650
In Dart, you can reason about
unfamiliar code more easily.

00:11:06.650 --> 00:11:11.240
For example, the JavaScript
example at the top reads, the

00:11:11.240 --> 00:11:15.480
calculate method takes an
origin, an offset, an

00:11:15.480 --> 00:11:19.260
estimate, and I don't even
know what it returns.

00:11:19.260 --> 00:11:20.410
What is an origin?

00:11:20.410 --> 00:11:21.760
What is an offset?

00:11:21.760 --> 00:11:23.460
What does this return?

00:11:23.460 --> 00:11:27.320
Given this function signature,
you know almost nothing.

00:11:27.320 --> 00:11:29.930
Of course, you can pray the
developer left comments that

00:11:29.930 --> 00:11:33.650
annotate all the types of the
parameters and return value.

00:11:33.650 --> 00:11:35.430
If you're lucky, they did.

00:11:35.430 --> 00:11:38.830
But then your tools don't know
how to parse written text.

00:11:38.830 --> 00:11:41.810
Worst case, you're reading the
function body, and if you're

00:11:41.810 --> 00:11:44.210
reading the function body,
you've broken encapsulation,

00:11:44.210 --> 00:11:45.970
and you're in a bad spot.

00:11:45.970 --> 00:11:48.875
You really want to know what
the method is, what you can

00:11:48.875 --> 00:11:51.750
pass to it, and what
it can return.

00:11:51.750 --> 00:11:54.620
With Dart's optional type
annotations, you can add

00:11:54.620 --> 00:11:57.870
inline types to better convey
your intention to fellow

00:11:57.870 --> 00:12:02.490
developers, and give the tools
to help you detect problems

00:12:02.490 --> 00:12:04.150
and bugs early.

00:12:04.150 --> 00:12:07.120
Optional static type annotations
is a long term,

00:12:07.120 --> 00:12:10.270
but it simply means you can use
static types when you want

00:12:10.270 --> 00:12:13.030
to, and leave them out
when you don't.

00:12:13.030 --> 00:12:15.870
We created a system that helps
you without getting in your

00:12:15.870 --> 00:12:19.020
way, a system that doesn't
create an overly burdensome,

00:12:19.020 --> 00:12:20.850
ceremonial type checker.

00:12:20.850 --> 00:12:23.580
Dart's types create an innocent
until proven guilty

00:12:23.580 --> 00:12:25.500
programing experience.

00:12:25.500 --> 00:12:28.730
Dart supports duck typing, but
there are plenty of cases

00:12:28.730 --> 00:12:30.820
where you want inline
documentation for the

00:12:30.820 --> 00:12:33.970
consumers of your API and
tool-based checks.

00:12:33.970 --> 00:12:37.290
We'll see how optional type
annotations help us scale our

00:12:37.290 --> 00:12:40.660
code from small ideas
to large apps.

00:12:40.660 --> 00:12:42.170
Let's look at an example now.

00:12:42.170 --> 00:12:45.010
To the Dart Editor!

00:12:45.010 --> 00:12:46.810
This is the standalone
Dart Editor.

00:12:46.810 --> 00:12:48.930
It ships with the
Dart project.

00:12:48.930 --> 00:12:51.930
Let's use it to write some
simple Dart code.

00:12:51.930 --> 00:12:54.640
Let's say that you want to write
a game, and you want two

00:12:54.640 --> 00:12:56.370
figures to battle.

00:12:56.370 --> 00:12:58.840
Let's see how that might look.

00:12:58.840 --> 00:13:02.690
First, we're going to write a
main method, and let's say

00:13:02.690 --> 00:13:07.210
that we want those two figures
to equip for battle, so equip

00:13:07.210 --> 00:13:08.980
for battle.

00:13:08.980 --> 00:13:11.760
And I guess they're warriors.

00:13:11.760 --> 00:13:13.580
And we want to do
warrior.equip.

00:13:17.290 --> 00:13:20.730
And let's say we're going
to give him a new sword.

00:13:20.730 --> 00:13:22.740
Cool.

00:13:22.740 --> 00:13:23.815
So I save my project.

00:13:23.815 --> 00:13:26.610
And immediately, my editor gives
me real-time feedback.

00:13:26.610 --> 00:13:29.190
It says, can't find sword.

00:13:29.190 --> 00:13:30.370
Doesn't know what a sword is.

00:13:30.370 --> 00:13:30.790
Well, that's great.

00:13:30.790 --> 00:13:33.060
I know before I even run
the program what

00:13:33.060 --> 00:13:35.570
else I need to do.

00:13:35.570 --> 00:13:36.920
So let's create a sword class.

00:13:39.740 --> 00:13:40.730
Very cool.

00:13:40.730 --> 00:13:43.940
So now in our main method, let's
create these warriors.

00:13:43.940 --> 00:13:46.280
Well, it's pretty fun to have
pirates and ninjas battle, so

00:13:46.280 --> 00:13:48.210
let's make a pirate first.

00:13:48.210 --> 00:13:49.460
I'm going to say
equipforbattle(new Pirate()).

00:13:57.370 --> 00:14:00.150
And sure enough, my editor again
tells me, I don't know

00:14:00.150 --> 00:14:00.990
what a pirate is.

00:14:00.990 --> 00:14:04.600
Let's go ahead and make him
happy and create a pirate.

00:14:04.600 --> 00:14:06.170
All right.

00:14:06.170 --> 00:14:09.860
OK, so let's just run
this program.

00:14:09.860 --> 00:14:14.280
Right away, the runtime says,
can't find method equip on

00:14:14.280 --> 00:14:16.230
instance of pirate.

00:14:16.230 --> 00:14:17.340
Well, he's right.

00:14:17.340 --> 00:14:19.730
I look, the pirate doesn't
have equip.

00:14:19.730 --> 00:14:21.650
If only my tools could
have told me this.

00:14:21.650 --> 00:14:25.830
But let's go ahead, and let's
make the program happy.

00:14:25.830 --> 00:14:33.470
We'll say it takes a weapon and
we'll say "arg." When I

00:14:33.470 --> 00:14:35.720
run the program again,
everything works and "arg" is

00:14:35.720 --> 00:14:39.000
printed out, exactly
as we'd expected.

00:14:39.000 --> 00:14:41.200
But Dart lets us do better.

00:14:41.200 --> 00:14:44.630
And now that we have a little
bit more comfort that we have

00:14:44.630 --> 00:14:47.160
these things called warriors,
and they get equipped with

00:14:47.160 --> 00:14:50.240
these things called weapons, we
can begin to solidify the

00:14:50.240 --> 00:14:51.700
design a little bit.

00:14:51.700 --> 00:14:54.170
Now, we need to things
to battle, so

00:14:54.170 --> 00:14:59.750
let's create a ninja.

00:14:59.750 --> 00:15:01.470
OK.

00:15:01.470 --> 00:15:04.486
And I'm going to be a little
bit smarter this time.

00:15:11.330 --> 00:15:18.000
If you are reading this,
you're already dead.

00:15:18.000 --> 00:15:18.350
OK.

00:15:18.350 --> 00:15:21.740
But I want my tools to warn me
before I run the program if

00:15:21.740 --> 00:15:23.540
there's any potential problems.
And this is where

00:15:23.540 --> 00:15:28.060
the optional static type
annotations come into play.

00:15:28.060 --> 00:15:30.450
I'm more comfortable now that I
have pirates and ninjas, and

00:15:30.450 --> 00:15:31.480
they're both warriors.

00:15:31.480 --> 00:15:34.850
So let's tell the program
that they're warriors.

00:15:34.850 --> 00:15:36.100
We'll create an interface.

00:15:39.620 --> 00:15:41.541
And we'll give it a weapon.

00:15:44.160 --> 00:15:47.880
Interfaces define just the
contract for a class.

00:15:47.880 --> 00:15:50.770
And we'll say a pirate
is a warrior.

00:15:50.770 --> 00:15:54.900
We'll say that a ninja
is a warrior.

00:15:58.430 --> 00:16:01.340
And finally, we're going to
tell equip for battle to

00:16:01.340 --> 00:16:06.730
expect that a warrior is
actually a warrior.

00:16:06.730 --> 00:16:12.240
And now, if I remove some code
here, my program can tell me a

00:16:12.240 --> 00:16:17.020
warning before I even run that a
ninja can't really be passed

00:16:17.020 --> 00:16:19.950
in here, because it's missing
some methods that are going to

00:16:19.950 --> 00:16:22.240
be called inside
equipForBattle.

00:16:22.240 --> 00:16:25.360
This is great, immediate,
instant feedback that my

00:16:25.360 --> 00:16:28.020
system can tell me before
I even run.

00:16:28.020 --> 00:16:29.922
So I add that code back.

00:16:29.922 --> 00:16:31.370
The program's very happy.

00:16:31.370 --> 00:16:34.800
Those warnings go away.

00:16:34.800 --> 00:16:36.640
And certainly, "if you're
reading this, you're already

00:16:36.640 --> 00:16:38.250
dead" and "arg" are
printed out.

00:16:38.250 --> 00:16:40.600
That's great.

00:16:40.600 --> 00:16:43.510
So we've shown now how we can
scale from a system that

00:16:43.510 --> 00:16:46.320
doesn't use optional static
type annotations up to

00:16:46.320 --> 00:16:48.850
actually using the type
annotations and how they give

00:16:48.850 --> 00:16:51.560
us these early warnings.

00:16:51.560 --> 00:16:53.750
This is great, but then you
might be thinking, doesn't

00:16:53.750 --> 00:16:56.410
this lock me into some
heavyweight design now?

00:16:56.410 --> 00:16:58.260
How do I move fast?

00:16:58.260 --> 00:16:58.930
How do I iterate?

00:16:58.930 --> 00:17:01.110
How do I develop further?

00:17:01.110 --> 00:17:03.770
Well again, you can scale up and
you can scale back down.

00:17:03.770 --> 00:17:06.020
So let's just use one
more example here.

00:17:06.020 --> 00:17:08.250
Let's say that I want to
introduce the wildcard to my

00:17:08.250 --> 00:17:10.130
battle and introduce a zombie.

00:17:12.660 --> 00:17:13.480
OK.

00:17:13.480 --> 00:17:19.670
So if I go ahead and add a
zombie class here, and let's

00:17:19.670 --> 00:17:20.920
say he takes a weapon.

00:17:24.240 --> 00:17:32.170
And I'll print, silly, a
zombie's weapon is his

00:17:32.170 --> 00:17:38.360
insatiable lust for
human flesh.

00:17:38.360 --> 00:17:40.890
Now, my program is going to run,
but it's giving me these

00:17:40.890 --> 00:17:42.390
warnings here.

00:17:42.390 --> 00:17:44.680
And I'm not certain that
a zombie is a warrior.

00:17:44.680 --> 00:17:49.220
A warrior has a code, and
zombies have no code.

00:17:49.220 --> 00:17:50.390
I want my program
to run anyway.

00:17:50.390 --> 00:17:54.220
I don't want to have to somehow
jam in a class into

00:17:54.220 --> 00:17:58.050
some particular hierarchy just
to satisfy the system.

00:17:58.050 --> 00:18:01.750
And so I can pull the type
annotations back off, thus

00:18:01.750 --> 00:18:02.910
making the program more happy.

00:18:02.910 --> 00:18:04.400
And I can run here.

00:18:04.400 --> 00:18:06.220
The program runs and terminates
correctly.

00:18:06.220 --> 00:18:09.830
You can see that a zombie
is equipped.

00:18:09.830 --> 00:18:13.200
But you've see how we can start
without static type

00:18:13.200 --> 00:18:16.310
annotations, create
a program as we're

00:18:16.310 --> 00:18:17.960
flushing out a design.

00:18:17.960 --> 00:18:20.200
As we get more comfortable with
it, we can add the type

00:18:20.200 --> 00:18:23.240
annotations, and the system
gives us that early feedback

00:18:23.240 --> 00:18:24.500
and the early warnings.

00:18:24.500 --> 00:18:26.610
And then later on if you're
doing some refactorings, or

00:18:26.610 --> 00:18:29.430
you need to manipulate the
program structure, you can

00:18:29.430 --> 00:18:33.680
pull some of the type
annotations off, reducing the

00:18:33.680 --> 00:18:35.090
amount of warnings, even
though you know it's

00:18:35.090 --> 00:18:35.980
all going to run.

00:18:35.980 --> 00:18:37.860
And then later, when you get
more comfortable, you can add

00:18:37.860 --> 00:18:39.600
the type annotations back on.

00:18:39.600 --> 00:18:43.020
That's that scalability story
that we talked about.

00:18:43.020 --> 00:18:45.360
Now, let's turn our attention
to the JavaScript puzzler

00:18:45.360 --> 00:18:46.960
section of the talk.

00:18:46.960 --> 00:18:50.580
In Dart, you can rely on
this not changing.

00:18:50.580 --> 00:18:53.590
Thanks to Dart's lexical scope,
we know exactly which

00:18:53.590 --> 00:18:57.320
method will be called, given
only the program structure.

00:18:57.320 --> 00:19:00.910
We no longer have to capture
this and assign it to that.

00:19:00.910 --> 00:19:05.790
In this example here, when a
button is clicked, the cool

00:19:05.790 --> 00:19:10.340
method is called on this for
the instance of awesome.

00:19:10.340 --> 00:19:13.030
This is the behavior that
developers expect from their

00:19:13.030 --> 00:19:14.980
programming language.

00:19:14.980 --> 00:19:17.880
In Dart, you can expect
sane for loops.

00:19:17.880 --> 00:19:20.990
If you know JavaScript, you
might know what happens if you

00:19:20.990 --> 00:19:22.690
run this code.

00:19:22.690 --> 00:19:26.000
Here we have a for loop
iterating over values of i,

00:19:26.000 --> 00:19:30.120
and giving them to closures
to be called later.

00:19:30.120 --> 00:19:32.750
When the code calls the
callbacks, JavaScript will

00:19:32.750 --> 00:19:36.330
print two and two, which
is quite surprising.

00:19:36.330 --> 00:19:39.340
Dart's for loops have sane
semantics for capturing values

00:19:39.340 --> 00:19:41.390
inside of closures.

00:19:41.390 --> 00:19:46.160
In Dart, the program outputs
zero and one, which is exactly

00:19:46.160 --> 00:19:47.410
what you would imagine.

00:19:47.410 --> 00:19:50.630
Creating readable method
calls is easy in Dart.

00:19:50.630 --> 00:19:53.300
You've seen those methods that
take one or more Booleans at

00:19:53.300 --> 00:19:56.340
the end, resulting in
hard to grok code.

00:19:56.340 --> 00:19:58.360
Try reading flipped flags.

00:19:58.360 --> 00:20:00.080
True, false, true?

00:20:00.080 --> 00:20:00.790
True what?

00:20:00.790 --> 00:20:02.380
False what?

00:20:02.380 --> 00:20:05.420
Thanks to Dart's named
parameters, you can say what

00:20:05.420 --> 00:20:07.810
you mean more easily.

00:20:07.810 --> 00:20:11.740
On is true, up is false,
hidden is true.

00:20:11.740 --> 00:20:12.852
Got it.

00:20:12.852 --> 00:20:16.140
A benefit of named parameters
is that they become optional

00:20:16.140 --> 00:20:19.710
if you give them a
default value.

00:20:19.710 --> 00:20:22.850
Here, hidden is default to
false, which means you can

00:20:22.850 --> 00:20:26.410
leave it out, like the
last example shows.

00:20:26.410 --> 00:20:29.130
A theme here is to make it
easier to write code

00:20:29.130 --> 00:20:32.450
understandable by humans and
machines, plus integrating

00:20:32.450 --> 00:20:34.780
more code into more
complex apps and

00:20:34.780 --> 00:20:36.690
catching issues early.

00:20:36.690 --> 00:20:38.160
Web developers know
that you never

00:20:38.160 --> 00:20:40.290
block the main UI thread.

00:20:40.290 --> 00:20:42.380
This example is something
you never do.

00:20:42.380 --> 00:20:45.080
You never put lengthy or
costly methods back

00:20:45.080 --> 00:20:46.870
to back like this.

00:20:46.870 --> 00:20:51.570
The common way to split up the
work is to use callbacks that

00:20:51.570 --> 00:20:54.390
trigger the next step
in the algorithm.

00:20:54.390 --> 00:20:56.920
These callbacks fire when the
event loop is ready, thus

00:20:56.920 --> 00:21:00.020
giving the UI thread a chance
to do other work.

00:21:00.020 --> 00:21:03.240
However, as you can see, these
callbacks get nasty and

00:21:03.240 --> 00:21:06.240
nested, making it
hard to read.

00:21:06.240 --> 00:21:09.900
Deeply nested and async code
becomes hard to follow.

00:21:09.900 --> 00:21:12.190
Luckily, in Dart, you
can use a future to

00:21:12.190 --> 00:21:14.120
encapsulate this pattern.

00:21:14.120 --> 00:21:17.740
A future is a promise for a
value to be provided later.

00:21:17.740 --> 00:21:21.220
If each of the costly methods
return a future as a token,

00:21:21.220 --> 00:21:24.360
you can chain the methods,
as shown here.

00:21:24.360 --> 00:21:27.280
These methods now line up and
become easier to read, yet

00:21:27.280 --> 00:21:29.660
still run asynchronously.

00:21:29.660 --> 00:21:32.720
A future is returned
immediately, and when it has a

00:21:32.720 --> 00:21:34.950
value, its chain method
is called.

00:21:34.950 --> 00:21:38.220
Or then is called when the
last future has a value.

00:21:38.220 --> 00:21:40.850
The future API is beginning to
show up in more and more Dart

00:21:40.850 --> 00:21:42.120
code as the preferred

00:21:42.120 --> 00:21:44.540
alternative to one-shot callbacks.

00:21:44.540 --> 00:21:47.100
One of the core tenets of Dart
is that it must compile to

00:21:47.100 --> 00:21:48.300
JavaScript.

00:21:48.300 --> 00:21:50.620
As you know, JavaScript
is single threaded.

00:21:50.620 --> 00:21:52.650
But as you also know,
devices are shipping

00:21:52.650 --> 00:21:54.565
with multicore machines.

00:21:54.565 --> 00:21:57.450
Concurrency is great, but
shared memory threads is

00:21:57.450 --> 00:21:59.840
error-prone and hard
to optimize.

00:21:59.840 --> 00:22:02.700
Dart programs can take advantage
of multicore through

00:22:02.700 --> 00:22:05.310
a system called isolates.

00:22:05.310 --> 00:22:08.060
An isolate is an isolated memory
heap that can run in a

00:22:08.060 --> 00:22:10.140
separate thread or process.

00:22:10.140 --> 00:22:13.090
Because there is no shared
state, you communicate between

00:22:13.090 --> 00:22:15.760
isolates by passing messages.

00:22:15.760 --> 00:22:17.280
Here is an example
of spawning an

00:22:17.280 --> 00:22:19.890
isolate for an echo function.

00:22:19.890 --> 00:22:24.320
A send port is returned, which
is used to send "hello from

00:22:24.320 --> 00:22:27.330
Maine" and wait for a reply.

00:22:27.330 --> 00:22:29.070
The use of then is a
signal that we're

00:22:29.070 --> 00:22:31.580
using the future library.

00:22:31.580 --> 00:22:34.920
You can see the echo function
waits for messages on its

00:22:34.920 --> 00:22:39.140
receive port, and replies to
those messages are sent with

00:22:39.140 --> 00:22:41.030
the send function.

00:22:41.030 --> 00:22:43.780
Even though Dart is a familiar
language, we took this rare

00:22:43.780 --> 00:22:47.090
opportunity when designing a
new language to fix a few

00:22:47.090 --> 00:22:48.730
things along the way.

00:22:48.730 --> 00:22:51.610
Isolates simplifies concurrent
programming.

00:22:51.610 --> 00:22:54.640
They were inspired by Erlang's
processes model for safer,

00:22:54.640 --> 00:22:58.130
easier to reason about
parallel programming.

00:22:58.130 --> 00:23:01.540
The Dart VM natively supports
isolates, and isolates compile

00:23:01.540 --> 00:23:05.040
to Web workers for HTML5 apps.

00:23:05.040 --> 00:23:07.690
We saw this example when we
played with optional static

00:23:07.690 --> 00:23:09.160
type annotations.

00:23:09.160 --> 00:23:11.630
The important point to remember
is that the type

00:23:11.630 --> 00:23:14.130
annotations aren't there
to get in your way .

00:23:14.130 --> 00:23:17.440
You can still write dynamic
duck typed code.

00:23:17.440 --> 00:23:20.260
This is especially useful when
you're experimenting or

00:23:20.260 --> 00:23:21.520
testing ideas.

00:23:21.520 --> 00:23:24.920
You can get even more dynamic-er
with Dart thanks to

00:23:24.920 --> 00:23:26.640
noSuchMethod.

00:23:26.640 --> 00:23:29.610
If a method isn't resolved on
an object, you can implement

00:23:29.610 --> 00:23:32.610
noSuchMethod and dynamically
handle it.

00:23:32.610 --> 00:23:38.150
For example, this code exposes
any Json map as a Dart object,

00:23:38.150 --> 00:23:42.220
and uses noSuchMethod to handle
the properties of the

00:23:42.220 --> 00:23:45.280
Json map as object methods.

00:23:45.280 --> 00:23:48.480
Dart is very much a dynamic
scripting language.

00:23:48.480 --> 00:23:50.580
We looked at a lot of cool
language features and

00:23:50.580 --> 00:23:52.530
improvements over JavaScript.

00:23:52.530 --> 00:23:54.700
Let's see how you can
run Dart code.

00:23:54.700 --> 00:23:57.810
First up, running Dart
on the server.

00:23:57.810 --> 00:24:00.840
Dart isn't just for modern web
apps running on the client.

00:24:00.840 --> 00:24:04.370
Dart can also run via its
standalone VM on the command

00:24:04.370 --> 00:24:06.680
line for scripts and servers.

00:24:06.680 --> 00:24:09.740
This example code serves static
files via the built-in

00:24:09.740 --> 00:24:13.100
HTTP server library.

00:24:13.100 --> 00:24:17.820
You can also see uses of files
and directories, critical

00:24:17.820 --> 00:24:20.080
functionality for command
line apps.

00:24:20.080 --> 00:24:22.350
The Dart VM supports a lot
of functionality for your

00:24:22.350 --> 00:24:26.420
servers, such as files,
directories, sockets, web

00:24:26.420 --> 00:24:30.040
servers, HTTP clients,
and even web

00:24:30.040 --> 00:24:32.270
socket servers and clients.

00:24:32.270 --> 00:24:35.130
We believe in a vision of
running Dart code on the

00:24:35.130 --> 00:24:37.370
client and the server.

00:24:37.370 --> 00:24:41.150
Let's see a demo of
this right now.

00:24:41.150 --> 00:24:42.700
We're back in the Dart Editor.

00:24:42.700 --> 00:24:45.130
Let's look at a simple
Dart server.

00:24:45.130 --> 00:24:48.250
This looks familiar to decode
on the slide previously.

00:24:48.250 --> 00:24:51.500
Let's make a small change so we
know that it's all working.

00:24:51.500 --> 00:24:55.520
Hello:Intertubes.

00:24:55.520 --> 00:24:57.060
Save the program.

00:24:57.060 --> 00:24:58.770
Our editor is happy.

00:24:58.770 --> 00:25:00.110
Let's go ahead and commit
the change.

00:25:05.030 --> 00:25:06.395
And now, let's send it
up to the cloud.

00:25:09.860 --> 00:25:11.920
This command is actually pushing
the Dart application

00:25:11.920 --> 00:25:14.950
you just saw in the editor
up to Heroku's cloud.

00:25:14.950 --> 00:25:18.720
Heroku lets you run arbitrary
applications in the cloud.

00:25:18.720 --> 00:25:21.350
We've wired in the Dart Virtual
Machine as one of

00:25:21.350 --> 00:25:22.990
those runtimes.

00:25:22.990 --> 00:25:25.290
So you see here the
deployment process

00:25:25.290 --> 00:25:27.630
happening in real time.

00:25:27.630 --> 00:25:29.650
Let's grab the URL from
our new Dart app.

00:25:32.210 --> 00:25:33.710
Zoom in.

00:25:33.710 --> 00:25:36.490
Hello:Intertubes, sure enough
is printed out.

00:25:36.490 --> 00:25:39.010
What you're seeing here is
debug outputs from a live

00:25:39.010 --> 00:25:42.320
running Dart Virtual Machine
program in the cloud.

00:25:42.320 --> 00:25:45.580
We deployed it in real time, and
this is running right now.

00:25:45.580 --> 00:25:47.750
Of course, Dart is first
and foremost a

00:25:47.750 --> 00:25:49.330
web programming language.

00:25:49.330 --> 00:25:51.890
Let's look at Dart running
on the client.

00:25:51.890 --> 00:25:54.730
Every web developer is familiar
with the DOM.

00:25:54.730 --> 00:25:57.880
Unfortunately, the DOM is a
language agnostic interface,

00:25:57.880 --> 00:26:00.030
and never feels natural to
whatever language you're

00:26:00.030 --> 00:26:01.470
working in.

00:26:01.470 --> 00:26:04.080
JQuery is popular in part
because it did a great job

00:26:04.080 --> 00:26:06.930
smoothing over the DOM and
making it feel natural to

00:26:06.930 --> 00:26:08.860
JavaScript developers.

00:26:08.860 --> 00:26:11.390
Our fresh approach to web
programming means we can take

00:26:11.390 --> 00:26:14.250
a fresh approach to interfacing
with the browser.

00:26:14.250 --> 00:26:18.490
We've created an HTML library
to make programming the

00:26:18.490 --> 00:26:20.790
browser feel like Dart code.

00:26:20.790 --> 00:26:24.680
This example shows some of the
HTML library's features.

00:26:24.680 --> 00:26:27.990
Creating a new element is simple
thanks to the use of

00:26:27.990 --> 00:26:30.350
element.tag named
constructors.

00:26:30.350 --> 00:26:34.410
And elements classes are just a
Dart list. So you can add a

00:26:34.410 --> 00:26:37.050
new class just like you can add
anything else to any Dart

00:26:37.050 --> 00:26:39.190
list.

00:26:39.190 --> 00:26:41.520
The event handler is one
of my favorites.

00:26:41.520 --> 00:26:46.570
On dot click dot ad reads
clearly and uses an anonymous

00:26:46.570 --> 00:26:49.500
function to handle
the click event.

00:26:49.500 --> 00:26:53.600
Finally, we easily add the
button to the body's elements,

00:26:53.600 --> 00:26:57.400
because elements is just another
Dart collection.

00:26:57.400 --> 00:27:00.710
The compiler targets ES5
JavaScript, essentially modern

00:27:00.710 --> 00:27:01.920
web browsers.

00:27:01.920 --> 00:27:04.600
Work has begun to perform tree
shaking and dead code

00:27:04.600 --> 00:27:08.030
elimination, helping apps
load and start quickly.

00:27:08.030 --> 00:27:10.260
The compiler itself is
written in Dart.

00:27:10.260 --> 00:27:12.540
In fact, you can use the
compiler to compile the

00:27:12.540 --> 00:27:14.830
compiler to JavaScript.

00:27:14.830 --> 00:27:17.150
We're working hard on generating
smaller and smaller

00:27:17.150 --> 00:27:20.790
JavaScript and continued
performance improvements.

00:27:20.790 --> 00:27:22.440
We've seen how to
run Dart code.

00:27:22.440 --> 00:27:25.070
Now, let's look at editing
and debugging Dart code.

00:27:25.070 --> 00:27:27.850
The Dart project ships Dartium,
our build of Chromium

00:27:27.850 --> 00:27:29.730
that embeds a Dart VM.

00:27:29.730 --> 00:27:32.320
Dartium is great for fast
iterations, enabling you to

00:27:32.320 --> 00:27:35.770
write Dart code, make edits, and
simply hit Reload to see

00:27:35.770 --> 00:27:37.140
the changes.

00:27:37.140 --> 00:27:40.330
The Dart Editor is wired into
Dartium for a nice debugging

00:27:40.330 --> 00:27:43.240
experience, and Dartium has
begun integrating the dev

00:27:43.240 --> 00:27:44.330
tools for Dart.

00:27:44.330 --> 00:27:46.070
Let's see a demo now.

00:27:46.070 --> 00:27:49.050
Here's the same code that you
just saw on the slide.

00:27:49.050 --> 00:27:52.020
Now, I want to show you this
running in two different ways.

00:27:52.020 --> 00:27:54.840
First, when we run it natively,
it'll fire up what

00:27:54.840 --> 00:27:58.130
we call Dartium.

00:27:58.130 --> 00:28:00.090
Dartium is Chromium
with the Dart

00:28:00.090 --> 00:28:03.050
Virtual Machine in action.

00:28:03.050 --> 00:28:05.280
Sure enough a button appears.

00:28:05.280 --> 00:28:07.270
When we click it, it
tells us clicked.

00:28:07.270 --> 00:28:08.730
Pretty impressive.

00:28:08.730 --> 00:28:11.730
But the real power is the
integration between Dartium

00:28:11.730 --> 00:28:13.340
and the editor.

00:28:13.340 --> 00:28:18.180
For instance, let's set
a debug break point.

00:28:18.180 --> 00:28:22.810
We run the program again, go
back to the editor, and you

00:28:22.810 --> 00:28:24.890
can see the program has stopped
right where we set the

00:28:24.890 --> 00:28:26.760
break point.

00:28:26.760 --> 00:28:28.620
We continue running
the program, the

00:28:28.620 --> 00:28:30.590
button is indeed rendered.

00:28:30.590 --> 00:28:31.630
So that's pretty cool.

00:28:31.630 --> 00:28:32.900
You can debug in the editor.

00:28:32.900 --> 00:28:34.760
You can also debug with
the dev tools

00:28:34.760 --> 00:28:36.970
integration in Dartium.

00:28:36.970 --> 00:28:42.960
So here, let's load up the
source, just to show you that

00:28:42.960 --> 00:28:47.280
the programmer running is indeed
the actual Dart code.

00:28:47.280 --> 00:28:50.180
Let's set the same breakpoint in
the dev tools and reload in

00:28:50.180 --> 00:28:50.670
the browser.

00:28:50.670 --> 00:28:52.840
And sure enough, it stops
exactly where we

00:28:52.840 --> 00:28:54.890
set the break point.

00:28:54.890 --> 00:28:57.380
More functionality will be added
to the dev tools over

00:28:57.380 --> 00:29:00.080
time, give you full debugging
and program manipulation

00:29:00.080 --> 00:29:00.786
capabilities.

00:29:00.786 --> 00:29:02.730
But let's dive deeper.

00:29:02.730 --> 00:29:05.870
For instance, in the editor, you
can do symbol refactoring,

00:29:05.870 --> 00:29:07.260
like renaming.

00:29:07.260 --> 00:29:09.180
Let's rename this button.

00:29:09.180 --> 00:29:10.530
Right-clicking on the button.

00:29:13.890 --> 00:29:17.780
Let's choose Clickable, and
sure enough, the editor,

00:29:17.780 --> 00:29:21.150
thanks to the optional static
type annotations, confined all

00:29:21.150 --> 00:29:24.110
uses of the button variable
and renames

00:29:24.110 --> 00:29:25.790
everything to Clickable.

00:29:25.790 --> 00:29:28.420
Finally, I want to show you
how you can compile this

00:29:28.420 --> 00:29:30.340
simple program into JavaScript
and run it

00:29:30.340 --> 00:29:31.940
on all modern browsers.

00:29:31.940 --> 00:29:35.250
Using the editor, we can go to
Generate JavaScript from the

00:29:35.250 --> 00:29:37.740
Tools menu.

00:29:37.740 --> 00:29:41.220
This will now run our
Dart to JS compiler.

00:29:41.220 --> 00:29:43.850
Now, we can take the URL
running in Dartium.

00:29:43.850 --> 00:29:48.710
We'll open up another
editor here.

00:29:48.710 --> 00:29:50.090
Here's Firefox.

00:29:50.090 --> 00:29:53.520
We paste in the URL.

00:29:53.520 --> 00:29:57.430
Sure enough, the same
application loads up and runs.

00:29:57.430 --> 00:30:01.090
This is all thanks to a
bootstrap script that we

00:30:01.090 --> 00:30:05.250
include with each
Dart project.

00:30:05.250 --> 00:30:10.270
The script here, you can see is
both the Dart application

00:30:10.270 --> 00:30:12.690
that is the native Dart code
in the script tag.

00:30:12.690 --> 00:30:17.340
But right below that is our
Dart.js bootstrap script.

00:30:17.340 --> 00:30:19.320
This will detect if your
browser runs the

00:30:19.320 --> 00:30:20.640
Dart Virtual Machine.

00:30:20.640 --> 00:30:24.280
If not, it will replace the
above Dart script with the

00:30:24.280 --> 00:30:27.860
equivalent compiled to
JavaScript version for

00:30:27.860 --> 00:30:31.070
browsers that don't have the
Dart VM embedded in them.

00:30:31.070 --> 00:30:34.040
So you've seen how using the
editor and our tools, you can

00:30:34.040 --> 00:30:38.010
run a Dart program in Dartium
and any modern web browser.

00:30:38.010 --> 00:30:40.590
As you just saw, the Dart editor
supports more than just

00:30:40.590 --> 00:30:42.130
editing text.

00:30:42.130 --> 00:30:44.870
You can jump to definition,
perform simple refactorings,

00:30:44.870 --> 00:30:47.440
debug code, and compile
to JavaScript.

00:30:47.440 --> 00:30:50.260
The last tool we'll look at
today is Dart's brand new

00:30:50.260 --> 00:30:53.140
package manager, affectionately
called Pub.

00:30:53.140 --> 00:30:55.850
With Pub you can install third
party packages into your

00:30:55.850 --> 00:30:57.310
application.

00:30:57.310 --> 00:31:00.580
Pub makes it easy to manage
application dependencies.

00:31:00.580 --> 00:31:03.460
Today, Pub will install packages
straight from Git,

00:31:03.460 --> 00:31:07.660
but in the future we will set
up pub.dartlang.org to host,

00:31:07.660 --> 00:31:10.110
discover, and install
packaged snapshots.

00:31:10.110 --> 00:31:11.340
Using Pub is simple.

00:31:11.340 --> 00:31:15.120
Step one, declare your
dependencies in a simple yaml

00:31:15.120 --> 00:31:17.480
Pub spec file.

00:31:17.480 --> 00:31:21.320
Step two, run Pub Install to
download and install the

00:31:21.320 --> 00:31:24.270
libraries into your
application.

00:31:24.270 --> 00:31:28.150
Step three, import the new
libraries with a new package

00:31:28.150 --> 00:31:29.790
colon prefix.

00:31:29.790 --> 00:31:31.460
Finally, deploy the kittens!

00:31:31.460 --> 00:31:32.540
Let's go to the demo.

00:31:32.540 --> 00:31:34.050
We're back in the Dart Editor.

00:31:34.050 --> 00:31:36.860
Let's look at the simple web app
that uses three different

00:31:36.860 --> 00:31:41.410
packages, cat pics, frames,
and widgets.

00:31:41.410 --> 00:31:43.960
Now, you can see the editor
doesn't know anything about

00:31:43.960 --> 00:31:45.340
these three different
libraries, so

00:31:45.340 --> 00:31:46.630
let's help it out.

00:31:46.630 --> 00:31:49.710
We define our dependencies here
with the Pub spec file.

00:31:49.710 --> 00:31:51.625
You can see the three different
package names, cat

00:31:51.625 --> 00:31:56.000
pic, frame, and widget, and
pointing to their individual

00:31:56.000 --> 00:31:59.100
Git repository somewhere
out on the net.

00:31:59.100 --> 00:32:03.340
Once we have that configured, we
can go to the command line

00:32:03.340 --> 00:32:08.320
inside our application,
and run Pub Install.

00:32:08.320 --> 00:32:11.790
This will go out, parse the Pub
spec file, and pull in all

00:32:11.790 --> 00:32:14.730
of our dependencies locally,
right next to our project.

00:32:14.730 --> 00:32:20.120
Now, going back to our editor,
you can see that the editor

00:32:20.120 --> 00:32:22.510
has now resolved the different
packages to their correct

00:32:22.510 --> 00:32:26.910
place, and a new packages
directory is now here.

00:32:26.910 --> 00:32:30.170
We defined a dependency on three
different packages, but

00:32:30.170 --> 00:32:32.560
we have four packages
installed.

00:32:32.560 --> 00:32:36.110
This is because one package
itself has a Pub spec file, so

00:32:36.110 --> 00:32:38.900
Pub will walk transitive
dependencies.

00:32:38.900 --> 00:32:41.600
Now that we have our application
wired up together

00:32:41.600 --> 00:32:43.980
and its dependencies resolved,
we can go ahead and run it.

00:32:48.210 --> 00:32:50.250
And sure enough, your
life is complete.

00:32:50.250 --> 00:32:53.130
You have cat pics in your app.

00:32:53.130 --> 00:32:56.700
And you can see the cat pics
themselves, the widgets, and

00:32:56.700 --> 00:32:59.020
the frames are now
all rendered.

00:32:59.020 --> 00:33:00.540
And we didn't write
any of that code.

00:33:00.540 --> 00:33:02.820
All of that code came from third
party dependencies and

00:33:02.820 --> 00:33:04.890
libraries out from the net.

00:33:04.890 --> 00:33:07.390
This was all just the
tip of the iceberg.

00:33:07.390 --> 00:33:09.960
There's a lot more to the Dart
language, libraries,

00:33:09.960 --> 00:33:11.490
and tools to cover.

00:33:11.490 --> 00:33:12.570
Let's see how to learn more.

00:33:12.570 --> 00:33:17.320
Our api.dartlang.org site has
all the API Docs for all the

00:33:17.320 --> 00:33:19.850
libraries that ship
with the Dart SDK.

00:33:19.850 --> 00:33:22.780
We even have comments enabled
for you to add your own tips

00:33:22.780 --> 00:33:24.050
and tricks.

00:33:24.050 --> 00:33:26.390
If you know JavaScript, you'll
definitely want to check out

00:33:26.390 --> 00:33:29.020
synonym.dartlang.org.

00:33:29.020 --> 00:33:32.390
This site maps common JavaScript
idioms, snippets,

00:33:32.390 --> 00:33:36.170
and patterns to their
equivalents in Dart.

00:33:36.170 --> 00:33:39.070
Everything is in this page, from
using arrays, to numbers,

00:33:39.070 --> 00:33:43.230
to functions, even how to work
with the DOM and jQuery.

00:33:43.230 --> 00:33:45.710
This site came out of an
internal Google hackathon.

00:33:45.710 --> 00:33:47.860
We think you'll find
it useful.

00:33:47.860 --> 00:33:50.690
Our Dart language tour takes
you through the language in

00:33:50.690 --> 00:33:52.160
much more detail.

00:33:52.160 --> 00:33:54.570
This is a good way to get an
overview of the language

00:33:54.570 --> 00:33:56.890
without reading the
language spec.

00:33:56.890 --> 00:33:59.040
It's a friendly way to
tour the language.

00:33:59.040 --> 00:34:01.350
The Dart library tour walks
you through most of the

00:34:01.350 --> 00:34:03.560
libraries that ship
with the SDK.

00:34:03.560 --> 00:34:05.850
You'll see what you can do
with the core libraries,

00:34:05.850 --> 00:34:10.210
isolates, UTF, URI,
Crypto, and more.

00:34:10.210 --> 00:34:12.360
For a high-level overview of
the Dart project, check out

00:34:12.360 --> 00:34:14.065
this free ebook from O'Reilly.

00:34:14.065 --> 00:34:16.179
This is a quick way to learn
about the project from the

00:34:16.179 --> 00:34:18.010
10,000 foot level.

00:34:18.010 --> 00:34:20.139
As you're learning about the
Dart language, libraries, and

00:34:20.139 --> 00:34:23.510
tools, don't forget to join the
growing Dart community.

00:34:23.510 --> 00:34:25.790
The community has already
started to publish libraries

00:34:25.790 --> 00:34:29.570
covering everything from MVC
frameworks to physics

00:34:29.570 --> 00:34:32.389
simulators, to template
libraries.

00:34:32.389 --> 00:34:35.690
More recently, we've spotted a
port of PhoneGap to Dart, and

00:34:35.690 --> 00:34:38.920
drivers for databases such
as MongoDB and Redis.

00:34:38.920 --> 00:34:41.639
One project that really caught
our attention was the Mod Dart

00:34:41.639 --> 00:34:44.389
project that embeds
Dart into Apache.

00:34:44.389 --> 00:34:47.500
Not only can you run Dart on
Heroku, but now you can run

00:34:47.500 --> 00:34:50.130
Dart with perhaps the most
popular web server.

00:34:50.130 --> 00:34:52.500
You can tell the world about
your cool new Dart libraries

00:34:52.500 --> 00:34:56.360
using Twitter, Google +, blogs,
IRC, our discussion

00:34:56.360 --> 00:34:59.250
mailing list, and of course,
stack overflow.

00:34:59.250 --> 00:35:01.630
Engineers from the project, as
well as active community

00:35:01.630 --> 00:35:03.450
members, hang out on
the mailing list

00:35:03.450 --> 00:35:04.850
and these other channels.

00:35:04.850 --> 00:35:07.820
Don't hesitate to drop in, say
hi, and ask questions.

00:35:07.820 --> 00:35:09.740
So get started with
Dart today.

00:35:09.740 --> 00:35:12.380
If you like rich code editors,
download the Dart Editor

00:35:12.380 --> 00:35:15.110
bundle, which has everything
you need, including Dartium

00:35:15.110 --> 00:35:16.880
and the Dart SDK.

00:35:16.880 --> 00:35:20.010
If you like Vi, Emacs, or
TextMate, you can download the

00:35:20.010 --> 00:35:21.730
standalone SDK.

00:35:21.730 --> 00:35:24.590
Most importantly, please
send us feedback.

00:35:24.590 --> 00:35:26.450
Now that you're all plugged into
the Dart community and

00:35:26.450 --> 00:35:28.830
writing Dart code, what's next
for the Dart project?

00:35:28.830 --> 00:35:32.400
Well, as we mentioned, Dart is
still in technology preview.

00:35:32.400 --> 00:35:34.860
Dart is not done, and there
are some cool new features

00:35:34.860 --> 00:35:36.540
coming for the project.

00:35:36.540 --> 00:35:39.335
Reflection support, an often
requested feature, is

00:35:39.335 --> 00:35:40.960
being worked on.

00:35:40.960 --> 00:35:43.120
This isn't as simple
as it may sound.

00:35:43.120 --> 00:35:45.680
We want to ensure that we can
ship the smallest amount of

00:35:45.680 --> 00:35:48.910
code possible over the wire, so
we need a reflection system

00:35:48.910 --> 00:35:52.370
that we can use to introspect
and perform intelligent tree

00:35:52.370 --> 00:35:54.260
shaking and dead code
elimination.

00:35:54.260 --> 00:35:56.800
Also coming are simplifications
to equality,

00:35:56.800 --> 00:36:00.390
the Pub Package Manager, method
cascades, shipping Dart

00:36:00.390 --> 00:36:04.680
directly in Chrome, and our
UI libraries for web apps.

00:36:04.680 --> 00:36:07.770
Other features like class
mixins, also known as traits,

00:36:07.770 --> 00:36:09.830
are being discussed
at a high level.

00:36:09.830 --> 00:36:12.610
Here's the summary
as we wrap up.

00:36:12.610 --> 00:36:16.110
Today, we learned that Dart
compiles to modern JavaScript.

00:36:16.110 --> 00:36:18.640
Dart is easy to learn, with type
annotations that fit the

00:36:18.640 --> 00:36:19.910
way you work.

00:36:19.910 --> 00:36:22.670
We learned that Dart runs on the
client and the server for

00:36:22.670 --> 00:36:25.270
an end-to-end programming
experience.

00:36:25.270 --> 00:36:27.860
The Dart project is much more
than just a language.

00:36:27.860 --> 00:36:31.350
It ships with libraries and
tools like the Dart Editor.

00:36:31.350 --> 00:36:33.750
Dart is under active
development, and has an active

00:36:33.750 --> 00:36:35.340
and growing community.

00:36:35.340 --> 00:36:39.040
Remember, Dart is structured
web programming compatible

00:36:39.040 --> 00:36:40.420
with today's web.

00:36:40.420 --> 00:36:43.380
Please give it a try and
give us feedback.

00:36:43.380 --> 00:36:45.210
Thanks very much, and thanks
for trying Dart.

