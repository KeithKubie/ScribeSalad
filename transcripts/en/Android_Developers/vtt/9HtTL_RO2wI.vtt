WEBVTT
Kind: captions
Language: en

00:00:00.986 --> 00:00:03.451
[MUSIC PLAYING]

00:00:06.409 --> 00:00:08.050
CHET HAASE: Wow,
what tepid applause.

00:00:08.050 --> 00:00:10.692
Thank you.

00:00:10.692 --> 00:00:12.400
CHRIS CRAIK: Hey, my
name is Chris Craik.

00:00:12.400 --> 00:00:14.390
I work on Android UI Toolkiit.

00:00:14.390 --> 00:00:15.640
CHET HAASE: And I'm Chet Haas.

00:00:15.640 --> 00:00:19.250
I also work on the
Android UI Toolkit team.

00:00:19.250 --> 00:00:21.650
And today, why don't we
talk about performance?

00:00:21.650 --> 00:00:24.010
It's been a while since
we've had a performance talk.

00:00:24.010 --> 00:00:25.468
So we thought we
should do it again

00:00:25.468 --> 00:00:27.880
because we like talking
about performance.

00:00:27.880 --> 00:00:29.290
For this year's
performance talk,

00:00:29.290 --> 00:00:31.390
we wanted to make it a
bit more use-case driven,

00:00:31.390 --> 00:00:33.580
tell you a bit about how
rendering works, some

00:00:33.580 --> 00:00:35.050
of the changes
that we made, some

00:00:35.050 --> 00:00:37.390
of the improvements
around performance,

00:00:37.390 --> 00:00:42.070
but also go through some steps
of how you would actually

00:00:42.070 --> 00:00:46.670
find out what jank is, and how
to fix it in your applications.

00:00:46.670 --> 00:00:47.380
So let's do that.

00:00:50.130 --> 00:00:52.390
UI performance,
hey, there you go.

00:00:52.390 --> 00:00:56.107
So we talk about
frames per second, FPS.

00:00:56.107 --> 00:00:57.190
It's a really good metric.

00:00:57.190 --> 00:00:59.200
It's a good way for
understanding what's

00:00:59.200 --> 00:01:00.790
going on in your application.

00:01:00.790 --> 00:01:03.350
But it's actually better to
think about the duration,

00:01:03.350 --> 00:01:03.850
right?

00:01:03.850 --> 00:01:06.460
So it's not how many frames
per second you can hit.

00:01:06.460 --> 00:01:08.800
Honestly, the display is
hitting 60 frames a second

00:01:08.800 --> 00:01:10.630
all the time.

00:01:10.630 --> 00:01:12.940
And then you need to sort
of hit the same number

00:01:12.940 --> 00:01:16.857
of frames for your
application in each second.

00:01:16.857 --> 00:01:18.940
But it's really better to
think about the duration

00:01:18.940 --> 00:01:20.080
that each frame is taking.

00:01:20.080 --> 00:01:22.900
How long is that frame
taking to actually draw?

00:01:22.900 --> 00:01:25.420
Because you're not going
to fit within that window

00:01:25.420 --> 00:01:28.130
if you're taking
too long to fit.

00:01:28.130 --> 00:01:31.390
So if you want to fix the
jank in your application,

00:01:31.390 --> 00:01:33.280
if you want to fix
the stutters, if when

00:01:33.280 --> 00:01:35.750
you're flinging and
scrolling that list,

00:01:35.750 --> 00:01:37.690
there's skipped
frames in the middle,

00:01:37.690 --> 00:01:40.180
and the user is seeing
this janky behavior,

00:01:40.180 --> 00:01:42.910
fixing that means fixing
the frames that are simply

00:01:42.910 --> 00:01:44.920
taking too long.

00:01:44.920 --> 00:01:48.180
So also, it's good to
think about consistency.

00:01:48.180 --> 00:01:50.800
It's great if you
can have 60 frames

00:01:50.800 --> 00:01:52.030
per second most of the time.

00:01:52.030 --> 00:01:55.480
But then occasionally, if
you're dropping several frames

00:01:55.480 --> 00:01:57.250
in a row, that's not good.

00:01:57.250 --> 00:01:59.470
What you really want
is consistent behavior.

00:01:59.470 --> 00:02:04.501
So chasing jank is all about
finding the places where you're

00:02:04.501 --> 00:02:06.250
dropping those and
making sure that you're

00:02:06.250 --> 00:02:10.199
fixing the bottlenecks that
are contributing to those.

00:02:10.199 --> 00:02:12.280
So let's talk about time.

00:02:12.280 --> 00:02:15.450
Let's take a look at time
going forward, from the left,

00:02:15.450 --> 00:02:16.410
to the right--

00:02:16.410 --> 00:02:19.290
sorry, from the
left to the right--

00:02:19.290 --> 00:02:23.280
and take a look at what's
happening in the UI space.

00:02:23.280 --> 00:02:26.940
So if you think about these
vertical refresh syncs,

00:02:26.940 --> 00:02:30.300
on every 16 and
2/3 milliseconds,

00:02:30.300 --> 00:02:34.450
typically, on a typical display,
we're getting a Vsync request,

00:02:34.450 --> 00:02:34.950
right?

00:02:34.950 --> 00:02:36.780
So this is the hardware
sort of posting the frame

00:02:36.780 --> 00:02:37.530
to the screen.

00:02:37.530 --> 00:02:39.690
That is when the
user sees something.

00:02:39.690 --> 00:02:43.890
So divide that by 60 second,
divided by 60, 16 2/3.

00:02:43.890 --> 00:02:47.610
I can go over the math
later if you need me to.

00:02:47.610 --> 00:02:50.340
Then if you map frames onto
that, each of these frames,

00:02:50.340 --> 00:02:52.470
this is sort of
these gray boxes are

00:02:52.470 --> 00:02:55.110
what your application is
doing in order to post

00:02:55.110 --> 00:02:57.570
that information to the screen.

00:02:57.570 --> 00:03:01.140
So ideally, all
of the stuff that

00:03:01.140 --> 00:03:04.819
needs to happen for that frame
would be within that 16 and 2/3

00:03:04.819 --> 00:03:05.360
milliseconds.

00:03:05.360 --> 00:03:06.485
I need to stop saying that.

00:03:06.485 --> 00:03:09.300
I'm going to say 16 milliseconds
and you can interpret it

00:03:09.300 --> 00:03:10.620
however you want.

00:03:10.620 --> 00:03:14.290
So the beautiful icon that
I hand-drew myself down

00:03:14.290 --> 00:03:17.040
to the bottom of the screen,
that's the user seeing things.

00:03:17.040 --> 00:03:19.380
So on each of those
vertical syncs,

00:03:19.380 --> 00:03:21.600
they are seeing whatever
the hardware buffer

00:03:21.600 --> 00:03:23.190
is posting to the screen.

00:03:23.190 --> 00:03:25.680
So they're going to see
it there, there, there.

00:03:25.680 --> 00:03:27.270
But if there's a
problem when you're

00:03:27.270 --> 00:03:29.970
rendering, if one of your
frames takes too long,

00:03:29.970 --> 00:03:31.890
then the user is not
going to see that.

00:03:31.890 --> 00:03:33.540
They're going to see
exactly what they

00:03:33.540 --> 00:03:35.130
saw in the previous
frame, because you

00:03:35.130 --> 00:03:37.200
took too long in
your application,

00:03:37.200 --> 00:03:38.500
and you skipped a frame.

00:03:38.500 --> 00:03:39.150
So that's jank.

00:03:39.150 --> 00:03:42.750
That's the stutter that we
need to try to analyze and fix.

00:03:42.750 --> 00:03:44.740
So let's take a little
step back and say, OK,

00:03:44.740 --> 00:03:48.237
how does rendering actually
happen in the UI toolkit?

00:03:48.237 --> 00:03:50.070
Well, there's the app
perspective, so what's

00:03:50.070 --> 00:03:51.870
going on in your
application, and then we'll

00:03:51.870 --> 00:03:53.745
take a look at what the
framework is actually

00:03:53.745 --> 00:03:55.510
doing on your behalf.

00:03:55.510 --> 00:03:57.090
So here's some simple code.

00:03:57.090 --> 00:03:59.670
I keep looking back at, OK,
so you can see on the screen

00:03:59.670 --> 00:04:00.930
back here.

00:04:00.930 --> 00:04:02.220
Here's some simple code.

00:04:02.220 --> 00:04:03.180
We have this color.

00:04:03.180 --> 00:04:04.570
Things are light gray right now.

00:04:04.570 --> 00:04:07.080
And when the user clicks in
the middle of this custom view,

00:04:07.080 --> 00:04:08.460
we're going to change the color.

00:04:08.460 --> 00:04:09.630
We're going to tell
the view that it needs

00:04:09.630 --> 00:04:11.088
to invalidate
itself, and then it's

00:04:11.088 --> 00:04:13.240
going redraw in the new color.

00:04:13.240 --> 00:04:18.149
So, user clicks on
the screen, that

00:04:18.149 --> 00:04:20.700
sends an event into
the onclick method,

00:04:20.700 --> 00:04:22.230
we're going to
change things around,

00:04:22.230 --> 00:04:23.820
then we're going to invalidate.

00:04:23.820 --> 00:04:27.030
And then invalidate is going to
cause a later call to onDraw.

00:04:27.030 --> 00:04:28.710
It's not a serial thing.

00:04:28.710 --> 00:04:30.120
It doesn't directly call onDraw.

00:04:30.120 --> 00:04:32.850
But it tells the system, hey,
things need to be redrawn.

00:04:32.850 --> 00:04:35.490
And then a later call will
filter into the onDraw method.

00:04:35.490 --> 00:04:38.490
And then the onDraw will
draw into the canvas,

00:04:38.490 --> 00:04:41.290
and that will eventually
be posted to the screen

00:04:41.290 --> 00:04:43.950
through all the operations
that the UI toolkit is

00:04:43.950 --> 00:04:46.109
doing on your behalf.

00:04:46.109 --> 00:04:48.150
So from the platform
perspective, what's going on

00:04:48.150 --> 00:04:49.830
is several things in a row.

00:04:49.830 --> 00:04:52.050
First of all, on
any given frame,

00:04:52.050 --> 00:04:55.630
when we get that Vsync
request, we process input.

00:04:55.630 --> 00:04:57.990
So if the user is clicked,
if the user is scrolling

00:04:57.990 --> 00:05:00.540
or flinging, that's where
we get that information

00:05:00.540 --> 00:05:02.470
and do something based on it.

00:05:02.470 --> 00:05:04.050
If there's animation,
if they have

00:05:04.050 --> 00:05:06.900
let go of that scrolling list,
and it's now flinging and just

00:05:06.900 --> 00:05:09.540
posting events so that it
gets updated as the list

00:05:09.540 --> 00:05:12.510
moves in space, or as views
move around on the screen,

00:05:12.510 --> 00:05:14.550
we process those
animation events.

00:05:14.550 --> 00:05:15.960
We change the properties.

00:05:15.960 --> 00:05:18.240
That causes invalidation
so that things

00:05:18.240 --> 00:05:20.220
can get redrawn appropriately.

00:05:20.220 --> 00:05:22.240
Then, if necessary,
we do layout.

00:05:22.240 --> 00:05:24.240
So if something changed
in your application that

00:05:24.240 --> 00:05:26.670
changes things,
size or location,

00:05:26.670 --> 00:05:28.497
that's when we
measure and lay out

00:05:28.497 --> 00:05:30.580
the things that need to
be changed, again, causing

00:05:30.580 --> 00:05:32.970
invalidation and redraws.

00:05:32.970 --> 00:05:35.760
And then we actually do
what we call record draw.

00:05:35.760 --> 00:05:38.580
So this is what we were
seeing on the previous slide,

00:05:38.580 --> 00:05:40.000
in the onDraw method.

00:05:40.000 --> 00:05:41.550
This is where you
turn whatever you

00:05:41.550 --> 00:05:45.120
want to do into drawing
operations that we then receive

00:05:45.120 --> 00:05:46.740
and store internally.

00:05:46.740 --> 00:05:49.930
So you're going to say, well,
canvas, draw this new color.

00:05:49.930 --> 00:05:52.170
So you're recording
the commands that

00:05:52.170 --> 00:05:55.200
should happen in order
for us to then draw

00:05:55.200 --> 00:05:56.910
the right thing under the hood.

00:05:56.910 --> 00:05:58.110
And then finally, render.

00:05:58.110 --> 00:05:59.970
And that's our stage in this.

00:05:59.970 --> 00:06:02.450
So you do everything in
the first four steps,

00:06:02.450 --> 00:06:06.255
in your codes, or for standard
views, we're doing it.

00:06:06.255 --> 00:06:07.630
And then we handle
the rendering.

00:06:07.630 --> 00:06:09.255
And that's basically
the transformation

00:06:09.255 --> 00:06:12.240
of those recorded draw
calls into whatever we

00:06:12.240 --> 00:06:14.160
need to do at the bottom layer.

00:06:14.160 --> 00:06:15.060
I'll give you a hint.

00:06:15.060 --> 00:06:17.460
We turn it into OpenGL
or GPU commands,

00:06:17.460 --> 00:06:19.350
that we then send to the GPU.

00:06:19.350 --> 00:06:23.250
So if we look at that beautiful,
brilliant colors, which we're

00:06:23.250 --> 00:06:25.500
going to use in some
upcoming diagrams,

00:06:25.500 --> 00:06:27.810
we have these five
stages, right?

00:06:27.810 --> 00:06:30.840
So in any particular frame,
the boring gray box there,

00:06:30.840 --> 00:06:34.560
it's actually broken down
into those different stages.

00:06:34.560 --> 00:06:37.534
In our previous example, in
that simple application code,

00:06:37.534 --> 00:06:39.450
we didn't have all of
the stages because there

00:06:39.450 --> 00:06:40.650
was no layout required.

00:06:40.650 --> 00:06:42.580
All we were doing
was changing a color.

00:06:42.580 --> 00:06:44.430
So we had the input
of the onclick,

00:06:44.430 --> 00:06:47.550
and then we had the record
draw of the canvas operation

00:06:47.550 --> 00:06:49.050
to draw in the new
color, and then

00:06:49.050 --> 00:06:51.350
the rendering operation
that resulted from that.

00:06:51.350 --> 00:06:54.970
In a typical-- yeah, just
like it says on the slide.

00:06:54.970 --> 00:07:00.354
In a typical application,
more general frame,

00:07:00.354 --> 00:07:02.520
then you're going to have
all of the steps in there.

00:07:02.520 --> 00:07:05.070
So we may process some
input and some animation

00:07:05.070 --> 00:07:07.560
and some layout and
record and then render.

00:07:07.560 --> 00:07:10.280
And all of these things are
happening in a sequence.

00:07:10.280 --> 00:07:12.620
So this is the
order of operations.

00:07:12.620 --> 00:07:15.380
In reality, we actually
have two threads kicking in

00:07:15.380 --> 00:07:19.550
as a lollipop, where we came
out with a render thread

00:07:19.550 --> 00:07:23.060
technology, which we've talked
about before, where we process

00:07:23.060 --> 00:07:25.710
all of the application
space stuff going on,

00:07:25.710 --> 00:07:28.550
those first four steps
in the application space,

00:07:28.550 --> 00:07:29.462
or on the UI thread.

00:07:29.462 --> 00:07:31.670
And then we have this separate
thread that's actually

00:07:31.670 --> 00:07:32.930
handling the rendering.

00:07:32.930 --> 00:07:35.330
They still happen in
series, in sequence,

00:07:35.330 --> 00:07:37.280
because the render
thread doesn't know what

00:07:37.280 --> 00:07:39.170
to render until you tell it.

00:07:39.170 --> 00:07:43.010
But the render thread can also
do other stuff asynchronously

00:07:43.010 --> 00:07:43.880
from the UI thread.

00:07:43.880 --> 00:07:46.371
So we can send over some
of the atomic animations

00:07:46.371 --> 00:07:47.870
that it can process
in the meantime.

00:07:47.870 --> 00:07:50.772
But in general, you do all
this stuff on the UI thread.

00:07:50.772 --> 00:07:52.730
And then we sync that
information to the render

00:07:52.730 --> 00:07:55.340
thread, and then render thread
on that separate thread,

00:07:55.340 --> 00:07:58.100
will handle talking to the GPU.

00:07:58.100 --> 00:08:00.890
So in a well-behaved
application, in a typical,

00:08:00.890 --> 00:08:04.622
let's say this is a scrolling
or a flinging situation,

00:08:04.622 --> 00:08:06.580
and things are well-behaved
in the application,

00:08:06.580 --> 00:08:09.890
and you draw relatively quickly,
this is what things look like.

00:08:09.890 --> 00:08:11.900
Again, the beautiful
eye icon at the bottom,

00:08:11.900 --> 00:08:14.890
the user sees the frames
happen, bam, bam, bam, bam,

00:08:14.890 --> 00:08:17.570
everything's happening within
the 16 millisecond barrier.

00:08:17.570 --> 00:08:21.050
But, in a typical janky
situation, all of a sudden,

00:08:21.050 --> 00:08:22.730
something took longer.

00:08:22.730 --> 00:08:26.310
So here, we see that the input
command took a lot longer.

00:08:26.310 --> 00:08:29.480
So maybe when the user clicks,
some expensive operation

00:08:29.480 --> 00:08:30.200
was performed.

00:08:30.200 --> 00:08:31.700
Somebody made a
web service call.

00:08:31.700 --> 00:08:35.030
Or more typically, you
created or you bound a view.

00:08:35.030 --> 00:08:37.010
You did some expensive
operation that

00:08:37.010 --> 00:08:40.287
caused us to do a lot of work,
pushed out the length of time

00:08:40.287 --> 00:08:42.620
that you're spending doing
all of that recording of draw

00:08:42.620 --> 00:08:43.760
operations.

00:08:43.760 --> 00:08:46.400
And then the rendering
operation necessarily slipped

00:08:46.400 --> 00:08:48.350
into the next
frame, and the user

00:08:48.350 --> 00:08:51.380
missed seeing that input because
it didn't hit the barrier.

00:08:51.380 --> 00:08:55.089
So that's the jank, again,
that we want to fix.

00:08:55.089 --> 00:08:56.630
CHRIS CRAIK: All
right, so let's move

00:08:56.630 --> 00:08:59.270
over to talking
about what do you do?

00:08:59.270 --> 00:09:01.460
You have problems
in the application.

00:09:01.460 --> 00:09:04.430
You see now, as Chet has
described, what can happen

00:09:04.430 --> 00:09:05.810
when the frame takes too long.

00:09:05.810 --> 00:09:07.310
Let's talk about
the process that we

00:09:07.310 --> 00:09:10.190
called de-janking, stepping
through your application,

00:09:10.190 --> 00:09:12.660
and finding and
fixing these problems.

00:09:12.660 --> 00:09:14.660
So the first step in
de-janking your application

00:09:14.660 --> 00:09:16.640
is to run a release-ish build.

00:09:16.640 --> 00:09:18.410
And so, what I mean
by that is, make

00:09:18.410 --> 00:09:20.420
sure that you're running
with debugging off.

00:09:20.420 --> 00:09:21.919
If you're running
with debugging on,

00:09:21.919 --> 00:09:24.050
arc has to add in a
bunch of different checks

00:09:24.050 --> 00:09:26.912
and verification steps that
can add a little bit of time

00:09:26.912 --> 00:09:28.370
and skew your
results a little bit.

00:09:28.370 --> 00:09:31.460
So we recommend overriding
that, or testing

00:09:31.460 --> 00:09:34.040
an actual release build.

00:09:34.040 --> 00:09:36.584
So the second step is to
inspect your app visually.

00:09:36.584 --> 00:09:38.000
As you're scrolling
through lists,

00:09:38.000 --> 00:09:40.995
if you see any jank occurring,
just visually detecting,

00:09:40.995 --> 00:09:43.400
if you see an
animation, definitely

00:09:43.400 --> 00:09:45.950
start with the most key,
important parts of your app.

00:09:45.950 --> 00:09:48.950
Lots of you guys have a
primary scrolling list,

00:09:48.950 --> 00:09:49.867
great place to start.

00:09:49.867 --> 00:09:51.950
If you happen to be one
of the kind of people that

00:09:51.950 --> 00:09:57.170
can't see jank, if you just see,
oh, well, it looks fine to me,

00:09:57.170 --> 00:09:59.241
you can turn on
profile GPU rendering,

00:09:59.241 --> 00:10:00.740
and that gives you
all of these bars

00:10:00.740 --> 00:10:02.870
at the bottom,
which will tell you

00:10:02.870 --> 00:10:04.940
when you pass that
particular threshold

00:10:04.940 --> 00:10:08.240
and give you a little hint as
to what might be happening,

00:10:08.240 --> 00:10:10.160
based upon the color.

00:10:10.160 --> 00:10:12.320
And there's some documentation
about that online.

00:10:12.320 --> 00:10:15.470
But the real next step, after
that, you've seen some jank,

00:10:15.470 --> 00:10:17.870
you see, oh yes, when
these items come on screen,

00:10:17.870 --> 00:10:21.140
or the first time that I load
this particular part of the UI,

00:10:21.140 --> 00:10:23.010
you figure out what
the interaction is,

00:10:23.010 --> 00:10:24.750
and you say, OK,
what do I do next?

00:10:24.750 --> 00:10:27.090
Well, the next step
is generally Systrace.

00:10:27.090 --> 00:10:31.140
Systrace is a tool
that exists in the SDK,

00:10:31.140 --> 00:10:32.696
in the platform tools directory.

00:10:32.696 --> 00:10:34.070
You can also get
it off of GitHub

00:10:34.070 --> 00:10:38.210
if you want the absolute
freshest version.

00:10:38.210 --> 00:10:44.390
And so from here, we're going
to do a very quick live look

00:10:44.390 --> 00:10:47.130
through what a Systrace
actually looks like.

00:10:47.130 --> 00:10:49.490
So this is what you might
see when you pull up

00:10:49.490 --> 00:10:51.230
a Systrace for the first time.

00:10:51.230 --> 00:10:52.910
So in this particular
example, I was

00:10:52.910 --> 00:10:55.054
scrolling through a
RecyclerView in my app.

00:10:55.054 --> 00:10:56.720
And I saw oh, there's
some janky frames.

00:10:56.720 --> 00:10:59.300
I can see some
visual stuttering.

00:10:59.300 --> 00:11:03.140
And so I captured a Systrace
over the duration of that time.

00:11:03.140 --> 00:11:04.800
And now I pull up a Systrace.

00:11:04.800 --> 00:11:07.970
And oh my goodness, there is
a lot of information here.

00:11:07.970 --> 00:11:08.990
There is a lot of noise.

00:11:08.990 --> 00:11:11.790
It is really hard to see,
what should I be looking at?

00:11:11.790 --> 00:11:14.390
So first and foremost,
what you can do

00:11:14.390 --> 00:11:15.860
is you can look
here on the left.

00:11:15.860 --> 00:11:18.430
You can see, OK,
well, there is kernel,

00:11:18.430 --> 00:11:20.120
there is potentially
other processes.

00:11:20.120 --> 00:11:20.780
You know what I'm going to do?

00:11:20.780 --> 00:11:22.850
I'm going to ignore
everybody else for now,

00:11:22.850 --> 00:11:25.846
and I'm going to scroll
down until the top process,

00:11:25.846 --> 00:11:27.470
the only thing that
I can see right now

00:11:27.470 --> 00:11:30.432
is my package, Android.janktown.

00:11:30.432 --> 00:11:32.390
And in fact, you can even
go further than that.

00:11:32.390 --> 00:11:34.170
You can look on the left here.

00:11:34.170 --> 00:11:36.470
This tells you, in
fact, individual threads

00:11:36.470 --> 00:11:37.280
that we care about.

00:11:37.280 --> 00:11:38.480
And as Chet was
talking about, there

00:11:38.480 --> 00:11:39.854
are two threads
that matter here.

00:11:39.854 --> 00:11:42.591
There's the UI thread of my
app and the render thread.

00:11:42.591 --> 00:11:44.090
So I'm going to
scroll down further,

00:11:44.090 --> 00:11:46.640
until all that I can see, at
the very top of the screen,

00:11:46.640 --> 00:11:47.791
is mostly that.

00:11:47.791 --> 00:11:49.790
And so from a very high
level, even just looking

00:11:49.790 --> 00:11:51.665
at this trace, without
knowing much about it,

00:11:51.665 --> 00:11:56.720
I can say, OK, the time in this
trace goes from left to right.

00:11:56.720 --> 00:11:58.787
On the leftmost we
have zero seconds

00:11:58.787 --> 00:11:59.870
going all the way further.

00:11:59.870 --> 00:12:01.640
And if you can't see
the specific details,

00:12:01.640 --> 00:12:02.514
don't worry about it.

00:12:02.514 --> 00:12:06.064
We'll go into some
zoomed-in screenshots later.

00:12:06.064 --> 00:12:07.730
But even from this
very high-level view,

00:12:07.730 --> 00:12:10.130
I can say, oh, well I got a
lot of tiny little slivers

00:12:10.130 --> 00:12:11.450
here, these little pulses.

00:12:11.450 --> 00:12:12.210
These are frames.

00:12:12.210 --> 00:12:13.370
OK, great.

00:12:13.370 --> 00:12:15.350
Most of that looks
incredibly consistent,

00:12:15.350 --> 00:12:17.300
looks really
smooth, and it looks

00:12:17.300 --> 00:12:19.130
to be repeating regularly.

00:12:19.130 --> 00:12:22.220
However, there are some
big visual standouts here.

00:12:22.220 --> 00:12:23.990
And this is very
often what de-janking

00:12:23.990 --> 00:12:26.960
is, is looking for these
particular standout frames

00:12:26.960 --> 00:12:29.010
and investigating.

00:12:29.010 --> 00:12:33.980
So if I zoom in
here, I can start

00:12:33.980 --> 00:12:36.560
looking at exactly what's
going wrong in these frames,

00:12:36.560 --> 00:12:39.590
and I can start clicking
around, figuring out

00:12:39.590 --> 00:12:40.790
exactly what the problem is.

00:12:40.790 --> 00:12:42.206
And just so that
you can see that,

00:12:42.206 --> 00:12:44.810
we're going to switch back
to slides and show you

00:12:44.810 --> 00:12:46.558
the screenshots in particular.

00:12:50.770 --> 00:12:53.310
So this is one of the
simple frames, zoomed

00:12:53.310 --> 00:12:56.820
in pretty significantly,
that we saw earlier

00:12:56.820 --> 00:12:59.829
as those very frequent
and very regular pulses.

00:12:59.829 --> 00:13:00.870
Now these were very nice.

00:13:00.870 --> 00:13:02.703
They looked like tiny
little slivers before.

00:13:02.703 --> 00:13:06.360
But let's go ahead and look at
them to see what a baseline is.

00:13:06.360 --> 00:13:08.850
So first of all, one of the
tricky things about Systrace

00:13:08.850 --> 00:13:10.170
is, there's a lot of data here.

00:13:10.170 --> 00:13:12.070
There's a lot of
things to click on.

00:13:12.070 --> 00:13:14.640
But one of the nice features
is that most of these UI thread

00:13:14.640 --> 00:13:16.804
components, click
on it, Systrace

00:13:16.804 --> 00:13:18.720
will do its best to try
and explain it to you.

00:13:18.720 --> 00:13:20.940
So if you click on this
particular type of the UI

00:13:20.940 --> 00:13:24.330
thread, which means this is
the top most traced section.

00:13:24.330 --> 00:13:28.459
This is the biggest chunk that
represents the UI thread work.

00:13:28.459 --> 00:13:30.750
If you click on that, at the
bottom of the Systrace UI,

00:13:30.750 --> 00:13:34.350
it'll say, oh, OK, well this
is what Choreographer is.

00:13:34.350 --> 00:13:37.320
And in fact, here it'll even
link you to the documentation

00:13:37.320 --> 00:13:40.860
where it describes on
d.android.com how Choreographer

00:13:40.860 --> 00:13:43.230
works.

00:13:43.230 --> 00:13:46.830
Similarly, if I want to
look down at draw frame,

00:13:46.830 --> 00:13:50.200
that's the render thread
component of the frame.

00:13:50.200 --> 00:13:53.000
And if I click on it, I
get a similar explanation.

00:13:53.000 --> 00:13:55.014
There's lots of this
for all sorts of tracing

00:13:55.014 --> 00:13:57.180
throughout Systrace,
especially on the UI and render

00:13:57.180 --> 00:14:00.340
thread, where you might
be most interested.

00:14:00.340 --> 00:14:02.370
OK, so now that we know
we can click on things,

00:14:02.370 --> 00:14:03.960
we can get a little bit
more information that way,

00:14:03.960 --> 00:14:06.293
let's go through exactly what
does this frame look like?

00:14:06.293 --> 00:14:08.070
What's it doing?

00:14:08.070 --> 00:14:10.880
So, the very first thing we see
here is an animation call back.

00:14:10.880 --> 00:14:12.630
If you click on this,
it'll say animation.

00:14:12.630 --> 00:14:14.130
Or if you zoom in,
you can see that.

00:14:14.130 --> 00:14:16.620
And I'm just going to go
through these that way.

00:14:16.620 --> 00:14:18.120
So this is animation
exactly as Chet

00:14:18.120 --> 00:14:19.286
was talking about it before.

00:14:19.286 --> 00:14:22.799
And if we saw before, we
had a whole lot of frames.

00:14:22.799 --> 00:14:24.340
And I told you it
was a RecyclerView.

00:14:24.340 --> 00:14:26.506
So there's one very common
reason for a RecyclerView

00:14:26.506 --> 00:14:30.060
to be animating,
and that's flinging.

00:14:30.060 --> 00:14:33.630
The flinging animation itself,
executes RecyclerView's actual

00:14:33.630 --> 00:14:38.940
translate and inflate work as
part of an animation callback.

00:14:38.940 --> 00:14:40.650
And then the other
stage that Chet talked

00:14:40.650 --> 00:14:42.445
about before is record draw.

00:14:42.445 --> 00:14:44.820
Well, this makes sense as
well, because RecyclerView view

00:14:44.820 --> 00:14:47.850
is invalidating, sliding
things around, and drawing.

00:14:47.850 --> 00:14:50.137
OK, we kind of get some
context for what it's doing.

00:14:50.137 --> 00:14:51.720
And in fact, if you
click on this part

00:14:51.720 --> 00:14:56.220
of the animation, which
is inside animation,

00:14:56.220 --> 00:14:57.540
this is RecyclerView scroll.

00:14:57.540 --> 00:14:58.956
So RecyclerView
scroll is actually

00:14:58.956 --> 00:15:00.330
going really, really fast here.

00:15:00.330 --> 00:15:04.780
And that's because RecyclerView
is doing very minimal work.

00:15:04.780 --> 00:15:07.420
In fact, if we look at the
amount of time taken by this UI

00:15:07.420 --> 00:15:09.600
frame, it's 1.25 milliseconds.

00:15:09.600 --> 00:15:10.770
That's great.

00:15:10.770 --> 00:15:13.560
The whole frame finishes
in less than six.

00:15:13.560 --> 00:15:16.470
This is a great frame,
congratulations.

00:15:16.470 --> 00:15:19.050
Now we look at a little
bit slower of a frame.

00:15:19.050 --> 00:15:20.910
Now this one's
actually not terrible,

00:15:20.910 --> 00:15:23.500
but let's look at how it
differs from the previous one.

00:15:23.500 --> 00:15:26.640
So first of all, we notice that
there's a measure pass in here.

00:15:26.640 --> 00:15:31.470
So something in the
hierarchy requested layout

00:15:31.470 --> 00:15:32.400
and got remeasured.

00:15:32.400 --> 00:15:34.560
OK, good to know.

00:15:34.560 --> 00:15:36.930
Then another thing down
here, we see upload bitmap.

00:15:36.930 --> 00:15:39.830
So the first time that the
RenderThread sees a bitmap

00:15:39.830 --> 00:15:43.290
and needs to display it, it
will be uploaded to the GPU,

00:15:43.290 --> 00:15:46.320
uploaded to OpenGL so that the
GPU can draw it really fast.

00:15:46.320 --> 00:15:48.870
Now that first upload
is a little expensive,

00:15:48.870 --> 00:15:50.800
and we'll talk about
that a bit more later.

00:15:50.800 --> 00:15:52.980
But really, if we look at
it, well, the UI thread

00:15:52.980 --> 00:15:54.990
takes four milliseconds,
the entire frame

00:15:54.990 --> 00:15:56.310
finishes in less than 13.

00:15:56.310 --> 00:15:57.660
This is not a problem frame.

00:15:57.660 --> 00:16:00.060
This is fine.

00:16:00.060 --> 00:16:01.920
But now let's look at
the really bad ones.

00:16:01.920 --> 00:16:04.560
These were the ones that
we saw from very far away.

00:16:04.560 --> 00:16:07.050
OK, something is
definitely going on here.

00:16:07.050 --> 00:16:09.300
But if you're new,
like, what's going on?

00:16:09.300 --> 00:16:11.410
How do I figure out
what's going on?

00:16:11.410 --> 00:16:13.860
So actually, if you click
on this part that says,

00:16:13.860 --> 00:16:16.680
RV CreateView, it'll
describe to you

00:16:16.680 --> 00:16:19.230
that this is basically
your adapter's callback

00:16:19.230 --> 00:16:20.610
for onCreateViewHolder.

00:16:20.610 --> 00:16:22.710
This means that RecyclerView
needs a new view,

00:16:22.710 --> 00:16:24.226
and it's creating it.

00:16:24.226 --> 00:16:26.100
And in fact, if you look
directly below that,

00:16:26.100 --> 00:16:28.770
well, a lot of the reason,
a lot of the time that

00:16:28.770 --> 00:16:31.222
takes up this
CreateView portion,

00:16:31.222 --> 00:16:32.180
is that it's inflating.

00:16:32.180 --> 00:16:34.260
And inflating, especially
with the complex items

00:16:34.260 --> 00:16:36.850
in my RecyclerView,
can take a while.

00:16:36.850 --> 00:16:38.520
Well, that's unfortunate.

00:16:38.520 --> 00:16:40.830
The next part here,
onBindViewHolder, that

00:16:40.830 --> 00:16:43.430
takes about a
millisecond and a half.

00:16:43.430 --> 00:16:46.836
Not great, but OK,
well what can I do?

00:16:46.836 --> 00:16:51.300
You know, this UI thread frame
took about 20 milliseconds

00:16:51.300 --> 00:16:54.720
on the UI thread and
totaled to be about 27.4.

00:16:54.720 --> 00:16:55.410
Not great.

00:16:55.410 --> 00:16:58.900
We are definitely going
to jank that frame.

00:16:58.900 --> 00:17:00.441
So this is actually,
this process

00:17:00.441 --> 00:17:02.190
is one that you might
go through yourself.

00:17:02.190 --> 00:17:03.960
But in this particular
case, we realize,

00:17:03.960 --> 00:17:05.918
well this is something
that we can help you out

00:17:05.918 --> 00:17:07.560
with in support lib.

00:17:07.560 --> 00:17:10.680
And this is a feature
that we worked in

00:17:10.680 --> 00:17:11.849
for exactly that purpose.

00:17:11.849 --> 00:17:13.432
So let's go back and
talk a little bit

00:17:13.432 --> 00:17:15.990
about what RecyclerView does.

00:17:15.990 --> 00:17:18.839
So RecyclerView is the
primary support lib component

00:17:18.839 --> 00:17:23.400
for displaying a dynamic
list of content that

00:17:23.400 --> 00:17:25.619
needs to show views
dynamically, that needs

00:17:25.619 --> 00:17:29.610
to scroll infinitely,
potentially, or display

00:17:29.610 --> 00:17:32.560
more content than what is
attached to the view hierarchy.

00:17:32.560 --> 00:17:33.310
So what do I mean?

00:17:33.310 --> 00:17:35.700
Well, I mean, if you have
these four items partially

00:17:35.700 --> 00:17:39.960
visible in your RecyclerView,
you start scrolling,

00:17:39.960 --> 00:17:42.540
and all the RecyclerView needs
to do is handle these four

00:17:42.540 --> 00:17:43.530
particular items.

00:17:43.530 --> 00:17:46.430
In fact, all that it has to do
is offset them very slightly.

00:17:46.430 --> 00:17:48.180
And that's the amount
of work that we see.

00:17:48.180 --> 00:17:50.514
And in fact, if you
remember, the very first RV

00:17:50.514 --> 00:17:52.180
scroll that we
highlighted, it was tiny.

00:17:52.180 --> 00:17:55.180
It was trivial because
RecyclerView did very little.

00:17:55.180 --> 00:17:58.030
But once we get to the edge
of this particular list, well,

00:17:58.030 --> 00:17:59.410
what happens?

00:17:59.410 --> 00:18:00.910
Now we suddenly
might see some jank

00:18:00.910 --> 00:18:03.640
because this is a frame in which
something interesting happens.

00:18:03.640 --> 00:18:06.610
For the first time, this
list has five items in it.

00:18:06.610 --> 00:18:09.910
That means it can't get an item
to be recycled from previously.

00:18:09.910 --> 00:18:15.490
That means this message
icon had to be inflated.

00:18:15.490 --> 00:18:18.250
Well, so that's the old way
of RecyclerView working.

00:18:18.250 --> 00:18:20.830
So let's go back to a sort
of simplified version of what

00:18:20.830 --> 00:18:22.270
we saw in the Systrace.

00:18:22.270 --> 00:18:24.670
Let's say, again, that
this happened during fling.

00:18:24.670 --> 00:18:27.020
We have two frames
that look totally fine.

00:18:27.020 --> 00:18:29.950
They have short UI
thread durations

00:18:29.950 --> 00:18:32.102
and very reasonable
RenderThread durations

00:18:32.102 --> 00:18:33.310
finished before the deadline.

00:18:33.310 --> 00:18:36.940
But then suddenly, you hit
a big chunk of animation.

00:18:36.940 --> 00:18:39.310
And as we know, in
this particular case,

00:18:39.310 --> 00:18:42.460
that's because RecyclerView
is doing it's create and bind

00:18:42.460 --> 00:18:44.500
work.

00:18:44.500 --> 00:18:46.430
So we see something
funny here, though.

00:18:46.430 --> 00:18:49.300
With RenderThread
working as it does,

00:18:49.300 --> 00:18:54.100
the UI thread is totally idle
for the 10 or so milliseconds

00:18:54.100 --> 00:18:56.151
in advance of this
new frame coming on.

00:18:56.151 --> 00:18:58.150
Well, it's not hard to
predict that the fling is

00:18:58.150 --> 00:18:59.150
going to continue.

00:18:59.150 --> 00:19:01.930
I mean, that's kind
of what animations do.

00:19:01.930 --> 00:19:03.370
And this create
work, it actually

00:19:03.370 --> 00:19:07.220
could have fit right there.

00:19:07.220 --> 00:19:10.640
So this is exactly what we
do in RecyclerView Prefetch.

00:19:10.640 --> 00:19:13.390
We started looking
ahead to new items that

00:19:13.390 --> 00:19:15.760
are about to come on
screen and basically

00:19:15.760 --> 00:19:17.020
stealing work from them.

00:19:17.020 --> 00:19:19.184
Realizing, oh no, that's
going to do a lot of work.

00:19:19.184 --> 00:19:20.600
Let me steal a
little bit of that.

00:19:20.600 --> 00:19:22.141
Let me go ahead and
do that inflation

00:19:22.141 --> 00:19:26.159
early so that we don't
have to do that on demand.

00:19:26.159 --> 00:19:27.950
And this is what it
looks like in practice.

00:19:27.950 --> 00:19:30.130
So this is a Systrace
from the exact same app.

00:19:30.130 --> 00:19:32.080
All that I did was
update the support

00:19:32.080 --> 00:19:34.180
lib to get this feature.

00:19:34.180 --> 00:19:37.780
And suddenly, we get an RV
Prefetch event in Systrace.

00:19:37.780 --> 00:19:40.120
Again, click on it, it
explains the Prefetch feature,

00:19:40.120 --> 00:19:43.000
what it does.

00:19:43.000 --> 00:19:47.350
And we see, wow, that's 13 1/2
milliseconds that we pulled out

00:19:47.350 --> 00:19:48.130
of the next frame.

00:19:48.130 --> 00:19:51.520
We saved a huge amount
of time by work stealing.

00:19:51.520 --> 00:19:53.860
And this is one great
example of something

00:19:53.860 --> 00:19:57.970
that the support lib has done,
but it's absolutely the process

00:19:57.970 --> 00:19:59.710
that you can go
through for looking

00:19:59.710 --> 00:20:01.840
for problems in your own app.

00:20:01.840 --> 00:20:05.200
Support lib can't solve
every problem this way.

00:20:05.200 --> 00:20:07.450
But look, let's talk about
Prefetch a little bit more.

00:20:07.450 --> 00:20:10.300
So there are some caveats.

00:20:10.300 --> 00:20:12.460
So what happens if the
item isn't actually needed?

00:20:12.460 --> 00:20:13.960
What happens if we
Prefetch an item,

00:20:13.960 --> 00:20:15.790
and suddenly, just
before that item is

00:20:15.790 --> 00:20:18.289
about to come on screen, the
user decides to tap the screen,

00:20:18.289 --> 00:20:19.200
stop the fling?

00:20:19.200 --> 00:20:21.783
If the fling is stopped, if you
don't end up needing the item,

00:20:21.783 --> 00:20:24.190
or if something else
comes in, some last minute

00:20:24.190 --> 00:20:28.000
arrival of new data, you might
have done the work incorrectly.

00:20:28.000 --> 00:20:29.290
And really, that's fine.

00:20:29.290 --> 00:20:31.192
99.9% of the time,
Prefetch is going

00:20:31.192 --> 00:20:32.650
to make the right
decision, and you

00:20:32.650 --> 00:20:35.800
might waste a little bit of
work in that particular case.

00:20:35.800 --> 00:20:38.110
What if there's no
RenderThread though?

00:20:38.110 --> 00:20:39.730
If there's no
RenderThread, we just

00:20:39.730 --> 00:20:41.950
don't try and Prefetch,
to begin with right now.

00:20:41.950 --> 00:20:46.107
So because RenderThread is on
the vast majority of devices,

00:20:46.107 --> 00:20:47.690
you get this on most
devices for free,

00:20:47.690 --> 00:20:50.610
by just using a recent
version of the support lib.

00:20:50.610 --> 00:20:54.100
But on older devices,
this feature doesn't work.

00:20:54.100 --> 00:20:56.620
So availability,
this was actually

00:20:56.620 --> 00:20:59.020
introduced a while ago,
with support lib v.25.

00:20:59.020 --> 00:21:01.660
But it's been getting better,
including with the most

00:21:01.660 --> 00:21:05.050
recent beta of 26.

00:21:05.050 --> 00:21:07.240
This feature is built into
default layout manager,

00:21:07.240 --> 00:21:10.300
so if you just use a
RecyclerView, horizontal,

00:21:10.300 --> 00:21:14.456
vertical, whatever, with linear,
or staggered, or grid layout,

00:21:14.456 --> 00:21:15.580
you just get this for free.

00:21:15.580 --> 00:21:20.410
This is just from updating
to the newer support lib.

00:21:20.410 --> 00:21:22.286
However, if you have a
custom layout manager,

00:21:22.286 --> 00:21:24.285
if you wanted to do
something completely custom,

00:21:24.285 --> 00:21:26.950
or if you wanted to subclass one
of them in an interesting way,

00:21:26.950 --> 00:21:30.100
just be aware that you
may need to override

00:21:30.100 --> 00:21:34.190
this particular method, collect
adjacent Prefetch positions.

00:21:34.190 --> 00:21:36.850
And this is how you, in
your custom layout manager,

00:21:36.850 --> 00:21:38.500
can get the exact same behavior.

00:21:38.500 --> 00:21:40.125
And you can look at
the implementations

00:21:40.125 --> 00:21:41.560
of the other ones.

00:21:41.560 --> 00:21:44.290
And you can read more about
this in Chet's wonderful post

00:21:44.290 --> 00:21:46.180
about RecyclerView
Prefetch on medium.

00:21:49.210 --> 00:21:52.100
But let's step back a little
bit and talk about, well,

00:21:52.100 --> 00:21:53.130
what happens to jank?

00:21:53.130 --> 00:21:54.730
Well, we saw in
this particular case

00:21:54.730 --> 00:21:58.390
that RecyclerView having bursty
workloads could cause jank.

00:21:58.390 --> 00:22:01.300
But let's talk about sort
of, stepping back, what

00:22:01.300 --> 00:22:06.820
has historically been the
problems for Android and jank?

00:22:06.820 --> 00:22:10.720
So one of the oldest ones
that we've thought about

00:22:10.720 --> 00:22:12.220
is garbage collection.

00:22:12.220 --> 00:22:16.090
Garbage collection historically
had been a significant problem

00:22:16.090 --> 00:22:17.155
on Android.

00:22:17.155 --> 00:22:19.030
But this has been
something that the platform

00:22:19.030 --> 00:22:21.410
has been improving steadily.

00:22:21.410 --> 00:22:24.670
So GC for alloc was essentially
fixed in L with ART.

00:22:24.670 --> 00:22:27.190
I've looked at
hundreds of traces,

00:22:27.190 --> 00:22:31.810
I haven't seen a blocking GC
on any but the most egregiously

00:22:31.810 --> 00:22:33.670
allocating apps.

00:22:33.670 --> 00:22:36.220
GC is not a huge problem.

00:22:36.220 --> 00:22:39.190
But even still, the
runtime keeps improving.

00:22:39.190 --> 00:22:40.720
Runtime keeps
getting better at GC,

00:22:40.720 --> 00:22:44.160
lowering the overhead
of allocation.

00:22:44.160 --> 00:22:47.890
OS Thread scheduling, so this is
a particularly interesting one,

00:22:47.890 --> 00:22:51.430
where on older
versions of the kernel,

00:22:51.430 --> 00:22:53.542
and on older versions
of Android, sometimes

00:22:53.542 --> 00:22:55.750
the platform will just make
a bad decision about when

00:22:55.750 --> 00:22:58.130
to schedule your application.

00:22:58.130 --> 00:23:01.330
This has been improving
greatly, especially in N/O,

00:23:01.330 --> 00:23:03.100
but it is unfortunately,
kernel specific.

00:23:03.100 --> 00:23:04.683
So that means that
it's not guaranteed

00:23:04.683 --> 00:23:07.750
to be in every N or O device.

00:23:07.750 --> 00:23:09.761
But definitely look
for newer devices,

00:23:09.761 --> 00:23:12.010
if you're looking specifically
into thread scheduling,

00:23:12.010 --> 00:23:15.130
if you're trying to make sure
that your work is running

00:23:15.130 --> 00:23:18.310
exactly when you want it to.

00:23:18.310 --> 00:23:19.750
Rendering is an interesting one.

00:23:19.750 --> 00:23:21.881
I work a whole lot on rendering.

00:23:21.881 --> 00:23:23.630
Rendering, specifically,
one of the things

00:23:23.630 --> 00:23:26.260
that I remember Chet and
Ramon talking about years ago,

00:23:26.260 --> 00:23:28.150
has been View Alpha.

00:23:28.150 --> 00:23:32.140
Let's see, there's has
overlapping rendering,

00:23:32.140 --> 00:23:34.847
there's set layer
type hardware, there's

00:23:34.847 --> 00:23:37.180
some other callbacks somewhere,
that I need to remember.

00:23:37.180 --> 00:23:39.100
Well, we tried to improve that.

00:23:39.100 --> 00:23:42.820
So we started adding
Auto-Hardware layer M,

00:23:42.820 --> 00:23:45.550
get that for free, and M+, you
can still use Hardware Layer

00:23:45.550 --> 00:23:46.870
to avoid that problem.

00:23:46.870 --> 00:23:49.360
But we've gotten even
further improvements in N,

00:23:49.360 --> 00:23:51.470
improving the worst case.

00:23:51.470 --> 00:23:53.020
Bitmap uploads are
another one that I

00:23:53.020 --> 00:23:57.160
talked about earlier
that can cause

00:23:57.160 --> 00:23:59.860
a significant amount of delay
in first displaying your bitmap.

00:23:59.860 --> 00:24:03.220
But we added a new feature
in N, prepareToDraw

00:24:03.220 --> 00:24:05.680
on bitmaps, that would
allow bitmap loading

00:24:05.680 --> 00:24:09.040
libraries to asynchronously
start that work early,

00:24:09.040 --> 00:24:12.070
and that's starting
to be adopted by them.

00:24:12.070 --> 00:24:14.560
View Recycling, just
as I said before,

00:24:14.560 --> 00:24:17.260
was another common
cause that basically

00:24:17.260 --> 00:24:20.530
support lib has significantly
improved for you.

00:24:20.530 --> 00:24:24.010
So added in 25, more
improvements to come there.

00:24:26.630 --> 00:24:29.680
And you can go back and watch
the recording of the ART

00:24:29.680 --> 00:24:32.170
session from this I/O if
you want to learn more

00:24:32.170 --> 00:24:34.235
about what ART has been doing.

00:24:34.235 --> 00:24:35.860
But I wanted to go
through all of those

00:24:35.860 --> 00:24:37.318
because I think
that that tells you

00:24:37.318 --> 00:24:39.820
a lot about how the platform
has been improving, and trying

00:24:39.820 --> 00:24:43.090
to get to the point where
the only sources of jank

00:24:43.090 --> 00:24:47.180
in your application are
ones that you can solve.

00:24:47.180 --> 00:24:49.810
So let's talk a little bit about
some of the sources of jank

00:24:49.810 --> 00:24:51.250
that might happen in
an application, that

00:24:51.250 --> 00:24:52.916
might happen because
of something that's

00:24:52.916 --> 00:24:54.584
going wrong inside your app.

00:24:54.584 --> 00:24:55.750
And there are a lot of them.

00:24:55.750 --> 00:24:56.860
But let's just go
really quickly.

00:24:56.860 --> 00:24:58.510
So issues in
RecyclerView, we talked

00:24:58.510 --> 00:25:02.230
about issues with RecyclerView
needing to inflate,

00:25:02.230 --> 00:25:04.360
doing that work at
the last minute,

00:25:04.360 --> 00:25:07.750
lazily, possibly causing
10 milliseconds or more

00:25:07.750 --> 00:25:09.670
of work in a single frame.

00:25:09.670 --> 00:25:14.620
But there's a lot of other
subtle issues in RecylcerView

00:25:14.620 --> 00:25:16.840
that can cause
unnecessary inflation.

00:25:16.840 --> 00:25:18.700
And talk a little
bit more about that.

00:25:18.700 --> 00:25:21.910
So bitmap painting
on the UI thread,

00:25:21.910 --> 00:25:24.220
one of the most common
reasons for your draw callback

00:25:24.220 --> 00:25:25.690
to be very long,
is because you're

00:25:25.690 --> 00:25:28.540
trying to cache some work,
cache some content in a bitmap.

00:25:28.540 --> 00:25:31.516
But unfortunately, drawing
to a software bitmap

00:25:31.516 --> 00:25:33.640
can take a lot of time,
especially if it's anywhere

00:25:33.640 --> 00:25:36.010
near screen size.

00:25:36.010 --> 00:25:39.310
Canvas calls, there are a few
canvas calls, namely draw path

00:25:39.310 --> 00:25:41.500
if you're mutating
your path frequently,

00:25:41.500 --> 00:25:43.400
save layer, that can
be somewhat expensive.

00:25:43.400 --> 00:25:44.983
And we've actually
gone out of our way

00:25:44.983 --> 00:25:46.090
to document some of these.

00:25:46.090 --> 00:25:47.660
And I'll mention this coming up.

00:25:47.660 --> 00:25:50.080
But let's go quickly
to an example of Binder

00:25:50.080 --> 00:25:55.570
because this has been one of
the favorite investigations

00:25:55.570 --> 00:25:59.290
of the Android performance
team in the past release

00:25:59.290 --> 00:26:03.030
has been looking and fixing
binding Binder problems.

00:26:03.030 --> 00:26:07.840
So Binder is the IPC
mechanism on Android.

00:26:07.840 --> 00:26:10.060
If you want to talk
to Window Manager,

00:26:10.060 --> 00:26:12.767
or if the view
hierarchy thinks you

00:26:12.767 --> 00:26:14.350
want to talk to
Window Manager, you're

00:26:14.350 --> 00:26:15.710
probably going through Binder.

00:26:15.710 --> 00:26:18.650
If you're talking to another
person's content provider,

00:26:18.650 --> 00:26:22.960
if you're talking
to surface flinger,

00:26:22.960 --> 00:26:24.950
if you're talking
across IPC, you're

00:26:24.950 --> 00:26:26.200
probably going through Binder.

00:26:26.200 --> 00:26:28.000
And Binder has tracing.

00:26:28.000 --> 00:26:30.610
Now unfortunately, IPC
is often very expensive.

00:26:30.610 --> 00:26:35.020
And truth be told, it can be
really easy to accidentally add

00:26:35.020 --> 00:26:35.950
to your application.

00:26:35.950 --> 00:26:38.890
Here's a particular
screenshot of Systrace

00:26:38.890 --> 00:26:41.620
that has a lot of Binder
transactions going on

00:26:41.620 --> 00:26:43.870
during RecyclerView scroll.

00:26:43.870 --> 00:26:46.967
If you look at it, Binder,
Binder, oh my goodness,

00:26:46.967 --> 00:26:49.300
and then they're just running
another callback on the UI

00:26:49.300 --> 00:26:50.920
thread, running lots of Binder.

00:26:50.920 --> 00:26:52.660
All of these are
pretty significant.

00:26:52.660 --> 00:26:54.160
It's a 21 millisecond frame.

00:26:54.160 --> 00:26:55.630
It's not doing any
inflation, it's

00:26:55.630 --> 00:26:58.330
not doing anything that should
absolutely take that long.

00:26:58.330 --> 00:27:00.760
It's just Binder
overheads doing work

00:27:00.760 --> 00:27:03.500
that they really shouldn't
be doing on the UI thread.

00:27:03.500 --> 00:27:05.181
So tracing Binder
can help a whole lot,

00:27:05.181 --> 00:27:07.680
and that's on by default in the
newest versions of Systrace.

00:27:12.070 --> 00:27:14.320
But to summarize,
there's a lot of reasons.

00:27:14.320 --> 00:27:16.390
And we've documented
a whole lot of them.

00:27:16.390 --> 00:27:18.520
If you go to
d.android.com/vitals,

00:27:18.520 --> 00:27:21.040
we have a lot of the material
in this presentation,

00:27:21.040 --> 00:27:25.540
a lot of those samples that I
went to in more depth with code

00:27:25.540 --> 00:27:30.850
examples, so on and so
forth, on this web site.

00:27:30.850 --> 00:27:32.350
And so now I'm going
to pass it back

00:27:32.350 --> 00:27:34.725
to Chet who's going to talk
about maintaining performance

00:27:34.725 --> 00:27:35.690
in your app.

00:27:35.690 --> 00:27:37.190
CHET HAASE: I should
point out, too,

00:27:37.190 --> 00:27:39.569
that the document that
Chris pointed to is new.

00:27:39.569 --> 00:27:40.360
It was just posted.

00:27:40.360 --> 00:27:41.929
CHRIS CRAIK: Yeah,
just Wednesday.

00:27:41.929 --> 00:27:44.470
CHET HAASE: So if you think the
performance docs on the site,

00:27:44.470 --> 00:27:46.120
you might want to
check it out anyway.

00:27:46.120 --> 00:27:48.490
Much more detailed,
in-depth info.

00:27:48.490 --> 00:27:50.347
And the documentation
team was working

00:27:50.347 --> 00:27:52.180
really closely with the
engineers like Chris

00:27:52.180 --> 00:27:54.270
and other teams to get
the information that

00:27:54.270 --> 00:27:58.450
was really accurate and deep to
help you with this de-janking.

00:27:58.450 --> 00:28:01.330
So let's talk about how
you can find, and fix,

00:28:01.330 --> 00:28:04.300
and actually maintain
your own app performance.

00:28:04.300 --> 00:28:07.360
It boils down to sort of
four steps, you can think of.

00:28:07.360 --> 00:28:10.150
One is that you can gather user
statistics, so actually figure

00:28:10.150 --> 00:28:11.710
out where the problems are.

00:28:11.710 --> 00:28:13.284
You can add your own tracing.

00:28:13.284 --> 00:28:15.700
It's important to note, when
we're looking at all Systrace

00:28:15.700 --> 00:28:21.410
stuff that Chris was showing,
that's not a sampling profiler.

00:28:21.410 --> 00:28:23.270
We're not seeing
per method calls.

00:28:23.270 --> 00:28:26.150
That's not all the stuff that's
going on in your application.

00:28:26.150 --> 00:28:28.540
Those are specific traces
that we have instrumented

00:28:28.540 --> 00:28:30.520
the framework and the
platform code with,

00:28:30.520 --> 00:28:33.340
so the only thing you're
going to see in Systrace

00:28:33.340 --> 00:28:36.880
are the traces that we've
actually added to the platform.

00:28:36.880 --> 00:28:38.906
Because if we add
a ton of traces,

00:28:38.906 --> 00:28:40.780
then it's going to slow
down the application.

00:28:40.780 --> 00:28:43.690
So we add it in the places
where it really makes sense.

00:28:43.690 --> 00:28:45.880
So you can actually add
your own tracing stuff.

00:28:45.880 --> 00:28:47.450
We'll show you how to do that.

00:28:47.450 --> 00:28:49.630
You can add jank tests.

00:28:49.630 --> 00:28:52.360
So maybe you actually
need continuous tests

00:28:52.360 --> 00:28:56.680
so that you can tell when
you implement a change,

00:28:56.680 --> 00:28:58.719
and you have a new build
of your application,

00:28:58.719 --> 00:29:00.010
and your performance goes down.

00:29:00.010 --> 00:29:03.220
Wouldn't that be nice if you
knew that instead of depending

00:29:03.220 --> 00:29:06.190
on lower ratings on Play
Store because your users

00:29:06.190 --> 00:29:07.584
are the first ones to see that?

00:29:07.584 --> 00:29:09.500
Maybe you could actually
have continuous tests

00:29:09.500 --> 00:29:11.090
that can catch that for you.

00:29:11.090 --> 00:29:12.490
And then finally, use the tools.

00:29:12.490 --> 00:29:14.230
He went in-depth on
Systrace, but it's worth

00:29:14.230 --> 00:29:15.700
thinking about some
other ones that

00:29:15.700 --> 00:29:19.540
should be a part of your normal
toolbox when you're developing.

00:29:19.540 --> 00:29:21.760
So one of the things
I should point out

00:29:21.760 --> 00:29:24.910
in looking at the
user stats is this

00:29:24.910 --> 00:29:28.480
is a screenshot of a
dashboard that is now--

00:29:28.480 --> 00:29:31.900
it's actually, it's sort of
a theoretical screenshot.

00:29:31.900 --> 00:29:35.530
We don't actually give gray
boxes, that would mean nothing.

00:29:35.530 --> 00:29:40.630
So this is from a talk that
the Play team gave on Wednesday

00:29:40.630 --> 00:29:42.610
and talked about the
different metrics

00:29:42.610 --> 00:29:44.620
that they can provide
on the Dashboard now.

00:29:44.620 --> 00:29:48.430
So there are metrics that are
being calculated and stored

00:29:48.430 --> 00:29:51.010
on the device, that, depending
on whether the user opts

00:29:51.010 --> 00:29:52.720
into it, may be
uploaded and then it

00:29:52.720 --> 00:29:56.180
can be information on your
Dashboard for your application.

00:29:56.180 --> 00:29:58.060
So you can see what
people are actually

00:29:58.060 --> 00:30:00.710
seeing in the real world,
including jank stats.

00:30:00.710 --> 00:30:03.110
So how many of your
frames are coming in,

00:30:03.110 --> 00:30:06.160
that's sort of a histogram
of these duration buckets.

00:30:06.160 --> 00:30:08.950
So how many frames are
coming in at each level

00:30:08.950 --> 00:30:09.850
of that histogram.

00:30:09.850 --> 00:30:13.630
So you can get an idea, not
just for how your application is

00:30:13.630 --> 00:30:16.420
doing in general, but also
if you just updated it,

00:30:16.420 --> 00:30:20.500
and things got worse,
wouldn't that be nice to know?

00:30:20.500 --> 00:30:25.270
That information that's
being aggregated and shown

00:30:25.270 --> 00:30:28.000
in the Play Dashboard is
actually coming from internals

00:30:28.000 --> 00:30:29.560
that we have in
the platform that

00:30:29.560 --> 00:30:33.490
were injected in the N release,
where we have this thing called

00:30:33.490 --> 00:30:34.650
frame metrics.

00:30:34.650 --> 00:30:37.330
And we have an API
around that as well.

00:30:37.330 --> 00:30:39.730
And we compile this thing
at a very low level.

00:30:39.730 --> 00:30:41.260
But you can listen in on that.

00:30:41.260 --> 00:30:44.650
You can implement this
OnFrameMetricsAvailableListener.

00:30:44.650 --> 00:30:47.920
And get the per frame
callback data, that says, OK,

00:30:47.920 --> 00:30:49.570
here's what the
duration was for each

00:30:49.570 --> 00:30:50.866
of these individual things.

00:30:50.866 --> 00:30:52.240
And if you think
about, if you've

00:30:52.240 --> 00:30:55.450
done the GPU profile, or
the on screen profiler,

00:30:55.450 --> 00:30:58.090
we saw the screenshot earlier,
all of that information

00:30:58.090 --> 00:30:59.710
is exactly the
durations that you get

00:30:59.710 --> 00:31:01.150
from the FrameMetricsListener.

00:31:01.150 --> 00:31:02.320
How long did input take?

00:31:02.320 --> 00:31:03.790
How long did animation take?

00:31:03.790 --> 00:31:05.860
How long was the total
duration of the frame?

00:31:05.860 --> 00:31:07.485
So you can get all
of that information,

00:31:07.485 --> 00:31:09.250
aggregate it yourself,
and then upload

00:31:09.250 --> 00:31:11.620
and analyze to your
heart's content.

00:31:11.620 --> 00:31:15.020
We simplified that a little
bit in v26 of the support lib.

00:31:15.020 --> 00:31:18.910
So the beta release should
have those bits now.

00:31:18.910 --> 00:31:21.970
So instead of listening per
frame and getting the durations

00:31:21.970 --> 00:31:23.440
and then needing
to aggregate them,

00:31:23.440 --> 00:31:25.270
we aggregate them
for you so you can

00:31:25.270 --> 00:31:29.030
get this SparseIntArray of
duration buckets, basically

00:31:29.030 --> 00:31:31.030
a histogram.

00:31:31.030 --> 00:31:34.090
And then again, you can
compile, aggregate this stuff,

00:31:34.090 --> 00:31:36.610
on the device and then
upload it to whatever

00:31:36.610 --> 00:31:39.040
server you choose
to analyze offline.

00:31:39.040 --> 00:31:41.950
So the Play Store Dashboard
does that for you,

00:31:41.950 --> 00:31:43.750
for your overall application.

00:31:43.750 --> 00:31:46.060
But if you want to
instrument particular flows

00:31:46.060 --> 00:31:47.590
in your application
that are really

00:31:47.590 --> 00:31:50.040
sensitive or important
for you to get right,

00:31:50.040 --> 00:31:54.370
then you can choose to do that
with the frame metric stuff.

00:31:54.370 --> 00:31:56.770
Custom tracing-- so as I
said, all of the traces

00:31:56.770 --> 00:31:59.410
that we saw in the Systrace
example that Chris was showing

00:31:59.410 --> 00:32:01.890
were the standard traces
that we have on the platform.

00:32:01.890 --> 00:32:03.880
But you have the ability
to add your own traces

00:32:03.880 --> 00:32:05.480
in your application.

00:32:05.480 --> 00:32:08.560
So you should think about doing
this for some of the things

00:32:08.560 --> 00:32:10.970
that you think might be more
expensive, where you know

00:32:10.970 --> 00:32:15.700
you're triggering
layouts, or whatever

00:32:15.700 --> 00:32:17.420
you want to do it for--

00:32:17.420 --> 00:32:19.355
for when you're binding
views or creating

00:32:19.355 --> 00:32:20.980
things that may be
expensive, maybe you

00:32:20.980 --> 00:32:22.780
want to add a trace
there, and sort of

00:32:22.780 --> 00:32:25.042
see what that time
is going to be,

00:32:25.042 --> 00:32:26.500
and what it looks
like in Systrace.

00:32:26.500 --> 00:32:28.900
It's important to know that
the more you instrument,

00:32:28.900 --> 00:32:31.460
the more time you're
going to spend actually

00:32:31.460 --> 00:32:33.280
outputting the
instrumentation information.

00:32:33.280 --> 00:32:36.310
That's why we don't have
per method instrumentation.

00:32:36.310 --> 00:32:39.100
On one hand, you don't want too
much information in Systrace,

00:32:39.100 --> 00:32:41.141
because then the important
information gets lost.

00:32:41.141 --> 00:32:42.970
But also, you don't
want to actually skew

00:32:42.970 --> 00:32:45.340
your times by the
instrumentation calls

00:32:45.340 --> 00:32:46.820
that you're actually making.

00:32:46.820 --> 00:32:49.670
So same thing is true
for your application.

00:32:49.670 --> 00:32:51.160
So you should think
about, if it's

00:32:51.160 --> 00:32:53.860
going to take greater
than a half a millisecond,

00:32:53.860 --> 00:32:55.614
then the overhead of
the instrumentation

00:32:55.614 --> 00:32:56.780
is going to be in the noise.

00:32:56.780 --> 00:32:58.700
But if it's much
faster than that,

00:32:58.700 --> 00:33:00.700
you probably don't want
to do that, at least not

00:33:00.700 --> 00:33:04.090
on any permanent basis.

00:33:04.090 --> 00:33:06.010
And performance
tests, it's always

00:33:06.010 --> 00:33:07.102
good to have tests anyway.

00:33:07.102 --> 00:33:08.560
Wouldn't it be nice
if you actually

00:33:08.560 --> 00:33:11.690
knew when you were triggering
a performance problem?

00:33:11.690 --> 00:33:14.420
This is especially true
for big apps and big teams.

00:33:14.420 --> 00:33:16.630
So if you have many
developers chucking code

00:33:16.630 --> 00:33:18.740
into a common code
base, it's good to have

00:33:18.740 --> 00:33:21.502
an automated way of detecting
when problems come in.

00:33:21.502 --> 00:33:23.710
If they're not-- if you have
developers chucking code

00:33:23.710 --> 00:33:26.530
in that are not as familiar
with your architecture

00:33:26.530 --> 00:33:28.600
or your practices,
then you want to be

00:33:28.600 --> 00:33:30.550
able to detect that
earlier, instead

00:33:30.550 --> 00:33:32.950
of catching at the user level.

00:33:32.950 --> 00:33:35.170
And you want to,
in particular, have

00:33:35.170 --> 00:33:38.110
tests around the
areas of your UI

00:33:38.110 --> 00:33:39.460
that are more important, right?

00:33:39.460 --> 00:33:42.160
So if there's a common
feed, some common list

00:33:42.160 --> 00:33:44.470
view, RecylerView
situation that people

00:33:44.470 --> 00:33:47.200
are going to be going into
all the time, if that's

00:33:47.200 --> 00:33:49.930
where everybody lands, well,
create some performance

00:33:49.930 --> 00:33:54.310
tests around that, and make
sure that that code stays tight.

00:33:54.310 --> 00:33:58.409
You can gather the
data on the user sides,

00:33:58.409 --> 00:33:59.950
on the device side,
and the app side,

00:33:59.950 --> 00:34:01.990
and FrameMetricsAggregator.

00:34:01.990 --> 00:34:03.770
Or you can also do
it on the host side.

00:34:03.770 --> 00:34:07.760
So you can run these command
line tools, dumpsys gfxinfo,

00:34:07.760 --> 00:34:09.880
that will get all
of that information.

00:34:09.880 --> 00:34:12.020
Gfxinfo, again,
this is the same--

00:34:12.020 --> 00:34:14.020
it's a different view
into exactly the same kind

00:34:14.020 --> 00:34:16.719
of duration data that I was
talking about earlier that you

00:34:16.719 --> 00:34:18.400
see in GPU profiling,
that you see

00:34:18.400 --> 00:34:20.350
in FrameMetrics aggregation.

00:34:20.350 --> 00:34:22.120
And in particular,
you want to watch

00:34:22.120 --> 00:34:24.050
what's going on with the
different percentiles

00:34:24.050 --> 00:34:24.550
of your app.

00:34:24.550 --> 00:34:27.460
If you skip a frame
occasionally, no big deal.

00:34:27.460 --> 00:34:30.969
If occasionally you have a
700 millisecond frame drop,

00:34:30.969 --> 00:34:32.230
that's probably a big deal.

00:34:32.230 --> 00:34:34.480
Or if you have
10% of your frames

00:34:34.480 --> 00:34:37.690
that are actually missing their
boundaries, that's a big deal.

00:34:37.690 --> 00:34:40.840
So just pay attention to,
A, what your app is doing,

00:34:40.840 --> 00:34:43.606
and know what the
performance is like,

00:34:43.606 --> 00:34:45.730
and try to get that
performance as good as you can.

00:34:45.730 --> 00:34:48.489
But also, pay attention to
what's changing over time.

00:34:48.489 --> 00:34:50.230
As you update that
app, make sure

00:34:50.230 --> 00:34:53.317
that you're not losing
performance as you do it.

00:34:53.317 --> 00:34:54.650
And then finally, use the tools.

00:34:54.650 --> 00:34:57.160
So we talked about Profile
GPU Rendering, something

00:34:57.160 --> 00:34:58.930
you can enable in
developer options

00:34:58.930 --> 00:35:02.164
very easily, just sort of
see where things are going,

00:35:02.164 --> 00:35:03.580
what's going on
in the device when

00:35:03.580 --> 00:35:07.800
you fling your RecyclerView
or whatever your common UI

00:35:07.800 --> 00:35:08.620
case is.

00:35:08.620 --> 00:35:09.850
That green line is important.

00:35:09.850 --> 00:35:11.391
If you're going
above the green line,

00:35:11.391 --> 00:35:13.400
you missed the 16
millisecond boundary.

00:35:13.400 --> 00:35:14.650
And you janked a frame.

00:35:14.650 --> 00:35:16.630
This one looks like a
particularly janky frame.

00:35:16.630 --> 00:35:18.505
I don't think they're
making any frame there.

00:35:18.505 --> 00:35:20.200
So at least they're consistent.

00:35:20.200 --> 00:35:22.240
They've got that going for them.

00:35:22.240 --> 00:35:23.740
So you can do that
on the device.

00:35:23.740 --> 00:35:26.080
This is more at the
debugger and developer

00:35:26.080 --> 00:35:28.630
level, just sort of see
where things are at.

00:35:28.630 --> 00:35:30.370
Again, it's using
the same information

00:35:30.370 --> 00:35:32.050
that we compile at
the lowest level,

00:35:32.050 --> 00:35:36.070
and just putting it on the
screen for ease of use.

00:35:36.070 --> 00:35:38.920
Android Studio just came out
with some new profiling tools

00:35:38.920 --> 00:35:40.157
in their latest release.

00:35:40.157 --> 00:35:42.740
They were talking about that in
some of their talks this week.

00:35:42.740 --> 00:35:45.073
So you can check those out
in the recordings on YouTube.

00:35:45.073 --> 00:35:47.050
In particular,
for this audience,

00:35:47.050 --> 00:35:49.150
the CPU monitor will
give you information

00:35:49.150 --> 00:35:51.850
about what's actually going on
in all of these method calls.

00:35:51.850 --> 00:35:53.890
It gives you a good
idea in general

00:35:53.890 --> 00:35:58.150
about where the performance
is going in your app,

00:35:58.150 --> 00:36:00.790
and also the GPU
monitor, which is, again,

00:36:00.790 --> 00:36:03.082
another view into how fast
you're rendering this stuff,

00:36:03.082 --> 00:36:05.373
and whether you're hitting
the 16 millisecond boundary.

00:36:05.373 --> 00:36:07.150
CHRIS CRAIK: Yeah, in
fact, I want to say,

00:36:07.150 --> 00:36:09.610
if you're ever familiar
with the previous tools that

00:36:09.610 --> 00:36:13.180
used to be part of the SDK,
the Trace View, that was built

00:36:13.180 --> 00:36:14.860
into monitor, this
does the same thing,

00:36:14.860 --> 00:36:17.320
but with a far better
UI, far more usable,

00:36:17.320 --> 00:36:20.000
and actually, far more
correct data as well.

00:36:20.000 --> 00:36:23.137
So far, far more advisable.

00:36:23.137 --> 00:36:25.220
CHET HAASE: So the way I
view the different tools.

00:36:25.220 --> 00:36:27.340
So we saw the deep
dive in Systrace.

00:36:27.340 --> 00:36:29.830
And especially when you first
see Systrace, you're like,

00:36:29.830 --> 00:36:31.476
I never want to see
that tool again.

00:36:31.476 --> 00:36:33.100
There's just so much
information there,

00:36:33.100 --> 00:36:35.516
and you're not quite sure what
to do with the information.

00:36:35.516 --> 00:36:37.845
That is the tool that has
all of the information,

00:36:37.845 --> 00:36:39.720
it just takes a little
bit of getting used to

00:36:39.720 --> 00:36:44.110
in using it to see how it
works and how you can divine

00:36:44.110 --> 00:36:46.750
the information you need and
add the custom traces that you

00:36:46.750 --> 00:36:47.440
want.

00:36:47.440 --> 00:36:49.150
I think an easier way
to get into it, is

00:36:49.150 --> 00:36:52.690
you can dip in slowly by using
the much easier to use, higher

00:36:52.690 --> 00:36:55.600
level view of what's going on
with the Android Studio Tools.

00:36:55.600 --> 00:36:58.270
And then if there's a
particular source of jank

00:36:58.270 --> 00:36:59.890
that you're trying
to trace, know

00:36:59.890 --> 00:37:01.840
that Systrace is a
fine grain tool that's

00:37:01.840 --> 00:37:05.390
going to help you trace
that at a much deeper level

00:37:05.390 --> 00:37:07.780
system-wide.

00:37:07.780 --> 00:37:10.330
And finally, not on
topic, but for this

00:37:10.330 --> 00:37:11.972
crowd that's interested
in performance,

00:37:11.972 --> 00:37:13.930
you may want to try out
a developer option that

00:37:13.930 --> 00:37:16.030
will enable this
alternative render, that's

00:37:16.030 --> 00:37:18.880
not on by default.
But you can see

00:37:18.880 --> 00:37:21.460
how your application
behaves with this,

00:37:21.460 --> 00:37:24.010
for possible future
possibilities.

00:37:24.010 --> 00:37:26.680
So it's the Skia Renderer, you
can go into developer options,

00:37:26.680 --> 00:37:28.447
and enable that,
and just make sure

00:37:28.447 --> 00:37:29.780
that there's not an issue there.

00:37:29.780 --> 00:37:31.850
If there is, it'd be
lovely to hear about it.

00:37:31.850 --> 00:37:34.570
That's why we're
mentioning it today.

00:37:34.570 --> 00:37:36.490
There are some resources
that we mentioned.

00:37:36.490 --> 00:37:37.930
I won't bring them up again.

00:37:37.930 --> 00:37:41.080
Again, check out the vitals
page on d.android.com.

00:37:41.080 --> 00:37:45.370
In particular, they have a jank
section called Slow Rendering.

00:37:45.370 --> 00:37:48.310
And there are some
important I/O sessions

00:37:48.310 --> 00:37:49.460
to check out on YouTube.

00:37:49.460 --> 00:37:50.890
They are probably
posted already.

00:37:50.890 --> 00:37:55.120
Tim Murray gave a great overview
about Systrace and system

00:37:55.120 --> 00:37:56.890
performance in general.

00:37:56.890 --> 00:37:58.930
So Android
Performance-- Overview.

00:37:58.930 --> 00:38:01.060
The ART Talk talked about
performance and memory

00:38:01.060 --> 00:38:02.110
improvements.

00:38:02.110 --> 00:38:03.910
They did some
pretty amazing stuff

00:38:03.910 --> 00:38:06.260
on both the runtime side,
runtime improvements,

00:38:06.260 --> 00:38:08.440
as well as the GC side.

00:38:08.440 --> 00:38:11.020
So now they have concurrent
garbage collection.

00:38:11.020 --> 00:38:12.520
There's almost no
pauses anymore,

00:38:12.520 --> 00:38:14.850
until they need to take
a full GC eventually.

00:38:14.850 --> 00:38:16.720
And they can compact
in the foreground.

00:38:16.720 --> 00:38:18.100
You get a minimal
sized heap, you

00:38:18.100 --> 00:38:20.770
get much faster allocations,
as well as collections.

00:38:20.770 --> 00:38:23.920
So the details for all of that
stuff are in the ART talk.

00:38:23.920 --> 00:38:28.420
And then finally, there's a
talk by the Play folks, called

00:38:28.420 --> 00:38:31.445
"No One Likes Crashing Or
Janky Apps," which is true.

00:38:31.445 --> 00:38:33.820
And that's where they talked
about the Dashboard and some

00:38:33.820 --> 00:38:35.319
of the other
facilities that they're

00:38:35.319 --> 00:38:37.300
providing for developers.

00:38:37.300 --> 00:38:38.952
And that is the talk.

00:38:38.952 --> 00:38:39.910
CHRIS CRAIK: All right.

00:38:39.910 --> 00:38:41.710
[APPLAUSE]

00:38:45.010 --> 00:38:48.360
[MUSIC PLAYING]

