WEBVTT
Kind: captions
Language: en

00:00:04.304 --> 00:00:06.220
LAURENCE MORONEY: My
name is Laurence Moroney.

00:00:06.220 --> 00:00:08.730
I'm a developer
advocate here at Google.

00:00:08.730 --> 00:00:11.830
I'm taking a big risk of doing
a talk with a brand new Linux

00:00:11.830 --> 00:00:12.540
laptop.

00:00:12.540 --> 00:00:15.120
So I've been having some tech
challenges here on the podium,

00:00:15.120 --> 00:00:16.620
particularly with
screen resolution.

00:00:16.620 --> 00:00:19.520
So bear with me if any of the
demos go a little bit awry.

00:00:19.520 --> 00:00:21.970
So I'm a developer
advocate here at Google

00:00:21.970 --> 00:00:26.620
I focus on a technology called
Google Play services primarily

00:00:26.620 --> 00:00:28.970
and Google Play services
if you're not-- actually,

00:00:28.970 --> 00:00:31.400
who's familiar with
Google Play services?

00:00:31.400 --> 00:00:32.130
OK, most of you.

00:00:32.130 --> 00:00:34.560
So then I don't need to go
into too much detail on it.

00:00:34.560 --> 00:00:36.100
But basically,
it's a way that we

00:00:36.100 --> 00:00:41.100
have of shipping the runtime
for various Google backend APIs.

00:00:41.100 --> 00:00:44.830
And it's something that we
update roughly every six weeks

00:00:44.830 --> 00:00:48.070
so that we're not going
Android release cycles.

00:00:48.070 --> 00:00:50.990
We can go much faster than the
typical Android release cycles.

00:00:50.990 --> 00:00:53.920
And we ship via the Play
Store, that kind of thing.

00:00:53.920 --> 00:00:56.170
So I've been a developer
advocate at Google

00:00:56.170 --> 00:00:57.300
for about two years.

00:00:57.300 --> 00:00:59.520
Prior to that, I did a
lot of mobile development,

00:00:59.520 --> 00:01:02.780
freelance mobile development,
including quite a few mapping

00:01:02.780 --> 00:01:06.520
apps on the iOS platform and
on the Windows Phone platform.

00:01:06.520 --> 00:01:09.420
And it was an
interesting experience.

00:01:09.420 --> 00:01:11.950
And what I'm trying
to bring today

00:01:11.950 --> 00:01:15.390
is like having used Google Maps
through Google Play services

00:01:15.390 --> 00:01:17.780
and having built various
mapping applications,

00:01:17.780 --> 00:01:21.275
I wanted to come up with a
set of tips for various things

00:01:21.275 --> 00:01:23.650
that you may not realize that
will really, really improve

00:01:23.650 --> 00:01:24.800
the perf of your maps.

00:01:24.800 --> 00:01:27.780
And as perf matter is
the theme of the show,

00:01:27.780 --> 00:01:30.387
hopefully some of these
will be useful to you.

00:01:30.387 --> 00:01:30.970
I'm an author.

00:01:30.970 --> 00:01:34.820
I've authored 20-ish-- I've lost
count-- of computer programming

00:01:34.820 --> 00:01:37.210
books, primarily on
the Microsoft platform.

00:01:37.210 --> 00:01:39.465
But forgive me for that.

00:01:39.465 --> 00:01:41.900
And about two years ago,
I got into writing novels.

00:01:41.900 --> 00:01:45.020
And this is a shameless
self-plug of my newest one,

00:01:45.020 --> 00:01:46.640
which is coming out next month.

00:01:46.640 --> 00:01:49.020
And I'm the host of a show
called "Coffee With A Googler"

00:01:49.020 --> 00:01:50.394
on the Google
Developers channel.

00:01:50.394 --> 00:01:51.800
Anybody watch that?

00:01:51.800 --> 00:01:53.360
Nice, thank you, thank you.

00:01:53.360 --> 00:01:56.290
So that's basically
where what I like to do

00:01:56.290 --> 00:01:59.430
is just grab a Googler, sit
down, have a coffee with them,

00:01:59.430 --> 00:02:01.930
and talk about what they do,
why they do it, how they do it,

00:02:01.930 --> 00:02:05.100
and just try and lift a
little bit of the veil that's

00:02:05.100 --> 00:02:09.000
around Google so that you guys
can see that we're just normal

00:02:09.000 --> 00:02:10.410
guys, normal
developers like you,

00:02:10.410 --> 00:02:12.300
where we love this
technology, and that's

00:02:12.300 --> 00:02:14.740
why we do what we do.

00:02:14.740 --> 00:02:17.800
So the agenda today
is just really talking

00:02:17.800 --> 00:02:19.540
about location
aware applications,

00:02:19.540 --> 00:02:21.800
and looking at some
of these 10 tips

00:02:21.800 --> 00:02:23.860
around building better apps.

00:02:23.860 --> 00:02:25.467
Build better apps
is a mantra that

00:02:25.467 --> 00:02:27.050
Magnus-- if you're
familiar with him--

00:02:27.050 --> 00:02:31.520
and he came up with, the really
why we do what we like to do.

00:02:31.520 --> 00:02:34.550
So we really want to help
you guys build better apps.

00:02:34.550 --> 00:02:36.620
It's very easy to build
mobile applications.

00:02:36.620 --> 00:02:39.280
It's very hard to build really
good mobile applications.

00:02:39.280 --> 00:02:40.270
And it's a journey.

00:02:40.270 --> 00:02:42.892
And it's a journey towards
making them and trying

00:02:42.892 --> 00:02:44.350
to improve them in
any way you can.

00:02:44.350 --> 00:02:45.620
And no matter how
good your app is,

00:02:45.620 --> 00:02:47.420
I think there's always
ways to improve it.

00:02:47.420 --> 00:02:49.880
And we're always here to learn
from you, just as hopefully,

00:02:49.880 --> 00:02:51.140
you can learn from us.

00:02:51.140 --> 00:02:53.280
And with some of these 10 tips,
some of them may apply to you.

00:02:53.280 --> 00:02:54.154
Some of them may not.

00:02:54.154 --> 00:02:56.420
So your mileage may vary.

00:02:56.420 --> 00:02:57.600
OK, tip number one.

00:02:57.600 --> 00:02:59.125
And this one
actually blew my mind

00:02:59.125 --> 00:03:01.500
when I started trying to think
of some of the new things.

00:03:01.500 --> 00:03:04.240
And number one is like with
Android Studio, if you've

00:03:04.240 --> 00:03:06.210
refreshed it and
brought it up to date,

00:03:06.210 --> 00:03:09.430
there's a new Google
Maps activity template

00:03:09.430 --> 00:03:11.350
that ships in Android Studio.

00:03:11.350 --> 00:03:13.480
And for me, I've
been building maps

00:03:13.480 --> 00:03:16.890
with Google Maps for Android
for a year, two years.

00:03:16.890 --> 00:03:20.660
And I got to the stage where
I always bypassed the wizard.

00:03:20.660 --> 00:03:22.406
And I just rolled my own maps.

00:03:22.406 --> 00:03:24.030
And I rolled my own
apps that use maps.

00:03:24.030 --> 00:03:25.600
And if you do that,
you may remember

00:03:25.600 --> 00:03:27.715
that you've got to go to
the developers console.

00:03:27.715 --> 00:03:29.240
And you've got to
register your app.

00:03:29.240 --> 00:03:32.190
You got to remember the
namespace for your Android app.

00:03:32.190 --> 00:03:34.280
You got to turn on the APIs.

00:03:34.280 --> 00:03:35.740
You got to get an
API key for it.

00:03:35.740 --> 00:03:36.880
Oh, sorry, I forgot.

00:03:36.880 --> 00:03:40.070
You got to get the SHA-1 key
for your development machine

00:03:40.070 --> 00:03:40.860
first, right?

00:03:40.860 --> 00:03:41.660
And then you've got to go back.

00:03:41.660 --> 00:03:43.600
And it's all these
ugly steps that you've

00:03:43.600 --> 00:03:45.650
got to go through, all
these hoops that you've

00:03:45.650 --> 00:03:48.170
got to go through just to
get an API key so that you

00:03:48.170 --> 00:03:51.562
can build a mapping app.

00:03:51.562 --> 00:03:53.140
And it's not necessary.

00:03:53.140 --> 00:03:54.640
It's a lot of
friction, particularly

00:03:54.640 --> 00:03:55.625
for new developers.

00:03:55.625 --> 00:03:58.000
But it's one thing that we've
really improved, I believe,

00:03:58.000 --> 00:03:59.450
in the new Android Studio.

00:03:59.450 --> 00:04:01.730
And the idea is that if
you use the Maps template,

00:04:01.730 --> 00:04:03.300
you get an XML file.

00:04:03.300 --> 00:04:05.870
It's called mapactivity.xml
or something like that.

00:04:05.870 --> 00:04:07.550
And it looks a
little bit like this.

00:04:07.550 --> 00:04:09.716
And if you can see in the
comments at the top there,

00:04:09.716 --> 00:04:10.600
there's a URL.

00:04:10.600 --> 00:04:13.010
And that URL is generated
dynamically for you

00:04:13.010 --> 00:04:14.570
based on your app.

00:04:14.570 --> 00:04:16.300
And it remembers the namespace.

00:04:16.300 --> 00:04:18.839
It gets the SHA-1 key,
all that kind of stuff.

00:04:18.839 --> 00:04:20.870
You paste that URL
into your browser.

00:04:20.870 --> 00:04:22.360
You get your API key back.

00:04:22.360 --> 00:04:24.000
You paste your
API key into that.

00:04:24.000 --> 00:04:25.020
And you're done.

00:04:25.020 --> 00:04:28.312
So all those ugly hoops
that I was talking about,

00:04:28.312 --> 00:04:30.430
all that stuff that
gave people like me

00:04:30.430 --> 00:04:34.060
a job teaching you had
to do it has now gone.

00:04:34.060 --> 00:04:37.310
And who's familiar with Udacity?

00:04:37.310 --> 00:04:38.640
You guys, anybody use Udacity?

00:04:38.640 --> 00:04:39.660
Oh, wow, a lot of you.

00:04:39.660 --> 00:04:40.430
It's really cool.

00:04:40.430 --> 00:04:41.610
I love Udacity.

00:04:41.610 --> 00:04:44.000
And I've done a maps
course on Udacity.

00:04:44.000 --> 00:04:46.100
And the maps course had
three modules in it.

00:04:46.100 --> 00:04:48.240
And most of the first
module is teaching you

00:04:48.240 --> 00:04:49.850
how to jump through
all those hoops.

00:04:49.850 --> 00:04:52.000
So it's a lot of time that
I had to spend recording it.

00:04:52.000 --> 00:04:53.666
But more importantly,
it's a lot of time

00:04:53.666 --> 00:04:55.880
that you guys have to
spend watching it in order

00:04:55.880 --> 00:04:57.796
to figure out how to
jump through these hoops.

00:04:57.796 --> 00:04:59.340
But thankfully,
this new template

00:04:59.340 --> 00:05:02.680
that ships with Android Studio
takes all that complexity away

00:05:02.680 --> 00:05:05.616
from you and gets you
quicker at producing maps.

00:05:05.616 --> 00:05:07.490
And when I'm talking
about perf, I'm not just

00:05:07.490 --> 00:05:08.490
talking about runtime perf.

00:05:08.490 --> 00:05:11.200
I'm talking about developer perf
as well, your own performance.

00:05:11.200 --> 00:05:13.160
And hopefully this will
get you into using maps

00:05:13.160 --> 00:05:16.160
a lot more quickly, a lot more
easily, and a lot more friendly

00:05:16.160 --> 00:05:18.350
so that you can focus
on what you're doing.

00:05:18.350 --> 00:05:22.120
OK, tip number two is to
think about lite mode maps.

00:05:22.120 --> 00:05:24.880
Now, it's all very easy to put
a map into your application.

00:05:24.880 --> 00:05:27.430
But I've seen applications,
I'll give one example.

00:05:27.430 --> 00:05:30.670
It was for a sports
complex near where I live.

00:05:30.670 --> 00:05:32.350
And they had this application.

00:05:32.350 --> 00:05:35.047
And they asked me how can they
make this application faster.

00:05:35.047 --> 00:05:37.130
Some of their users had
been complaining about it.

00:05:37.130 --> 00:05:39.088
And they had a map in
the application which was

00:05:39.088 --> 00:05:40.720
directions to where they are.

00:05:40.720 --> 00:05:42.140
And that's all the map did.

00:05:42.140 --> 00:05:44.862
But they had the full map in
there with all of the controls

00:05:44.862 --> 00:05:47.320
and all the panning and zooming
and all that kind of stuff.

00:05:47.320 --> 00:05:48.611
And they used the full control.

00:05:48.611 --> 00:05:50.720
And it took them time
to develop for that when

00:05:50.720 --> 00:05:52.290
most of the
functionality that that

00:05:52.290 --> 00:05:55.610
gives you for all that extra
weight, they never used.

00:05:55.610 --> 00:05:58.890
So it's a common mistake that
developers make because they're

00:05:58.890 --> 00:06:01.030
not aware of Lite Mode maps.

00:06:01.030 --> 00:06:02.450
And we have lite mode maps now.

00:06:02.450 --> 00:06:06.510
It shipped a few months
back for Google Maps.

00:06:06.510 --> 00:06:10.180
And if you follow this URI,
you can learn about it.

00:06:10.180 --> 00:06:11.960
But the idea is
that you trade off

00:06:11.960 --> 00:06:14.150
a little bit of the
interaction in favor

00:06:14.150 --> 00:06:16.950
of having a much lighter
map within your application.

00:06:16.950 --> 00:06:19.710
And some of the things that
are available to you-- sorry,

00:06:19.710 --> 00:06:22.060
I can't see my slides
because of my screen issue.

00:06:22.060 --> 00:06:23.520
So I have to keep turning back.

00:06:23.520 --> 00:06:25.820
Just one sec.

00:06:25.820 --> 00:06:29.340
Like some of the things that
are available to you is-- going

00:06:29.340 --> 00:06:31.552
back to the sports app,
this sports complex app

00:06:31.552 --> 00:06:33.010
that I was talking
about, one thing

00:06:33.010 --> 00:06:34.843
that they really wanted
to do was, OK, well,

00:06:34.843 --> 00:06:37.860
if you can touch on the map,
then can it navigate from where

00:06:37.860 --> 00:06:39.775
you are now to get to us.

00:06:39.775 --> 00:06:42.400
Like if you want to come skating
with us, how do you get there?

00:06:42.400 --> 00:06:43.640
So guess what?

00:06:43.640 --> 00:06:45.120
Lite maps will
actually give that.

00:06:45.120 --> 00:06:46.676
You can launch an activity.

00:06:46.676 --> 00:06:49.050
And you can launch a viewer
directions request from that.

00:06:49.050 --> 00:06:51.770
So you don't lose that
by going to lite maps.

00:06:51.770 --> 00:06:53.994
All the different types--
normal, satellite, hybrid,

00:06:53.994 --> 00:06:55.410
all that kind of
stuff-- are still

00:06:55.410 --> 00:06:57.620
available within lite maps.

00:06:57.620 --> 00:06:59.760
If you like to draw on
your map, like maybe draw

00:06:59.760 --> 00:07:01.900
a circle around the
area that you cover

00:07:01.900 --> 00:07:05.190
or draw polylines for whatever
you would draw, like maybe

00:07:05.190 --> 00:07:06.820
a territory that
you cover as well,

00:07:06.820 --> 00:07:09.020
these are still also available.

00:07:09.020 --> 00:07:11.472
Projection is still
included in API maps.

00:07:11.472 --> 00:07:13.930
And by that, what I mean is
that's calculating the latitude

00:07:13.930 --> 00:07:16.980
and longitude offset based on
the pixels on the map itself,

00:07:16.980 --> 00:07:19.230
rather than just the
pixels on the screen.

00:07:19.230 --> 00:07:20.311
Location is supported.

00:07:20.311 --> 00:07:22.060
So if you're using
location on your phone,

00:07:22.060 --> 00:07:24.900
you can still plot the
location on the map.

00:07:24.900 --> 00:07:26.700
It has partial marker support.

00:07:26.700 --> 00:07:28.076
This is one of the trade-offs.

00:07:28.076 --> 00:07:29.450
If you build an
application where

00:07:29.450 --> 00:07:32.760
you want people to be able
to drag markers around,

00:07:32.760 --> 00:07:36.000
drop them in different places,
and customize them at runtime,

00:07:36.000 --> 00:07:37.780
lite mode is not for you.

00:07:37.780 --> 00:07:39.280
But if you just
want to plot markers

00:07:39.280 --> 00:07:41.487
on a map which are
static, then you

00:07:41.487 --> 00:07:43.070
don't have to trade
that off if you're

00:07:43.070 --> 00:07:44.570
going to use lite mode maps.

00:07:44.570 --> 00:07:46.705
And same partial camera support.

00:07:46.705 --> 00:07:48.330
There's some nice
little applications--

00:07:48.330 --> 00:07:49.840
if you watched my
Udacity course,

00:07:49.840 --> 00:07:52.020
you probably saw where I
built one application where

00:07:52.020 --> 00:07:54.690
you could fly from Dublin to
Tokyo in about two minutes.

00:07:54.690 --> 00:07:56.590
Would that be really nice?

00:07:56.590 --> 00:07:58.160
Or from Tokyo to
Dublin and back.

00:07:58.160 --> 00:08:00.090
And it was this
beautiful panning

00:08:00.090 --> 00:08:02.154
that the camera can
do around the Earth,

00:08:02.154 --> 00:08:03.820
showing the Earth
flying underneath you,

00:08:03.820 --> 00:08:04.740
all that kind of stuff.

00:08:04.740 --> 00:08:07.323
Unfortunately, you can't do that
type of thing with lite maps.

00:08:07.323 --> 00:08:09.490
You'd still need to have
the full Google Maps

00:08:09.490 --> 00:08:11.490
experience to be able to
take advantage of that.

00:08:11.490 --> 00:08:13.364
But if you're thinking
about your application

00:08:13.364 --> 00:08:14.940
and if you're thinking
about you just

00:08:14.940 --> 00:08:16.440
need a basic map
in your application

00:08:16.440 --> 00:08:19.700
that maybe has some polylines,
maybe has some markers,

00:08:19.700 --> 00:08:21.996
but you still need to maybe
launch out the navigation,

00:08:21.996 --> 00:08:23.370
lite mode maps
will work for you.

00:08:23.370 --> 00:08:24.740
And it's much, much lighter.

00:08:24.740 --> 00:08:27.840
And it will perform a lot
better within your app.

00:08:27.840 --> 00:08:32.880
OK, so tip number three is
to consider GeoJSON or KML.

00:08:32.880 --> 00:08:35.820
Now, anybody using either
of these at the moment?

00:08:35.820 --> 00:08:37.039
Nobody, OK.

00:08:37.039 --> 00:08:41.890
So for some types
of applications--

00:08:41.890 --> 00:08:43.544
and I'm going to
demo one in a moment.

00:08:43.544 --> 00:08:44.960
I have an application--
hopefully,

00:08:44.960 --> 00:08:47.120
I can get it to work
on this screen-- which

00:08:47.120 --> 00:08:50.300
plots all of the earthquakes
that happened on Planet Earth

00:08:50.300 --> 00:08:52.310
in the last 24 hours.

00:08:52.310 --> 00:08:54.410
And what happened is
the US government,

00:08:54.410 --> 00:08:58.520
the USGS, has provided
a feed in GeoJSON

00:08:58.520 --> 00:09:01.691
of basically those
earthquakes, including

00:09:01.691 --> 00:09:04.190
the latitude and longitude, the
magnitude of the earthquake,

00:09:04.190 --> 00:09:05.430
and all that type of thing.

00:09:05.430 --> 00:09:10.390
And because they have formatted
their data in GeoJSON,

00:09:10.390 --> 00:09:12.230
the task that I
have as a developer

00:09:12.230 --> 00:09:15.745
to actually build a map to
plot that is insanely easy.

00:09:15.745 --> 00:09:18.120
Now, consider that if you're
building an application that

00:09:18.120 --> 00:09:22.120
maybe needs to plot a lot
of pins on a map, how would

00:09:22.120 --> 00:09:22.710
you do that?

00:09:22.710 --> 00:09:24.790
You might have your
server that's generating

00:09:24.790 --> 00:09:26.220
these pins dynamically.

00:09:26.220 --> 00:09:28.690
And you've probably rolled
your own data format in order

00:09:28.690 --> 00:09:30.050
to download that.

00:09:30.050 --> 00:09:31.460
And then on the
mobile phone, you

00:09:31.460 --> 00:09:34.800
have to write your own parser
to parse that and to plot them.

00:09:34.800 --> 00:09:36.390
And we're all smart developers.

00:09:36.390 --> 00:09:38.280
That's something
that we can all do.

00:09:38.280 --> 00:09:41.760
But have we optimized that
the first time we've built it?

00:09:41.760 --> 00:09:44.570
Have we optimized the data
transfer the very first time

00:09:44.570 --> 00:09:45.220
we've done it?

00:09:45.220 --> 00:09:48.306
Have we optimized the client
for consuming that and plotting

00:09:48.306 --> 00:09:50.180
those pins the very
first time we've done it?

00:09:50.180 --> 00:09:51.920
The answer is probably no.

00:09:51.920 --> 00:09:53.920
And the answer is that
we may have a lot of work

00:09:53.920 --> 00:09:56.830
to do to actually build a
client to be able to plot these.

00:09:56.830 --> 00:10:00.550
But if on your server side,
you encode these in GeoJSON,

00:10:00.550 --> 00:10:02.650
and it's a really
straightforward format,

00:10:02.650 --> 00:10:05.080
and then on your
client side, there's

00:10:05.080 --> 00:10:07.380
a huge set of utility
libraries, they

00:10:07.380 --> 00:10:11.950
will decode the GeoJSON on your
behalf and plot it for you.

00:10:11.950 --> 00:10:15.370
And I'll show a quick demo of
an application that does that.

00:10:15.370 --> 00:10:17.710
And then I'll show you how
much code on the client side

00:10:17.710 --> 00:10:19.250
was required to do this.

00:10:19.250 --> 00:10:21.750
So bear with me
while I change out

00:10:21.750 --> 00:10:24.366
of presenter mode
on the side screen.

00:10:24.366 --> 00:10:27.030
Whoops.

00:10:27.030 --> 00:10:29.040
And see if I can
drag the demo over.

00:10:34.120 --> 00:10:36.730
Wi-Fi in here has not
been behaving for me,

00:10:36.730 --> 00:10:39.400
so it might take a while
for the pins to appear.

00:10:39.400 --> 00:10:42.120
And I can't really drag any
further than that, can I?

00:10:42.120 --> 00:10:43.790
There we go.

00:10:43.790 --> 00:10:45.510
So I'm just running
this in the emulator.

00:10:45.510 --> 00:10:48.550
It's hitting the services at
the moment to download the pins.

00:10:48.550 --> 00:10:49.340
There we go.

00:10:49.340 --> 00:10:51.290
Now the pins are
beginning to appear.

00:10:51.290 --> 00:10:54.920
So this is a very
simple application.

00:10:54.920 --> 00:10:55.850
I got my map.

00:10:55.850 --> 00:10:57.530
I got my standard
controls on my map.

00:10:57.530 --> 00:10:58.730
I can zoom into my map.

00:10:58.730 --> 00:10:59.910
I see these pins.

00:10:59.910 --> 00:11:02.960
These pins are colored based
on the earthquake magnitude.

00:11:02.960 --> 00:11:05.270
So we can see a
green pin here was

00:11:05.270 --> 00:11:08.130
a magnitude of 1.69 earthquake.

00:11:08.130 --> 00:11:11.580
And this blue pin was I guess
a magnitude of less than one.

00:11:11.580 --> 00:11:15.590
So the amount of lines of
code to actually do this,

00:11:15.590 --> 00:11:19.130
it's about two lines of
code to consume the GeoJSON

00:11:19.130 --> 00:11:20.400
and to plot it on a map.

00:11:20.400 --> 00:11:22.400
And I'll show that
code in a second.

00:11:22.400 --> 00:11:26.110
But as you can see,
typical map, lots of pins,

00:11:26.110 --> 00:11:27.860
very, very, easy to develop.

00:11:27.860 --> 00:11:34.470
Now the URL-- this
is one of those Linux

00:11:34.470 --> 00:11:37.430
laptops with a really
large screen resolution.

00:11:37.430 --> 00:11:40.060
But the second
screen is not so big.

00:11:40.060 --> 00:11:42.270
And we get something like this.

00:11:42.270 --> 00:11:46.880
So if I go to the URL,
it should be here.

00:11:46.880 --> 00:11:50.990
Or if you want to open
this URL yourself,

00:11:50.990 --> 00:11:54.202
you can see a little bit
of what GeoJSON looks like.

00:11:58.220 --> 00:12:02.070
Again Wi-Fi here is
not really behaving.

00:12:02.070 --> 00:12:03.070
I'll give that a second.

00:12:07.647 --> 00:12:08.230
You know what?

00:12:08.230 --> 00:12:10.390
I'll come back to it.

00:12:10.390 --> 00:12:12.090
But it gives you the idea.

00:12:12.090 --> 00:12:16.090
And here's what the code looks
like when I had my GeoJSON URL.

00:12:16.090 --> 00:12:18.312
It actually loaded
when I moved it away.

00:12:18.312 --> 00:12:19.270
It'll take it a second.

00:12:19.270 --> 00:12:22.790
So when I have a GeoJSON URL
and I download the GeoJSON data

00:12:22.790 --> 00:12:27.770
into a JSON object from that,
if I'm using the Android Maps

00:12:27.770 --> 00:12:29.370
utils libraries,
all I have to do

00:12:29.370 --> 00:12:31.750
is create a new
GeoJSON layer, and then

00:12:31.750 --> 00:12:32.910
add that layer to my map.

00:12:32.910 --> 00:12:34.400
And that's it.

00:12:34.400 --> 00:12:37.780
I didn't have to write any
code for parsing out the data.

00:12:37.780 --> 00:12:40.030
I didn't have to write any
code for plotting the pins.

00:12:40.030 --> 00:12:41.738
And the people who
have written this code

00:12:41.738 --> 00:12:42.750
have it written as a V1.

00:12:42.750 --> 00:12:43.880
It's an open source library.

00:12:43.880 --> 00:12:45.046
You can see all the changes.

00:12:45.046 --> 00:12:46.830
And it's continually
being optimized.

00:12:46.830 --> 00:12:50.137
So performance of productivity,
if nothing else, it's great.

00:12:50.137 --> 00:12:52.220
But I would say also argue
for performance of like

00:12:52.220 --> 00:12:54.220
if you need to plot a
lot of pins on your map,

00:12:54.220 --> 00:12:56.200
and these pins are
something that your app you

00:12:56.200 --> 00:12:58.010
need to generate server side--

00:12:58.010 --> 00:13:01.860
Like one application that I
wrote when I was freelancing,

00:13:01.860 --> 00:13:04.160
it was for hotel chains.

00:13:04.160 --> 00:13:06.880
And each of these hotel
chains had a curated set

00:13:06.880 --> 00:13:09.360
of things near their hotel
that they wanted guests

00:13:09.360 --> 00:13:10.516
to be interested in.

00:13:10.516 --> 00:13:11.640
And that was a set of pins.

00:13:11.640 --> 00:13:14.150
It was set at latitudes and
longitudes and a little bit

00:13:14.150 --> 00:13:16.220
of metadata about the location.

00:13:16.220 --> 00:13:18.120
They had a server that
would spit that out.

00:13:18.120 --> 00:13:20.140
And this iPhone application
that I had written,

00:13:20.140 --> 00:13:22.784
I had to write a custom parser
to parse that data, to plot it,

00:13:22.784 --> 00:13:24.200
to pin it, all
that kind of thing.

00:13:24.200 --> 00:13:26.880
I wish back then I had
known about GeoJSON.

00:13:26.880 --> 00:13:30.064
And let me drag my GeoJSON over.

00:13:30.064 --> 00:13:31.980
I've got to get this out
of full screen first.

00:13:35.480 --> 00:13:37.340
And you can see a
little bit what GeoJSON

00:13:37.340 --> 00:13:38.760
looks like in the browser.

00:13:38.760 --> 00:13:41.340
It's pretty
straightforward JSON code.

00:13:41.340 --> 00:13:42.940
So this is the code
that was generated

00:13:42.940 --> 00:13:44.900
by the US government's
earthquake service.

00:13:44.900 --> 00:13:48.130
And you can see, you have
JSON, where you just say,

00:13:48.130 --> 00:13:50.790
it's being generated.

00:13:50.790 --> 00:13:52.380
There's a time that was updated.

00:13:52.380 --> 00:13:53.820
But ultimately,
there's a latitude

00:13:53.820 --> 00:13:54.820
and there's a longitude.

00:13:54.820 --> 00:13:56.880
And there's metadata
about the event.

00:13:56.880 --> 00:14:01.380
And all I did, loaded JSON
object with this code, created

00:14:01.380 --> 00:14:04.350
GeoJSON layer, add the
GeoJSON layer to the map,

00:14:04.350 --> 00:14:07.089
and I was done in creating
that mobile application

00:14:07.089 --> 00:14:09.130
that we saw earlier that
was plotting these pins.

00:14:09.130 --> 00:14:10.171
I think it's pretty cool.

00:14:22.190 --> 00:14:24.160
So that was the code
for using GeoJSON.

00:14:24.160 --> 00:14:26.280
In addition to that,
there's also KML.

00:14:26.280 --> 00:14:28.060
It's a very similar context.

00:14:28.060 --> 00:14:32.000
But KML is usually used for
drawing outlines on a map.

00:14:32.000 --> 00:14:33.410
So for example,
you may have seen

00:14:33.410 --> 00:14:35.870
maps that show the
Googleplex and has

00:14:35.870 --> 00:14:38.529
outlines of the actual
buildings in the Googleplex.

00:14:38.529 --> 00:14:41.070
And when you go down to them,
then you have different floors.

00:14:41.070 --> 00:14:42.940
And you can see what's
on different floors.

00:14:42.940 --> 00:14:44.830
Or maybe you see that
in shopping malls.

00:14:44.830 --> 00:14:46.550
There's a great
one on Google Maps.

00:14:46.550 --> 00:14:48.850
The language KML is
a markup language

00:14:48.850 --> 00:14:50.530
that's used to define that.

00:14:50.530 --> 00:14:53.150
And again, if on
your server side,

00:14:53.150 --> 00:14:56.155
you need to generate some
type of dynamic floor

00:14:56.155 --> 00:14:59.637
or outlines on a map, why
not generate it is KML?

00:14:59.637 --> 00:15:01.220
And a very similar
kind of thing here,

00:15:01.220 --> 00:15:03.949
two lines of code to be able
to apply that to your map,

00:15:03.949 --> 00:15:06.490
instead of you thinking in terms
of all the polylines and all

00:15:06.490 --> 00:15:07.790
the floors and all
those kind of things

00:15:07.790 --> 00:15:08.831
that you'd have to do it.

00:15:08.831 --> 00:15:10.800
Makes your life a
little bit easier.

00:15:10.800 --> 00:15:15.120
OK, tip number four-- cluster
is not necessarily a bad word.

00:15:15.120 --> 00:15:16.410
So this is a map.

00:15:16.410 --> 00:15:19.320
Anybody guess what city this is?

00:15:19.320 --> 00:15:20.350
I guess you can read it.

00:15:20.350 --> 00:15:21.980
There's a train station.

00:15:21.980 --> 00:15:24.900
This is the city of
Cardiff in Wales.

00:15:24.900 --> 00:15:26.610
And this is where I
went to university.

00:15:26.610 --> 00:15:28.620
And I'm getting to go
back there next week.

00:15:28.620 --> 00:15:29.900
I'm really excited.

00:15:29.900 --> 00:15:32.190
It's one of my favorite
cities in the world.

00:15:32.190 --> 00:15:34.850
And when I was
there as a student,

00:15:34.850 --> 00:15:36.210
I was a poor broke student.

00:15:36.210 --> 00:15:38.710
And there was a Chinese
restaurant with a really cheap

00:15:38.710 --> 00:15:40.520
lunch that I absolutely loved.

00:15:40.520 --> 00:15:42.790
And it was almost every day
I went there as a student.

00:15:42.790 --> 00:15:45.050
So I went on to-- I
won't say which website.

00:15:45.050 --> 00:15:46.940
I went onto a website
to start looking

00:15:46.940 --> 00:15:49.360
to see if I can find
this Chinese restaurant.

00:15:49.360 --> 00:15:51.930
And I did a search for Chinese
restaurants in Cardiff.

00:15:51.930 --> 00:15:52.987
And I found three.

00:15:52.987 --> 00:15:54.570
And then I went onto
one of them and I

00:15:54.570 --> 00:15:57.560
asked to plot it on a
map, and I got this.

00:15:57.560 --> 00:16:01.390
All right, can you spot the
Chinese restaurant on this map?

00:16:01.390 --> 00:16:03.700
Cardiff is a wonderful city
with lots of restaurants.

00:16:03.700 --> 00:16:06.200
But I can almost guarantee
not every one of those dots

00:16:06.200 --> 00:16:07.200
is a Chinese restaurant.

00:16:07.200 --> 00:16:08.290
There's all kinds
of things there.

00:16:08.290 --> 00:16:09.280
There's sandwich bars.

00:16:09.280 --> 00:16:10.936
There's [INAUDIBLE].

00:16:10.936 --> 00:16:14.221
If you've got sharp eyes,
the dot over on the right,

00:16:14.221 --> 00:16:15.970
the rightmost one is
actually in a prison.

00:16:19.810 --> 00:16:22.960
And no joke, apparently, it's
one of the best restaurants

00:16:22.960 --> 00:16:23.460
in the city.

00:16:23.460 --> 00:16:24.790
I'm going to go visit it.

00:16:24.790 --> 00:16:27.080
And what it is, it's for
rehabilitating the prisoners.

00:16:27.080 --> 00:16:29.845
They give them jobs
as chefs and waiters

00:16:29.845 --> 00:16:30.970
and all that kind of stuff.

00:16:30.970 --> 00:16:33.470
And people say it's one of the
best restaurants in the city.

00:16:33.470 --> 00:16:37.090
I discovered it when I
was looking for something

00:16:37.090 --> 00:16:38.810
completely different.

00:16:38.810 --> 00:16:41.244
But anyway, so the problem
with a map like this one--

00:16:41.244 --> 00:16:42.660
and when I took
this screenshot, I

00:16:42.660 --> 00:16:44.990
was using a really
cheap Chromebook.

00:16:44.990 --> 00:16:47.684
When I was searching for this,
it's like $100 Chromebook.

00:16:47.684 --> 00:16:49.100
And when I have a
map like this, I

00:16:49.100 --> 00:16:51.120
can only see a limited
part of the city.

00:16:51.120 --> 00:16:53.600
And I've got all these
dots on this map.

00:16:53.600 --> 00:16:57.080
And if I pan this map around,
the several dots here,

00:16:57.080 --> 00:16:58.790
they have to pan around as well.

00:16:58.790 --> 00:17:01.900
If I zoom in and out, the map
has to plot where these are.

00:17:01.900 --> 00:17:04.430
And as you can imagine, that
could be very, very slow,

00:17:04.430 --> 00:17:06.930
particularly on a
really cheap Chromebook.

00:17:06.930 --> 00:17:14.349
And so my experience in using
this was very, very poor.

00:17:14.349 --> 00:17:18.069
And here's another example
of when you can cluster pins

00:17:18.069 --> 00:17:21.339
together so that the map is
smart enough that it determines

00:17:21.339 --> 00:17:24.609
that if there's over a
certain number of pins

00:17:24.609 --> 00:17:28.470
in a specific location, instead
of plotting all of those pins,

00:17:28.470 --> 00:17:30.480
it will gather those
pins together and plot

00:17:30.480 --> 00:17:31.581
one entity instead.

00:17:31.581 --> 00:17:32.580
And if you look at this.

00:17:32.580 --> 00:17:33.625
This a map of London.

00:17:33.625 --> 00:17:34.500
And if you look here.

00:17:34.500 --> 00:17:38.490
I believe there's over a
thousand items actually plotted

00:17:38.490 --> 00:17:39.180
on this map.

00:17:39.180 --> 00:17:40.860
You can see there's four 200's.

00:17:40.860 --> 00:17:41.400
There's 100.

00:17:41.400 --> 00:17:42.820
There's a couple of 50s.

00:17:42.820 --> 00:17:47.320
There's 1,070 items actually
being plotted on this map.

00:17:47.320 --> 00:17:51.081
But the number of things being
drawn on the map-- is it nine?

00:17:51.081 --> 00:17:51.580
Yeah.

00:17:51.580 --> 00:17:52.700
There's nine items.

00:17:52.700 --> 00:17:56.090
So if I zoom this map around,
I'm only moving nine items.

00:17:56.090 --> 00:17:58.830
And if I zoom in, then
it will replot this.

00:17:58.830 --> 00:18:00.330
I mean, I can show
a live demo later

00:18:00.330 --> 00:18:01.455
if anybody wants to see it.

00:18:01.455 --> 00:18:02.954
I'm having troubles
with the screen,

00:18:02.954 --> 00:18:04.060
so I won't to show it now.

00:18:04.060 --> 00:18:06.185
But if you've seen clusters
before, if you zoom in,

00:18:06.185 --> 00:18:08.370
then it will pick the
location that you're in.

00:18:08.370 --> 00:18:10.140
And it will intelligently
cluster them.

00:18:10.140 --> 00:18:12.360
But the idea behind that,
first of all, a great user

00:18:12.360 --> 00:18:13.220
experience.

00:18:13.220 --> 00:18:16.110
But second of all, performance,
because as the user

00:18:16.110 --> 00:18:17.790
pans, as the user
zooms around, you're

00:18:17.790 --> 00:18:20.870
only moving eight, nine,
ten entities, instead of

00:18:20.870 --> 00:18:22.930
1,000 entities, which
I would be moving

00:18:22.930 --> 00:18:25.480
if I tried to pan this
map without clustering.

00:18:25.480 --> 00:18:27.010
So clustering, not a bad word.

00:18:27.010 --> 00:18:27.930
It's a good thing.

00:18:27.930 --> 00:18:29.721
I'll skip over the demo
for the time being.

00:18:29.721 --> 00:18:30.690
And I'll show the code.

00:18:30.690 --> 00:18:33.200
Again, the code is
really, really simple.

00:18:33.200 --> 00:18:35.690
If you're reading
your clusters in--

00:18:35.690 --> 00:18:38.620
so we provide an object
in the utils library

00:18:38.620 --> 00:18:40.730
called a cluster manager.

00:18:40.730 --> 00:18:42.960
You create a cluster
manager for your map.

00:18:42.960 --> 00:18:45.320
As you can see here, I
have ClusterManager is new,

00:18:45.320 --> 00:18:49.730
CustomManager of item,
and just this .getmap.

00:18:49.730 --> 00:18:51.450
And then I have cluster items.

00:18:51.450 --> 00:18:55.130
And if I store my locations
as a cluster item.

00:18:55.130 --> 00:18:59.720
Sorry, if just general, I have
a collection of my locations.

00:18:59.720 --> 00:19:02.840
If I create a cluster
item from that location

00:19:02.840 --> 00:19:06.660
and then add those cluster
items to the cluster manager

00:19:06.660 --> 00:19:09.290
and then render the map,
all of that hard work

00:19:09.290 --> 00:19:11.690
of managing the
clusters, of drawing--

00:19:11.690 --> 00:19:13.120
is it 200 in this area?

00:19:13.120 --> 00:19:13.810
Is it 100?

00:19:13.810 --> 00:19:16.850
Is it 50-- of panning and
moving them around, all of that

00:19:16.850 --> 00:19:19.250
work is done for me
by the mapping engine.

00:19:19.250 --> 00:19:21.511
So again, like I said,
this is something

00:19:21.511 --> 00:19:22.510
you could roll yourself.

00:19:22.510 --> 00:19:23.530
And you'd roll a V1.

00:19:23.530 --> 00:19:24.940
But would it be optimized?

00:19:24.940 --> 00:19:26.655
You know, I'm sure there are
some great developers here who

00:19:26.655 --> 00:19:27.970
could build something awesome.

00:19:27.970 --> 00:19:30.080
But it may not be
optimized at V1.

00:19:30.080 --> 00:19:32.480
This is stuff that we've been
working on for some time.

00:19:32.480 --> 00:19:34.210
And this will make
your maps faster.

00:19:34.210 --> 00:19:36.632
And it will greatly improve
your user experience.

00:19:36.632 --> 00:19:39.090
Now, they may not discover a
restaurant in a prison the way

00:19:39.090 --> 00:19:40.100
I did.

00:19:40.100 --> 00:19:44.390
But at least you'll be able to
really, really polish and make

00:19:44.390 --> 00:19:47.820
your mapping apps a lot
more slick when using this.

00:19:47.820 --> 00:19:49.900
OK, next one is
consider something

00:19:49.900 --> 00:19:52.220
called polyline encoding.

00:19:52.220 --> 00:19:55.220
So one of the apps that I
wrote when I was freelancing

00:19:55.220 --> 00:19:59.420
was for a company that provides
services for pet owners.

00:19:59.420 --> 00:20:01.670
And in some of the major
cities like New York City,

00:20:01.670 --> 00:20:04.270
there is a big business
of hiring people

00:20:04.270 --> 00:20:07.200
to walk your dog
while you are at work.

00:20:07.200 --> 00:20:10.510
But if I hire somebody to
walk my dog when I'm at work,

00:20:10.510 --> 00:20:13.490
how do I know they
actually walked my dog?

00:20:13.490 --> 00:20:15.455
And so part of this
application-- I

00:20:15.455 --> 00:20:16.830
couldn't put a
beacon on the dog.

00:20:16.830 --> 00:20:18.330
Maybe some day
that would be good.

00:20:18.330 --> 00:20:21.120
But part of this application,
part of the service

00:20:21.120 --> 00:20:24.240
was that your dog walker would
then run this application

00:20:24.240 --> 00:20:25.690
while they're walking the dog.

00:20:25.690 --> 00:20:27.970
You would ask them to walk
in a particular location.

00:20:27.970 --> 00:20:30.190
And then it would
plot-- a little bit

00:20:30.190 --> 00:20:31.650
like you've probably
all seen apps

00:20:31.650 --> 00:20:34.430
for managing if you go for a
run or if you go for a bike ride

00:20:34.430 --> 00:20:35.439
and you can plot that.

00:20:35.439 --> 00:20:36.230
Same kind of thing.

00:20:36.230 --> 00:20:37.440
And it would plot the dog walk.

00:20:37.440 --> 00:20:39.314
And it would plot when
the dog walk happened.

00:20:39.314 --> 00:20:41.790
And you could even plot
when you paused for a little

00:20:41.790 --> 00:20:43.150
while you were walking the dog.

00:20:43.150 --> 00:20:46.070
And you could figure out why you
would pause for a little while

00:20:46.070 --> 00:20:47.320
while you're walking a dog.

00:20:47.320 --> 00:20:52.035
And all this type of thing was
very valuable to the subscriber

00:20:52.035 --> 00:20:53.910
because now they can
see that this money they

00:20:53.910 --> 00:20:56.670
paid to a dog walker, the
dog really was being walked.

00:20:56.670 --> 00:20:59.130
Now, when you map
a route like that,

00:20:59.130 --> 00:21:00.710
you generate a lot of data.

00:21:00.710 --> 00:21:02.560
And I'll give one data here.

00:21:02.560 --> 00:21:03.530
This isn't a dog walk.

00:21:03.530 --> 00:21:04.710
This is a bike ride.

00:21:04.710 --> 00:21:06.350
This is a bike ride
that my wife and I

00:21:06.350 --> 00:21:08.590
did about three weeks ago.

00:21:08.590 --> 00:21:10.490
And we did this
26-mile bike ride

00:21:10.490 --> 00:21:12.830
on the east side of Seattle.

00:21:12.830 --> 00:21:15.820
And I took a look at the
data dump for this bike ride.

00:21:15.820 --> 00:21:19.670
And it was 3,008 data
points were collected

00:21:19.670 --> 00:21:21.220
when I did this bike ride.

00:21:21.220 --> 00:21:23.910
So the data points that were
collected were the longitude ,

00:21:23.910 --> 00:21:26.330
the latitude, the time,
the speed I was going

00:21:26.330 --> 00:21:28.790
at, the elevation, all
that type of thing.

00:21:28.790 --> 00:21:32.010
And the service that
provides these data points

00:21:32.010 --> 00:21:33.290
would give me an XML dump.

00:21:33.290 --> 00:21:35.020
And I downloaded that XML dump.

00:21:35.020 --> 00:21:36.200
And I took a look at it.

00:21:36.200 --> 00:21:38.380
And it was 1.3
megabytes of data.

00:21:38.380 --> 00:21:39.710
That's a lot of data.

00:21:39.710 --> 00:21:41.540
Now, to be fair on
the service, they

00:21:41.540 --> 00:21:44.690
have a lot more data than
just latitude and longitude.

00:21:44.690 --> 00:21:47.500
When I'm drawing the line, all I
want is latitude and longitude.

00:21:47.500 --> 00:21:49.950
So a lot of that data,
a lot of that size

00:21:49.950 --> 00:21:52.510
is because of really useful
data like speed and elevation

00:21:52.510 --> 00:21:54.600
and that type of thing.

00:21:54.600 --> 00:21:58.340
But when I took a look at if
I want to just draw a line,

00:21:58.340 --> 00:22:00.530
like in my dog
walker scenario, I

00:22:00.530 --> 00:22:03.910
did a polyline encoding of my
latitude and longitude data

00:22:03.910 --> 00:22:05.230
from this plot.

00:22:05.230 --> 00:22:08.600
And my 26-mile bike
ride, 3,008 data points,

00:22:08.600 --> 00:22:11.790
when using polyline
encoding was about 30K.

00:22:11.790 --> 00:22:15.510
OK, that's a lot less
than 1.3 megabytes, right?

00:22:15.510 --> 00:22:19.120
And so if you're building an
application that does something

00:22:19.120 --> 00:22:22.550
like my dog walker or
plots anything on a map

00:22:22.550 --> 00:22:25.289
and you need to store that data,
consider polyline encoding.

00:22:25.289 --> 00:22:27.080
I'm not going to go
into the algorithm now.

00:22:27.080 --> 00:22:28.454
It's quite an
involved algorithm.

00:22:28.454 --> 00:22:31.670
But it basically turns the
latitude and longitude numbers

00:22:31.670 --> 00:22:33.260
into-- it string encodes them.

00:22:33.260 --> 00:22:34.790
It ASCII encodes them.

00:22:34.790 --> 00:22:36.750
And it takes about
eight to 10 bytes

00:22:36.750 --> 00:22:39.670
per latitude-longitude
pair to be able to do that.

00:22:39.670 --> 00:22:43.050
And that's where I came with
30K for 3,000 odd points.

00:22:43.050 --> 00:22:45.220
I'm just rounding it
to 10 bytes per one.

00:22:45.220 --> 00:22:47.500
The URL here-- sorry
if it's hard to see.

00:22:47.500 --> 00:22:49.150
But I'm sure the
slides will be shared.

00:22:49.150 --> 00:22:52.660
We do actually have, on
the Google Maps website,

00:22:52.660 --> 00:22:54.826
the polyline encoding
algorithm is there.

00:22:54.826 --> 00:22:55.450
But guess what?

00:22:55.450 --> 00:22:56.908
You don't need to
write it yourself

00:22:56.908 --> 00:22:58.650
because we've
written it for you.

00:22:58.650 --> 00:23:00.520
So if you want to
get set of data

00:23:00.520 --> 00:23:03.100
and you want to polyline
encode it, you can do so.

00:23:03.100 --> 00:23:04.930
So on your server,
for example, you

00:23:04.930 --> 00:23:07.000
could polyline encode
something like this,

00:23:07.000 --> 00:23:09.809
so it's 30K instead
of 1.3 megabytes.

00:23:09.809 --> 00:23:11.350
And then on your
client, you're going

00:23:11.350 --> 00:23:13.690
to download that 30K
string and the libraries

00:23:13.690 --> 00:23:16.120
will decode that for
you into a set of points

00:23:16.120 --> 00:23:18.080
that you can then plot
on a map like this.

00:23:18.080 --> 00:23:20.484
So again, great
perf improvements.

00:23:20.484 --> 00:23:22.400
You don't need to write
all this for yourself.

00:23:22.400 --> 00:23:25.540
You don't need to store all
this type of data for yourself.

00:23:25.540 --> 00:23:27.830
And just use the libraries
that are out there.

00:23:27.830 --> 00:23:31.630
And again, as I've been saying,
they're optimized for you.

00:23:31.630 --> 00:23:33.781
So here's my favorite map again.

00:23:33.781 --> 00:23:37.390
And tip six is really
around curated locations.

00:23:37.390 --> 00:23:39.070
So one of the things
that I've found

00:23:39.070 --> 00:23:42.380
that provides great value
in-- I spoke a little bit.

00:23:42.380 --> 00:23:46.610
I created a hotels app
that had mapping in it.

00:23:46.610 --> 00:23:48.550
And one of the things
that was of great value

00:23:48.550 --> 00:23:50.640
to our customers,
the hotels, was

00:23:50.640 --> 00:23:54.150
that instead of a blind API
call to something like a places

00:23:54.150 --> 00:23:58.400
API that just throws a bunch
of places at the user that

00:23:58.400 --> 00:24:00.560
have been generated
by Google's algorithm,

00:24:00.560 --> 00:24:03.060
it was much better for
the customer experience

00:24:03.060 --> 00:24:04.820
for something curated.

00:24:04.820 --> 00:24:09.550
So the concierge of the hotel
has tried this restaurant

00:24:09.550 --> 00:24:10.720
and loved it.

00:24:10.720 --> 00:24:12.750
We want to tell that
to our customers.

00:24:12.750 --> 00:24:14.950
He's been to this museum,
and it was awesome.

00:24:14.950 --> 00:24:16.830
We want to tell that
to our customers.

00:24:16.830 --> 00:24:22.520
So there's a dichotomy between
having a pure, just curated set

00:24:22.520 --> 00:24:25.990
of content, or having
something that's API driven,

00:24:25.990 --> 00:24:28.680
so you can take advantage of
the universe of information

00:24:28.680 --> 00:24:30.430
that Google API's
can give to you.

00:24:30.430 --> 00:24:32.950
Well, there's also a happy
medium in between them.

00:24:32.950 --> 00:24:34.820
And this happy
medium is, go ahead,

00:24:34.820 --> 00:24:38.210
build your curated content,
store it in a local database

00:24:38.210 --> 00:24:39.190
so it's fast.

00:24:39.190 --> 00:24:40.800
The user doesn't
need to be connected

00:24:40.800 --> 00:24:42.050
or anything like that.

00:24:42.050 --> 00:24:42.900
But guess what?

00:24:42.900 --> 00:24:47.230
These locations in the
places API have an ID.

00:24:47.230 --> 00:24:50.160
So why not just store that ID
in your local database as well

00:24:50.160 --> 00:24:51.930
and get the best of both worlds?

00:24:51.930 --> 00:24:55.960
So now for example, I
go to my hotel scenario.

00:24:55.960 --> 00:24:58.420
Best 10 restaurants within
a mile of the hotel.

00:24:58.420 --> 00:24:59.930
The hotel has picked please.

00:24:59.930 --> 00:25:01.420
The hotel might
have a relationship

00:25:01.420 --> 00:25:03.003
with these that will
give you a coupon

00:25:03.003 --> 00:25:06.140
or have pictures that they've
taken of these restaurants.

00:25:06.140 --> 00:25:08.080
But for the user
experience, you can also

00:25:08.080 --> 00:25:12.180
use the places ID to
call the places API,

00:25:12.180 --> 00:25:14.270
and to get back information
that Google provides

00:25:14.270 --> 00:25:17.100
about that place, such as
reviews, such as a Street

00:25:17.100 --> 00:25:19.987
View, so you can see what
the restaurant looks like,

00:25:19.987 --> 00:25:22.070
such as the online menu,
and everything that would

00:25:22.070 --> 00:25:23.730
be available in Google Reviews.

00:25:23.730 --> 00:25:27.050
So a great way to really
optimize your maps or location

00:25:27.050 --> 00:25:30.770
experience for you users is to
curate, curate, curate, and use

00:25:30.770 --> 00:25:32.600
the places API smartly.

00:25:32.600 --> 00:25:35.880
This map of my future
visit to Cardiff

00:25:35.880 --> 00:25:38.010
was an example where
the places API really

00:25:38.010 --> 00:25:39.085
wasn't used that smartly.

00:25:39.085 --> 00:25:41.460
It was like, this guy's looking
for a Chinese restaurant.

00:25:41.460 --> 00:25:43.560
Let's plot everything
that's associated

00:25:43.560 --> 00:25:46.312
with food within a two-mile
radius of his hotel.

00:25:46.312 --> 00:25:48.270
And this really doesn't
help me because there's

00:25:48.270 --> 00:25:50.670
no way I'm going to click
on every one of those dots

00:25:50.670 --> 00:25:51.900
to check out that restaurant.

00:25:51.900 --> 00:25:52.460
OK?

00:25:52.460 --> 00:25:54.020
I ended up finding
the prison one

00:25:54.020 --> 00:25:56.561
that I've been joking about just
because it was off by itself

00:25:56.561 --> 00:25:59.040
on the right-hand side.

00:25:59.040 --> 00:26:02.990
OK, location and sensor
optimization is our next one.

00:26:02.990 --> 00:26:05.670
Now, if you're using location
services on your phone,

00:26:05.670 --> 00:26:08.534
guess what, it can
eat your battery.

00:26:08.534 --> 00:26:10.950
With Android, we have this
thing called the Fused Location

00:26:10.950 --> 00:26:14.030
Provider that allows you to pick
different levels of location

00:26:14.030 --> 00:26:14.860
access.

00:26:14.860 --> 00:26:18.380
The top most level is
you're using the GPS,

00:26:18.380 --> 00:26:20.970
you're using the radio,
you're a Wi-Fi signal,

00:26:20.970 --> 00:26:23.890
using lots of other sensors to
be able to determine location.

00:26:23.890 --> 00:26:26.450
But of course, the more
accurate, the more expensive

00:26:26.450 --> 00:26:28.050
it can be on battery life.

00:26:28.050 --> 00:26:30.370
So you really, really be
careful and really optimize

00:26:30.370 --> 00:26:34.091
how you're using the
location services.

00:26:34.091 --> 00:26:36.590
First of all, you don't always
need to turn them on on start

00:26:36.590 --> 00:26:37.095
up.

00:26:37.095 --> 00:26:39.220
One thing that we've noticed
when working with apps

00:26:39.220 --> 00:26:40.970
and when looking at
apps a lot of the time

00:26:40.970 --> 00:26:43.620
is, as soon as the app opens,
boom, I need to use location.

00:26:43.620 --> 00:26:46.125
And there's one app that I've
used for when I ride my bike.

00:26:46.125 --> 00:26:47.250
And that's what it gave me.

00:26:47.250 --> 00:26:50.420
And I'm like, I'm in my garage
pumping up the tires of my bike

00:26:50.420 --> 00:26:50.920
right now.

00:26:50.920 --> 00:26:51.711
And I open the app.

00:26:51.711 --> 00:26:53.400
Why do you need my location now?

00:26:53.400 --> 00:26:57.040
How often are you going to
be pinging the GPS to be

00:26:57.040 --> 00:26:58.740
able to get my location now?

00:26:58.740 --> 00:27:01.370
It might be 20 minutes before
I actually start riding.

00:27:01.370 --> 00:27:04.390
So think about, as you're
building for location, starting

00:27:04.390 --> 00:27:05.560
at the appropriate time.

00:27:05.560 --> 00:27:07.380
With activity recognition
on your phone,

00:27:07.380 --> 00:27:09.140
you can get really
smart about that.

00:27:09.140 --> 00:27:11.690
You don't even need
to-- I mean, you'll

00:27:11.690 --> 00:27:14.900
ping the user for permission
to use location services.

00:27:14.900 --> 00:27:17.160
And in Android M, we
do that at the point

00:27:17.160 --> 00:27:19.100
that the location service
has been accessed,

00:27:19.100 --> 00:27:21.777
rather than when the
app is first installed.

00:27:21.777 --> 00:27:24.110
But once you've done that,
you can start using something

00:27:24.110 --> 00:27:25.240
like activity recognition.

00:27:25.240 --> 00:27:27.840
Say, OK, Laurence is
now riding his bike.

00:27:27.840 --> 00:27:29.827
Let's start pinging
for location services.

00:27:29.827 --> 00:27:31.410
Doesn't always have
to be at start up.

00:27:31.410 --> 00:27:34.030
And it's a common
mistake that we see.

00:27:34.030 --> 00:27:37.200
Secondly, a lot of times
for good user experience,

00:27:37.200 --> 00:27:39.160
you turn on your
location services.

00:27:39.160 --> 00:27:40.380
You open a map.

00:27:40.380 --> 00:27:42.070
And then you wait.

00:27:42.070 --> 00:27:44.670
And you wait for
like a few seconds

00:27:44.670 --> 00:27:47.340
maybe, or maybe a little bit
longer, for it to actually plot

00:27:47.340 --> 00:27:48.820
where you are right now.

00:27:48.820 --> 00:27:51.870
There is a little
used and really cool

00:27:51.870 --> 00:27:55.440
getLastKnownLocation
on the location API.

00:27:55.440 --> 00:27:57.845
And what that will do is
that the last known location

00:27:57.845 --> 00:27:58.470
that you're at.

00:27:58.470 --> 00:27:59.290
It may not always be right.

00:27:59.290 --> 00:28:01.010
It may not always be
where you are now.

00:28:01.010 --> 00:28:02.020
Particularly if
you travel a lot,

00:28:02.020 --> 00:28:04.730
it's kind of funny where it's--
I might open an app that using

00:28:04.730 --> 00:28:05.590
getLastLocation.

00:28:05.590 --> 00:28:06.760
And I live in Seattle.

00:28:06.760 --> 00:28:09.357
And it will show me I'm
in Seattle until location

00:28:09.357 --> 00:28:11.190
initializes properly
and then say, actually,

00:28:11.190 --> 00:28:11.800
you are in Dallas.

00:28:11.800 --> 00:28:13.150
So it doesn't always work great.

00:28:13.150 --> 00:28:14.790
But in some scenarios
it works really,

00:28:14.790 --> 00:28:19.189
really well to just get your
user into using the location

00:28:19.189 --> 00:28:21.480
and seeing where they are,
and then maybe, for example,

00:28:21.480 --> 00:28:23.840
seeing restaurants or whatever
around them very quickly.

00:28:23.840 --> 00:28:26.006
And it's something that's
really worth investigating

00:28:26.006 --> 00:28:28.000
for a great user experience.

00:28:28.000 --> 00:28:30.632
Maintaining a best
estimate is also

00:28:30.632 --> 00:28:31.840
something that's really good.

00:28:31.840 --> 00:28:34.560
When you receive location
updates from the Fused Location

00:28:34.560 --> 00:28:37.327
Provider, there can be
random noise in there.

00:28:37.327 --> 00:28:39.160
You've probably seen
some applications where

00:28:39.160 --> 00:28:40.280
it's showing your bike ride.

00:28:40.280 --> 00:28:40.770
And you're going.

00:28:40.770 --> 00:28:42.460
And you're like this,
you're like this, like this.

00:28:42.460 --> 00:28:43.810
And then there's
one point over here.

00:28:43.810 --> 00:28:45.010
And then you're
back in like this,

00:28:45.010 --> 00:28:46.468
and like this, and
like this again.

00:28:46.468 --> 00:28:48.540
And what that
application is doing

00:28:48.540 --> 00:28:50.750
is that's just receiving
updates and plotting them

00:28:50.750 --> 00:28:53.200
without really thinking about
them, without doing anything

00:28:53.200 --> 00:28:53.880
smart.

00:28:53.880 --> 00:28:57.220
There's good things in there
for maintaining a best estimate.

00:28:57.220 --> 00:28:58.350
We've provided some code.

00:28:58.350 --> 00:29:00.090
It's on the Google
Developer site

00:29:00.090 --> 00:29:03.370
for smartly maintaining a
best estimate like that.

00:29:03.370 --> 00:29:05.680
I'd strongly recommend to
go and take a look at it.

00:29:05.680 --> 00:29:07.730
And then secondly, to
adjust the Fused Location

00:29:07.730 --> 00:29:08.694
Provider as needed.

00:29:08.694 --> 00:29:11.110
I mentioned before, there are
different tiers of the Fused

00:29:11.110 --> 00:29:12.250
Location Provider.

00:29:12.250 --> 00:29:15.130
And you can change
them on the fly.

00:29:15.130 --> 00:29:19.230
And again, if you're
building an application that

00:29:19.230 --> 00:29:22.880
needs to plot your GPS
location every few seconds

00:29:22.880 --> 00:29:24.719
like for a bike
ride, it's pretty

00:29:24.719 --> 00:29:26.760
obvious you need to keep
it on the highest level.

00:29:26.760 --> 00:29:29.300
But maybe you're not building
an application that does that.

00:29:29.300 --> 00:29:30.855
Maybe you're building
an application,

00:29:30.855 --> 00:29:33.480
for example, that says, find the
nearest coffee shops near you.

00:29:33.480 --> 00:29:36.426
You turn on the Fused Location
Provider to the highest level.

00:29:36.426 --> 00:29:37.550
You find out where you are.

00:29:37.550 --> 00:29:39.091
And then you turn
it right off again.

00:29:39.091 --> 00:29:40.070
Or you turn it down.

00:29:40.070 --> 00:29:41.130
That type of thing.

00:29:41.130 --> 00:29:42.630
It's a really,
really powerful tool.

00:29:42.630 --> 00:29:45.024
But like any powerful tool,
you have to use it wisely.

00:29:45.024 --> 00:29:46.690
So remember, the
higher the sensitivity,

00:29:46.690 --> 00:29:47.523
the higher the cost.

00:29:47.523 --> 00:29:49.830
And your users don't like it
if you spend their battery

00:29:49.830 --> 00:29:52.110
life flippantly.

00:29:52.110 --> 00:29:56.102
A bad habit that people do is to
use overlays to segregate data.

00:29:56.102 --> 00:29:57.560
And you've got to
be really, really

00:29:57.560 --> 00:29:59.400
careful when using overlays.

00:29:59.400 --> 00:30:01.980
So for example, in the
earthquakes example

00:30:01.980 --> 00:30:04.950
that I showed earlier on, there
were different colored pins

00:30:04.950 --> 00:30:06.820
for different magnitude
of earthquake.

00:30:06.820 --> 00:30:08.790
And there's an argument
for you to put each

00:30:08.790 --> 00:30:10.360
of these on a different layer.

00:30:10.360 --> 00:30:12.880
So then, from the user
experience point of view,

00:30:12.880 --> 00:30:15.580
you could say, OK,
turn off the layer

00:30:15.580 --> 00:30:17.460
of low magnitude
earthquakes so I can just

00:30:17.460 --> 00:30:18.880
see the high magnitude ones.

00:30:18.880 --> 00:30:21.990
Or vice versa, that type
of thing, so the user

00:30:21.990 --> 00:30:23.540
has this really nice experience.

00:30:23.540 --> 00:30:25.590
And it's very easy
for you to develop

00:30:25.590 --> 00:30:28.721
because turning layers on
and off is very, very simple.

00:30:28.721 --> 00:30:30.720
But you've got to be
really, really careful when

00:30:30.720 --> 00:30:33.680
using layers and overlays
like this because if you think

00:30:33.680 --> 00:30:36.880
about it, there's 20 different
types of earthquake magnitude,

00:30:36.880 --> 00:30:38.800
and I now have 20
different layers,

00:30:38.800 --> 00:30:40.940
and I'm using a
low powered device,

00:30:40.940 --> 00:30:42.840
if I start dragging
my map around,

00:30:42.840 --> 00:30:44.870
I'm replotting 20
different layers.

00:30:44.870 --> 00:30:46.970
And each of those pins
and each of those layers

00:30:46.970 --> 00:30:49.510
has to have its relative
coordinates plotted based

00:30:49.510 --> 00:30:51.420
on its latitude and
longitude, and perf

00:30:51.420 --> 00:30:52.960
can be killed as a result.

00:30:52.960 --> 00:30:55.810
So my recommendation would
be unless you absolutely

00:30:55.810 --> 00:30:58.665
have to use layers, avoid
using too many of them.

00:30:58.665 --> 00:31:01.040
Great examples of layers you
probably see in Google Maps,

00:31:01.040 --> 00:31:02.990
like traffic is a good layer.

00:31:02.990 --> 00:31:06.980
So I like when I'm using Google
Maps that I don't see traffic

00:31:06.980 --> 00:31:08.500
until I ask for it.

00:31:08.500 --> 00:31:10.130
And then I turn on
the traffic layer.

00:31:10.130 --> 00:31:11.560
And if I'm dragging
my map around

00:31:11.560 --> 00:31:14.420
to see my location, say,
from here to the airport,

00:31:14.420 --> 00:31:17.380
then I understand that I'm
getting a perf hit because

00:31:17.380 --> 00:31:18.520
of all this extra data.

00:31:18.520 --> 00:31:20.460
But I've asked for
this extra data.

00:31:20.460 --> 00:31:21.990
So I definitely
recommend that when

00:31:21.990 --> 00:31:24.890
you're using overlays,
just be very, very

00:31:24.890 --> 00:31:26.170
careful about using them.

00:31:26.170 --> 00:31:29.590
Design your application sensibly
so that the number of overlays

00:31:29.590 --> 00:31:32.480
that you are using is really
based on what the user needs.

00:31:32.480 --> 00:31:35.040
And don't forget to give your
users the option, of course--

00:31:35.040 --> 00:31:36.873
like in the case of the
traffic one- to turn

00:31:36.873 --> 00:31:39.020
overlays on and off.

00:31:39.020 --> 00:31:40.740
OK, tip nine, using beacons.

00:31:40.740 --> 00:31:42.950
And the demo gods haven't
really been with me today.

00:31:42.950 --> 00:31:44.200
So I can't really demo this.

00:31:44.200 --> 00:31:46.760
But how many of you
have used beacons?

00:31:46.760 --> 00:31:47.260
Oh, wow.

00:31:47.260 --> 00:31:47.801
A lot of you.

00:31:47.801 --> 00:31:49.270
Cool.

00:31:49.270 --> 00:31:51.640
So beacons, I find,
are a lot of fun.

00:31:51.640 --> 00:31:54.800
I have a few Estimote Beacons
up here on stage with me.

00:31:54.800 --> 00:31:58.070
And one of the things that
with beacons is that sometimes

00:31:58.070 --> 00:32:00.140
a lot of the samples that
I've seen with beacons

00:32:00.140 --> 00:32:02.550
and a lot of the methodologies
I've seen with beacons

00:32:02.550 --> 00:32:05.140
are unnecessarily complicated.

00:32:05.140 --> 00:32:07.250
And they can be quite
difficult for the user

00:32:07.250 --> 00:32:08.562
as well as for the developer.

00:32:08.562 --> 00:32:09.520
Let me give an example.

00:32:09.520 --> 00:32:10.980
I've seen a scenario
where beacons

00:32:10.980 --> 00:32:12.560
could be used at a bus stop.

00:32:12.560 --> 00:32:14.660
So you put a beacon
like this on a bus stop.

00:32:14.660 --> 00:32:16.810
And you write an
application for your phone,

00:32:16.810 --> 00:32:18.620
so that when your
application is open

00:32:18.620 --> 00:32:20.180
and it's sniffing
for the beacons

00:32:20.180 --> 00:32:22.130
and it gets the idea
of this beacon and then

00:32:22.130 --> 00:32:24.050
it knows which bus
stop that you're at,

00:32:24.050 --> 00:32:25.750
and then it will give
you a bus schedule

00:32:25.750 --> 00:32:27.160
for buses at that bus stop.

00:32:27.160 --> 00:32:28.290
Great, right?

00:32:28.290 --> 00:32:30.460
Any of you see the drawback?

00:32:30.460 --> 00:32:32.530
Trick question.

00:32:32.530 --> 00:32:33.133
What's that?

00:32:33.133 --> 00:32:34.260
AUDIENCE: [INAUDIBLE]

00:32:34.260 --> 00:32:36.260
LAURENCE MORONEY: I wasn't
thinking of that one.

00:32:36.260 --> 00:32:37.780
But yeah, that is a good one.

00:32:37.780 --> 00:32:39.410
And the sticky on
this isn't very good.

00:32:39.410 --> 00:32:40.430
They keep falling off.

00:32:40.430 --> 00:32:44.010
But more, it's a case of this
broadcasts a unique namespace

00:32:44.010 --> 00:32:45.800
and ID anyway.

00:32:45.800 --> 00:32:47.820
So why do I need to register?

00:32:47.820 --> 00:32:50.789
I can just sniff that
namespace and ID at any point.

00:32:50.789 --> 00:32:52.330
And I can build an
application that's

00:32:52.330 --> 00:32:55.230
based on sniffing
that namespace and ID.

00:32:55.230 --> 00:32:58.970
And in Google, a few
weeks back, we actually

00:32:58.970 --> 00:33:03.040
ran a competition for
people to build applications

00:33:03.040 --> 00:33:04.000
based on beacons.

00:33:04.000 --> 00:33:07.760
And for the competition-- I won
a prize in the competition--

00:33:07.760 --> 00:33:10.360
I came up with the idea of
virtualizing these beacons.

00:33:10.360 --> 00:33:12.020
So instead of
thinking of a beacon

00:33:12.020 --> 00:33:15.550
in terms of absolute
sense, like this beacon is

00:33:15.550 --> 00:33:17.840
at this particular bus stop
and needing to register

00:33:17.840 --> 00:33:19.720
and having that
kind of thing, there

00:33:19.720 --> 00:33:24.200
are scenarios where you
want beacons anywhere

00:33:24.200 --> 00:33:26.754
to be used to be
able to do something.

00:33:26.754 --> 00:33:27.920
Now, that sounds very vague.

00:33:27.920 --> 00:33:28.930
So let me give you an example.

00:33:28.930 --> 00:33:30.080
What I wrote was a game.

00:33:30.080 --> 00:33:34.780
And my game was a virtual
tour around some locations.

00:33:34.780 --> 00:33:36.570
So I had these three locations.

00:33:36.570 --> 00:33:38.040
I work in Google Kirkland.

00:33:38.040 --> 00:33:40.540
I had these three beacons
around Google Kirkland.

00:33:40.540 --> 00:33:42.760
And I knew the ID
of these beacons.

00:33:42.760 --> 00:33:47.220
And I built a little server
side application that said,

00:33:47.220 --> 00:33:49.960
the beacon with this ID
is in the barista cafe.

00:33:49.960 --> 00:33:52.620
The beacon with this ID
is in-- I can't remember.

00:33:52.620 --> 00:33:53.770
It was in registration.

00:33:53.770 --> 00:33:56.300
And the beacon with this ID
is in such-and-such a meeting

00:33:56.300 --> 00:33:56.950
room.

00:33:56.950 --> 00:34:00.210
And then, when somebody played
the game, the idea of the game

00:34:00.210 --> 00:34:02.580
was that there's this
animated character who talks

00:34:02.580 --> 00:34:04.190
to you through cyberspace.

00:34:04.190 --> 00:34:07.650
I have a picture of her here.

00:34:07.650 --> 00:34:10.840
There's a bunch of videos, these
CGI videos that are on YouTube,

00:34:10.840 --> 00:34:11.889
of her talking to you.

00:34:11.889 --> 00:34:14.940
And she's guiding you, saying,
can you go to this location.

00:34:14.940 --> 00:34:17.190
And then the location is
what's printed at the bottom.

00:34:17.190 --> 00:34:19.030
In this case, it was
Building B Barista.

00:34:19.030 --> 00:34:20.570
And then you got to go
there and play a game.

00:34:20.570 --> 00:34:22.290
And then she tells you
to go to the next one.

00:34:22.290 --> 00:34:23.664
And you go there
and play a game.

00:34:23.664 --> 00:34:26.630
But the idea is that by
virtualizing the beacons,

00:34:26.630 --> 00:34:30.989
anybody could take any set of
three beacons anywhere-- maybe

00:34:30.989 --> 00:34:32.699
bus stop beacons,
or maybe beacons

00:34:32.699 --> 00:34:35.110
around the conference
center here-- and turn that

00:34:35.110 --> 00:34:36.560
into the same game.

00:34:36.560 --> 00:34:38.897
You didn't have to be playing
it in Google Kirkland.

00:34:38.897 --> 00:34:40.980
And that's the concept
that I'm talking about when

00:34:40.980 --> 00:34:42.350
I say to virtualize beacons.

00:34:42.350 --> 00:34:44.710
It's really, really powerful.

00:34:44.710 --> 00:34:47.150
Another great example if
you're building for customers

00:34:47.150 --> 00:34:49.670
would be, for example,
department stores.

00:34:49.670 --> 00:34:50.986
So there are Macy's.

00:34:50.986 --> 00:34:53.110
There is one just across
the road here in the mall.

00:34:53.110 --> 00:34:54.560
There's one near where I live.

00:34:54.560 --> 00:34:57.080
Big department stores
like Macy's, instead

00:34:57.080 --> 00:35:00.420
of you registering a particular
beacon in a particular Macy's

00:35:00.420 --> 00:35:03.740
location somewhere, you could
say the beacon of this ID

00:35:03.740 --> 00:35:08.030
is in the Menswear
in Macy's in Dallas.

00:35:08.030 --> 00:35:11.220
Another one is in the Menswear
in Bellevue in Washington.

00:35:11.220 --> 00:35:12.130
That type of thing.

00:35:12.130 --> 00:35:15.810
So then when you use
location services to say,

00:35:15.810 --> 00:35:17.930
oh, this user is in Washington.

00:35:17.930 --> 00:35:19.710
He or she is in Bellevue.

00:35:19.710 --> 00:35:23.140
And let's start sniffing
the beacons that we can see.

00:35:23.140 --> 00:35:25.910
Ah, I've matched this
beacon against the Menswear.

00:35:25.910 --> 00:35:29.430
And now I'm able to give
an experience for Menswear

00:35:29.430 --> 00:35:29.940
in Macy's.

00:35:29.940 --> 00:35:31.130
That type of thing.

00:35:31.130 --> 00:35:32.920
So virtualizing
beacons can actually

00:35:32.920 --> 00:35:34.456
be really, really powerful.

00:35:34.456 --> 00:35:36.330
I'm going to open source
that game if anybody

00:35:36.330 --> 00:35:38.670
wants to-- email me if you
want to take a look at it.

00:35:38.670 --> 00:35:39.880
It's a whole lot of fun.

00:35:39.880 --> 00:35:43.522
I hired a professional actress
to voice this character.

00:35:43.522 --> 00:35:44.230
It's really cool.

00:35:44.230 --> 00:35:46.271
I'll see if I can run it
on my phone in a moment.

00:35:46.271 --> 00:35:48.620
But the Wi-Fi hasn't
been behaving.

00:35:48.620 --> 00:35:51.614
So tip 10 we're on to next.

00:35:51.614 --> 00:35:53.780
A lot of the tips that I've
been talking about today

00:35:53.780 --> 00:35:55.110
actually are part of this.

00:35:55.110 --> 00:35:57.820
We have a thing called
the API utility library.

00:35:57.820 --> 00:35:59.530
If you build anything
to do with maps,

00:35:59.530 --> 00:36:02.310
I strongly recommend you
go and download this today.

00:36:02.310 --> 00:36:04.260
Download the samples
for this today.

00:36:04.260 --> 00:36:05.290
Dissect this today.

00:36:05.290 --> 00:36:07.860
Because a lot of the hips
that I've been going through

00:36:07.860 --> 00:36:11.490
have been encapsulated
in APIs that are in this.

00:36:11.490 --> 00:36:15.230
So GeoJSON and KML that I spoke
about are available in this.

00:36:15.230 --> 00:36:18.182
So your decoders for
Android are in there.

00:36:18.182 --> 00:36:20.140
Heat maps are something
I haven't spoken about.

00:36:20.140 --> 00:36:23.710
But if you want to plot a heat
map around a particular area,

00:36:23.710 --> 00:36:25.350
like thunderstorms.

00:36:25.350 --> 00:36:27.670
I hear the thunderstorm
is coming tonight.

00:36:27.670 --> 00:36:29.420
So if you wanted,
instead of just plotting

00:36:29.420 --> 00:36:32.107
pins for thunderstorms
based on the concentration

00:36:32.107 --> 00:36:33.690
of thunderstorms in
a particular area,

00:36:33.690 --> 00:36:35.250
to actually build
a heat map, which

00:36:35.250 --> 00:36:36.795
would give the user a
better-- or the earthquakes

00:36:36.795 --> 00:36:38.310
is another one--
to give the user

00:36:38.310 --> 00:36:41.810
a better feeling of what is
really happening with the data.

00:36:41.810 --> 00:36:43.027
Heat maps are great.

00:36:43.027 --> 00:36:44.610
You can customize
your markers instead

00:36:44.610 --> 00:36:46.070
of just the usual regular pins.

00:36:46.070 --> 00:36:48.650
You can customize them and have
a whole lot of fun with them.

00:36:48.650 --> 00:36:51.920
Clusters, which is probably
my single favorite feature--

00:36:51.920 --> 00:36:53.670
if you've ever built
any map applications,

00:36:53.670 --> 00:36:55.640
clusters are really your friend.

00:36:55.640 --> 00:36:57.670
All that cluster manager
stuff is in there.

00:36:57.670 --> 00:36:59.650
The polyline encoding
that I spoke about,

00:36:59.650 --> 00:37:02.090
so the libraries to turn
latitude and longitude

00:37:02.090 --> 00:37:05.450
into a few bytes so that you
can store, decode them, make

00:37:05.450 --> 00:37:07.410
your life a lot
easier is in there.

00:37:07.410 --> 00:37:10.266
Things such as calculating
distance between two points.

00:37:10.266 --> 00:37:11.890
It's not really a
straight line because

00:37:11.890 --> 00:37:13.520
of the curvature of the earth.

00:37:13.520 --> 00:37:15.760
Things like that, those type
of distance calculations

00:37:15.760 --> 00:37:16.720
are in there.

00:37:16.720 --> 00:37:18.105
Area of a location, same thing.

00:37:18.105 --> 00:37:20.230
When you think about
curvature of the Earth as well

00:37:20.230 --> 00:37:22.164
as contours, that's in there.

00:37:22.164 --> 00:37:23.580
Heading calculations
are in there.

00:37:23.580 --> 00:37:24.840
And it's all open source.

00:37:24.840 --> 00:37:26.640
And there's a really
teeny tiny URL there.

00:37:26.640 --> 00:37:27.348
Sorry about that.

00:37:27.348 --> 00:37:29.720
Hopefully, when those
slides are shared,

00:37:29.720 --> 00:37:31.680
you'll be able to see them.

00:37:31.680 --> 00:37:33.210
But wait, there's more.

00:37:33.210 --> 00:37:36.980
And good-- what's the word?

00:37:36.980 --> 00:37:38.657
Commercial sense, anyway.

00:37:38.657 --> 00:37:40.240
What are those late
night commercials?

00:37:40.240 --> 00:37:41.612
What are they called?

00:37:41.612 --> 00:37:42.570
AUDIENCE: Infomercials.

00:37:42.570 --> 00:37:43.910
LAURENCE MORONEY:
Infomercials, thank you.

00:37:43.910 --> 00:37:46.220
In good infomercial
sense-- wait, there's more.

00:37:46.220 --> 00:37:48.136
So there's lots of other
great stuff with maps

00:37:48.136 --> 00:37:49.710
that I didn't have
time to fit in.

00:37:49.710 --> 00:37:52.224
Maps on Android Wear is
something that we shipped.

00:37:52.224 --> 00:37:54.390
So you can actually have a
little map on your watch,

00:37:54.390 --> 00:37:56.410
like great for
navigation applications,

00:37:56.410 --> 00:37:57.420
that type of thing.

00:37:57.420 --> 00:37:59.880
And there's something called
ambient mode, which turns it

00:37:59.880 --> 00:38:02.710
down into a low contrast map, a
very dark one, when you're not

00:38:02.710 --> 00:38:06.410
moving your watch around
to save battery life.

00:38:06.410 --> 00:38:08.360
The camera, to play
with the camera

00:38:08.360 --> 00:38:11.840
is really interesting to
create very dramatic scenarios.

00:38:11.840 --> 00:38:14.800
There are 3D plots you may
have seen on Google Maps.

00:38:14.800 --> 00:38:17.680
And when you combine those 3D
plots with satellite imagery,

00:38:17.680 --> 00:38:19.880
you can create really
interesting, fun,

00:38:19.880 --> 00:38:21.950
beautiful fly-arounds of cities.

00:38:21.950 --> 00:38:24.380
And again, they perform
really, really well.

00:38:24.380 --> 00:38:28.210
Street View, also known in
my opinion as Best Tech Ever.

00:38:28.210 --> 00:38:28.984
OK?

00:38:28.984 --> 00:38:30.400
Street View was
the tech that made

00:38:30.400 --> 00:38:31.690
me fall in love with Google.

00:38:31.690 --> 00:38:33.430
And I tell this
story all the time.

00:38:33.430 --> 00:38:35.400
And this is a true story.

00:38:35.400 --> 00:38:38.040
And earlier on at the
beginning of the presentation,

00:38:38.040 --> 00:38:39.660
I said I write books.

00:38:39.660 --> 00:38:43.980
And I wrote this
book back in 2011.

00:38:43.980 --> 00:38:46.770
And it was a science
fiction book, most of which

00:38:46.770 --> 00:38:49.970
was based in the Navajo
reservation in New Mexico,

00:38:49.970 --> 00:38:52.940
and some of which was based
in a small town in Japan

00:38:52.940 --> 00:38:54.930
just outside of Nagasaki.

00:38:54.930 --> 00:38:57.010
And after the book
was published,

00:38:57.010 --> 00:39:00.260
within the same week,
coincidentally enough,

00:39:00.260 --> 00:39:02.940
I received two emails
from readers-- one

00:39:02.940 --> 00:39:05.300
from the town in New Mexico
that the book is based.

00:39:05.300 --> 00:39:06.860
It's called Shiprock.

00:39:06.860 --> 00:39:10.240
And one from Omura in Japan.

00:39:10.240 --> 00:39:11.850
And they said, we love the book.

00:39:11.850 --> 00:39:14.090
It's so cool that our
town was in this book.

00:39:14.090 --> 00:39:15.680
This is fabulous.

00:39:15.680 --> 00:39:17.026
When did you visit?

00:39:17.026 --> 00:39:18.650
You know, when did
you write this book?

00:39:18.650 --> 00:39:21.252
If you ever come back,
let's grab a coffee together

00:39:21.252 --> 00:39:22.210
or something like that.

00:39:22.210 --> 00:39:23.380
This is fabulous.

00:39:23.380 --> 00:39:26.380
And I was like, I've never
been to either of those towns.

00:39:26.380 --> 00:39:28.565
And I did everything
using Street View.

00:39:28.565 --> 00:39:29.940
You know, I'd open
up Street View

00:39:29.940 --> 00:39:31.000
and I walked around the town.

00:39:31.000 --> 00:39:32.550
And one of the
scenes in this book

00:39:32.550 --> 00:39:34.190
is in the high
school in Shiprock.

00:39:34.190 --> 00:39:36.610
And apparently, I nailed
it, what it looks like.

00:39:36.610 --> 00:39:38.160
And I was like, I've
never even been.

00:39:38.160 --> 00:39:39.909
I'd love to go someday.

00:39:39.909 --> 00:39:41.450
But it was all thanks
to Street View.

00:39:41.450 --> 00:39:44.175
That's why I love Street View,
to me, AKA Best Tech Ever.

00:39:44.175 --> 00:39:46.550
And think about the things
that you can do for your users

00:39:46.550 --> 00:39:49.330
by having Street
View in your apps.

00:39:49.330 --> 00:39:51.940
Marker visualizations, custom
markers I've mentioned already.

00:39:51.940 --> 00:39:52.440
Sorry.

00:39:52.440 --> 00:39:53.680
Another one is geofencing.

00:39:53.680 --> 00:39:56.250
Anybody build anything or
familiar with geofencing?

00:39:56.250 --> 00:39:57.190
Oh, cool.

00:39:57.190 --> 00:39:57.810
Nice.

00:39:57.810 --> 00:39:59.360
So geofencing, the
idea is you can

00:39:59.360 --> 00:40:00.610
pick a latitude and longitude.

00:40:00.610 --> 00:40:02.300
You can define a
radius around that,

00:40:02.300 --> 00:40:05.080
and generate an alarm when
something enters or exits

00:40:05.080 --> 00:40:06.050
that area.

00:40:06.050 --> 00:40:08.580
And I used to have this
app that I used at home

00:40:08.580 --> 00:40:12.610
and my family still use it, so
that when my daughter started

00:40:12.610 --> 00:40:15.620
driving, we asked that she
use this app so that we

00:40:15.620 --> 00:40:17.290
could know where she is.

00:40:17.290 --> 00:40:18.790
But one of the
downsides of this app

00:40:18.790 --> 00:40:20.940
was that whenever she
came home and went

00:40:20.940 --> 00:40:23.400
through the geofence
for home, a sound would

00:40:23.400 --> 00:40:25.170
play on everybody's phone.

00:40:25.170 --> 00:40:29.300
Now, my dog got to associate the
sound with my daughter coming

00:40:29.300 --> 00:40:29.820
home.

00:40:29.820 --> 00:40:32.140
And my dog loves my
daughter to bits.

00:40:32.140 --> 00:40:33.830
So he would hear the
sound on the phone.

00:40:33.830 --> 00:40:35.970
And he'd go crazy.

00:40:35.970 --> 00:40:37.340
He would go run to the garage.

00:40:37.340 --> 00:40:39.020
And bang, bang, bang,
bang on the door,

00:40:39.020 --> 00:40:40.936
so we could open the
garage so he could go out

00:40:40.936 --> 00:40:42.870
and he could greet my
daughter coming home.

00:40:42.870 --> 00:40:45.180
And so one day as
an experiment, I

00:40:45.180 --> 00:40:47.870
decided to get the wave file
of the same sound and play it.

00:40:47.870 --> 00:40:50.470
Poor dog went nuts.

00:40:50.470 --> 00:40:51.470
My daughter wasn't home.

00:40:51.470 --> 00:40:52.130
I opened the garage.

00:40:52.130 --> 00:40:53.180
He had to run out to the garage.

00:40:53.180 --> 00:40:55.160
He had to run around the
garage, that kind of thing.

00:40:55.160 --> 00:40:56.100
And it took a
little while for him

00:40:56.100 --> 00:40:57.940
to be satisfied that she
wasn't actually there.

00:40:57.940 --> 00:41:00.148
At that point, I was tempted
to play the sound again.

00:41:00.148 --> 00:41:02.980
But I'm not that cruel.

00:41:02.980 --> 00:41:04.430
So some of the
scenarios that can

00:41:04.430 --> 00:41:07.013
be enabled by geofencing I just
think are really, really cool.

00:41:07.013 --> 00:41:08.330
You can trick your dog with it.

00:41:08.330 --> 00:41:11.490
Or you can build applications
that are good for families

00:41:11.490 --> 00:41:13.270
or whatever using geofencing.

00:41:13.270 --> 00:41:15.380
And one thing that I
actually built once

00:41:15.380 --> 00:41:19.940
was a virtual reality
game that used geofencing.

00:41:19.940 --> 00:41:22.210
So once you ran into a
particular area, then

00:41:22.210 --> 00:41:24.257
you have augmented
reality in that area.

00:41:24.257 --> 00:41:26.590
And then you have to do things
within augmented reality.

00:41:26.590 --> 00:41:27.673
It was a whole lot of fun.

00:41:27.673 --> 00:41:30.260
And then finally, the activity
recognition that I mentioned.

00:41:30.260 --> 00:41:32.070
The activity
recognition APIs, they

00:41:32.070 --> 00:41:34.544
will give you back a
percentage likelihood

00:41:34.544 --> 00:41:35.710
that you're doing something.

00:41:35.710 --> 00:41:38.010
They're not entirely
100% accurate.

00:41:38.010 --> 00:41:40.122
They will say, hey, at
this moment in time,

00:41:40.122 --> 00:41:41.830
there's a 20% chance
that you're running,

00:41:41.830 --> 00:41:43.160
but you're probably
standing still.

00:41:43.160 --> 00:41:43.951
That type of thing.

00:41:43.951 --> 00:41:47.080
So it takes a little
bit of working

00:41:47.080 --> 00:41:48.860
with them and a little
bit of intelligence

00:41:48.860 --> 00:41:50.810
to be able to use them
very, very accurately.

00:41:50.810 --> 00:41:53.180
But they are pretty good.

00:41:53.180 --> 00:41:54.800
OK, so contact.

00:41:54.800 --> 00:41:56.460
My Twitter is I'm at @lmoroney.

00:41:56.460 --> 00:41:59.245
If you've any questions for
me, it's lmoroney@google.

00:41:59.245 --> 00:42:01.960
On Plus, I'm
+laurencemoroney, or Facebook,

00:42:01.960 --> 00:42:05.146
it's
facebook.com/laurence.moroney.

00:42:05.146 --> 00:42:06.020
With that, thank you.

00:42:06.020 --> 00:42:08.182
Sorry for the few technical
hiccups that we had.

00:42:08.182 --> 00:42:09.556
And if anybody
has any questions?

00:42:09.556 --> 00:42:13.190
[APPLAUSE]

00:42:13.190 --> 00:42:18.040
[MUSIC PLAYING]

