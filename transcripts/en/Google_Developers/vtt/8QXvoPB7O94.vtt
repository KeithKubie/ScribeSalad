WEBVTT
Kind: captions
Language: en

00:00:09.820 --> 00:00:12.270
MALE SPEAKER: So yeah,
this is going to be a quiz.

00:00:12.270 --> 00:00:16.200
So if you're not on the Wi-Fi,
get yourself on the Wi-Fi now.

00:00:16.200 --> 00:00:18.240
The username and
password is on there.

00:00:18.240 --> 00:00:20.940
And then once you've done that,
if you want to go to this URL

00:00:20.940 --> 00:00:24.770
and make up your own
username and password.

00:00:24.770 --> 00:00:27.860
Obviously not the same username
and password, or a bunch of you

00:00:27.860 --> 00:00:29.401
will be on the same account.

00:00:29.401 --> 00:00:30.900
You won't be able
to get to that URL

00:00:30.900 --> 00:00:34.040
if you're not on that Wi-Fi
network, so make sure you are.

00:00:34.040 --> 00:00:36.550
And if you're watching this on
the live stream, tough luck,

00:00:36.550 --> 00:00:37.050
I'm afraid.

00:00:37.050 --> 00:00:39.790
You've just got to play
along using your brain.

00:00:39.790 --> 00:00:41.500
And you can write
things down on paper

00:00:41.500 --> 00:00:44.090
and score yourself if you want.

00:00:44.090 --> 00:00:46.560
The reason I'm asking you
for a username and password

00:00:46.560 --> 00:00:49.610
is just so you can switch
devices halfway through in case

00:00:49.610 --> 00:00:51.330
your phone starts
running out of battery,

00:00:51.330 --> 00:00:53.034
and you want to
switch to your laptop.

00:00:53.034 --> 00:00:54.700
Just use the same
username and password,

00:00:54.700 --> 00:00:56.110
and everything will work.

00:00:56.110 --> 00:00:58.970
The password is stored in
plain text on my machine.

00:00:58.970 --> 00:01:01.490
So don't use your credit
card number or anything

00:01:01.490 --> 00:01:04.050
like that unless you're
intending to make a donation,

00:01:04.050 --> 00:01:07.670
and that will be gratefully
received, thank you very much.

00:01:07.670 --> 00:01:09.500
I'm going to assume
everyone's ready to go.

00:01:09.500 --> 00:01:11.890
I will keep the URL in
the corner of the screen,

00:01:11.890 --> 00:01:17.750
so if anyone loses it, you'll
be able to pick it back up.

00:01:17.750 --> 00:01:19.520
I hacked this
together on a plane.

00:01:19.520 --> 00:01:22.080
You could probably break
it by trying to break it,

00:01:22.080 --> 00:01:24.360
so please don't
try and break it.

00:01:24.360 --> 00:01:26.770
I've made it so little
Bobby Tables can play.

00:01:26.770 --> 00:01:28.450
That's not going to break it.

00:01:28.450 --> 00:01:29.950
But there are
probably other things.

00:01:29.950 --> 00:01:32.140
You could probably doss it,
so please don't do that.

00:01:32.140 --> 00:01:35.399
And I want to stress that
this quiz is pretty tough.

00:01:35.399 --> 00:01:36.940
I've seen it get
the better of people

00:01:36.940 --> 00:01:40.530
who do this kind of study of
browser quirks for a living.

00:01:40.530 --> 00:01:43.055
So if you're the kind of
person who gets really angry

00:01:43.055 --> 00:01:45.220
and starts flipping over
tables when you don't win,

00:01:45.220 --> 00:01:49.180
then just maybe stay away from
the tables for a little while,

00:01:49.180 --> 00:01:50.220
OK?

00:01:50.220 --> 00:01:52.420
Of course, what
kind of a quiz would

00:01:52.420 --> 00:01:55.870
be complete without a prize?

00:01:55.870 --> 00:01:58.560
The Chromebook Pixel is
Google's latest laptop

00:01:58.560 --> 00:02:02.190
featuring an I5 1.8 gigahertz
dual core processor,

00:02:02.190 --> 00:02:04.640
four gigabytes of RAM, and
a touch screen with a higher

00:02:04.640 --> 00:02:06.682
DPI than a MacBook Pro.

00:02:06.682 --> 00:02:08.350
Couldn't get hold
of one of those.

00:02:08.350 --> 00:02:08.849
Sorry.

00:02:08.849 --> 00:02:10.924
They wouldn't let me.

00:02:10.924 --> 00:02:13.369
But what I did get
is a Chromecast

00:02:13.369 --> 00:02:14.910
so I've got one of
those to give away

00:02:14.910 --> 00:02:16.490
for whoever gets
the highest score.

00:02:16.490 --> 00:02:19.800
So it's not quite a Pixel,
but it's very, very good.

00:02:19.800 --> 00:02:20.990
So let's start.

00:02:20.990 --> 00:02:22.747
Let's start off really simple.

00:02:22.747 --> 00:02:24.830
And so the URL's there on
the bottom of the screen

00:02:24.830 --> 00:02:25.750
if you need it again.

00:02:25.750 --> 00:02:27.900
But here's a nice, easy start.

00:02:27.900 --> 00:02:29.990
You've all worked with
images in HTML, right?

00:02:29.990 --> 00:02:34.319
OK, so here's a div, but it has
a source like an image might.

00:02:34.319 --> 00:02:35.860
Which browsers do
you think are going

00:02:35.860 --> 00:02:37.650
to make a request
for that image?

00:02:37.650 --> 00:02:39.420
Now, on your phones
or on your laptops,

00:02:39.420 --> 00:02:41.129
you should be presented
with the options.

00:02:41.129 --> 00:02:43.670
So you pick which ones you think
are going to make a request,

00:02:43.670 --> 00:02:44.920
and then hit "submit."

00:02:44.920 --> 00:02:46.420
If it's not appearing
on the screen,

00:02:46.420 --> 00:02:48.310
or the icons aren't, you can
just give the page a refresh,

00:02:48.310 --> 00:02:49.920
and that should come through.

00:02:49.920 --> 00:02:51.586
When we're talking
about these browsers,

00:02:51.586 --> 00:02:55.300
I mean the latest versions of
each one, so IE 10, et cetera.

00:02:55.300 --> 00:02:58.707
You get one point if you get it
right for a particular browser.

00:02:58.707 --> 00:03:01.290
You lose a point if you get it
wrong for a particular browser.

00:03:01.290 --> 00:03:03.460
So there's a maximum of
four points per question

00:03:03.460 --> 00:03:04.920
and a minimum of minus 4.

00:03:04.920 --> 00:03:07.160
You can score negatively.

00:03:07.160 --> 00:03:09.160
You can assume the
HTML5 doc type,

00:03:09.160 --> 00:03:11.590
and there's nothing
hidden going on.

00:03:11.590 --> 00:03:13.090
I'm not going to
turn round and say,

00:03:13.090 --> 00:03:15.390
oh but there's a base
element that's changing URLs.

00:03:15.390 --> 00:03:16.440
There'll be none of that.

00:03:16.440 --> 00:03:19.589
It's just what's there on
the screen, that one line.

00:03:19.589 --> 00:03:22.130
What we're seeing here is a live
opinion of the room as well.

00:03:22.130 --> 00:03:25.520
So the needle swings one way
when you're saying collectively

00:03:25.520 --> 00:03:27.270
that yes, the browser
will make a request.

00:03:27.270 --> 00:03:29.100
It'll swing the other
way if you're saying no.

00:03:29.100 --> 00:03:30.600
But I'm going to
randomize which way

00:03:30.600 --> 00:03:33.260
is yes and no for each
question, so you can't just

00:03:33.260 --> 00:03:35.530
look at the screen and
vote along with the room.

00:03:35.530 --> 00:03:37.540
OK, that's probably enough time.

00:03:37.540 --> 00:03:41.550
I'm going to close the
question in three, two, one.

00:03:41.550 --> 00:03:43.160
OK, we can see from
this that you're

00:03:43.160 --> 00:03:46.480
saying Chrome is going
to make a request here.

00:03:46.480 --> 00:03:48.230
You're less sure about
the other browsers.

00:03:48.230 --> 00:03:51.087
And the answer is no.

00:03:51.087 --> 00:03:53.420
None of the browsers is going
to make a request in this.

00:03:53.420 --> 00:03:56.230
But it's not actually
as mad as it seems.

00:03:56.230 --> 00:04:00.725
This doesn't work in HTML5,
but it was proposed in XHTML2.

00:04:03.770 --> 00:04:06.040
XHTML2 allows you to do
this: put a source attribute

00:04:06.040 --> 00:04:08.247
on anything, and it
would replace the content

00:04:08.247 --> 00:04:09.580
with what you had in the source.

00:04:09.580 --> 00:04:11.250
And this is really
good, because it

00:04:11.250 --> 00:04:14.560
meant that the old attribute
on the images became redundant,

00:04:14.560 --> 00:04:17.430
because you could replace
real semantic content.

00:04:17.430 --> 00:04:20.970
Pretty cool idea, but XHTML2
was backwards incompatible,

00:04:20.970 --> 00:04:23.770
and it carried with it XML's
draconian error handling.

00:04:23.770 --> 00:04:27.750
And once you invite XML into
your home, it XML's everything.

00:04:27.750 --> 00:04:29.750
XMLs all over the
floor, up the walls.

00:04:29.750 --> 00:04:32.520
And in the same way that Smurfs
stick the word "Smurf" in front

00:04:32.520 --> 00:04:34.370
of everything to make
it a Smurf thing,

00:04:34.370 --> 00:04:39.880
XML does it with X. You don't
want HTML, you want XHTML.

00:04:39.880 --> 00:04:42.740
You don't want frames,
you want Xframes.

00:04:42.740 --> 00:04:47.290
You don't want forms,
you want Xforms.

00:04:47.290 --> 00:04:48.900
If you let XML take
over your life,

00:04:48.900 --> 00:04:50.800
it will turn your
boyfriend or girlfriend

00:04:50.800 --> 00:04:54.479
into an ex-boyfriend
or girlfriend.

00:04:54.479 --> 00:04:56.020
And XML's cool with
that, because you

00:04:56.020 --> 00:04:57.270
don't need a partner any more.

00:04:57.270 --> 00:04:59.220
You've got XML to
look after you.

00:04:59.220 --> 00:05:01.910
It seems fitting
that in 2009, XHTML

00:05:01.910 --> 00:05:04.810
became an ex-specification, and
it was completely abandoned.

00:05:04.810 --> 00:05:07.320
And no browsers ever implemented
that source attributes

00:05:07.320 --> 00:05:09.740
on elements other than
images and the things

00:05:09.740 --> 00:05:10.940
they work on now.

00:05:10.940 --> 00:05:12.837
OK, but what about this?

00:05:12.837 --> 00:05:14.170
Here we've got an image element.

00:05:14.170 --> 00:05:14.919
It's got a source.

00:05:14.919 --> 00:05:18.250
It's in the page, but I've
spelled "image ' incorrectly.

00:05:18.250 --> 00:05:21.960
I've put it I-M-A-G-E
rather than I-M-G.

00:05:21.960 --> 00:05:24.200
Does the browser treat
it as an unknown element,

00:05:24.200 --> 00:05:25.592
or does it make the request?

00:05:25.592 --> 00:05:27.300
The browser only has
to make the request.

00:05:27.300 --> 00:05:29.049
It doesn't have to
display it on the page,

00:05:29.049 --> 00:05:30.559
in case you think that matters.

00:05:30.559 --> 00:05:32.225
XML was too strict
to work with the web,

00:05:32.225 --> 00:05:34.020
but is HTML best lenient?

00:05:34.020 --> 00:05:36.100
Or are the browsers more
lenient than the spec?

00:05:36.100 --> 00:05:37.475
Just get your
answers in quickly.

00:05:37.475 --> 00:05:42.630
I'm going to close the
question in three, two, one,

00:05:42.630 --> 00:05:43.650
and it's closed.

00:05:43.650 --> 00:05:48.610
So we're edging towards
no in all of the browsers.

00:05:48.610 --> 00:05:50.980
All the browsers will make
a request for this image,

00:05:50.980 --> 00:05:53.130
and they will display it.

00:05:53.130 --> 00:05:57.580
Because in the past, a browser
decided that I-M-G is quite

00:05:57.580 --> 00:05:59.150
difficult for
developers to remember,

00:05:59.150 --> 00:06:02.296
so they should support
I-M-A-G-E as well.

00:06:02.296 --> 00:06:04.630
And we've been stuck
with it ever since.

00:06:04.630 --> 00:06:06.070
Which browser
engine do you think

00:06:06.070 --> 00:06:07.420
we've got to thank for this?

00:06:07.420 --> 00:06:08.990
Yep, you've guessed it.

00:06:08.990 --> 00:06:13.607
It is Mosaic back in 1993.

00:06:13.607 --> 00:06:15.190
The people who
invented the image tag,

00:06:15.190 --> 00:06:16.245
they put this alias in.

00:06:16.245 --> 00:06:19.720
And a study in 2005 showed
that 0.2 percent of pages

00:06:19.720 --> 00:06:22.680
were using this
misspelled image tag.

00:06:22.680 --> 00:06:24.530
So any browser that
wants to work on the web

00:06:24.530 --> 00:06:27.364
that we have today has
to duplicate this alias.

00:06:27.364 --> 00:06:29.780
The WHATWG recognized this,
and they added it to the spec.

00:06:29.780 --> 00:06:31.330
This is the parsing spec.

00:06:31.330 --> 00:06:34.180
Start tag, name image,
change the token to IMG,

00:06:34.180 --> 00:06:35.090
and reprocess it.

00:06:35.090 --> 00:06:37.110
Don't ask, which is great.

00:06:37.110 --> 00:06:39.410
But this was actually used
in a clever hack recently.

00:06:39.410 --> 00:06:42.140
Alexei10 came up with
this, which I really liked.

00:06:42.140 --> 00:06:44.760
You would use this in place
of your image elements.

00:06:44.760 --> 00:06:48.415
What it does is it loads an SVG,
for browsers that support SVG,

00:06:48.415 --> 00:06:51.210
and it loads a PNG for
browsers that don't.

00:06:51.210 --> 00:06:53.710
So the way a modern browser
would parse it is it sees SVG,

00:06:53.710 --> 00:06:56.680
and it goes OK, it's got a
width and height of 100%,

00:06:56.680 --> 00:06:58.320
so about 100 pixels.

00:06:58.320 --> 00:07:00.290
And it sees this,
and this is a-- it

00:07:00.290 --> 00:07:03.250
sees this as an SVG image
element. 'Cause in SVG, images

00:07:03.250 --> 00:07:05.770
are spelled out full,
rather than IMG.

00:07:05.770 --> 00:07:08.190
It's got a width and a height,
and I'm going to load this.

00:07:08.190 --> 00:07:11.690
Because this is how you define
the source of an image in SVG.

00:07:11.690 --> 00:07:16.320
Because why have links
when you could have Xlinks?

00:07:16.320 --> 00:07:18.850
And then it sees this, and
that doesn't mean anything

00:07:18.850 --> 00:07:20.862
to SVG images, so it's ignored.

00:07:20.862 --> 00:07:22.320
So we're now showing
the SVG image.

00:07:22.320 --> 00:07:26.320
An older browser such as
Android 2 or IE8 and below,

00:07:26.320 --> 00:07:29.142
they will parse it like
this: No idea what that is.

00:07:29.142 --> 00:07:30.100
I'm going to ignore it.

00:07:30.100 --> 00:07:32.057
I'm going to treat it
like an unknown element.

00:07:32.057 --> 00:07:34.140
Oh look, the developer has
spelled "image " wrong.

00:07:34.140 --> 00:07:34.690
It's OK.

00:07:34.690 --> 00:07:36.065
I'm going to
correct it for them.

00:07:36.065 --> 00:07:38.520
It's 100 by 100.

00:07:38.520 --> 00:07:41.476
No idea what that means,
so I'll ignore that.

00:07:41.476 --> 00:07:43.350
And then oh, there's
the source of the image.

00:07:43.350 --> 00:07:44.941
I've got to download the PNG.

00:07:44.941 --> 00:07:47.440
So it's kind of nice, because
it doesn't require JavaScript,

00:07:47.440 --> 00:07:49.440
and it's a nice way
to conditionally load

00:07:49.440 --> 00:07:51.260
the kind of file that
the browser supports.

00:07:51.260 --> 00:07:54.340
We got quite excited about it,
and we were tweeting about it.

00:07:54.340 --> 00:07:56.654
The mistake we made
is we did not test it.

00:07:56.654 --> 00:07:58.570
So a few of us did just
that, and we found out

00:07:58.570 --> 00:08:00.970
something interesting.

00:08:00.970 --> 00:08:03.100
All of these
browsers support SVG,

00:08:03.100 --> 00:08:06.039
but which browsers will
download the PNG as well?

00:08:06.039 --> 00:08:07.080
And I'll give you a clue.

00:08:07.080 --> 00:08:08.000
It's not all of them.

00:08:08.000 --> 00:08:09.440
Not all of them get it wrong.

00:08:09.440 --> 00:08:11.690
It's just one or
some of the browsers

00:08:11.690 --> 00:08:14.870
are going to get this
wrong, and they end up

00:08:14.870 --> 00:08:17.750
downloading both
the PNG and the SVG.

00:08:17.750 --> 00:08:23.850
I'm going to close the
question in three, two, one.

00:08:23.850 --> 00:08:26.742
OK, we're saying no in all
the browsers and yes in IE.

00:08:26.742 --> 00:08:28.200
It's almost like
you've been burned

00:08:28.200 --> 00:08:30.000
by that browser in the past.

00:08:30.000 --> 00:08:33.253
Well, the answer
is you are right.

00:08:33.253 --> 00:08:35.669
Internet Explorer will make a
request for two images here.

00:08:35.669 --> 00:08:37.133
It's because all
modern browsers,

00:08:37.133 --> 00:08:38.799
they've got two parsers
built into them.

00:08:38.799 --> 00:08:40.674
It's a relatively new
thing for them to have,

00:08:40.674 --> 00:08:42.380
but they all have it.

00:08:42.380 --> 00:08:45.019
One parser runs ahead, and it
goes, and it tries and finds

00:08:45.019 --> 00:08:47.310
things like it should download,
like scripts and images

00:08:47.310 --> 00:08:47.960
or whatever.

00:08:47.960 --> 00:08:50.460
And the other parser comes along
and does the heavy lifting,

00:08:50.460 --> 00:08:54.040
like building the DOM tree,
parsing scripts, et cetera.

00:08:54.040 --> 00:08:55.975
And this has a
really large benefit.

00:08:55.975 --> 00:08:58.631
A study we did at Google,
we looked at 2,000 sites,

00:08:58.631 --> 00:09:00.005
and then we added
this preloader,

00:09:00.005 --> 00:09:01.910
and we got a 20%
speed improvement

00:09:01.910 --> 00:09:05.010
to get to DOM content loaded,
so it's really useful.

00:09:05.010 --> 00:09:07.040
But in order to be
quick, this pre-parser

00:09:07.040 --> 00:09:08.350
is a little bit stupid.

00:09:08.350 --> 00:09:11.340
And in Internet Explorer, it's
a bit too stupid at the moment.

00:09:11.340 --> 00:09:12.870
It gets over excited.

00:09:12.870 --> 00:09:14.835
It's like oh, look, I'm
going to show this PNG.

00:09:14.835 --> 00:09:15.960
I'm going to show this PNG.

00:09:15.960 --> 00:09:17.330
Here I go showing the PNG.

00:09:17.330 --> 00:09:18.960
Oh, no, actually, I won't.

00:09:18.960 --> 00:09:20.290
It's actually an SVG.

00:09:20.290 --> 00:09:21.830
I'll do that instead.

00:09:21.830 --> 00:09:24.610
So the main parser sees the
markup and it sees the image,

00:09:24.610 --> 00:09:26.361
but it misses the SVG context.

00:09:26.361 --> 00:09:27.860
And then the main
parser comes along

00:09:27.860 --> 00:09:30.410
and goes why am I
downloading PNG?

00:09:30.410 --> 00:09:33.807
And it cancels that download
and goes for the SVG instead.

00:09:33.807 --> 00:09:35.640
But by that point, it's
made the connection.

00:09:35.640 --> 00:09:38.500
It's probably got all of
the image by that point.

00:09:38.500 --> 00:09:41.780
The moral here is don't
trust performance tips.

00:09:41.780 --> 00:09:43.180
Make sure you test things.

00:09:43.180 --> 00:09:46.190
At Chrome we say "tools,
not rules," which rhymes,

00:09:46.190 --> 00:09:47.790
so I guess it must be true.

00:09:47.790 --> 00:09:51.990
But always be on the lookout for
existing data or existing tests

00:09:51.990 --> 00:09:53.210
that you can run.

00:09:53.210 --> 00:09:55.854
One of my favorite stories
in science, or a tale,

00:09:55.854 --> 00:09:57.270
I don't know how
true it is but it

00:09:57.270 --> 00:09:58.980
involves this man,
August Weismann.

00:09:58.980 --> 00:10:02.902
And he wanted to disprove
that life experience was

00:10:02.902 --> 00:10:04.860
part of evolution, like
something that happened

00:10:04.860 --> 00:10:07.692
to you during your life would
be passed down as evolution.

00:10:07.692 --> 00:10:09.150
So the way he was
going to disprove

00:10:09.150 --> 00:10:11.380
this is he took two mice,
and he cut their tails off

00:10:11.380 --> 00:10:12.550
and bred them together.

00:10:12.550 --> 00:10:14.091
And then he took
the offspring there,

00:10:14.091 --> 00:10:16.220
and he cut their tails off
and bred them together.

00:10:16.220 --> 00:10:18.670
The idea was we shouldn't
end up with mice

00:10:18.670 --> 00:10:20.194
being born without tails, right?

00:10:20.194 --> 00:10:21.860
And he was running
this test for quite a

00:10:21.860 --> 00:10:24.460
while until one of his
colleagues pointed out, August,

00:10:24.460 --> 00:10:28.190
you do realize that Jewish
people have been inadvertently

00:10:28.190 --> 00:10:32.460
carrying out this experiment
a lot longer than you have.

00:10:32.460 --> 00:10:33.260
Oh, yeah.

00:10:33.260 --> 00:10:37.710
So he stopped his test, and
he just used that as evidence.

00:10:37.710 --> 00:10:38.720
So what about this?

00:10:38.720 --> 00:10:39.500
We've got a div.

00:10:39.500 --> 00:10:41.249
It's displaying non
as an image inside it.

00:10:41.249 --> 00:10:43.850
So the image won't be
displayed, but which browsers

00:10:43.850 --> 00:10:46.740
are going to download it anyway?

00:10:46.740 --> 00:10:49.950
So yeah, it's not
going to render.

00:10:49.950 --> 00:10:52.917
So you could say it was a
waste of bytes to do so.

00:10:52.917 --> 00:10:54.750
Or maybe some browser's
going to get it just

00:10:54.750 --> 00:10:56.830
in preparation, thinking
it might be shown.

00:10:56.830 --> 00:11:01.257
I'm going to close the
question in three, two, one.

00:11:01.257 --> 00:11:03.590
OK, we're sort of leaning
towards yes for every browser.

00:11:03.590 --> 00:11:05.740
We're quite certain it's going
to happen in Internet Explorer.

00:11:05.740 --> 00:11:07.880
The answer, collectively
you are correct.

00:11:07.880 --> 00:11:09.460
Yes, all of the
browsers here are

00:11:09.460 --> 00:11:11.070
going to download that image.

00:11:11.070 --> 00:11:13.150
And this behavior
is part of the spec.

00:11:13.150 --> 00:11:15.790
So in the browser in the
beginning, there is nothing,

00:11:15.790 --> 00:11:18.162
and then the browser gets
sprayed with HTML text.

00:11:18.162 --> 00:11:20.370
And it will convert that
text into a tree of elements

00:11:20.370 --> 00:11:23.320
that we know as the DOM.

00:11:23.320 --> 00:11:24.370
When is this is HTML?

00:11:24.370 --> 00:11:26.705
When an element is
turned into-- when

00:11:26.705 --> 00:11:28.996
a tag is turned into an
element, the construction steps

00:11:28.996 --> 00:11:30.220
for that element have run.

00:11:30.220 --> 00:11:33.567
And for image, it's really
complicated, actually,

00:11:33.567 --> 00:11:34.650
creating an image element.

00:11:34.650 --> 00:11:36.400
But step 14 down
here at the bottom

00:11:36.400 --> 00:11:39.650
is where it actually makes the
request and requests the image,

00:11:39.650 --> 00:11:41.150
so visibility doesn't
matter at all.

00:11:41.150 --> 00:11:42.150
It doesn't come into it.

00:11:42.150 --> 00:11:43.690
And that's kind of
good, because it

00:11:43.690 --> 00:11:46.001
means that your images can
download before your CSS is

00:11:46.001 --> 00:11:48.000
downloaded, before your
scripts have downloaded.

00:11:48.000 --> 00:11:51.210
As a downside, it meant that
responsive images polyfills did

00:11:51.210 --> 00:11:54.090
not work because by the
time your JavaScript gets

00:11:54.090 --> 00:11:56.050
to the image, it's
already started

00:11:56.050 --> 00:11:58.060
to download the thing
that was there already.

00:11:58.060 --> 00:11:59.810
You're just going to
add a second download

00:11:59.810 --> 00:12:01.480
by changing the source.

00:12:01.480 --> 00:12:03.510
This won't be a
problem in the future.

00:12:03.510 --> 00:12:05.690
The resource priority
spec we've specified

00:12:05.690 --> 00:12:08.470
the postpone attribute,
which tells an image that it

00:12:08.470 --> 00:12:10.230
shouldn't display if
it's displaying non,

00:12:10.230 --> 00:12:12.800
among other things.

00:12:12.800 --> 00:12:15.310
But what if we are using CSS?

00:12:15.310 --> 00:12:16.050
What then?

00:12:16.050 --> 00:12:17.966
So here we've got a div
that's displaying non,

00:12:17.966 --> 00:12:20.462
and inside there's a div
with a background image.

00:12:20.462 --> 00:12:22.170
So it's kind of similar
to the image one.

00:12:22.170 --> 00:12:24.360
But we saw that images
are ignoring CSS,

00:12:24.360 --> 00:12:26.440
but here we're actually
in CSS land already.

00:12:26.440 --> 00:12:29.661
So are there any browsers that
are going to download that,

00:12:29.661 --> 00:12:31.160
or are they just
going to ignore it?

00:12:31.160 --> 00:12:33.500
Because once again, it's
not going to be displayed.

00:12:33.500 --> 00:12:35.500
So you could consider
it a waste of bytes.

00:12:35.500 --> 00:12:40.710
I'm going to close the
question in three, two, one.

00:12:40.710 --> 00:12:43.720
We're kind of edging towards
yes in every browser.

00:12:43.720 --> 00:12:44.420
I'm afraid not.

00:12:44.420 --> 00:12:46.711
No browsers are going to
download it here, none at all.

00:12:46.711 --> 00:12:48.339
And that's kind
of-- I suppose you

00:12:48.339 --> 00:12:49.630
could see that as a good thing.

00:12:49.630 --> 00:12:50.410
It's saving bytes.

00:12:50.410 --> 00:12:51.410
But what if we did this?

00:12:51.410 --> 00:12:52.730
Similar question.

00:12:52.730 --> 00:12:56.310
It's a div displaying non,
and it has a background image.

00:12:56.310 --> 00:12:58.200
The difference in
the last question

00:12:58.200 --> 00:12:59.600
is it's all on one element.

00:12:59.600 --> 00:13:02.290
It's not-- the image isn't
inside another element that's

00:13:02.290 --> 00:13:03.200
displaying non.

00:13:03.200 --> 00:13:04.890
Does that change things?

00:13:04.890 --> 00:13:07.610
Once again, it's not going to
need that background image.

00:13:07.610 --> 00:13:12.381
I'm going to close the
question in three, two, one.

00:13:12.381 --> 00:13:14.130
We're edging towards
yes in every browser.

00:13:14.130 --> 00:13:17.280
A little bit more
confident in Chrome.

00:13:17.280 --> 00:13:18.890
Most browsers will.

00:13:18.890 --> 00:13:20.530
Firefox will not.

00:13:20.530 --> 00:13:23.009
So what's going on here?

00:13:23.009 --> 00:13:24.800
Once the browser has
this tree of elements,

00:13:24.800 --> 00:13:26.551
it needs to work out
what they look like

00:13:26.551 --> 00:13:27.800
and where they go on the page.

00:13:27.800 --> 00:13:29.957
And the first step of this
is a style calculation.

00:13:29.957 --> 00:13:31.290
So it calculates all the styles.

00:13:31.290 --> 00:13:32.980
It goes through the
CSS cascade, the style

00:13:32.980 --> 00:13:35.070
attributes, the font tags
if you're from the '90s.

00:13:35.070 --> 00:13:37.930
And works out what style
applies to each element.

00:13:37.930 --> 00:13:39.830
But not everything gets
its style calculated,

00:13:39.830 --> 00:13:42.885
so this div up at the top
turned out to be displaying non.

00:13:42.885 --> 00:13:43.885
The browser stops there.

00:13:43.885 --> 00:13:45.468
It doesn't calculate
for the children,

00:13:45.468 --> 00:13:47.710
because those elements
have no impact

00:13:47.710 --> 00:13:48.980
on the rendering of the page.

00:13:48.980 --> 00:13:50.006
So it short cuts.

00:13:50.006 --> 00:13:51.880
So if these elements
have a background image,

00:13:51.880 --> 00:13:54.180
the browser just never
finds out about it.

00:13:54.180 --> 00:13:56.256
This div up at the top
here is displaying non,

00:13:56.256 --> 00:13:58.130
but it did have its
style calculated in order

00:13:58.130 --> 00:13:58.905
to find that out.

00:13:58.905 --> 00:14:01.530
And that's when the browser will
discover the background image.

00:14:01.530 --> 00:14:04.482
Firefox is a little bit smarter
here and avoids the download.

00:14:04.482 --> 00:14:06.690
But if you change that to,
instead of displaying non,

00:14:06.690 --> 00:14:10.080
you use visibility
hidden or opacity zero,

00:14:10.080 --> 00:14:12.380
Firefox would download as well.

00:14:12.380 --> 00:14:15.360
Who's getting it right
according to the specification?

00:14:15.360 --> 00:14:16.170
Everyone is.

00:14:16.170 --> 00:14:18.250
The spec is really vague here.

00:14:18.250 --> 00:14:19.931
It says the browser
may optimize,

00:14:19.931 --> 00:14:21.430
even if the element
is just obscured

00:14:21.430 --> 00:14:23.560
or it's underneath another one.

00:14:23.560 --> 00:14:25.550
But no browsers are that smart.

00:14:25.550 --> 00:14:27.430
This kind of freedom
in specifications

00:14:27.430 --> 00:14:29.390
is kind of good,
because it means

00:14:29.390 --> 00:14:31.130
the browser can do
the right thing given

00:14:31.130 --> 00:14:34.990
the device, the connectivity,
maybe even the battery percent,

00:14:34.990 --> 00:14:36.540
how much battery
you've got left.

00:14:36.540 --> 00:14:37.720
But it's also scary,
because it means

00:14:37.720 --> 00:14:40.380
you're going to get the browsers
doing different things as they

00:14:40.380 --> 00:14:42.314
try new stuff with
that freedom they have.

00:14:42.314 --> 00:14:43.730
But I think that
kind of diversity

00:14:43.730 --> 00:14:45.520
is what makes the web great.

00:14:45.520 --> 00:14:49.050
It's not one company driving
forward with its own interests.

00:14:49.050 --> 00:14:51.070
It's lots of companies
driving forward

00:14:51.070 --> 00:14:52.300
in different directions.

00:14:52.300 --> 00:14:56.480
And we get this kind of car
crash, but with a happy ending.

00:14:56.480 --> 00:15:00.016
And that's the web
that we have today.

00:15:00.016 --> 00:15:03.359
If you want to avoid
downloading a CSS background,

00:15:03.359 --> 00:15:04.650
hiding an element isn't enough.

00:15:04.650 --> 00:15:07.206
You need to put it inside an
element that is displaying non.

00:15:07.206 --> 00:15:08.580
But when you do
this, you're just

00:15:08.580 --> 00:15:11.050
relying on what
browsers do today.

00:15:11.050 --> 00:15:12.310
It's not specified behavior.

00:15:12.310 --> 00:15:13.870
Browsers may change.

00:15:13.870 --> 00:15:16.350
The only sure-fire way is
make sure the browser doesn't

00:15:16.350 --> 00:15:18.750
find out about that
background image.

00:15:18.750 --> 00:15:20.992
Don't add the class name
that adds that background.

00:15:20.992 --> 00:15:22.450
Or don't add the
element to the DOM

00:15:22.450 --> 00:15:25.360
at all until you really need it.

00:15:25.360 --> 00:15:27.302
OK, things have
been relatively easy

00:15:27.302 --> 00:15:29.260
so far because we weren't
involving JavaScript.

00:15:29.260 --> 00:15:31.214
So let's get
JavaScript involved.

00:15:31.214 --> 00:15:31.880
What about this?

00:15:31.880 --> 00:15:33.650
I'm creating an image,
I'm giving it a source.

00:15:33.650 --> 00:15:35.108
I'm not putting it
in the document,

00:15:35.108 --> 00:15:38.460
and I'm spelling "image"
incorrectly like we did before.

00:15:38.460 --> 00:15:43.890
So we saw in HTML that it
was also correcting I-M-A-G-E

00:15:43.890 --> 00:15:47.325
to I-M-G. But does it
do the same in the DOM?

00:15:47.325 --> 00:15:49.700
Do images even download when
they're not in the document?

00:15:49.700 --> 00:15:51.590
Because once again,
this is not--

00:15:51.590 --> 00:15:53.669
the browser doesn't
need to render this yet,

00:15:53.669 --> 00:15:54.835
or it can't render this yet.

00:15:54.835 --> 00:15:59.380
I'm going to close the
question three, two, one.

00:15:59.380 --> 00:16:02.100
This is the point in the
quiz where the audience just

00:16:02.100 --> 00:16:04.030
gets broken, and the
needles just drift

00:16:04.030 --> 00:16:07.800
towards the center of I
don't know what's going on.

00:16:07.800 --> 00:16:11.130
In this case, most
browsers will download.

00:16:11.130 --> 00:16:14.160
Firefox won't, and
there are three parts

00:16:14.160 --> 00:16:15.430
to this explanation.

00:16:15.430 --> 00:16:18.270
As we saw before,
the DOM gets parsed,

00:16:18.270 --> 00:16:20.312
and the creation steps
of the elements are run.

00:16:20.312 --> 00:16:21.770
This animation took
me a long time,

00:16:21.770 --> 00:16:23.395
which is why you've
seen it three times

00:16:23.395 --> 00:16:25.120
already, but that
is the last time.

00:16:25.120 --> 00:16:27.859
But when an element is
created using DOM stuff,

00:16:27.859 --> 00:16:29.650
it's still going to
run the creation steps,

00:16:29.650 --> 00:16:31.500
and we solve for
images in step 14.

00:16:31.500 --> 00:16:33.725
That is going to be when
it downloads the image.

00:16:33.725 --> 00:16:35.100
We can use this
to our advantage,

00:16:35.100 --> 00:16:37.870
because this one line, you
can make a "get" request

00:16:37.870 --> 00:16:40.470
to anything that the
machine can access.

00:16:40.470 --> 00:16:44.370
And in fact, images have
their own DOM constructor,

00:16:44.370 --> 00:16:45.890
unlike a lot of other elements.

00:16:45.890 --> 00:16:47.732
So that tiny bit
of code: instant

00:16:47.732 --> 00:16:48.940
get request to anywhere else.

00:16:48.940 --> 00:16:51.231
And this is pretty much how
Google Analytics talks back

00:16:51.231 --> 00:16:52.310
to the server.

00:16:52.310 --> 00:16:54.820
But we saw before that Firefox
didn't make the request,

00:16:54.820 --> 00:16:56.900
so what's going on there?

00:16:56.900 --> 00:17:00.320
When we create this, most
browsers-- Chrome, Safari, IE--

00:17:00.320 --> 00:17:03.850
will give us an HTML image
element back, whereas Firefox

00:17:03.850 --> 00:17:05.190
will give us an HTML element.

00:17:05.190 --> 00:17:06.060
It's not an image.

00:17:06.060 --> 00:17:09.319
If you add it to the page,
it won't display an image.

00:17:09.319 --> 00:17:11.540
And the interesting
thing is here,

00:17:11.540 --> 00:17:13.990
it's the only one
getting it right.

00:17:13.990 --> 00:17:16.190
We saw before, this
is how the browser

00:17:16.190 --> 00:17:17.692
or how the spec
deals with images

00:17:17.692 --> 00:17:18.900
that are spelled incorrectly.

00:17:18.900 --> 00:17:21.329
But this is in the
parsing spec, and we

00:17:21.329 --> 00:17:24.619
bypassed parsing by
using create element,

00:17:24.619 --> 00:17:26.470
completely bypassing the parser.

00:17:26.470 --> 00:17:30.320
So it should-- Firefox
gives us an HTML element.

00:17:30.320 --> 00:17:32.430
It should give us an
HTML unknown element,

00:17:32.430 --> 00:17:34.830
which it does if you do
create an element fubar.

00:17:34.830 --> 00:17:37.150
Firefox is doing something
special for these images.

00:17:37.150 --> 00:17:40.090
But it's getting it more
right than other browsers.

00:17:40.090 --> 00:17:43.370
I think I preferred it when we
were developing for browsers.

00:17:43.370 --> 00:17:44.800
It was like there
was one bad guy,

00:17:44.800 --> 00:17:47.070
and it was Internet
Explorer 6 or 7 or 8.

00:17:47.070 --> 00:17:49.890
And all the other browsers
seemed perfect in comparison.

00:17:49.890 --> 00:17:53.550
But I see the browser-scape as
being like an orchestra where

00:17:53.550 --> 00:17:55.130
Internet Explorer
8 was just this kid

00:17:55.130 --> 00:17:57.360
hitting two cymbals
together and screaming.

00:17:57.360 --> 00:17:59.911
But once we finally kick
the screaming child out

00:17:59.911 --> 00:18:02.410
of the room, and we come back
and we start conducting again,

00:18:02.410 --> 00:18:04.470
we realize oh,
everyone is actually

00:18:04.470 --> 00:18:05.750
a little bit out of tune.

00:18:05.750 --> 00:18:08.630
We just didn't realize because
of the screaming cymbal child

00:18:08.630 --> 00:18:10.300
of Internet Explorer.

00:18:10.300 --> 00:18:14.764
So let's just get CSS involved
again, but JavaScript as well.

00:18:14.764 --> 00:18:15.430
What about this?

00:18:15.430 --> 00:18:17.221
I'm creating a div,
giving it a background.

00:18:17.221 --> 00:18:19.280
It's not in the document,
but everything's

00:18:19.280 --> 00:18:21.070
spelled right and valid.

00:18:21.070 --> 00:18:23.180
We saw images download
at this point,

00:18:23.180 --> 00:18:25.470
but what about when
CSS is involved?

00:18:25.470 --> 00:18:27.400
Are we going to see
things download there?

00:18:27.400 --> 00:18:28.860
Get your answers in quickly.

00:18:28.860 --> 00:18:33.871
I'm going to close the
question in three, two, one.

00:18:33.871 --> 00:18:35.370
Once again, the
needles are starting

00:18:35.370 --> 00:18:37.090
to drift into the middle.

00:18:37.090 --> 00:18:38.700
The answer here is no.

00:18:38.700 --> 00:18:40.980
No browsers will download here.

00:18:40.980 --> 00:18:43.090
This is the same as
the display non case.

00:18:43.090 --> 00:18:45.830
The browser won't calculate
the style of elements

00:18:45.830 --> 00:18:47.705
that display non, and
it also won't calculate

00:18:47.705 --> 00:18:49.121
the styles of
elements that aren't

00:18:49.121 --> 00:18:50.940
in the document, because
there's no point.

00:18:50.940 --> 00:18:53.350
It doesn't affect the
rendering of the page at all.

00:18:53.350 --> 00:18:55.090
OK, I'm going to be cruel now.

00:18:55.090 --> 00:18:56.590
What about this?

00:18:56.590 --> 00:18:57.850
So same again.

00:18:57.850 --> 00:18:59.340
I'm adding it to the document.

00:18:59.340 --> 00:19:01.210
Then I'm removing it again.

00:19:01.210 --> 00:19:03.960
Is it in the document long
enough for the browser

00:19:03.960 --> 00:19:06.770
to go oh, I should download
this background image?

00:19:06.770 --> 00:19:09.070
Or does it not get to
see it long enough?

00:19:09.070 --> 00:19:11.680
Does it not bother?

00:19:11.680 --> 00:19:17.314
I'm going to close the
question in three, two, one.

00:19:17.314 --> 00:19:18.980
OK, we're suggesting
yes because yes, it

00:19:18.980 --> 00:19:21.250
has entered the document.

00:19:21.250 --> 00:19:23.360
I'm afraid you are all
wrong with that one, all

00:19:23.360 --> 00:19:24.401
the people who said that.

00:19:24.401 --> 00:19:26.890
The browser doesn't want to
think about styles or layout

00:19:26.890 --> 00:19:28.602
until the very last moment.

00:19:28.602 --> 00:19:30.560
And that's normally
rendering, when it actually

00:19:30.560 --> 00:19:32.320
needs to change
pixels on the screen.

00:19:32.320 --> 00:19:34.420
And we can't do that,
or we don't do that,

00:19:34.420 --> 00:19:36.200
while we're in the
middle of JavaScript.

00:19:36.200 --> 00:19:37.800
So the browser
actually sits back

00:19:37.800 --> 00:19:39.800
and waits for that
JavaScript block to execute.

00:19:39.800 --> 00:19:42.175
And then afterwards it will
go and look at what's changed

00:19:42.175 --> 00:19:45.210
and react to that when
it needs to render next.

00:19:45.210 --> 00:19:46.683
But does this change that?

00:19:46.683 --> 00:19:49.365
So same code again, but in
between adding and removing it

00:19:49.365 --> 00:19:50.740
to the document,
I'm going to ask

00:19:50.740 --> 00:19:52.252
for the text content
of the element.

00:19:52.252 --> 00:19:54.460
Now, the text content is
going to be an empty string,

00:19:54.460 --> 00:19:56.350
because it is an empty element.

00:19:56.350 --> 00:19:58.220
But is just accessing
that property

00:19:58.220 --> 00:19:59.300
going to change things?

00:19:59.300 --> 00:20:02.380
I'm not even assigning
it to a variable.

00:20:02.380 --> 00:20:04.830
Is it just even going to be
optimized away by JavaScript

00:20:04.830 --> 00:20:06.520
because it has no impact?

00:20:06.520 --> 00:20:10.857
I'm going to close the
question in three, two, one.

00:20:10.857 --> 00:20:11.940
Almost dead in the middle.

00:20:11.940 --> 00:20:12.780
Excellent.

00:20:12.780 --> 00:20:14.030
The answer is no.

00:20:14.030 --> 00:20:15.895
No browsers will make a request.

00:20:15.895 --> 00:20:17.320
Getting the text
content is easy.

00:20:17.320 --> 00:20:19.778
It's just going to go through
the DOM, find the text nodes,

00:20:19.778 --> 00:20:22.070
concatenate the values together.

00:20:22.070 --> 00:20:22.911
What about this?

00:20:22.911 --> 00:20:25.160
Similar question, but this
time enter HTML rather than

00:20:25.160 --> 00:20:26.000
text content.

00:20:26.000 --> 00:20:28.880
Once again, it's going to be
an empty string that comes back

00:20:28.880 --> 00:20:30.990
there, because the
element is empty.

00:20:30.990 --> 00:20:34.239
But does it behave
differently to text content?

00:20:34.239 --> 00:20:36.280
Are the browsers going to
do something different?

00:20:36.280 --> 00:20:41.460
I'm going to close the
question in three, two, one.

00:20:41.460 --> 00:20:43.380
We're saying no here.

00:20:43.380 --> 00:20:46.060
Well, you're mostly right.

00:20:46.060 --> 00:20:48.940
Internet Explorer will
make a download here.

00:20:48.940 --> 00:20:53.810
And the reason for that is
because in Internet Explorer--

00:20:53.810 --> 00:20:54.540
I don't know.

00:20:54.540 --> 00:20:56.550
I have absolutely no idea.

00:20:56.550 --> 00:20:59.150
Some things in the world
cannot be explained,

00:20:59.150 --> 00:21:00.150
and this is one of them.

00:21:00.150 --> 00:21:03.220
Like how it takes three
attempts to plug in a USB cable,

00:21:03.220 --> 00:21:05.270
even though there are
only two possibilities,

00:21:05.270 --> 00:21:08.880
some things cannot be explained.

00:21:08.880 --> 00:21:12.900
OK, on the same theme again,
but this time in the text.

00:21:12.900 --> 00:21:14.670
Once again, like
the other two, this

00:21:14.670 --> 00:21:16.260
is going to come back as an
empty string, because it's

00:21:16.260 --> 00:21:17.220
an empty element.

00:21:17.220 --> 00:21:18.930
But is that going to
behave differently?

00:21:18.930 --> 00:21:20.730
Is Internet Explorer still
going to make the request

00:21:20.730 --> 00:21:22.350
erroneously, like it did before?

00:21:22.350 --> 00:21:24.550
Is it going to get
it correct this time?

00:21:24.550 --> 00:21:25.150
Who knows?

00:21:25.150 --> 00:21:30.590
I'm going to close the
question in three, two, one.

00:21:30.590 --> 00:21:31.830
We're edging towards no.

00:21:31.830 --> 00:21:33.690
Little bit less sure
on Internet Explorer.

00:21:33.690 --> 00:21:35.810
The answer: yes.

00:21:35.810 --> 00:21:37.710
Most browsers will
make a request here.

00:21:37.710 --> 00:21:41.700
And this actually kind of
makes sense in an odd way.

00:21:41.700 --> 00:21:42.690
Let's make a div.

00:21:42.690 --> 00:21:45.721
It's got a background image,
and it's got some inner HTML.

00:21:45.721 --> 00:21:47.845
It's got Hello World inside
it, but World is inside

00:21:47.845 --> 00:21:48.940
a div of its own.

00:21:48.940 --> 00:21:50.100
We add it to the document.

00:21:50.100 --> 00:21:51.266
We ask for its text content.

00:21:51.266 --> 00:21:52.930
It's Hello World,
but when we ask

00:21:52.930 --> 00:21:56.157
for the inner text in,
i.e., Safari and Chrome,

00:21:56.157 --> 00:21:57.240
it's going to return this.

00:21:57.240 --> 00:21:58.870
It's got a line
break in the middle.

00:21:58.870 --> 00:22:02.195
And the reason for this is inner
text isn't just a text content.

00:22:02.195 --> 00:22:03.570
It's more like
what you would get

00:22:03.570 --> 00:22:05.650
if you copied-- if you
highlighted the element

00:22:05.650 --> 00:22:06.870
and copied it.

00:22:06.870 --> 00:22:09.520
And because of this, it's
got style information,

00:22:09.520 --> 00:22:11.240
because the World is
on a different line,

00:22:11.240 --> 00:22:12.800
because the div is block level.

00:22:12.800 --> 00:22:15.100
Or it is by default,
and it is in this case.

00:22:15.100 --> 00:22:17.440
So what actually happens
here is the browser--

00:22:17.440 --> 00:22:19.500
we asked for the text content.

00:22:19.500 --> 00:22:22.470
It just gets that back, but
when you ask for the inner text,

00:22:22.470 --> 00:22:24.010
the browser has to go Ah!

00:22:24.010 --> 00:22:25.930
I need to know what the
layout of this element

00:22:25.930 --> 00:22:27.607
is in order to return this.

00:22:27.607 --> 00:22:29.940
I need to find out if that
div's block level, where am I

00:22:29.940 --> 00:22:31.119
going to put my line breaks?

00:22:31.119 --> 00:22:32.910
Oh, look, there's a
background image there.

00:22:32.910 --> 00:22:34.409
And then it downloads
it, because it

00:22:34.409 --> 00:22:36.290
forces it to look at the styles.

00:22:36.290 --> 00:22:37.800
Most of the time,
the browser will

00:22:37.800 --> 00:22:40.006
defer looking at styles
as late as it can.

00:22:40.006 --> 00:22:41.630
But here we forced
it to happen sooner,

00:22:41.630 --> 00:22:43.100
because we've
asked for something

00:22:43.100 --> 00:22:44.690
that's style dependent.

00:22:44.690 --> 00:22:47.700
Firefox didn't make
a request, because it

00:22:47.700 --> 00:22:48.920
doesn't support inner text.

00:22:48.920 --> 00:22:50.570
It doesn't support
the property at all,

00:22:50.570 --> 00:22:52.180
so that's just undefined.

00:22:52.180 --> 00:22:53.540
That was quite cruel.

00:22:53.540 --> 00:22:56.290
But if we used any
of these properties,

00:22:56.290 --> 00:22:58.130
like out of text--
not out of text,

00:22:58.130 --> 00:23:01.170
but offset left,
offset parens, Firefox

00:23:01.170 --> 00:23:04.640
would have made the
request as well.

00:23:04.640 --> 00:23:07.900
So ignorance of
those elements that

00:23:07.900 --> 00:23:11.240
will require style information,
that's one of the number

00:23:11.240 --> 00:23:14.320
one problems with performance
that we see on the web.

00:23:14.320 --> 00:23:16.500
Because also you can do
some nice hackery with it.

00:23:16.500 --> 00:23:19.260
If you look at code like this,
it looks really expensive,

00:23:19.260 --> 00:23:19.865
but it's not.

00:23:19.865 --> 00:23:21.740
It's really cheap,
because the browser's just

00:23:21.740 --> 00:23:23.580
going to sit back and
watch you just writing

00:23:23.580 --> 00:23:26.000
this property to an object.

00:23:26.000 --> 00:23:30.000
And it's not going to care
about it until that block ends.

00:23:30.000 --> 00:23:34.260
And once that's all done, it
will just look at the results,

00:23:34.260 --> 00:23:37.380
and in this case, there's
no pixel difference.

00:23:37.380 --> 00:23:40.590
This can lead to some
unexpected results, not just

00:23:40.590 --> 00:23:42.440
graphical performance, but--

00:23:42.440 --> 00:23:46.530
So imagine-- let's have a
look at a practical example.

00:23:46.530 --> 00:23:47.870
Here is Paul Lewis and me.

00:23:47.870 --> 00:23:49.000
We work together.

00:23:49.000 --> 00:23:50.150
We want to go over there.

00:23:50.150 --> 00:23:51.960
You can tell, because
we're pointing.

00:23:51.960 --> 00:23:53.930
Let's do it with code.

00:23:53.930 --> 00:23:56.490
We're going to say left 0%,
going to set a transition,

00:23:56.490 --> 00:23:57.880
and then left 100%.

00:23:57.880 --> 00:23:58.980
We run that code.

00:23:58.980 --> 00:24:00.211
Hey, off we go.

00:24:00.211 --> 00:24:00.710
Excellent.

00:24:00.710 --> 00:24:02.070
We win at code.

00:24:02.070 --> 00:24:06.065
But if we run that code
again, nothing happens.

00:24:06.065 --> 00:24:07.440
And the reason
nothing happens is

00:24:07.440 --> 00:24:09.640
the browser's going to batch
up these style changes.

00:24:09.640 --> 00:24:11.725
So we've got-- we're
setting "left" twice,

00:24:11.725 --> 00:24:14.760
but the browser's only going
to listen to the last one.

00:24:14.760 --> 00:24:17.470
And we're essentially
saying transition to 100%,

00:24:17.470 --> 00:24:20.392
but we're already at
100%, so it doesn't move.

00:24:20.392 --> 00:24:22.100
You might have
encountered this and tried

00:24:22.100 --> 00:24:25.100
to fix it with set timeouts in
an arbitrary number in there.

00:24:25.100 --> 00:24:27.240
But what you actually want
to do is at this point,

00:24:27.240 --> 00:24:28.780
just after we set
the first left,

00:24:28.780 --> 00:24:31.144
you want the browser to
go look at that style

00:24:31.144 --> 00:24:32.310
and actually think about it.

00:24:32.310 --> 00:24:34.893
And we can actually do that by
putting one of those properties

00:24:34.893 --> 00:24:36.150
in: offset width or whatever.

00:24:36.150 --> 00:24:39.310
And once we do that, we can
run that code as many times

00:24:39.310 --> 00:24:41.780
as we want, and it
will work every time.

00:24:41.780 --> 00:24:43.610
But you are relying on
unspecified behavior

00:24:43.610 --> 00:24:44.550
when you do that.

00:24:44.550 --> 00:24:47.620
The web animations API
will save us there.

00:24:47.620 --> 00:24:49.320
And just before I
get kicked off stage,

00:24:49.320 --> 00:24:52.580
I want to go through
the bad side of that.

00:24:52.580 --> 00:24:54.630
Normally, using things
that offset width

00:24:54.630 --> 00:24:56.274
in the middle of
your code can lead

00:24:56.274 --> 00:24:57.440
to a performance difficulty.

00:24:57.440 --> 00:24:58.690
And here's an example of that.

00:24:58.690 --> 00:25:01.025
Here I've got a page with
a load of paragraphs.

00:25:01.025 --> 00:25:02.400
What I'm going to
do is I'm going

00:25:02.400 --> 00:25:04.050
to set Chrome's timeline
recording, which

00:25:04.050 --> 00:25:05.500
is going to record
everything that's going on,

00:25:05.500 --> 00:25:07.710
resize this green box, and
I'm going to hit that button.

00:25:07.710 --> 00:25:09.668
When I hit that button,
all of these paragraphs

00:25:09.668 --> 00:25:12.130
are going to become the
same size as the green box.

00:25:12.130 --> 00:25:15.790
So do that, press the
button, and they all change.

00:25:15.790 --> 00:25:16.790
And that was quite slow.

00:25:16.790 --> 00:25:19.123
We can see in the timeline
there's a little spike there.

00:25:19.123 --> 00:25:22.720
And if we have a look at the
number that comes up there,

00:25:22.720 --> 00:25:25.400
it's 1.27 seconds.

00:25:25.400 --> 00:25:26.640
It's very slow.

00:25:26.640 --> 00:25:28.930
But this is the little
Warning icon on there,

00:25:28.930 --> 00:25:31.529
and if we look into that, we
get a clue of what's going on.

00:25:31.529 --> 00:25:33.820
We get this recalculate style
layout, recalculate style

00:25:33.820 --> 00:25:35.770
layout happening
over and over again,

00:25:35.770 --> 00:25:37.800
and that's not looking great.

00:25:37.800 --> 00:25:39.430
The code we're using
is really simple.

00:25:39.430 --> 00:25:41.346
We just looped through
all of those paragraphs

00:25:41.346 --> 00:25:44.317
and set the offset width of the
green block to the paragraph.

00:25:44.317 --> 00:25:46.150
Now, the first time we
go through this loop,

00:25:46.150 --> 00:25:48.750
we ask the browser what is
the size of the green box?

00:25:48.750 --> 00:25:51.450
And it goes oh, I
know the answer,

00:25:51.450 --> 00:25:52.619
because I've just drawn it.

00:25:52.619 --> 00:25:53.410
Here's your answer.

00:25:53.410 --> 00:25:54.679
Easy peasy.

00:25:54.679 --> 00:25:56.470
And then we set the
width of the paragraph.

00:25:56.470 --> 00:25:58.090
But the next time we
come around the loop,

00:25:58.090 --> 00:26:00.298
we ask the browser what's
the width of the green box?

00:26:00.298 --> 00:26:02.440
And it's like hmm,
I used to know

00:26:02.440 --> 00:26:04.580
the answer to that question,
but since then you've

00:26:04.580 --> 00:26:06.890
been playing around
with styles on the page.

00:26:06.890 --> 00:26:09.920
So I need to go away and have a
think about what you've changed

00:26:09.920 --> 00:26:13.180
and see if it affects the
width of the green block.

00:26:13.180 --> 00:26:14.970
And that's going to
happen on every loop.

00:26:14.970 --> 00:26:16.320
This is layout thrashing.

00:26:16.320 --> 00:26:18.490
This is interleaving
style reads and writes,

00:26:18.490 --> 00:26:20.070
and it's a performance killer.

00:26:20.070 --> 00:26:22.430
What we actually want to
do is just cache that,

00:26:22.430 --> 00:26:25.632
do the reads first outside the
loop, get the green box width,

00:26:25.632 --> 00:26:26.840
and then go through the loop.

00:26:26.840 --> 00:26:28.690
And the difference is
absolutely astounding.

00:26:28.690 --> 00:26:31.060
So recording that, changing
the width of the green box,

00:26:31.060 --> 00:26:32.893
click the button, it
just happens instantly,

00:26:32.893 --> 00:26:34.170
and it's a massive difference.

00:26:34.170 --> 00:26:35.545
And that was like
60 milliseconds

00:26:35.545 --> 00:26:39.110
all in for everything,
versus over a second.

00:26:39.110 --> 00:26:42.350
So if you need to read something
that's style dependent,

00:26:42.350 --> 00:26:45.230
do it before you start
making style changes.

00:26:45.230 --> 00:26:46.260
Am I out of time?

00:26:46.260 --> 00:26:47.440
Am I done?

00:26:47.440 --> 00:26:51.670
OK, but before we do that, we'll
have a look at the final scores

00:26:51.670 --> 00:26:54.190
and see who managed
to win the Chromecast.

00:26:54.190 --> 00:26:57.650
If I can get my mouse
pointer over here.

00:26:57.650 --> 00:27:00.240
Right.

00:27:00.240 --> 00:27:02.890
A moment of tension.

00:27:02.890 --> 00:27:04.081
Where's my mouse pointer?

00:27:04.081 --> 00:27:05.080
Let's see if this works.

00:27:10.310 --> 00:27:11.410
OK.

00:27:11.410 --> 00:27:14.650
Oh, we've got a draw.

00:27:14.650 --> 00:27:15.520
That's how many?

00:27:15.520 --> 00:27:17.512
We've got one Chromecast.

00:27:17.512 --> 00:27:18.470
We can get another one.

00:27:18.470 --> 00:27:18.890
That's excellent.

00:27:18.890 --> 00:27:21.540
And I do have a bonus round,
but we're definitely out time.

00:27:21.540 --> 00:27:24.170
Where are you two people?

00:27:24.170 --> 00:27:26.290
Where are you?

00:27:26.290 --> 00:27:30.112
Oh, one here, and there--
Oh, congratulations, guys.

00:27:30.112 --> 00:27:31.570
A round of applause
for these guys.

00:27:36.790 --> 00:27:38.599
And with that, I say
thank you very much,

00:27:38.599 --> 00:27:40.390
and I'm going to make
way for someone else.

00:27:40.390 --> 00:27:41.473
Thank you very much, guys.

00:27:41.473 --> 00:27:42.580
Cheers.

