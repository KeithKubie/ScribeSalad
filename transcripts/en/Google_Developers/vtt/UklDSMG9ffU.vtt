WEBVTT
Kind: captions
Language: en

00:00:01.020 --> 00:00:02.690
MATT WARD: So I guess
we can get started.

00:00:02.690 --> 00:00:04.330
My name's Matt Ward,
and this is my

00:00:04.330 --> 00:00:07.060
friend, Steven Robertson.

00:00:07.060 --> 00:00:09.420
And today we're going to tell
you a little bit about how

00:00:09.420 --> 00:00:11.880
we're changing the way we stream
videos at YouTube.

00:00:11.880 --> 00:00:13.880
We're going to talk about
adaptive streaming.

00:00:13.880 --> 00:00:16.840
And as you know, we'll
be talking about

00:00:16.840 --> 00:00:18.220
the internet today.

00:00:18.220 --> 00:00:20.090
This is a great picture that
my friends over at

00:00:20.090 --> 00:00:22.110
collegehumor.com put together.

00:00:22.110 --> 00:00:24.090
You can go check it out if you
don't know any of these memes.

00:00:24.090 --> 00:00:26.190
A lot of them are YouTube
memes, which is why I'm

00:00:26.190 --> 00:00:27.340
showing this off.

00:00:27.340 --> 00:00:31.810
And we're actually going to go
and talk about the birthplace

00:00:31.810 --> 00:00:32.810
from our perspective.

00:00:32.810 --> 00:00:36.300
This is not the artist-- once
the artist uploads it, this is

00:00:36.300 --> 00:00:38.350
kind of where everything
starts for us.

00:00:38.350 --> 00:00:40.750
And that's in our Google
data centers.

00:00:40.750 --> 00:00:42.780
We're making some big changes
about how we're processing

00:00:42.780 --> 00:00:45.450
these videos that we're
going to go into.

00:00:45.450 --> 00:00:48.220
And then the next part of these
video's life cycle, if

00:00:48.220 --> 00:00:50.890
you will, is traveling
through these pipes.

00:00:50.890 --> 00:00:55.410
And these are kind of the first
pipes that these videos

00:00:55.410 --> 00:00:58.070
go through as they leave our
data centers and head towards

00:00:58.070 --> 00:00:59.410
your computer.

00:00:59.410 --> 00:01:01.700
It is one of the first possible
places that we can

00:01:01.700 --> 00:01:02.880
see congestion.

00:01:02.880 --> 00:01:05.580
And there's a lot of congestion
out there on the

00:01:05.580 --> 00:01:07.294
internet today.

00:01:07.294 --> 00:01:10.090
No, I have to click that
and this slide.

00:01:10.090 --> 00:01:13.120
And this is really kind of
what we're doing to the

00:01:13.120 --> 00:01:15.590
internet today with all of the
data that we're putting

00:01:15.590 --> 00:01:16.600
through it.

00:01:16.600 --> 00:01:20.152
We're really just doing this.

00:01:20.152 --> 00:01:21.995
[AUDIENCE LAUGHS]

00:01:21.995 --> 00:01:23.640
MATT WARD: Don't worry,
it'll start.

00:01:23.640 --> 00:01:33.910
[SPEAKING JAPANESE IN VIDEO]

00:01:33.910 --> 00:01:35.900
MATT WARD: We're pushing as much
data as possible through

00:01:35.900 --> 00:01:38.160
these pipes right now.

00:01:38.160 --> 00:01:42.660
And it's kind of getting
crowded in there.

00:01:42.660 --> 00:01:47.100
So when it gets crowded
like that, this is

00:01:47.100 --> 00:01:48.310
what our users see.

00:01:48.310 --> 00:01:49.750
They get a buffer spinner.

00:01:49.750 --> 00:01:53.380
Your network gets congested,
and you're not able to pull

00:01:53.380 --> 00:01:55.420
data down as quickly
as you were before,

00:01:55.420 --> 00:01:57.610
and so, buffer spinner.

00:01:57.610 --> 00:02:00.680
So today we're going to talk
about a four-year project at

00:02:00.680 --> 00:02:04.040
YouTube to change the
way that we actually

00:02:04.040 --> 00:02:06.390
stream videos to users.

00:02:06.390 --> 00:02:08.550
We're going to talk about
two projects.

00:02:08.550 --> 00:02:10.889
The first project
is called Zeri.

00:02:10.889 --> 00:02:14.070
It's something Adobe introduced
to us, a new API,

00:02:14.070 --> 00:02:18.660
specifically, that Adobe
introduced to us back in 2009.

00:02:18.660 --> 00:02:20.940
It took us a couple of years
to get a working prototype,

00:02:20.940 --> 00:02:23.870
and another year to actually
ship it to all of our users.

00:02:23.870 --> 00:02:27.570
And then we started really
focusing on HTML5, and we're

00:02:27.570 --> 00:02:30.670
going to end today talking about
how we're doing the same

00:02:30.670 --> 00:02:33.610
kind of thing in HTML5.

00:02:33.610 --> 00:02:36.350
So let's kind of get started.

00:02:36.350 --> 00:02:39.000
We actually refer to this
project as Sliced Bread

00:02:39.000 --> 00:02:39.840
internally.

00:02:39.840 --> 00:02:42.940
We talk about it as chunked
video playback.

00:02:42.940 --> 00:02:44.650
The best thing since
sliced bread.

00:02:44.650 --> 00:02:50.840
And that's because before for
these APIs, we were delivering

00:02:50.840 --> 00:02:53.160
video in giant loaves
of bread like this.

00:02:53.160 --> 00:02:55.230
There was nothing between
the internet

00:02:55.230 --> 00:02:56.980
and the actual plug-in.

00:02:56.980 --> 00:02:58.890
Here, I'm going to
give you a couple

00:02:58.890 --> 00:03:01.080
flash examples to start.

00:03:01.080 --> 00:03:05.150
And we really just used to send
the video right into the

00:03:05.150 --> 00:03:07.410
net stream, and the
video would play.

00:03:07.410 --> 00:03:07.830
That was it.

00:03:07.830 --> 00:03:10.250
There wasn't any more
complication to it.

00:03:10.250 --> 00:03:15.020
And then we introduced the Zeri
API, and now we sit right

00:03:15.020 --> 00:03:17.400
in between the internet and
the plug-in, and we really

00:03:17.400 --> 00:03:19.730
have control over how
quickly the data is

00:03:19.730 --> 00:03:21.550
flowing through it.

00:03:21.550 --> 00:03:24.320
And we chunk everything.

00:03:24.320 --> 00:03:28.778
And we'll go into why that
happens in a minute.

00:03:28.778 --> 00:03:29.630
[INAUDIBLE]

00:03:29.630 --> 00:03:30.280
MATT WARD: Exactly.

00:03:30.280 --> 00:03:31.910
There's four reasons why.

00:03:31.910 --> 00:03:35.080
We will go into each of them
in more details, but let's

00:03:35.080 --> 00:03:37.400
start talking about
efficiency.

00:03:37.400 --> 00:03:39.410
And like I said, chunking.

00:03:39.410 --> 00:03:43.590
So the first piece of the
pipeline that we built was

00:03:43.590 --> 00:03:45.930
taking the video and requesting
it in ranges.

00:03:45.930 --> 00:03:48.560
So rather than just requesting
the whole entire video in one

00:03:48.560 --> 00:03:51.580
big request, kind of like
putting data on as it comes

00:03:51.580 --> 00:03:56.820
along, what we did is we said,
OK, give me two megabytes.

00:03:56.820 --> 00:03:58.240
And then I'll put that on.

00:03:58.240 --> 00:04:00.420
Give me another two megabytes,
and then I'll put that on.

00:04:00.420 --> 00:04:02.570
And what this did was it
actually reduced our

00:04:02.570 --> 00:04:04.030
over send by 5%.

00:04:04.030 --> 00:04:05.650
This is a really big
savings for us and

00:04:05.650 --> 00:04:06.700
great for the internet.

00:04:06.700 --> 00:04:10.020
We actually were making more
space on the internet for

00:04:10.020 --> 00:04:12.760
other people to send bytes
through, because we made this

00:04:12.760 --> 00:04:13.860
improvement here.

00:04:13.860 --> 00:04:18.350
So, let's go into another
advantage that this gave us,

00:04:18.350 --> 00:04:23.360
which is because we were doing
this chunked request thing,

00:04:23.360 --> 00:04:28.280
what's happening is when we go
and seek around the video, we

00:04:28.280 --> 00:04:31.670
will try and align your chunk
request again so that the

00:04:31.670 --> 00:04:34.830
browser can actually handle
a layer of caching for us.

00:04:34.830 --> 00:04:38.990
So if we seek back to, say, zero
seconds, and you're all

00:04:38.990 --> 00:04:43.080
at the end of the video, and the
browser had that first two

00:04:43.080 --> 00:04:47.060
megabytes of the video in cache,
we can get access to

00:04:47.060 --> 00:04:47.790
that really quickly.

00:04:47.790 --> 00:04:51.450
And that's kind of the first
layer of cache that we see.

00:04:51.450 --> 00:04:53.110
And the next layer is
actually a little

00:04:53.110 --> 00:04:55.180
bit more in our control.

00:04:55.180 --> 00:04:57.730
So the browser cache, we don't
have any control over the

00:04:57.730 --> 00:04:59.150
eviction that's going
on there.

00:04:59.150 --> 00:05:03.360
We can't actually say,
do you have this two

00:05:03.360 --> 00:05:04.970
megabyte chunk in memory?

00:05:04.970 --> 00:05:08.150
The browser hasn't given us an
API for that, and we don't see

00:05:08.150 --> 00:05:09.510
one coming anytime soon.

00:05:09.510 --> 00:05:12.580
So we introduce this
next layer of cache

00:05:12.580 --> 00:05:13.970
that's really in memory.

00:05:13.970 --> 00:05:15.850
And that's really what you're
seeing when you see a buffer

00:05:15.850 --> 00:05:16.910
bar on our video.

00:05:16.910 --> 00:05:19.610
That's the amount of data that
we're actually holding in

00:05:19.610 --> 00:05:22.390
memory inside of the
Flash plug-in.

00:05:22.390 --> 00:05:26.630
So once the data flows out of
our in memory holdings, we

00:05:26.630 --> 00:05:30.280
kind of send it up to this net
stream object in Flash.

00:05:30.280 --> 00:05:32.020
And that's where the decoder
kind of lives.

00:05:32.020 --> 00:05:33.850
And once we've passed the bytes
in there, we really

00:05:33.850 --> 00:05:36.380
don't have any control over it
anymore, and the only thing we

00:05:36.380 --> 00:05:38.960
can do is say stop.

00:05:38.960 --> 00:05:45.690
So, let's talk a little bit more
about this buffer bar.

00:05:45.690 --> 00:05:48.780
So this is our great
seek bar here.

00:05:48.780 --> 00:05:53.195
And what we used to do is to try
and prevent all that over

00:05:53.195 --> 00:05:54.920
send we talked about
a little earlier.

00:05:54.920 --> 00:05:57.450
So we used to actually have
logic in our servers that

00:05:57.450 --> 00:05:59.530
trickled the bytes down.

00:05:59.530 --> 00:06:01.970
Believe it or not, this
logic wasn't perfect.

00:06:01.970 --> 00:06:04.120
I know it's shocking.

00:06:04.120 --> 00:06:07.630
But now that we are looking at
how many bytes the client is

00:06:07.630 --> 00:06:09.400
actually receiving, and we
have this really accurate

00:06:09.400 --> 00:06:11.820
measurement of how many bytes
are arriving on the client,

00:06:11.820 --> 00:06:14.400
we're able to effectively
manage how much

00:06:14.400 --> 00:06:15.150
read ahead we have.

00:06:15.150 --> 00:06:18.560
And today we kind of cap
that around 40 seconds.

00:06:18.560 --> 00:06:22.660
And that's what we found
was a good value.

00:06:22.660 --> 00:06:25.600
When you made that value larger,
you crash a lot of

00:06:25.600 --> 00:06:27.210
Flash plug-ins.

00:06:27.210 --> 00:06:29.330
Trust me.

00:06:29.330 --> 00:06:32.930
So the next thing here that
I've pointed out that we

00:06:32.930 --> 00:06:36.940
changed was we had this other
really advanced logic in our

00:06:36.940 --> 00:06:39.880
servers to handle a certain
kind of seeking.

00:06:39.880 --> 00:06:43.010
So when we talk about seeking
there's two kinds of seeking.

00:06:43.010 --> 00:06:44.640
The first kind of seeking
is what we

00:06:44.640 --> 00:06:46.140
call in buffer seeking.

00:06:46.140 --> 00:06:48.110
And that kind of looks
like this.

00:06:48.110 --> 00:06:50.130
You seek to an area that you
kind of have already

00:06:50.130 --> 00:06:52.650
downloaded and you have in
memory in the browser.

00:06:52.650 --> 00:06:56.470
And these we're able to handle
by feeding the bytes we kind

00:06:56.470 --> 00:06:58.440
of already have in memory
right in there.

00:06:58.440 --> 00:07:02.010
Now, what happens when you seek
to this region, which we

00:07:02.010 --> 00:07:03.730
don't really know
anything about?

00:07:03.730 --> 00:07:04.760
Right?

00:07:04.760 --> 00:07:09.030
In the past, those in buffer
seeks were really simple,

00:07:09.030 --> 00:07:11.490
because the plug-in just
handled them for you.

00:07:11.490 --> 00:07:13.480
You didn't have to think
about it at all.

00:07:13.480 --> 00:07:15.470
But when you did this, the
plug-in would say, I don't

00:07:15.470 --> 00:07:16.420
know anything about that.

00:07:16.420 --> 00:07:17.540
What can you do for me?

00:07:17.540 --> 00:07:21.610
And we would re-request the
whole entire stream again by

00:07:21.610 --> 00:07:25.830
appending a start parameter to
the actual URL, and say, hey,

00:07:25.830 --> 00:07:29.360
I seek to a minute into the
video, but I'd only downloaded

00:07:29.360 --> 00:07:31.620
30 seconds, right, so I don't
know about what's going on

00:07:31.620 --> 00:07:32.570
that minute.

00:07:32.570 --> 00:07:35.040
So really you would say, start
at 60 seconds and give me a

00:07:35.040 --> 00:07:36.160
video stream from there.

00:07:36.160 --> 00:07:39.510
And the servers would stitch
together a new video for us.

00:07:39.510 --> 00:07:42.920
And we changed that, and now we
do all of that logic on the

00:07:42.920 --> 00:07:43.690
client side.

00:07:43.690 --> 00:07:46.910
And it's made our servers a
lot dumber, if you will.

00:07:46.910 --> 00:07:48.550
But our clients are really,
really smart.

00:07:48.550 --> 00:07:50.920
And it also let us play some
really neat tricks on the

00:07:50.920 --> 00:07:52.820
client that we'll talk
about later.

00:07:52.820 --> 00:07:56.570
So to do client side seeking
like this, we have to gain a

00:07:56.570 --> 00:07:59.500
really, really clear
understanding of what the

00:07:59.500 --> 00:08:00.730
container is.

00:08:00.730 --> 00:08:03.360
So I'm going to give a little
background on what videos

00:08:03.360 --> 00:08:04.020
actually look like.

00:08:04.020 --> 00:08:06.010
And I'm going to make a little
analogy for you.

00:08:06.010 --> 00:08:08.660
Videos are like tacos.

00:08:08.660 --> 00:08:10.980
They look exactly like this.

00:08:10.980 --> 00:08:12.800
So what do I mean?

00:08:12.800 --> 00:08:13.560
OK.

00:08:13.560 --> 00:08:17.550
So, the meat of this video,
the stuff that we really,

00:08:17.550 --> 00:08:19.240
really care about is
the underlying

00:08:19.240 --> 00:08:20.640
video and audio codecs.

00:08:20.640 --> 00:08:23.680
Here I give a few examples of
that on the left over here.

00:08:23.680 --> 00:08:26.400
And then, the container is this
kind of stuff that wraps

00:08:26.400 --> 00:08:27.410
around the outside.

00:08:27.410 --> 00:08:30.390
It kind of tells you something
about what's inside.

00:08:30.390 --> 00:08:34.740
It's what keeps the whole video
together, if you will.

00:08:34.740 --> 00:08:37.400
It brings all of these
individual samples that we've

00:08:37.400 --> 00:08:42.539
encoded together into this one
big glorious hunk of video.

00:08:42.539 --> 00:08:47.890
So what we did in our project
initially that we did in Flash

00:08:47.890 --> 00:08:54.290
was answer this question of how
do we know a byte offset

00:08:54.290 --> 00:08:56.520
for a time that the
user requests?

00:08:56.520 --> 00:08:59.960
And we kind of built this really
common interface for

00:08:59.960 --> 00:09:01.510
the whole entire thing.

00:09:01.510 --> 00:09:03.550
You know FLV, we have this
time to byte map.

00:09:03.550 --> 00:09:07.840
MP4s have these things
called moov atoms.

00:09:07.840 --> 00:09:10.740
Sidx, kind of the same story.

00:09:10.740 --> 00:09:14.680
HLS and DASH each
have a manifest.

00:09:14.680 --> 00:09:18.010
The manifest says, oh, well
here's five second chunk, five

00:09:18.010 --> 00:09:19.720
second chunk, five second chunk,
and that's kind of the

00:09:19.720 --> 00:09:21.670
granularity you get there.

00:09:21.670 --> 00:09:24.470
So we built a kind of common
interface to that from time to

00:09:24.470 --> 00:09:28.100
byte that our application can
query into to find out this

00:09:28.100 --> 00:09:31.310
answer that's so important
for seeking.

00:09:31.310 --> 00:09:33.990
The next part was for the
samples that we actually hold

00:09:33.990 --> 00:09:36.510
onto, we'll talk about this in
a second, but we actually

00:09:36.510 --> 00:09:40.385
sometimes switch the codec that
we're using in the middle

00:09:40.385 --> 00:09:41.510
of playback.

00:09:41.510 --> 00:09:43.560
We're doing this a little less
and less today, and I'll talk

00:09:43.560 --> 00:09:44.570
about that later.

00:09:44.570 --> 00:09:46.530
But let's first talk
about what a video

00:09:46.530 --> 00:09:47.170
really looks like.

00:09:47.170 --> 00:09:50.200
And it looks a lot more
like this than a taco.

00:09:50.200 --> 00:09:53.290
So the videos kind of start
with this thing that

00:09:53.290 --> 00:09:54.690
initializes the decoder.

00:09:54.690 --> 00:09:56.650
You kind of tell the decoder,
this is the key frame I'm

00:09:56.650 --> 00:09:57.210
about to feed you.

00:09:57.210 --> 00:09:59.130
This is what--

00:09:59.130 --> 00:10:01.860
the data you're about to see
is going to look like this.

00:10:01.860 --> 00:10:03.640
That's what we start
by saying.

00:10:03.640 --> 00:10:07.280
And then videos have key frames
and progressive frames

00:10:07.280 --> 00:10:12.840
and this simple example here
uses H264 without any fancy B

00:10:12.840 --> 00:10:15.100
frames or anything that you
guys might know about.

00:10:15.100 --> 00:10:17.570
And some basic AAC audio.

00:10:17.570 --> 00:10:20.010
That's a lot of what we've been
streaming these days.

00:10:20.010 --> 00:10:23.790
So let's go into how
we do adaptation.

00:10:23.790 --> 00:10:27.300
One of the big things that we're
able to do now is switch

00:10:27.300 --> 00:10:27.930
between streams.

00:10:27.930 --> 00:10:30.140
So here we have two streams.

00:10:30.140 --> 00:10:33.750
A and B. And we detect
that there's a

00:10:33.750 --> 00:10:35.270
change in the network.

00:10:35.270 --> 00:10:35.720
Right?

00:10:35.720 --> 00:10:41.246
And what we want to do is
this, make a switch.

00:10:41.246 --> 00:10:44.840
So when we make a switch, that
has to happen at a key frame,

00:10:44.840 --> 00:10:49.240
because the decoder will not
understand if you switch at a

00:10:49.240 --> 00:10:51.520
progressive frame here.

00:10:51.520 --> 00:10:58.890
How do I make this transfer from
my current data to some--

00:10:58.890 --> 00:11:01.300
each of the progressive frames
kind of build on key frames.

00:11:01.300 --> 00:11:02.890
So you must feed a
key frame first.

00:11:02.890 --> 00:11:06.140
And that's the logic that we
also had to be very careful to

00:11:06.140 --> 00:11:07.530
take care of.

00:11:07.530 --> 00:11:09.910
So once we kind of had this
understanding of all this

00:11:09.910 --> 00:11:13.440
stuff, and really understand how
to glue videos together on

00:11:13.440 --> 00:11:17.050
the fly in our clients, we
introduced this simple

00:11:17.050 --> 00:11:18.640
splicing mechanism.

00:11:18.640 --> 00:11:21.040
Now, this is going to look
crazy, but this is what our

00:11:21.040 --> 00:11:22.480
application got to
at this point.

00:11:22.480 --> 00:11:26.060
We were building and tearing
down all of these things that

00:11:26.060 --> 00:11:30.960
parse and handle different media
containers, and cache

00:11:30.960 --> 00:11:32.810
each of those individual files
that you're pulling

00:11:32.810 --> 00:11:33.680
separately.

00:11:33.680 --> 00:11:35.110
And then we had this
splicing thing that

00:11:35.110 --> 00:11:36.730
switched back and forth.

00:11:36.730 --> 00:11:40.270
And this API was really
interesting and really fun to

00:11:40.270 --> 00:11:43.030
work with, but Steve's going to
talk about its implication

00:11:43.030 --> 00:11:46.480
of this later in HTML5, so you
guys don't have to deal with

00:11:46.480 --> 00:11:48.180
any of this stuff anymore.

00:11:48.180 --> 00:11:52.200
So the next part, once we
have all this stuff, how

00:11:52.200 --> 00:11:53.410
do we launch it?

00:11:53.410 --> 00:11:57.170
Well, like I said, this took
us four years from start to

00:11:57.170 --> 00:11:58.460
finish, more or less.

00:11:58.460 --> 00:12:01.010
And even once we finished, all
of the stuff that you saw so

00:12:01.010 --> 00:12:03.490
far, we had all of it
like code complete.

00:12:03.490 --> 00:12:07.810
We spent months finding bugs,
and launching experiments, and

00:12:07.810 --> 00:12:11.230
trying to figure out where
are all the problems.

00:12:11.230 --> 00:12:13.970
So let's talk about a couple
of those problems here.

00:12:13.970 --> 00:12:17.630
The first problem, remember how
I had those nice pretty

00:12:17.630 --> 00:12:20.520
lineups between all of videos?

00:12:20.520 --> 00:12:22.580
That's not really what
our videos look like.

00:12:22.580 --> 00:12:25.230
They look a lot more
like this.

00:12:25.230 --> 00:12:29.080
So if you're going to switch
between stream A and stream B

00:12:29.080 --> 00:12:32.810
here, what's going to happen
is you're going to have to

00:12:32.810 --> 00:12:33.820
switch at that key frame.

00:12:33.820 --> 00:12:35.720
Are you going to switch in the
middle of that progressive

00:12:35.720 --> 00:12:36.910
frame on the top one?

00:12:36.910 --> 00:12:40.210
Or are you going to drop
that progressive frame?

00:12:40.210 --> 00:12:42.870
So what would happen is you
would either get black

00:12:42.870 --> 00:12:45.340
flashes, or you'd
go back in time.

00:12:45.340 --> 00:12:49.030
Some people don't notice this,
because it's very, very quick.

00:12:49.030 --> 00:12:51.420
But this was happening.

00:12:51.420 --> 00:12:54.220
Well, I had a worse problem.

00:12:54.220 --> 00:12:57.290
People are more sensitive
about audio.

00:12:57.290 --> 00:12:58.870
Audio--

00:12:58.870 --> 00:13:01.530
if you're doing this in audio,
you're making pops and

00:13:01.530 --> 00:13:03.440
glitches is in people's ears.

00:13:03.440 --> 00:13:05.280
This is bad.

00:13:05.280 --> 00:13:09.940
So for a while, actually, we
were paying the price of the

00:13:09.940 --> 00:13:14.110
occasional pop and glitch in
people's ears, for the cost of

00:13:14.110 --> 00:13:16.370
less re-buffers and smoother
play backs.

00:13:16.370 --> 00:13:19.110
We tried to limit how many
switches we would do during a

00:13:19.110 --> 00:13:22.260
play back to minimize the
number of these kind of

00:13:22.260 --> 00:13:24.040
problems that users would see.

00:13:24.040 --> 00:13:27.510
But what we're doing today
is we're making our

00:13:27.510 --> 00:13:28.900
videos look like this.

00:13:28.900 --> 00:13:31.700
We're re-transcoding everything
inside of YouTube

00:13:31.700 --> 00:13:34.170
to really improve
the experience.

00:13:34.170 --> 00:13:36.270
We want all the key frames
lined up so that when we

00:13:36.270 --> 00:13:38.540
switch streams, you don't
even notice any

00:13:38.540 --> 00:13:40.460
black frames or anything.

00:13:40.460 --> 00:13:43.680
The audio, for all of our
qualities now, the

00:13:43.680 --> 00:13:45.290
audio is the same.

00:13:45.290 --> 00:13:48.390
When we're playing an auto
adapted playback.

00:13:48.390 --> 00:13:52.180
We hold the same exact audio
stream at CD quality through

00:13:52.180 --> 00:13:53.240
the whole entire thing.

00:13:53.240 --> 00:13:54.480
It's great.

00:13:54.480 --> 00:13:57.340
I mean, you know how everyone
always used to switch up, to

00:13:57.340 --> 00:13:59.570
like try and get that better
audio quality?

00:13:59.570 --> 00:14:03.350
Well, now we hold the same one
for almost all of them.

00:14:03.350 --> 00:14:06.350
This also enabled a bunch of
other neat things, but Steve

00:14:06.350 --> 00:14:08.530
might talk about those later.

00:14:08.530 --> 00:14:13.410
The other major problem that
we had was our caches.

00:14:13.410 --> 00:14:17.710
So at YouTube, we have a
bunch of caches, where

00:14:17.710 --> 00:14:18.990
we store our videos.

00:14:18.990 --> 00:14:21.530
This is shocking.

00:14:21.530 --> 00:14:24.200
Basically, this is what they
used to look like.

00:14:24.200 --> 00:14:27.020
Formats A, B and C, for
a video, were all

00:14:27.020 --> 00:14:28.380
on different machines.

00:14:28.380 --> 00:14:30.920
So when we wanted to pull one
of these videos, we had to

00:14:30.920 --> 00:14:33.990
open a new connection to a new
machine, and say, hey, how

00:14:33.990 --> 00:14:35.890
quickly can you get me
those video bytes?

00:14:35.890 --> 00:14:38.830
And the actual rate at which
you can get them from these

00:14:38.830 --> 00:14:41.720
two different machines might
vary, because of, like I said

00:14:41.720 --> 00:14:43.740
before, varying network
conditions, right?

00:14:43.740 --> 00:14:47.020
This is all about understanding
what the network

00:14:47.020 --> 00:14:48.660
is like between you and
the server you're

00:14:48.660 --> 00:14:49.760
pulling videos from.

00:14:49.760 --> 00:14:51.660
When you start changing that
in the middle of your

00:14:51.660 --> 00:14:54.420
adaptation, it gets really,
really complicated.

00:14:54.420 --> 00:14:57.395
So we did this.

00:14:57.395 --> 00:14:59.300
We moved everything
on to one machine.

00:14:59.300 --> 00:15:00.650
And that took months.

00:15:00.650 --> 00:15:04.130
We had to redesign our caches
from the ground up to make

00:15:04.130 --> 00:15:05.150
this happen.

00:15:05.150 --> 00:15:09.040
It was a very, very large
project, as you

00:15:09.040 --> 00:15:11.370
could probably imagine.

00:15:11.370 --> 00:15:17.990
The last problem, latency.

00:15:17.990 --> 00:15:23.000
So anyone want to guess where we
launched adaptive streaming

00:15:23.000 --> 00:15:25.390
and Flash in this?

00:15:25.390 --> 00:15:28.400
We'll talk about that in a
minute, but right in the

00:15:28.400 --> 00:15:32.525
middle here, you'll see the blue
line is Flash, red line

00:15:32.525 --> 00:15:37.920
is HTML5, and all of a
sudden, HTML5 is a

00:15:37.920 --> 00:15:39.620
lot faster than Flash.

00:15:39.620 --> 00:15:41.760
I'm going to hand it over to
Steve to tell you about why

00:15:41.760 --> 00:15:44.550
we're switching to HTML5 and
why this is the case.

00:15:44.550 --> 00:15:47.760
And he'll talk about HTML5.

00:15:47.760 --> 00:15:49.850
STEVEN ROBERTSON: Thanks Matt.

00:15:49.850 --> 00:15:53.190
So when we started doing
application level streaming, a

00:15:53.190 --> 00:15:55.330
new security mechanism
kicked in.

00:15:55.330 --> 00:15:58.120
That security mechanism is
a cross origin request

00:15:58.120 --> 00:15:58.960
restriction.

00:15:58.960 --> 00:16:02.310
When you try and place a request
to a new domain,

00:16:02.310 --> 00:16:05.840
because all of our videos are
stored on separate machines,

00:16:05.840 --> 00:16:08.910
that request needs a security
check first.

00:16:08.910 --> 00:16:12.000
And that security check is
implemented in Flash by making

00:16:12.000 --> 00:16:15.190
an initial request to a
policy file located at

00:16:15.190 --> 00:16:16.300
the document root.

00:16:16.300 --> 00:16:18.970
That initial request has to
complete before the next

00:16:18.970 --> 00:16:20.940
request cam start.

00:16:20.940 --> 00:16:25.200
In HTML5, that information is
actually embedded straight

00:16:25.200 --> 00:16:27.790
into the HTTP request and
response, and the browser is

00:16:27.790 --> 00:16:29.290
responsible for dropping
response.

00:16:29.290 --> 00:16:31.100
It offers the same level
of security, but

00:16:31.100 --> 00:16:32.260
no extra round trip.

00:16:32.260 --> 00:16:35.450
And that tiny little XML file
makes the difference between

00:16:35.450 --> 00:16:38.580
HTML5 being faster.

00:16:38.580 --> 00:16:41.980
So this change actually has a
lot of fortuitous timing,

00:16:41.980 --> 00:16:45.440
because for the first time,
we're also able to append

00:16:45.440 --> 00:16:49.930
media directly to the video
element from an application

00:16:49.930 --> 00:16:52.820
control in HTML5.

00:16:52.820 --> 00:16:56.660
The media source extensions are
a new specification in the

00:16:56.660 --> 00:16:59.110
W3, just won't work in draft.

00:16:59.110 --> 00:17:02.090
And they basically do the same
thing that Zeri did.

00:17:02.090 --> 00:17:06.550
They offer an application and
opportunity to append a data

00:17:06.550 --> 00:17:07.660
straight to a media element.

00:17:07.660 --> 00:17:09.890
And in fact, in the first draft,
they basically look

00:17:09.890 --> 00:17:11.460
exactly like Zeri.

00:17:11.460 --> 00:17:15.270
And we tried this out, and we
realized that it wouldn't

00:17:15.270 --> 00:17:16.869
actually work.

00:17:16.869 --> 00:17:19.660
Well, it would work on desktop
Chrome, but we needed this to

00:17:19.660 --> 00:17:20.190
be everywhere.

00:17:20.190 --> 00:17:22.115
We needed this to be on phones,
we needed this to be

00:17:22.115 --> 00:17:25.170
on TVs, and the API
just was not as

00:17:25.170 --> 00:17:27.339
portable as the web required.

00:17:27.339 --> 00:17:31.670
And understanding that takes us
to one of the core axioms

00:17:31.670 --> 00:17:33.980
of engineering work
at YouTube.

00:17:33.980 --> 00:17:37.790
Which is that playing
videos is hard.

00:17:37.790 --> 00:17:39.060
Surprisingly hard.

00:17:39.060 --> 00:17:43.110
But it's a little easier to
understand given the history

00:17:43.110 --> 00:17:44.890
of video codec development.

00:17:44.890 --> 00:17:46.290
This is just one facet of it.

00:17:46.290 --> 00:17:50.480
But the codecs themselves are
optimized for a tremendous

00:17:50.480 --> 00:17:53.970
number of conditions and each
one has separate trade offs.

00:17:53.970 --> 00:17:56.130
But they're all gunning
for lower bit

00:17:56.130 --> 00:17:57.780
rate, or higher fidelity.

00:17:57.780 --> 00:18:01.220
And none of the things that
they're optimized are

00:18:01.220 --> 00:18:02.390
simplicity.

00:18:02.390 --> 00:18:07.010
In fact, the codec target for
most next generation codecs,

00:18:07.010 --> 00:18:10.380
whatever that generation is, is
like, oh, we'll only double

00:18:10.380 --> 00:18:11.770
or triple the complexity.

00:18:11.770 --> 00:18:15.960
And we at YouTube are thrilled
about this, because it does

00:18:15.960 --> 00:18:22.320
cut down on the most important
expenses, and lets us access a

00:18:22.320 --> 00:18:26.060
lot more content and distribute
it more widely.

00:18:26.060 --> 00:18:28.910
But when you tell a bunch of
very smart scientists and

00:18:28.910 --> 00:18:31.310
engineers to make something more
complicated over the span

00:18:31.310 --> 00:18:33.750
of 40 years, they succeed.

00:18:33.750 --> 00:18:37.750
So Adobe dealt with this
originally in the Flash player

00:18:37.750 --> 00:18:39.620
by basically drawing a map.

00:18:39.620 --> 00:18:42.970
By codifying exactly what their
platform would do under

00:18:42.970 --> 00:18:44.930
all of these circumstances.

00:18:44.930 --> 00:18:47.250
And that allowed developers to
build applications for the

00:18:47.250 --> 00:18:51.290
first time that would be able
to do complicated mechanics,

00:18:51.290 --> 00:18:54.380
like the things that we do
in the YouTube player.

00:18:54.380 --> 00:18:57.070
It was a tremendous
boom for the web.

00:18:57.070 --> 00:19:00.500
It allowed a lot of video
applications and videos, of

00:19:00.500 --> 00:19:04.200
course, really fundamental to
all kinds of experiences.

00:19:04.200 --> 00:19:09.390
And that was a fantastic move.

00:19:09.390 --> 00:19:11.580
But it was a trade off,
because when you build

00:19:11.580 --> 00:19:14.030
applications with these
implementation details in

00:19:14.030 --> 00:19:15.720
mind, they become brittle.

00:19:15.720 --> 00:19:16.480
They are hard to port.

00:19:16.480 --> 00:19:17.900
They're hard to maintain.

00:19:17.900 --> 00:19:20.720
And the Flash plug-in itself
has a lot of portability

00:19:20.720 --> 00:19:23.900
limitations due to restrictions
from those kind

00:19:23.900 --> 00:19:25.970
of implementation agreements.

00:19:25.970 --> 00:19:30.270
By contrast, the W3 expects and
mandates that their specs

00:19:30.270 --> 00:19:31.960
are interoperable, that
you can get multiple

00:19:31.960 --> 00:19:33.210
implementations going.

00:19:33.210 --> 00:19:37.550
And the append bytes model
didn't really fit with that.

00:19:37.550 --> 00:19:43.950
So, with the Chrome media team,
we worked out a system

00:19:43.950 --> 00:19:48.490
that was a little bit richer,
had more of an intermediate

00:19:48.490 --> 00:19:50.840
layer, so that you could
hide those interfaces.

00:19:50.840 --> 00:19:54.730
And so the media source spec
became much more effective at

00:19:54.730 --> 00:19:55.970
doing that.

00:19:55.970 --> 00:19:58.760
The core feature of this
is the source buffer.

00:19:58.760 --> 00:20:00.870
The source buffer is
an abstraction.

00:20:00.870 --> 00:20:02.570
It's mostly a timeline.

00:20:02.570 --> 00:20:06.520
And once you create a source
buffer object, you can just

00:20:06.520 --> 00:20:08.660
append media to it, after
you've downloaded it by

00:20:08.660 --> 00:20:10.060
whatever means.

00:20:10.060 --> 00:20:13.510
And as you continue to append,
to a certain point, the media

00:20:13.510 --> 00:20:14.990
is retained on the timeline.

00:20:14.990 --> 00:20:18.515
That's a lot like appending
media to a queue

00:20:18.515 --> 00:20:21.250
in the normal situation.

00:20:21.250 --> 00:20:24.850
So to understand more about
why this is so important,

00:20:24.850 --> 00:20:28.060
let's talk about an
Adaptive Upswitch.

00:20:28.060 --> 00:20:30.880
The adaptive algorithm has a
single goal, which is to put

00:20:30.880 --> 00:20:32.520
the best video quality
in front of

00:20:32.520 --> 00:20:33.920
the user at all times.

00:20:33.920 --> 00:20:36.110
And that means that if you're
watching a video, and you

00:20:36.110 --> 00:20:39.370
suddenly detect that you have
additional bandwidth, the

00:20:39.370 --> 00:20:43.310
player is going to start
downloading new video, not at

00:20:43.310 --> 00:20:47.120
the end of the queue, but as
soon as it can, for the next

00:20:47.120 --> 00:20:49.010
adaptive checkpoint.

00:20:49.010 --> 00:20:51.750
And normally what you would
expect is you just drop that

00:20:51.750 --> 00:20:54.870
new media in there, and it will
swap out for the media

00:20:54.870 --> 00:20:58.970
that is playing at 10 seconds
on this diagram.

00:20:58.970 --> 00:21:02.660
But underneath, the decoder
might have actually started

00:21:02.660 --> 00:21:05.110
pulling data far ahead.

00:21:05.110 --> 00:21:08.660
On Chrome, for instance, this
is like two or three frames,

00:21:08.660 --> 00:21:09.480
which is great.

00:21:09.480 --> 00:21:13.170
On a lot of TVs, it could be
10 seconds read ahead.

00:21:13.170 --> 00:21:17.370
And the platform needs to find
a way to communicate this

00:21:17.370 --> 00:21:21.230
effectively to the client if
you were using it in a pen

00:21:21.230 --> 00:21:23.220
bite style API, where you're
doing all this manual

00:21:23.220 --> 00:21:24.260
management.

00:21:24.260 --> 00:21:27.410
On the other hand, the source
buffer abstraction is capable

00:21:27.410 --> 00:21:29.300
of keeping track of
all this for you.

00:21:29.300 --> 00:21:31.840
So all you do is drop in the
media, and source buffer takes

00:21:31.840 --> 00:21:36.770
care of knowing when to splice,
and retaining the

00:21:36.770 --> 00:21:41.900
existing information so that
the decoder is pulling from

00:21:41.900 --> 00:21:43.350
exactly the right samples.

00:21:43.350 --> 00:21:47.330
And then once that process is
done, it'll swap in exactly

00:21:47.330 --> 00:21:50.130
what you told it to, so that way
the representation in the

00:21:50.130 --> 00:21:54.320
browser is exactly what the
application expects it to.

00:21:54.320 --> 00:21:57.780
So that's how we're doing
adaptive streaming in both

00:21:57.780 --> 00:21:59.450
HTML5 and Flash.

00:21:59.450 --> 00:22:03.250
A more interesting question
is what's in it for you?

00:22:03.250 --> 00:22:06.090
Why is this beneficial
for our users?

00:22:06.090 --> 00:22:09.320
And on a familiar theme,
the most important

00:22:09.320 --> 00:22:11.530
reason for us is speed.

00:22:11.530 --> 00:22:15.130
A lot of the existing adaptive
schemes may be simpler for

00:22:15.130 --> 00:22:18.160
applications to implement,
but they have

00:22:18.160 --> 00:22:19.520
a significant penalty.

00:22:19.520 --> 00:22:23.060
For example, one streaming
protocol, in order to do this

00:22:23.060 --> 00:22:26.900
adaptation, requires multiple
separate requests before it

00:22:26.900 --> 00:22:27.870
can get started.

00:22:27.870 --> 00:22:29.970
Some these requests are
megabytes of things that

00:22:29.970 --> 00:22:30.900
aren't movies.

00:22:30.900 --> 00:22:33.960
And that cost has to
be paid up front.

00:22:33.960 --> 00:22:38.070
The media source solution allows
us to embed a lot of

00:22:38.070 --> 00:22:41.250
that logic, and cuts down the
number of requests so that we

00:22:41.250 --> 00:22:44.490
can start making media fetches
at the top of the page,

00:22:44.490 --> 00:22:48.230
because we can coordinate that
with our application.

00:22:48.230 --> 00:22:51.090
Another important feature
is experiments.

00:22:51.090 --> 00:22:52.940
YouTube's constantly running
experiments.

00:22:52.940 --> 00:22:55.810
At any given time, you can
expect hundreds of experiments

00:22:55.810 --> 00:22:56.590
are going on.

00:22:56.590 --> 00:22:59.120
And because we see billions of
playbacks a day, these get

00:22:59.120 --> 00:23:01.780
data and are collected and
processed very quickly.

00:23:01.780 --> 00:23:04.890
And platform makers, browser
manufacturers, just don't have

00:23:04.890 --> 00:23:06.480
that instrumentation.

00:23:06.480 --> 00:23:09.020
They would have to build a
YouTube in order to collect

00:23:09.020 --> 00:23:09.590
that much data.

00:23:09.590 --> 00:23:12.190
So we can tune our algorithms
a lot faster, release new

00:23:12.190 --> 00:23:15.040
ones, and adapt to the changing
network conditions

00:23:15.040 --> 00:23:17.410
and geographic regions.

00:23:17.410 --> 00:23:20.080
Another thing we find out from
all this experimentation is

00:23:20.080 --> 00:23:23.430
that there's a lot of region
specific differences in what

00:23:23.430 --> 00:23:24.710
people like to see.

00:23:24.710 --> 00:23:27.470
For instance, in the United
States, people would rather

00:23:27.470 --> 00:23:30.150
watch a buffer spinner than see
their video adapt down to

00:23:30.150 --> 00:23:32.070
the very lowest qualities.

00:23:32.070 --> 00:23:34.290
But in other parts of
the world, people

00:23:34.290 --> 00:23:36.640
would prefer the 144p.

00:23:36.640 --> 00:23:38.330
They're like, don't even
give me the 360P.

00:23:38.330 --> 00:23:40.560
I want this to start quickly.

00:23:40.560 --> 00:23:44.380
So you have to build these
differences in a way that you

00:23:44.380 --> 00:23:47.850
can see the responsiveness, and
that requires this kind of

00:23:47.850 --> 00:23:51.390
online continuous tuning
and experimentation.

00:23:51.390 --> 00:23:54.030
Another surprising thing we
learned from this process is

00:23:54.030 --> 00:23:55.640
that software has bugs.

00:23:55.640 --> 00:23:59.470
Some bugs are more surprising
than others.

00:23:59.470 --> 00:24:03.280
For instance, if a popular
mobile handset manufacturer

00:24:03.280 --> 00:24:06.980
releases a software update that
opens TCP connections and

00:24:06.980 --> 00:24:08.900
doesn't close them,
you get something

00:24:08.900 --> 00:24:10.210
that looks like this.

00:24:10.210 --> 00:24:13.150
A globally distributed denial
of service attack on your

00:24:13.150 --> 00:24:15.280
servers that lasts for months.

00:24:15.280 --> 00:24:17.760
And there's basically nothing
you can do to avoid this

00:24:17.760 --> 00:24:20.090
situation except sit
and wait and hope

00:24:20.090 --> 00:24:21.490
they release an update.

00:24:21.490 --> 00:24:23.320
That means that we have to
make the choice between

00:24:23.320 --> 00:24:27.220
degrading service for all users,
or cutting off a large

00:24:27.220 --> 00:24:27.980
fraction of users.

00:24:27.980 --> 00:24:29.460
And we never want to
make that choice.

00:24:29.460 --> 00:24:31.460
With application level
streaming, we can deliver a

00:24:31.460 --> 00:24:36.420
fix or a work around in hours,
instead of months.

00:24:36.420 --> 00:24:37.870
And finally, there
are a lot of new

00:24:37.870 --> 00:24:41.370
features that this unlocks.

00:24:41.370 --> 00:24:44.740
One that's great for our users
is pre-loading the video, so

00:24:44.740 --> 00:24:47.890
we can make sure that videos on
the page start even faster.

00:24:47.890 --> 00:24:52.480
By downloading exactly how much
video we need without

00:24:52.480 --> 00:24:53.080
going over.

00:24:53.080 --> 00:24:55.970
We couldn't enable this on a
global basis, because some

00:24:55.970 --> 00:24:59.670
browsers will actually start
downloading the whole video.

00:24:59.670 --> 00:25:02.280
So having this application level
control gives us the

00:25:02.280 --> 00:25:04.470
assurance that we're doing the
right thing by the user.

00:25:04.470 --> 00:25:07.530
I'm really excited about global
load balancing, but

00:25:07.530 --> 00:25:10.950
that is an internal feature,
and the only effective

00:25:10.950 --> 00:25:13.800
response that you'll see is that
things will be much more

00:25:13.800 --> 00:25:15.510
stable over time.

00:25:15.510 --> 00:25:18.020
You won't encounter these
hiccups where your video

00:25:18.020 --> 00:25:22.070
connection suddenly gets slow
because one link is congested.

00:25:22.070 --> 00:25:26.560
So being able to see this, as
we mentioned, Flash, it is

00:25:26.560 --> 00:25:28.050
live at 100 percent.

00:25:28.050 --> 00:25:33.010
HTML5, the media source APIs are
implemented in Chrome, and

00:25:33.010 --> 00:25:34.820
we look forward to rolling
those out.

00:25:34.820 --> 00:25:37.810
You can join the HTML5
experiment to see how things

00:25:37.810 --> 00:25:38.470
work today.

00:25:38.470 --> 00:25:41.100
Or just stay put, and in the
next couple of months, you'll

00:25:41.100 --> 00:25:44.420
see this HTML5 experience
shipping natively on Chrome

00:25:44.420 --> 00:25:47.960
and then on any other browsers
that pick up this API.

00:25:47.960 --> 00:25:49.250
And we're also--

00:25:49.250 --> 00:25:54.030
a lot of our TV and console
applications are built on web

00:25:54.030 --> 00:25:54.970
technologies.

00:25:54.970 --> 00:25:57.810
So this same player will appear
there, and handsets

00:25:57.810 --> 00:26:00.020
will use the same streaming
strategies.

00:26:00.020 --> 00:26:04.490
So thank you for watching both
this presentation and YouTube.

00:26:04.490 --> 00:26:07.870
And if you all have any
questions, we'd

00:26:07.870 --> 00:26:09.508
love to hear them.

00:26:09.508 --> 00:26:14.100
[AUDIENCE CLAPS]

00:26:14.100 --> 00:26:14.920
AUDIENCE: Hi.

00:26:14.920 --> 00:26:21.640
What is it for us like
developers that need to give

00:26:21.640 --> 00:26:22.940
our users content?

00:26:22.940 --> 00:26:27.210
I mean, are you making any of
these available for us to use

00:26:27.210 --> 00:26:31.400
on our own websites instead
of YouTube?

00:26:31.400 --> 00:26:34.050
STEVEN ROBERTSON: The media
source extensions?

00:26:34.050 --> 00:26:35.810
The media source is
a new web API.

00:26:35.810 --> 00:26:36.930
So anybody can use it.

00:26:36.930 --> 00:26:41.330
But what we expect to happen,
and have seen some activity

00:26:41.330 --> 00:26:45.640
around, is that content
distribution networks will

00:26:45.640 --> 00:26:48.290
actually be doing the same kind
of experimentation and

00:26:48.290 --> 00:26:50.910
produce algorithms that are
tuned for their networks.

00:26:50.910 --> 00:26:53.560
So what they'll expose to users
is a simple player, a

00:26:53.560 --> 00:26:54.510
JavaScript thing.

00:26:54.510 --> 00:26:54.780
AUDIENCE: Mmm hmm.

00:26:54.780 --> 00:26:56.440
STEVEN ROBERTSON: You just
drop it in, and that

00:26:56.440 --> 00:26:59.760
JavaScript takes care of all
of the adaptive logic.

00:26:59.760 --> 00:27:02.490
But of course, being a web
technology, if you want to get

00:27:02.490 --> 00:27:05.280
in there and actually implement
your own stuff, more

00:27:05.280 --> 00:27:05.870
power to you.

00:27:05.870 --> 00:27:06.750
You definitely can.

00:27:06.750 --> 00:27:07.240
AUDIENCE: Thank you.

00:27:07.240 --> 00:27:08.950
MATT WARD: Of course, you're
also welcome to use our video

00:27:08.950 --> 00:27:11.640
player, which will just
do this all for free.

00:27:11.640 --> 00:27:12.900
AUDIENCE: Yeah.

00:27:12.900 --> 00:27:13.540
AUDIENCE: Hi.

00:27:13.540 --> 00:27:14.920
Great presentation, thanks.

00:27:14.920 --> 00:27:15.700
STEVEN ROBERTSON: Thank you.

00:27:15.700 --> 00:27:19.450
AUDIENCE: I'm wondering, why is
there no always play in HD

00:27:19.450 --> 00:27:21.560
option on YouTube?

00:27:21.560 --> 00:27:25.220
There's one that is play in HD
when you're in full screen,

00:27:25.220 --> 00:27:29.670
but what happens all the time
when I watch videos, I launch

00:27:29.670 --> 00:27:34.420
the video, put it in full
screen, and I've got like the

00:27:34.420 --> 00:27:37.130
15 or 20 first seconds
not in HD.

00:27:37.130 --> 00:27:38.460
And it's like, OK.

00:27:38.460 --> 00:27:40.860
I would always use the
HD option if it was

00:27:40.860 --> 00:27:41.950
there, but it's not.

00:27:41.950 --> 00:27:43.580
Is there a reason for that?

00:27:43.580 --> 00:27:46.831
MATT WARD: So I think part of
what you're asking here is--

00:27:46.831 --> 00:27:49.830
is your question more why am I
not getting HD right away when

00:27:49.830 --> 00:27:51.370
I go full screen
or is it more--

00:27:51.370 --> 00:27:53.430
AUDIENCE: So that I understood,
thanks to the

00:27:53.430 --> 00:27:58.600
presentation, it's why you do
not let users actually always

00:27:58.600 --> 00:28:01.070
have HD all the time
if they want to.

00:28:01.070 --> 00:28:03.640
MATT WARD: So you remember
how the pipes are

00:28:03.640 --> 00:28:05.300
getting really clogged?

00:28:05.300 --> 00:28:08.620
So if we did that the pipes
would be even more clogged and

00:28:08.620 --> 00:28:10.610
nobody would be able
to get through.

00:28:10.610 --> 00:28:14.750
So we're doing the best thing
here for a number of reasons.

00:28:14.750 --> 00:28:17.600
For that reason we're
conservative about how we're

00:28:17.600 --> 00:28:19.340
using bandwidth on
the internet.

00:28:19.340 --> 00:28:21.430
In addition, we're never
actually going to send you a

00:28:21.430 --> 00:28:24.900
720P video into a little
360P screen.

00:28:24.900 --> 00:28:28.560
This actually puts a lot more
strain on your CPU and your

00:28:28.560 --> 00:28:31.380
local processing, and will drain
your battery faster.

00:28:31.380 --> 00:28:34.050
We're thinking about things like
that and trying to pick

00:28:34.050 --> 00:28:36.980
the right quality for the size
screen that you have, as well

00:28:36.980 --> 00:28:40.190
as account for certain network
conditions that

00:28:40.190 --> 00:28:41.350
you might be seeing.

00:28:41.350 --> 00:28:42.090
AUDIENCE: Thanks.

00:28:42.090 --> 00:28:43.330
MATT WARD: Yep.

00:28:43.330 --> 00:28:44.352
AUDIENCE: Hi.

00:28:44.352 --> 00:28:47.130
I had a question about rate
estimation, because in a

00:28:47.130 --> 00:28:50.900
mobile device your radio
changes very fast.

00:28:50.900 --> 00:28:53.400
How do you guys do that, and
how fast can you do it?

00:28:56.270 --> 00:28:57.670
STEVEN ROBERTSON: Some of the
more interesting strategies

00:28:57.670 --> 00:29:02.410
for rate estimation on mobile
devices involve packet pacing

00:29:02.410 --> 00:29:04.730
to actually look at the
interarrival time.

00:29:04.730 --> 00:29:07.390
WebRTC uses this strategy.

00:29:07.390 --> 00:29:12.750
And TCP doesn't have the-- at
the web level, TCP doesn't

00:29:12.750 --> 00:29:17.040
have the exposure to
measure those APIs.

00:29:17.040 --> 00:29:21.940
So one strategy we're exploring
is to perform some

00:29:21.940 --> 00:29:25.650
client server cooperation on TCP
window clamping to get an

00:29:25.650 --> 00:29:27.350
estimate of this.

00:29:27.350 --> 00:29:32.980
But the short answer is it's a
hard problem, and we're still

00:29:32.980 --> 00:29:35.360
looking in to how to solve it.

00:29:35.360 --> 00:29:38.980
It's definitely a challenge.

00:29:38.980 --> 00:29:43.480
It comes down to being more
conservative on mobile.

00:29:43.480 --> 00:29:45.910
When you detect that you're on
a mobile network, there's a

00:29:45.910 --> 00:29:48.230
little bit more conservativeness
as just our

00:29:48.230 --> 00:29:52.720
fallback until a better
solution is presented.

00:29:52.720 --> 00:29:54.380
AUDIENCE: Thanks.

00:29:54.380 --> 00:29:58.890
AUDIENCE: On iOS, certainly, and
also on Chrome on Android,

00:29:58.890 --> 00:30:02.880
at least on recent versions of
Android, you live stream using

00:30:02.880 --> 00:30:06.186
HLS, which is built into mobile
Safari, and I assume

00:30:06.186 --> 00:30:08.360
it's also built into
Chrome on Android.

00:30:08.360 --> 00:30:11.810
So is that application level
streaming or is that system

00:30:11.810 --> 00:30:12.820
level streaming?

00:30:12.820 --> 00:30:13.950
MATT WARD: That's system
level streaming.

00:30:13.950 --> 00:30:15.400
That's actually exactly
what we we're talking

00:30:15.400 --> 00:30:16.340
about on that slide.

00:30:16.340 --> 00:30:19.730
That was a picture
of how HLS works.

00:30:19.730 --> 00:30:25.460
So basically, on these devices
today, we don't have access to

00:30:25.460 --> 00:30:27.020
the APIs that we talked
about in the second

00:30:27.020 --> 00:30:27.960
half of this talk.

00:30:27.960 --> 00:30:29.580
Those APIs don't exist.

00:30:29.580 --> 00:30:33.190
And for that reason today we are
still doing live streaming

00:30:33.190 --> 00:30:36.470
via HLS, because we really want
to hit all of the devices

00:30:36.470 --> 00:30:37.280
on the market.

00:30:37.280 --> 00:30:39.800
We really want you to have live
streaming on your iPad

00:30:39.800 --> 00:30:42.330
and your iPhone and
your Android.

00:30:42.330 --> 00:30:45.690
So that's really why we're
doing HLS today on those

00:30:45.690 --> 00:30:47.260
devices, and that's
why you see that.

00:30:47.260 --> 00:30:49.340
AUDIENCE: So you're going
to switch over or

00:30:49.340 --> 00:30:50.760
what is the road map?

00:30:50.760 --> 00:30:50.850
MATT WARD: Yeah.

00:30:50.850 --> 00:30:53.840
When the API becomes available
on all these devices, we would

00:30:53.840 --> 00:30:56.170
ideally like to see our
applications having full

00:30:56.170 --> 00:31:01.010
control over streaming
during--

00:31:01.010 --> 00:31:04.640
we want that application level
control of streaming live.

00:31:04.640 --> 00:31:08.400
We are fully capable of doing
it today on the desktop, but

00:31:08.400 --> 00:31:09.910
again, for portability reasons,

00:31:09.910 --> 00:31:11.710
we're still using HLS.

00:31:11.710 --> 00:31:14.590
AUDIENCE: So on iOS it would be
implemented in your Chrome

00:31:14.590 --> 00:31:15.840
implementation somehow?

00:31:15.840 --> 00:31:16.520
MATT WARD: Yeah.

00:31:16.520 --> 00:31:21.760
I mean Chrome, we hope, is
finishing bringing media

00:31:21.760 --> 00:31:26.570
source to our mobile Chrome
very shortly, is my

00:31:26.570 --> 00:31:27.640
understanding.

00:31:27.640 --> 00:31:29.710
I don't work on the Chrome team,
so I can't actually say

00:31:29.710 --> 00:31:32.990
what the timeline of that is,
but yeah, it's coming.

00:31:36.440 --> 00:31:39.375
AUDIENCE: I would like to follow
up on the HD question.

00:31:41.900 --> 00:31:45.460
On my mobile device, I totally
get I don't want my battery to

00:31:45.460 --> 00:31:48.100
run down, I don't things
to get hot.

00:31:48.100 --> 00:31:52.310
But, say on the pixel, for
example, when I've got my LTE

00:31:52.310 --> 00:31:57.580
connection with 20 plus megabit
download speeds, and

00:31:57.580 --> 00:32:01.582
I've got a video that
I want to--

00:32:01.582 --> 00:32:03.450
I want to see the quality.

00:32:03.450 --> 00:32:04.740
I'm that kind of person.

00:32:04.740 --> 00:32:06.420
So I prefer to wait.

00:32:06.420 --> 00:32:08.490
But it's coming instantly.

00:32:08.490 --> 00:32:15.260
What protocols are in place that
makes it go to a lower

00:32:15.260 --> 00:32:17.865
quality setting whenever I've
got plenty bandwidth and

00:32:17.865 --> 00:32:21.880
plenty CPU processing power?

00:32:21.880 --> 00:32:24.950
MATT WARD: One thing you might
actually have is a lot of

00:32:24.950 --> 00:32:27.730
bandwidth to a lot
of the network.

00:32:27.730 --> 00:32:31.650
So you might have a great, great
connection to wherever

00:32:31.650 --> 00:32:33.130
you're doing your
speed test to.

00:32:33.130 --> 00:32:34.920
You might not actually have
a great connection to our

00:32:34.920 --> 00:32:37.380
servers, so we might not
actually have a 20 megabit

00:32:37.380 --> 00:32:40.790
connection to your device
on an LTE network.

00:32:40.790 --> 00:32:43.600
So the number that we're
actually seeing is the one

00:32:43.600 --> 00:32:46.470
that is informing our stream
selection logic.

00:32:46.470 --> 00:32:51.970
So from our perspective, and
from a lot of our experiments,

00:32:51.970 --> 00:32:56.700
we value smooth play backs
and fast play backs.

00:32:56.700 --> 00:32:59.210
We're talking, actually,
there's a lot of heated

00:32:59.210 --> 00:33:01.950
discussion about this exact
thing internally right now.

00:33:01.950 --> 00:33:05.170
And we're trying to figure out
exactly how we can give more

00:33:05.170 --> 00:33:08.470
fine grain quality controls for
people like you that want

00:33:08.470 --> 00:33:11.880
really to crank it
up if I can.

00:33:11.880 --> 00:33:17.170
And today, our best answer to
that is, go full screen.

00:33:17.170 --> 00:33:20.780
And these algorithms are
going to do their best.

00:33:20.780 --> 00:33:21.700
AUDIENCE: OK, thank you.

00:33:21.700 --> 00:33:25.320
And I will ask you right now.

00:33:25.320 --> 00:33:29.460
I request that there be an
option for HD playback, no

00:33:29.460 --> 00:33:32.550
matter what is going on.

00:33:32.550 --> 00:33:35.360
MATT WARD: I will accept
your request.

00:33:35.360 --> 00:33:41.590
[AUDIENCE LAUGHS]

00:33:41.590 --> 00:33:43.500
MATT WARD: Well, thank you
guys very much for coming

00:33:43.500 --> 00:33:47.900
today, and enjoy the rest of
the activities this week.

00:33:47.900 --> 00:33:53.765
[AUDIENCE CLAPS]

