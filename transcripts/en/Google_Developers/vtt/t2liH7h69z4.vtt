WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.982
[MUSIC PLAYING]

00:00:04.480 --> 00:00:06.380
MARKKU LEPISTO: Good
to see all of you.

00:00:06.380 --> 00:00:07.060
Rise and shine.

00:00:07.060 --> 00:00:08.020
Early morning here.

00:00:08.020 --> 00:00:10.090
Hope you found some coffee.

00:00:10.090 --> 00:00:11.660
My name is Markku.

00:00:11.660 --> 00:00:13.750
I am a solutions
architect at Google Cloud,

00:00:13.750 --> 00:00:15.880
and I focus on IoT.

00:00:15.880 --> 00:00:18.760
And that's exactly what I would
like to show you this morning.

00:00:18.760 --> 00:00:22.390
I'd like to show you how to
build IoT solutions using

00:00:22.390 --> 00:00:27.370
Sigfox, Radio Network for IoT
devices, and Google Cloud.

00:00:27.370 --> 00:00:29.300
So let's get started.

00:00:29.300 --> 00:00:33.610
First I'd like to talk
to you about LPWAN.

00:00:33.610 --> 00:00:36.280
What is LPWAN 1, I hear you say.

00:00:36.280 --> 00:00:40.390
Well, it's low-power
wide-area networks.

00:00:40.390 --> 00:00:43.360
With IoT, it's super important.

00:00:43.360 --> 00:00:46.280
OK, you might have an
IoT device in your home,

00:00:46.280 --> 00:00:49.660
but many, many IoT devices
are actually out there.

00:00:49.660 --> 00:00:53.290
They may be measuring
air quality in a field

00:00:53.290 --> 00:00:54.940
or up in a mountain
somewhere, maybe

00:00:54.940 --> 00:00:58.090
measuring some flood gates,
water levels in a canal

00:00:58.090 --> 00:00:59.030
or whatever.

00:00:59.030 --> 00:01:00.790
So they are somewhere.

00:01:00.790 --> 00:01:02.260
You may have thousands of them.

00:01:02.260 --> 00:01:04.900
We have customers who have
millions of IoT devices,

00:01:04.900 --> 00:01:07.670
so there is quite
a bit of scale.

00:01:07.670 --> 00:01:10.300
So you want your devices
to be kind of autonomous,

00:01:10.300 --> 00:01:12.752
and self managing,
and low maintenance.

00:01:12.752 --> 00:01:14.710
You don't want to have
to go there all the time

00:01:14.710 --> 00:01:16.330
to charge them and check them.

00:01:16.330 --> 00:01:18.640
They need to just
survive on their own.

00:01:18.640 --> 00:01:21.910
So low power means that you can
run your devices with battery

00:01:21.910 --> 00:01:25.140
power, so you can easily,
with these solutions

00:01:25.140 --> 00:01:27.820
that I'll show you
today, build solutions

00:01:27.820 --> 00:01:31.390
where the device can run from
a single battery for months

00:01:31.390 --> 00:01:33.310
or even years.

00:01:33.310 --> 00:01:35.980
And wide area network means
that if your device is up

00:01:35.980 --> 00:01:38.950
in a mountain or in a field,
it can still connect--

00:01:38.950 --> 00:01:41.420
where?-- to the internet.

00:01:41.420 --> 00:01:45.640
So one way to do that is with
our technology partner, Sigfox.

00:01:45.640 --> 00:01:50.440
So Sigfox is providing a radio
network specifically for IoT.

00:01:50.440 --> 00:01:54.430
They call it 0G, not 4G, 5G.

00:01:54.430 --> 00:01:57.130
They go the other way, 0G.

00:01:57.130 --> 00:02:02.600
It's extremely low bandwidth,
but it's really, really nice

00:02:02.600 --> 00:02:03.330
for IoT.

00:02:03.330 --> 00:02:04.290
I'll show you.

00:02:04.290 --> 00:02:06.230
And when you build
IoT solutions,

00:02:06.230 --> 00:02:09.240
you, unfortunately, also
need to consider the cost.

00:02:09.240 --> 00:02:11.090
So there's a lot
of cost elements.

00:02:11.090 --> 00:02:12.200
There's the hardware cost.

00:02:12.200 --> 00:02:17.600
So if you buy or specify a
very simple, very constrained

00:02:17.600 --> 00:02:20.980
microcontroller, you can
squeeze the hardware cost down.

00:02:20.980 --> 00:02:21.950
That's good.

00:02:21.950 --> 00:02:24.560
Microcontrollers are also
reliable because they

00:02:24.560 --> 00:02:26.450
don't really have
an operating system.

00:02:26.450 --> 00:02:27.920
They just get some
power, and they

00:02:27.920 --> 00:02:31.850
execute a binary that does
stuff like read the air quality

00:02:31.850 --> 00:02:34.940
sensor reading and send it out.

00:02:34.940 --> 00:02:36.260
So that's it.

00:02:36.260 --> 00:02:37.360
That's the hardware cost.

00:02:37.360 --> 00:02:42.530
With Sigfox, you need
a radio module that

00:02:42.530 --> 00:02:43.790
would be a couple of dollars.

00:02:43.790 --> 00:02:47.000
And then the connectivity
is something like this,

00:02:47.000 --> 00:02:51.740
from $15 per device per
year, down to just $1

00:02:51.740 --> 00:02:54.020
per device per
year, so that's nice

00:02:54.020 --> 00:02:57.840
if you have thousands
or millions of devices.

00:02:57.840 --> 00:03:00.180
So Sigfox provide
the radio network,

00:03:00.180 --> 00:03:03.420
they build the base
stations, they connect them.

00:03:03.420 --> 00:03:04.770
So they provide the coverage.

00:03:04.770 --> 00:03:07.680
They currently have about
60 countries covered,

00:03:07.680 --> 00:03:13.230
and 21 of those countries
have nationwide coverage.

00:03:13.230 --> 00:03:16.030
Now what is a LPWAN1 here?

00:03:16.030 --> 00:03:19.410
First of all, with Sigfox
and LPWAN1 networks,

00:03:19.410 --> 00:03:21.690
the payload is extremely small.

00:03:21.690 --> 00:03:23.430
That's why it's 0G.

00:03:23.430 --> 00:03:25.560
It's not 5G.

00:03:25.560 --> 00:03:28.660
The maximum data, or
same as the telemetry

00:03:28.660 --> 00:03:31.650
usually that you can
send with Sigfox devices,

00:03:31.650 --> 00:03:38.550
is 12 bytes uplink-- so from
device up 12 bytes, so 96 bits.

00:03:38.550 --> 00:03:40.590
You have 96 bits to play with.

00:03:40.590 --> 00:03:42.240
And now you're like,
this cannot be.

00:03:42.240 --> 00:03:43.045
It's 2019.

00:03:43.045 --> 00:03:44.170
What are you talking about?

00:03:44.170 --> 00:03:45.810
12 bytes?

00:03:45.810 --> 00:03:47.360
Crazy.

00:03:47.360 --> 00:03:48.470
It's good.

00:03:48.470 --> 00:03:52.040
You can squeeze a lot of
information in those 12 bytes.

00:03:52.040 --> 00:03:55.670
Zero bytes can be
actionable information.

00:03:55.670 --> 00:03:58.395
If you just send a
message with no payload,

00:03:58.395 --> 00:03:59.270
it's still a message.

00:03:59.270 --> 00:04:00.620
It has metadata.

00:04:00.620 --> 00:04:02.300
That can be a heartbeat.

00:04:02.300 --> 00:04:03.230
I'm still here.

00:04:03.230 --> 00:04:04.580
The air quality monitor--

00:04:04.580 --> 00:04:06.130
I'm still here.

00:04:06.130 --> 00:04:09.470
1 bit can transmit 0 or 1.

00:04:09.470 --> 00:04:11.150
True or false?

00:04:11.150 --> 00:04:13.670
Like, how is the water level
in this drainage canal?

00:04:13.670 --> 00:04:15.839
Is it too low, or
is it too high?

00:04:15.839 --> 00:04:16.339
No.

00:04:16.339 --> 00:04:17.560
Zero.

00:04:17.560 --> 00:04:21.950
With six bytes, you can transmit
GPS coordinates, and you still

00:04:21.950 --> 00:04:25.550
have six bytes left for
things like sensor readings--

00:04:25.550 --> 00:04:27.830
multiple sensor readings.

00:04:27.830 --> 00:04:28.850
So that's uplink--

00:04:28.850 --> 00:04:30.140
12 bytes up.

00:04:30.140 --> 00:04:34.190
And you can transmit about
six messages per hour

00:04:34.190 --> 00:04:38.410
with Sigfox network, so that's
about 140 messages per day.

00:04:38.410 --> 00:04:40.560
But usually the sensor
readings are sent, like,

00:04:40.560 --> 00:04:42.060
every hour, et cetera.

00:04:42.060 --> 00:04:45.520
Downlink is then from the
network to the device.

00:04:45.520 --> 00:04:48.150
So that could be a command
that you send to the device

00:04:48.150 --> 00:04:51.030
to do something, maybe
based on an analytics,

00:04:51.030 --> 00:04:54.740
or maybe you want to update
the device configuration.

00:04:54.740 --> 00:04:58.860
Now with Sigfox, you cannot
push messages to the devices.

00:04:58.860 --> 00:05:01.380
They are not listening
because they are sleeping,

00:05:01.380 --> 00:05:04.170
so that they can conserve power.

00:05:04.170 --> 00:05:06.360
The radio is off.

00:05:06.360 --> 00:05:07.830
So how does it work?

00:05:07.830 --> 00:05:10.600
With Sigfox, the
device can set a flag,

00:05:10.600 --> 00:05:12.300
so you, in your
code on the device,

00:05:12.300 --> 00:05:16.870
can set a flag that says, I want
to have a downlink response.

00:05:16.870 --> 00:05:18.990
So when it's sending
something, there's a flag,

00:05:18.990 --> 00:05:21.300
and then the network
can send back a downlink

00:05:21.300 --> 00:05:23.820
message which is 8 bytes.

00:05:23.820 --> 00:05:25.980
So that would be a device
configuration and maybe

00:05:25.980 --> 00:05:28.790
some commands.

00:05:28.790 --> 00:05:32.120
Now in order for
these devices to have

00:05:32.120 --> 00:05:34.940
highly successful
transmission of data,

00:05:34.940 --> 00:05:36.950
Sigfox is using narrowband.

00:05:36.950 --> 00:05:39.210
It's extremely
narrowband transmission,

00:05:39.210 --> 00:05:42.170
192 kilohertz, radio burst.

00:05:42.170 --> 00:05:43.220
No protocol.

00:05:43.220 --> 00:05:44.940
There is no protocol.

00:05:44.940 --> 00:05:48.470
So in order to save power on the
devices, there is no handshake.

00:05:48.470 --> 00:05:50.780
There is no connection to
the network and handshake.

00:05:50.780 --> 00:05:51.860
Hi, I'm here.

00:05:51.860 --> 00:05:52.730
Hello.

00:05:52.730 --> 00:05:55.010
No, they just send.

00:05:55.010 --> 00:05:58.640
They literally trust
encode the data,

00:05:58.640 --> 00:06:01.880
and modulate it with radio,
and send a radio burst.

00:06:01.880 --> 00:06:04.850
They actually send, or
transmit, three radio

00:06:04.850 --> 00:06:06.920
bursts-- the same
message three times.

00:06:06.920 --> 00:06:08.510
They do channel hopping.

00:06:08.510 --> 00:06:10.790
They send the same
message three times

00:06:10.790 --> 00:06:13.370
consecutively in three
different channels.

00:06:13.370 --> 00:06:15.770
This is increasing the
likelihood of the network

00:06:15.770 --> 00:06:19.820
hearing and receiving
the message.

00:06:19.820 --> 00:06:22.140
And then the rest of
the time, the device

00:06:22.140 --> 00:06:24.050
should be sleeping,
especially if it's

00:06:24.050 --> 00:06:27.950
battery or maybe solar
powered, so 99 point something

00:06:27.950 --> 00:06:31.440
percent of the time, your
device can be in deep sleep.

00:06:31.440 --> 00:06:34.250
So nowadays, there's a lot
of microcontrollers, MCUs,

00:06:34.250 --> 00:06:37.250
that you can literally
put to a deep sleep mode.

00:06:37.250 --> 00:06:39.980
Now if there's a
Sigfox radio there,

00:06:39.980 --> 00:06:42.200
while the device is
transmitting it's

00:06:42.200 --> 00:06:44.203
consuming some
milliwatts of power.

00:06:44.203 --> 00:06:46.370
AUTOMATED VOICE: Thank you
for joining this session.

00:06:46.370 --> 00:06:47.662
MARKKU LEPISTO: You're welcome.

00:06:51.470 --> 00:06:55.280
And then when the device
has finished transmitting,

00:06:55.280 --> 00:06:58.250
you should put it to deep
sleep, and then maybe it

00:06:58.250 --> 00:06:59.160
sleeps 10 minutes.

00:06:59.160 --> 00:07:00.720
Maybe it sleeps an hour.

00:07:00.720 --> 00:07:01.940
Maybe it sleeps a day.

00:07:01.940 --> 00:07:05.640
When the MCU, depending on the
microcontroller, is sleeping,

00:07:05.640 --> 00:07:08.900
you can go down to
nanowatts-- sorry, nanoamps.

00:07:08.900 --> 00:07:11.300
Nanoamps of current.

00:07:11.300 --> 00:07:14.120
So the device can actually
consume less power

00:07:14.120 --> 00:07:18.630
than the battery's
natural self drainage.

00:07:18.630 --> 00:07:21.120
Batteries lose some
power over time,

00:07:21.120 --> 00:07:24.050
so you need to choose
some battery types that

00:07:24.050 --> 00:07:28.670
keep the power longer without
any loss of power over time.

00:07:28.670 --> 00:07:31.760
Anyway, most of the time
the devices are sleeping.

00:07:31.760 --> 00:07:34.300
And then the wide area
network part of this

00:07:34.300 --> 00:07:35.480
is the link budget.

00:07:35.480 --> 00:07:39.380
With radio connections,
radio connectivity--

00:07:39.380 --> 00:07:43.190
the link budget means like
if you transmit the signal

00:07:43.190 --> 00:07:47.120
from your device, how easily
can the network actually hear

00:07:47.120 --> 00:07:47.790
this signal?

00:07:47.790 --> 00:07:49.850
And Sigfox is
really good at that.

00:07:49.850 --> 00:07:52.070
Depending on the different
countries and frequencies,

00:07:52.070 --> 00:07:54.240
if you look at the uplink FCCs--

00:07:54.240 --> 00:07:56.180
so that's here in the US--

00:07:56.180 --> 00:07:59.600
the devices can
transmit at 22 decibels.

00:07:59.600 --> 00:08:01.820
That's a radio power.

00:08:01.820 --> 00:08:04.760
And the network
sensitivity for receiving

00:08:04.760 --> 00:08:09.410
is minus 134 decibels, so
actually the Sigfox radio

00:08:09.410 --> 00:08:15.440
network can hear the
message 134 decibels lower

00:08:15.440 --> 00:08:17.390
than the transmission power--

00:08:17.390 --> 00:08:19.740
so very, very weak signal.

00:08:19.740 --> 00:08:23.210
So in practice, it means that if
a Sigfox device is transmitting

00:08:23.210 --> 00:08:26.300
in urban areas where there's
buildings and stuff like that,

00:08:26.300 --> 00:08:30.230
you have a few miles of a
distance to the base stations,

00:08:30.230 --> 00:08:35.570
but in rural areas, maybe
some fields, et cetera,

00:08:35.570 --> 00:08:39.100
you can have dozens of miles,
dozens of kilometers' range.

00:08:39.100 --> 00:08:40.809
So that's good.

00:08:40.809 --> 00:08:42.669
So let's get to the
integration now.

00:08:42.669 --> 00:08:46.300
So Sigfox is one option for
you to have connectivity,

00:08:46.300 --> 00:08:49.510
especially for remote
devices, somewhere,

00:08:49.510 --> 00:08:53.120
and Google Cloud can
then help with the data.

00:08:53.120 --> 00:08:55.150
So the main point is this.

00:08:55.150 --> 00:08:58.790
Your devices emit the essential
readings-- maybe air quality,

00:08:58.790 --> 00:08:59.430
whatever--

00:08:59.430 --> 00:09:02.170
Sigfox antennas pick
up these messages,

00:09:02.170 --> 00:09:04.630
the Sigfox platform
can optionally then

00:09:04.630 --> 00:09:05.860
forward the data--

00:09:05.860 --> 00:09:08.450
forward the messages
to a backend system.

00:09:08.450 --> 00:09:11.350
And in this case, we can use
Google Cloud and our data

00:09:11.350 --> 00:09:15.340
services in GCP to
receive, analyze, store,

00:09:15.340 --> 00:09:17.710
and have actionable
insights from the data--

00:09:17.710 --> 00:09:20.390
maybe even machine learning.

00:09:20.390 --> 00:09:22.470
So to help with
this, in January,

00:09:22.470 --> 00:09:24.800
we published the integration.

00:09:24.800 --> 00:09:27.890
The QR code there and
the URL on the top

00:09:27.890 --> 00:09:31.450
bring you to that tutorial,
so it's fully open source.

00:09:31.450 --> 00:09:34.610
The tutorial gives you
the step-by-step guide

00:09:34.610 --> 00:09:37.610
on how to actually
integrate your Sigfox

00:09:37.610 --> 00:09:40.110
account and your
Google Cloud account,

00:09:40.110 --> 00:09:44.710
and everything is open source,
and all the code is in GitHub.

00:09:44.710 --> 00:09:46.640
It works like this.

00:09:46.640 --> 00:09:49.800
On your left, you have
the Sigfox devices.

00:09:49.800 --> 00:09:52.740
When they transmit messages
with your sensor readings,

00:09:52.740 --> 00:09:56.430
they call the Sigfox
system, Sigfox platform.

00:09:56.430 --> 00:09:59.220
And then you can configure
a so-called callback

00:09:59.220 --> 00:10:01.740
or multiple callbacks
that, if you will get data

00:10:01.740 --> 00:10:05.130
from your devices, or if
there's something else to notify

00:10:05.130 --> 00:10:09.030
the backend system, Sigfox
can push the messages

00:10:09.030 --> 00:10:11.112
to a backend system.

00:10:11.112 --> 00:10:12.570
And that's what we
have implemented

00:10:12.570 --> 00:10:15.140
with the integration
in Google Cloud,

00:10:15.140 --> 00:10:17.010
and we are using Cloud
Functions for that.

00:10:17.010 --> 00:10:20.340
Because with Sigfox, first of
all, you have very small data--

00:10:20.340 --> 00:10:23.840
maximum 12 bytes per device--

00:10:23.840 --> 00:10:28.810
and at maximum, a single device
can transmit every 10 minutes.

00:10:28.810 --> 00:10:30.870
So most of the time,
there's very little traffic

00:10:30.870 --> 00:10:33.120
unless you have
millions of devices,

00:10:33.120 --> 00:10:35.130
so Cloud Functions are
really handy because you

00:10:35.130 --> 00:10:37.200
can scale them down.

00:10:37.200 --> 00:10:38.340
They appear.

00:10:38.340 --> 00:10:42.120
Your compute system appears
when there's a message,

00:10:42.120 --> 00:10:44.070
so the payload will
trigger the compute.

00:10:44.070 --> 00:10:46.170
So it's event-driven computing.

00:10:46.170 --> 00:10:47.670
And its serverless,
meaning that you

00:10:47.670 --> 00:10:49.620
don't have any servers
running, and you

00:10:49.620 --> 00:10:53.530
don't need to manage any
servers or even any containers.

00:10:53.530 --> 00:10:57.020
So the Cloud Function will
receive the data from Sigfox.

00:10:57.020 --> 00:10:59.190
There is, of course,
authentication and encryption

00:10:59.190 --> 00:11:01.170
for the link there.

00:11:01.170 --> 00:11:02.700
Then the Cloud
Function will check

00:11:02.700 --> 00:11:04.410
that the message looks OK.

00:11:04.410 --> 00:11:07.675
It's conforming to
the Sigfox standards.

00:11:07.675 --> 00:11:09.300
So what is coming to
the Cloud Function

00:11:09.300 --> 00:11:13.620
is the payload from your device
and then metadata around that,

00:11:13.620 --> 00:11:14.790
like what is the device?

00:11:14.790 --> 00:11:16.350
What is the device type?

00:11:16.350 --> 00:11:19.710
Maybe what is the Sigfox
operator, like US, et cetera?

00:11:19.710 --> 00:11:22.320
So there's the metadata
and then the payload.

00:11:22.320 --> 00:11:26.070
And remember the payload is
binary encoded, maximum 12

00:11:26.070 --> 00:11:27.930
bytes.

00:11:27.930 --> 00:11:31.230
Once the Cloud Function receives
this payload and metadata,

00:11:31.230 --> 00:11:34.170
it will drop them
in Cloud Pub/Sub.

00:11:34.170 --> 00:11:36.690
Cloud Pub/Sub is our
global message queue

00:11:36.690 --> 00:11:38.190
so it's a really
handy place for you

00:11:38.190 --> 00:11:41.070
to keep your data
reliably up to seven days

00:11:41.070 --> 00:11:43.440
and then process the data
from this message queue

00:11:43.440 --> 00:11:46.300
with your data
processing system.

00:11:46.300 --> 00:11:49.620
So in effect, you get a
real-time streaming data, off

00:11:49.620 --> 00:11:52.930
payload, into Cloud Pub/Sub.

00:11:52.930 --> 00:11:55.690
And if the devices are
requesting a configuration

00:11:55.690 --> 00:11:59.530
update, a downlink message,
then the Cloud Function

00:11:59.530 --> 00:12:02.360
will detect this flag
that the device is saying,

00:12:02.360 --> 00:12:04.870
hey, I want to have
a downlink message.

00:12:04.870 --> 00:12:09.460
And we use Cloud Datastore as
a really simple, easy, handy

00:12:09.460 --> 00:12:12.920
database service to store
the device configurations.

00:12:12.920 --> 00:12:16.060
So you will create the
device configurations.

00:12:16.060 --> 00:12:18.880
We check the device
ID, device type ID.

00:12:18.880 --> 00:12:21.550
If they are requesting a
downlink, we get the payload--

00:12:21.550 --> 00:12:23.800
the configuration
from Datastore--

00:12:23.800 --> 00:12:26.530
and the Cloud Function
sends it back to the device

00:12:26.530 --> 00:12:29.410
through the Sigfox network.

00:12:29.410 --> 00:12:33.370
Also, if the Sigfox network is
sending any service messages,

00:12:33.370 --> 00:12:35.960
we have a second Cloud
Function receiving those--

00:12:35.960 --> 00:12:38.207
and just logging
everything in Stackdriver,

00:12:38.207 --> 00:12:40.040
which is the logging
system in Google Cloud.

00:12:40.040 --> 00:12:43.470
Now that is the integration,
and the integration

00:12:43.470 --> 00:12:45.210
is device independent.

00:12:45.210 --> 00:12:46.890
It's solution independent.

00:12:46.890 --> 00:12:50.070
It works with any
solution with Sigfox

00:12:50.070 --> 00:12:53.130
because it just takes the
payload as is and drops it

00:12:53.130 --> 00:12:56.730
in Pub/Sub, but
every IoT solution

00:12:56.730 --> 00:13:00.420
will be different, based on
your devices and use cases.

00:13:00.420 --> 00:13:04.830
So after Pub/Sub, it's good to
have a device specific and use

00:13:04.830 --> 00:13:07.740
case specific backend system.

00:13:07.740 --> 00:13:11.130
For example, you can use
another Cloud Function.

00:13:11.130 --> 00:13:14.250
Then you look at this payload
in Pub/Sub or Dataflow.

00:13:14.250 --> 00:13:16.010
With Cloud Dataflow,
you can create

00:13:16.010 --> 00:13:21.030
Apache Beam DACs,
Directed Acyclic Graphs,

00:13:21.030 --> 00:13:23.100
of data processing steps.

00:13:23.100 --> 00:13:25.880
You can enrich data, you
can branch it, whatever.

00:13:25.880 --> 00:13:28.590
So Dataflow is great for that.

00:13:28.590 --> 00:13:30.660
And after
preprocessing the data,

00:13:30.660 --> 00:13:32.940
you want to store the
data in a data store.

00:13:32.940 --> 00:13:36.690
We have many handy services
for that, like Cloud Bigtable.

00:13:36.690 --> 00:13:39.000
It's extremely
fast and scalable.

00:13:39.000 --> 00:13:42.150
Key value store-- very
good for time series data,

00:13:42.150 --> 00:13:45.610
and a lot of IoT
data is time series.

00:13:45.610 --> 00:13:50.010
But BigQuery definitely is
probably the most likely data

00:13:50.010 --> 00:13:51.360
store that many people use.

00:13:51.360 --> 00:13:54.430
It's becoming a data
lake, if you will.

00:13:54.430 --> 00:13:58.780
So with BigQuery, you can store
your data there in real time,

00:13:58.780 --> 00:14:02.160
so the system can write the
data in BigQuery in real time.

00:14:02.160 --> 00:14:05.580
Then your data warehouse
is up to date in real time.

00:14:05.580 --> 00:14:09.060
You can run machine learning
inside BigQuery on your data

00:14:09.060 --> 00:14:11.590
without moving it
anywhere, and of course you

00:14:11.590 --> 00:14:14.310
can have analytics,
dashboards, et cetera

00:14:14.310 --> 00:14:17.100
connected to your
BigQuery data warehouse.

00:14:17.100 --> 00:14:19.620
And you can use Cloud,
ML, and other machine

00:14:19.620 --> 00:14:22.200
learning services then
to do things, like, maybe

00:14:22.200 --> 00:14:25.320
predictive maintenance, looking
at trending of your sensor

00:14:25.320 --> 00:14:28.030
values.

00:14:28.030 --> 00:14:31.240
I talked through the functional
requirements on the left

00:14:31.240 --> 00:14:34.340
already, but when I
created this integration,

00:14:34.340 --> 00:14:36.550
we set some non-functional
requirements as well.

00:14:36.550 --> 00:14:38.202
So we wanted this
to be serverless--

00:14:38.202 --> 00:14:40.660
so we don't have to worry about
running servers or managing

00:14:40.660 --> 00:14:41.260
them--

00:14:41.260 --> 00:14:45.980
event driven, and stateless,
and scale out, of course,

00:14:45.980 --> 00:14:49.450
if there a lot of traffic,
but importantly also scale

00:14:49.450 --> 00:14:51.220
in even to zero.

00:14:51.220 --> 00:14:54.610
So if there's no messages
coming from your Sigfox devices,

00:14:54.610 --> 00:14:57.820
the system will scale in
and kind of hibernate,

00:14:57.820 --> 00:15:00.910
and it's woken by the
messages, and that

00:15:00.910 --> 00:15:03.160
means-- that's what
event-driven architecture means.

00:15:03.160 --> 00:15:05.470
The messages will
wake up the system,

00:15:05.470 --> 00:15:07.210
and it will process
your messages.

00:15:07.210 --> 00:15:10.120
And of course, everything is
customizable and open source.

00:15:10.120 --> 00:15:13.990
Now with that, let's
actually see the demo.

00:15:13.990 --> 00:15:20.870
So live demos-- so first, we
switch to my Sigfox backend.

00:15:20.870 --> 00:15:23.890
So when you create
a Sigfox account,

00:15:23.890 --> 00:15:26.290
you'll get access to
the backend system,

00:15:26.290 --> 00:15:29.230
and then for your devices,
or device types which

00:15:29.230 --> 00:15:31.700
are groups of devices,
you can optionally

00:15:31.700 --> 00:15:33.290
configure these callbacks.

00:15:33.290 --> 00:15:35.110
So these callbacks
are the instructions

00:15:35.110 --> 00:15:37.570
in the Sigfox network side.

00:15:37.570 --> 00:15:40.670
If your devices are
sending data, do something.

00:15:40.670 --> 00:15:43.310
Send it somewhere else
to a backend system.

00:15:43.310 --> 00:15:45.940
So we can see here that,
in my Sigfox backend,

00:15:45.940 --> 00:15:48.800
we have some callbacks
already configured.

00:15:48.800 --> 00:15:51.400
And if you can see over
there, the callbacks

00:15:51.400 --> 00:15:55.480
are actually implemented
by cloudfunctions.net, so

00:15:55.480 --> 00:15:57.130
Google Cloud Functions.

00:15:57.130 --> 00:15:58.930
We have different
callbacks here for data,

00:15:58.930 --> 00:16:02.140
for service messages, et cetera.

00:16:02.140 --> 00:16:05.857
Now as part of the
integration, of course,

00:16:05.857 --> 00:16:08.440
you can use the user interface,
but I also made a command line

00:16:08.440 --> 00:16:11.740
tool that uses the Sigfox API.

00:16:11.740 --> 00:16:13.480
Because to configure
the callbacks,

00:16:13.480 --> 00:16:15.100
it can be a bit
tedious if there's

00:16:15.100 --> 00:16:16.910
a lot of parameters, et cetera.

00:16:16.910 --> 00:16:18.370
So we are humans.

00:16:18.370 --> 00:16:21.160
We make human
mistakes, human errors.

00:16:21.160 --> 00:16:22.390
So I wanted to automate it.

00:16:22.390 --> 00:16:25.690
And also, then maybe you
can build a CI/CD pipeline

00:16:25.690 --> 00:16:27.490
that uses these
command line tools

00:16:27.490 --> 00:16:29.770
as part of your automation.

00:16:29.770 --> 00:16:32.530
So to use the Sigfox
API command line

00:16:32.530 --> 00:16:35.080
tool that's part of the
integration in GitHub,

00:16:35.080 --> 00:16:38.110
first, we can execute
callbacks list.

00:16:38.110 --> 00:16:40.040
And there is a
configuration file,

00:16:40.040 --> 00:16:43.270
which then has your credentials
and your API keys and points

00:16:43.270 --> 00:16:45.400
to your system in Sigfox.

00:16:45.400 --> 00:16:47.110
On the bottom, you
can see that now,

00:16:47.110 --> 00:16:51.260
for this Sigfox device type
which is the one for the demos,

00:16:51.260 --> 00:16:53.320
we have five
callbacks configured.

00:16:53.320 --> 00:16:53.890
That's right.

00:16:53.890 --> 00:16:55.790
We have five of them here.

00:16:55.790 --> 00:17:00.170
But if we use,
now, the same API,

00:17:00.170 --> 00:17:05.800
and we execute callbacks
delete all, oh, dear.

00:17:05.800 --> 00:17:07.060
Gone.

00:17:07.060 --> 00:17:10.210
So now the API client said we
deleted the five callbacks.

00:17:10.210 --> 00:17:12.970
If we refresh the
screen, they're gone.

00:17:12.970 --> 00:17:13.990
That's it.

00:17:13.990 --> 00:17:16.180
And let's put them back.

00:17:16.180 --> 00:17:21.099
So simply, I just execute
create, if I can type it.

00:17:21.099 --> 00:17:22.510
There is a configuration file.

00:17:22.510 --> 00:17:25.000
There's a JSON file which
contains the callback

00:17:25.000 --> 00:17:25.780
configuration.

00:17:25.780 --> 00:17:30.350
So mine are examples, and if you
need to modify them or add them

00:17:30.350 --> 00:17:33.100
you can simply modify this
JSON config file and add

00:17:33.100 --> 00:17:35.570
or modify more callbacks.

00:17:35.570 --> 00:17:39.090
So this script will read that
JSON file, and by default it

00:17:39.090 --> 00:17:43.600
will create these five callbacks
that point to Google Cloud

00:17:43.600 --> 00:17:44.260
Functions.

00:17:44.260 --> 00:17:44.770
There we go.

00:17:44.770 --> 00:17:46.120
Now it's back.

00:17:46.120 --> 00:17:49.990
So let's actually now
go back to the slides

00:17:49.990 --> 00:17:51.870
and start using this system.

00:17:55.630 --> 00:17:58.690
Let me show you, really
quickly, a piece of the code.

00:17:58.690 --> 00:18:01.320
So this is the Sigfox
API command line

00:18:01.320 --> 00:18:03.870
tool that we just used.

00:18:03.870 --> 00:18:05.910
Sigfox has a Swagger
configuration

00:18:05.910 --> 00:18:08.730
file for the API,
API version 2, and we

00:18:08.730 --> 00:18:10.200
generated a Python client.

00:18:10.200 --> 00:18:11.880
In this case, it's in Python.

00:18:11.880 --> 00:18:15.090
And how it works is very simple.

00:18:15.090 --> 00:18:19.260
I've got the JSON file that
contains the configuration,

00:18:19.260 --> 00:18:22.260
the desired configuration,
for the Sigfox callbacks that

00:18:22.260 --> 00:18:24.760
point to Cloud
Functions in this case,

00:18:24.760 --> 00:18:27.180
and then the script will
just run through all

00:18:27.180 --> 00:18:30.030
of those in the template.

00:18:30.030 --> 00:18:34.450
In this case, it does five loops
and calls the API instance,

00:18:34.450 --> 00:18:37.380
create callback function,
for each of those callback

00:18:37.380 --> 00:18:38.160
configuration.

00:18:38.160 --> 00:18:42.300
So very simply-- to loop
through and automatically create

00:18:42.300 --> 00:18:43.810
the integration.

00:18:43.810 --> 00:18:46.452
So that's handy.

00:18:46.452 --> 00:18:51.640
Now let's actually use it, so
let's have a live demo now.

00:18:51.640 --> 00:18:55.570
I've got here, on stage, my
Sens'it Discovery version 3

00:18:55.570 --> 00:18:56.960
device.

00:18:56.960 --> 00:18:58.900
It's a microcontroller
that's battery powered.

00:18:58.900 --> 00:19:01.610
I charge it every couple
of months, if I remember,

00:19:01.610 --> 00:19:03.910
so the battery
lasts a long time.

00:19:03.910 --> 00:19:05.620
It's an off-the-shelf
development kit

00:19:05.620 --> 00:19:08.590
that's handy for getting
started with Sigfox,

00:19:08.590 --> 00:19:10.510
and IoT, and Google Cloud.

00:19:10.510 --> 00:19:13.000
It's got a lot of
sensors, ambient sensors--

00:19:13.000 --> 00:19:14.440
temperature, humidity.

00:19:14.440 --> 00:19:16.300
There's a magnetic senator.

00:19:16.300 --> 00:19:19.000
There's an accelerometer,
light sensor,

00:19:19.000 --> 00:19:21.890
et cetera, and of
course a Sigfox radio.

00:19:21.890 --> 00:19:26.490
So let's now see
what we have here.

00:19:26.490 --> 00:19:29.330
So we have the integration,
which is the middle gray part.

00:19:29.330 --> 00:19:32.310
You saw that or part of that.

00:19:32.310 --> 00:19:37.190
And on the right side, we have
a device specific backend,

00:19:37.190 --> 00:19:42.750
so when this device is sending
data it has a defined payload.

00:19:42.750 --> 00:19:45.380
It's got the sensors,
and depending

00:19:45.380 --> 00:19:49.500
on the mode of the device it
actually changes the payload.

00:19:49.500 --> 00:19:51.770
So the payload is
dynamic, but as

00:19:51.770 --> 00:19:55.350
part of the payload the device
is transmitting a value--

00:19:55.350 --> 00:19:56.370
what is my mode?

00:19:56.370 --> 00:19:59.070
Mode one is temperature
and humidity.

00:19:59.070 --> 00:20:01.130
So then the rest of the
payload, actually, we

00:20:01.130 --> 00:20:03.110
know that it contains
temperature and humidity

00:20:03.110 --> 00:20:06.680
information, so that's a
device specific payload that

00:20:06.680 --> 00:20:08.720
leverages those 12
bytes-- actually

00:20:08.720 --> 00:20:11.340
only four bytes in this case.

00:20:11.340 --> 00:20:14.840
So to handle the device
specific data, on your right,

00:20:14.840 --> 00:20:18.530
I've created a device
specific backend,

00:20:18.530 --> 00:20:23.890
and we have also published this
as an open source tutorial.

00:20:23.890 --> 00:20:26.270
And let's take a
look at that now.

00:20:26.270 --> 00:20:30.920
So let's use this integration
with the Sigfox Sens'it device,

00:20:30.920 --> 00:20:32.350
so let me show you the device.

00:20:32.350 --> 00:20:33.850
Here it is.

00:20:33.850 --> 00:20:35.650
On the table, it's quite small.

00:20:35.650 --> 00:20:39.100
So it's a battery powered MCU
with some sensors built in,

00:20:39.100 --> 00:20:43.180
small LiPo battery in
there, and a button.

00:20:43.180 --> 00:20:49.180
And then let's go back to my
laptop before we send any data.

00:20:49.180 --> 00:20:51.160
So remember we've got
the callbacks here,

00:20:51.160 --> 00:20:53.490
so if any data comes
from my devices,

00:20:53.490 --> 00:20:55.350
these callbacks
will be activated,

00:20:55.350 --> 00:20:58.590
and Sigfox will send the
data to Google Cloud,

00:20:58.590 --> 00:21:00.810
specifically here.

00:21:00.810 --> 00:21:04.620
So now we are in Google Cloud,
and this is the receiving side

00:21:04.620 --> 00:21:05.500
of the data.

00:21:05.500 --> 00:21:07.450
This is the integration in GCP.

00:21:07.450 --> 00:21:09.240
We've got the two
callbacks here--

00:21:09.240 --> 00:21:12.510
call back data which is
receiving the data payloads,

00:21:12.510 --> 00:21:14.490
and the optional
callback service

00:21:14.490 --> 00:21:16.440
which is receiving
service messages

00:21:16.440 --> 00:21:20.310
and logging those
in Stackdriver.

00:21:20.310 --> 00:21:22.570
And we have the logs here.

00:21:22.570 --> 00:21:27.840
So this is the callback
data, Stackdriver Logging.

00:21:27.840 --> 00:21:31.050
And the device itself is here.

00:21:31.050 --> 00:21:32.820
So this is this
particular device,

00:21:32.820 --> 00:21:38.990
and now if I switch here, and I
double click this button here,

00:21:38.990 --> 00:21:41.230
we should see a blink,
blink, blink here.

00:21:41.230 --> 00:21:41.780
There.

00:21:41.780 --> 00:21:44.440
It's now transmitting those
three bursts, three radio

00:21:44.440 --> 00:21:45.700
bursts.

00:21:45.700 --> 00:21:48.550
And we go back here.

00:21:48.550 --> 00:21:50.340
You can see green.

00:21:50.340 --> 00:21:52.120
Call back OK.

00:21:52.120 --> 00:21:55.630
So the Sigfox callback
was activated,

00:21:55.630 --> 00:21:58.270
and the arrow turned
green, meaning

00:21:58.270 --> 00:22:01.990
that Google Cloud replied with
a positive acknowledgment.

00:22:01.990 --> 00:22:02.560
Thank you.

00:22:02.560 --> 00:22:04.450
I received the message.

00:22:04.450 --> 00:22:07.390
So Sigfox received
the radio transmission

00:22:07.390 --> 00:22:10.240
and forwarded the
message to Google Cloud,

00:22:10.240 --> 00:22:12.430
and the actual data is here.

00:22:12.430 --> 00:22:15.370
You can see that
it's hexadecimal,

00:22:15.370 --> 00:22:17.350
signifying that
it's binary encoded.

00:22:17.350 --> 00:22:19.870
So eight characters
in hexadecimal

00:22:19.870 --> 00:22:22.300
are four bytes, so it's
actually four bytes

00:22:22.300 --> 00:22:23.770
of binary encoded data.

00:22:23.770 --> 00:22:26.800
I will copy it to my clipboard,
and I can show you later

00:22:26.800 --> 00:22:29.420
how to decode it.

00:22:29.420 --> 00:22:32.080
So let's go back
now to Google Cloud

00:22:32.080 --> 00:22:33.633
look at the callback
data function,

00:22:33.633 --> 00:22:35.050
and it should have
been triggered.

00:22:35.050 --> 00:22:36.170
Here we go.

00:22:36.170 --> 00:22:40.220
So this function was triggered
by the message just now.

00:22:40.220 --> 00:22:42.260
And if we go to the
logging of this function,

00:22:42.260 --> 00:22:46.790
and we refresh
the logging, here,

00:22:46.790 --> 00:22:48.440
we can see in
Stackdriver logging,

00:22:48.440 --> 00:22:52.640
it says we received a Sigfox
message from this device type

00:22:52.640 --> 00:22:57.080
from this particular
device ID at this time.

00:22:57.080 --> 00:22:58.610
The data is there.

00:22:58.610 --> 00:23:02.070
You can see the data is still
in hexadecimal binary-encoded

00:23:02.070 --> 00:23:02.570
format.

00:23:02.570 --> 00:23:04.700
That's the payload.

00:23:04.700 --> 00:23:10.040
The operator is here,
and the next message

00:23:10.040 --> 00:23:13.430
says that simply we publish
the message to Pub/Sub

00:23:13.430 --> 00:23:17.750
to a particular topic, so now
we get the payload in Pub/Sub.

00:23:17.750 --> 00:23:19.460
And then your data
processing system

00:23:19.460 --> 00:23:21.860
can pick it up from this
message queue in real time--

00:23:21.860 --> 00:23:23.990
maybe Cloud Functions
or Dataflow--

00:23:23.990 --> 00:23:26.378
and do something with the data.

00:23:26.378 --> 00:23:27.670
Now, what did we actually send?

00:23:30.133 --> 00:23:30.800
Let me show you.

00:23:34.720 --> 00:23:39.130
As part of the integration,
we also published a tutorial

00:23:39.130 --> 00:23:40.630
for this particular device--

00:23:40.630 --> 00:23:42.970
a tutorial that creates
the device-specific

00:23:42.970 --> 00:23:47.140
backend that uses
BigQuery, and we

00:23:47.140 --> 00:23:49.480
need to have a parser
because the device is

00:23:49.480 --> 00:23:51.840
sending binary payloads.

00:23:51.840 --> 00:23:54.170
Those are a little
bit difficult to use,

00:23:54.170 --> 00:23:58.750
so let's decode
the binary messages

00:23:58.750 --> 00:24:01.700
using the specification
of the device

00:24:01.700 --> 00:24:05.920
and then write to BigQuery
a normal set of columns

00:24:05.920 --> 00:24:07.460
and values.

00:24:07.460 --> 00:24:09.040
So how do we do that?

00:24:09.040 --> 00:24:14.270
I have a Cloud Function,
another Cloud function here.

00:24:18.210 --> 00:24:23.190
This one, this Cloud Function,
knows the binary payload

00:24:23.190 --> 00:24:26.280
of this device type, Sigfox
Sens'it, so that Pub/Sub

00:24:26.280 --> 00:24:29.850
BigQuery Cloud Function will
get the messages from Pub/Sub,

00:24:29.850 --> 00:24:32.520
which contain a
binary-encoded payload.

00:24:32.520 --> 00:24:38.560
It will decode them and
write them to BigQuery.

00:24:38.560 --> 00:24:41.710
The same parser also
has a command line tool,

00:24:41.710 --> 00:24:43.840
so that you can do
debugging, and testing,

00:24:43.840 --> 00:24:46.340
and maybe developing
your own binary payloads.

00:24:46.340 --> 00:24:48.230
So it's an example for that.

00:24:48.230 --> 00:24:51.160
So here we're going to see
that we could execute Python

00:24:51.160 --> 00:24:53.890
Sens'it, which is
this device, parser,

00:24:53.890 --> 00:24:58.690
parser mode decoding data for
which hexadecimal string from

00:24:58.690 --> 00:25:00.850
my clipboard-- the same
that the device sent.

00:25:00.850 --> 00:25:03.520
Then I press Enter,
and now we can

00:25:03.520 --> 00:25:06.370
see that the parser
is identifying,

00:25:06.370 --> 00:25:08.830
from the mode, what
is the device mode?

00:25:08.830 --> 00:25:11.770
There's a certain
two-bit value there

00:25:11.770 --> 00:25:13.480
that specifies the device mode.

00:25:13.480 --> 00:25:16.330
In this case, it's
temperature and humidity.

00:25:16.330 --> 00:25:18.580
And then the rest
of the payload is

00:25:18.580 --> 00:25:22.210
decoded using that information,
and we can see it down here,

00:25:22.210 --> 00:25:24.790
that the battery level
is now 4.1 volts.

00:25:24.790 --> 00:25:28.900
It's 54% humidity, modest
temperature, humidity.

00:25:28.900 --> 00:25:33.070
Temperature is 20.2 centigrade,
so it's really chilly here.

00:25:33.070 --> 00:25:35.230
And the button
alert flag is true,

00:25:35.230 --> 00:25:37.450
meaning that the
device sent the message

00:25:37.450 --> 00:25:39.320
because I clicked the button.

00:25:39.320 --> 00:25:42.010
The other option is
sending it with a timer.

00:25:42.010 --> 00:25:46.620
OK, so now we can
decode the message.

00:25:46.620 --> 00:25:49.220
That's what this Cloud
Function does here--

00:25:49.220 --> 00:25:50.540
Pub/Sub BigQuery.

00:25:50.540 --> 00:25:52.760
If we look at the logging
of this Cloud Function

00:25:52.760 --> 00:25:57.640
now, what happens is
that this function

00:25:57.640 --> 00:26:00.580
is triggered when the
first function puts

00:26:00.580 --> 00:26:03.070
the payload in Cloud Pub/Sub.

00:26:03.070 --> 00:26:07.060
So the first function puts
the payload in Pub/Sub as is--

00:26:07.060 --> 00:26:09.890
as a hexadecimal binary string.

00:26:09.890 --> 00:26:13.150
The second function
is device-specific,

00:26:13.150 --> 00:26:16.243
and it knows how to read
this binary payload.

00:26:16.243 --> 00:26:18.160
So if we look at the
logging of this function,

00:26:18.160 --> 00:26:21.800
we can see here that these
device sent some data.

00:26:21.800 --> 00:26:23.670
OK, that's it.

00:26:23.670 --> 00:26:25.300
But the next row--

00:26:25.300 --> 00:26:28.800
the next row in Stackdriver
logging for this function--

00:26:28.800 --> 00:26:31.660
has already opened up the data.

00:26:31.660 --> 00:26:33.640
We can see here
that, in addition

00:26:33.640 --> 00:26:37.040
to just a binary payload
here, we now have new values.

00:26:37.040 --> 00:26:40.450
We have battery level-- we
have temperature and humidity--

00:26:40.450 --> 00:26:45.100
so that the next step for
this function can be this.

00:26:45.100 --> 00:26:49.720
It formulates a BigQuery row
and then simply writes the data

00:26:49.720 --> 00:26:52.850
in streaming mode to BigQuery.

00:26:52.850 --> 00:26:55.480
So now the effect is
that, when we send data

00:26:55.480 --> 00:26:58.690
from Sigfox devices
using this integration,

00:26:58.690 --> 00:27:03.010
your data warehouse, which
can be, for example, BigQuery,

00:27:03.010 --> 00:27:05.620
can be real time.

00:27:05.620 --> 00:27:06.660
So here we are.

00:27:06.660 --> 00:27:10.680
We are in Cloud BigQuery, and
I have a very simple SQL query

00:27:10.680 --> 00:27:11.680
here, select star.

00:27:11.680 --> 00:27:13.090
I'm not supposed to do that.

00:27:13.090 --> 00:27:19.045
Anyway, from this table, ordered
by time descending limit 20--

00:27:19.045 --> 00:27:22.070
now let's execute that.

00:27:22.070 --> 00:27:24.840
And it's in UK time.

00:27:24.840 --> 00:27:26.900
So the last messages
sent by the device

00:27:26.900 --> 00:27:30.365
are here, the same data payload,
but you can see in BigQuery

00:27:30.365 --> 00:27:32.240
that we have handy
information here-- battery

00:27:32.240 --> 00:27:34.920
level, temperature, humidity.

00:27:34.920 --> 00:27:36.580
And all the other
sensor readings,

00:27:36.580 --> 00:27:38.080
which are not sent
now, but they are

00:27:38.080 --> 00:27:40.190
sent in another
mode of the device,

00:27:40.190 --> 00:27:44.120
have a place holder here
in the BigQuery schema.

00:27:44.120 --> 00:27:47.450
So then, you can start
analyzing in real time

00:27:47.450 --> 00:27:51.170
your data warehouse for IoT
data coming from, in this case,

00:27:51.170 --> 00:27:51.920
Sigfox devices.

00:27:51.920 --> 00:27:54.493
You can have real-time
despots and maybe even

00:27:54.493 --> 00:27:56.910
machine learning doing things
like predictive maintenance,

00:27:56.910 --> 00:28:00.780
trending, other things
looking at the actual values.

00:28:00.780 --> 00:28:03.960
And everything is
end-to-end real time.

00:28:03.960 --> 00:28:09.330
Now the device can also send
configuration updates request.

00:28:09.330 --> 00:28:13.490
So for example here, you can
see that we have a lot of short

00:28:13.490 --> 00:28:15.150
messages-- four bytes--

00:28:15.150 --> 00:28:17.390
but every once in
a while the device

00:28:17.390 --> 00:28:20.250
is sending a much
longer payload string.

00:28:20.250 --> 00:28:21.150
Now what is that?

00:28:21.150 --> 00:28:23.350
Let's put this in my clipboard.

00:28:23.350 --> 00:28:26.310
I'll copy that to the clipboard.

00:28:26.310 --> 00:28:29.310
Go back to the
command line tool,

00:28:29.310 --> 00:28:32.690
and let's investigate
what is actually

00:28:32.690 --> 00:28:36.930
inside this binary payload.

00:28:36.930 --> 00:28:40.920
The parser can now detect that,
actually, this long string

00:28:40.920 --> 00:28:43.200
here contains both
the data, which

00:28:43.200 --> 00:28:45.480
is the sensor
readings, four bytes,

00:28:45.480 --> 00:28:49.090
and an optional configuration.

00:28:49.090 --> 00:28:52.860
So when this device is sending
a configuration update request,

00:28:52.860 --> 00:28:55.110
it's also sending its
current configuration.

00:28:55.110 --> 00:28:59.100
By the way, I'm currently
using these configurations.

00:28:59.100 --> 00:29:05.170
And the parser can decode those,
and what you can see here are

00:29:05.170 --> 00:29:07.990
the valid configuration
parameters and values

00:29:07.990 --> 00:29:09.520
for the Sigfox Sens'it device.

00:29:09.520 --> 00:29:12.140
So it's sending all these.

00:29:12.140 --> 00:29:13.800
This is the device
configuration,

00:29:13.800 --> 00:29:17.180
so this is the device telling
us what it's doing now.

00:29:17.180 --> 00:29:20.150
And in order for us to actually
use this and easily update

00:29:20.150 --> 00:29:25.630
the configuration, we
can do the following.

00:29:25.630 --> 00:29:28.450
We can use the
command line tool,

00:29:28.450 --> 00:29:31.360
paste the received payload
from the device here,

00:29:31.360 --> 00:29:36.130
and specify that we write
the device configuration

00:29:36.130 --> 00:29:40.810
in an output file,
temp/sensit.ini.

00:29:40.810 --> 00:29:41.530
Boom.

00:29:41.530 --> 00:29:46.280
Config file return
to temp/sensit.ini.

00:29:46.280 --> 00:29:49.860
So if we edit this--

00:29:49.860 --> 00:29:52.080
it's actually the
current configuration

00:29:52.080 --> 00:29:55.890
sent by the device, but
it's in human readable

00:29:55.890 --> 00:29:57.330
and human editable format.

00:29:57.330 --> 00:29:59.142
So what we could
do, for example,

00:29:59.142 --> 00:30:00.600
is change the
message period, which

00:30:00.600 --> 00:30:05.220
is the interval of the
device transmitting data.

00:30:05.220 --> 00:30:09.020
One, in this device's
case, means every hour.

00:30:09.020 --> 00:30:11.970
But if I change the
value from one to zero,

00:30:11.970 --> 00:30:15.950
I'm asking the device to
transmit every 10 minutes.

00:30:15.950 --> 00:30:18.520
So we modified that
one parameter value--

00:30:18.520 --> 00:30:19.930
the first one, message period.

00:30:19.930 --> 00:30:27.120
I save it, and then I run the
parser the other way around.

00:30:27.120 --> 00:30:29.900
I want to encode a
new configuration

00:30:29.900 --> 00:30:33.510
from that configuration
file that we just edited.

00:30:33.510 --> 00:30:34.790
Boom.

00:30:34.790 --> 00:30:36.120
So all this is open source.

00:30:36.120 --> 00:30:38.270
It's in GitHub as part
of the integration,

00:30:38.270 --> 00:30:40.620
and even if you
don't use this device

00:30:40.620 --> 00:30:44.120
you can use this configuration,
and payload, tools and parsers

00:30:44.120 --> 00:30:47.780
as a starting point for you to
develop your own binary-encoded

00:30:47.780 --> 00:30:50.390
small sensor readings
and device configs.

00:30:50.390 --> 00:30:52.400
So that's the main point here.

00:30:52.400 --> 00:30:55.490
So the tool is giving us a
new configuration hexadecimal

00:30:55.490 --> 00:30:56.180
string.

00:30:56.180 --> 00:30:59.870
That's the desired new
configuration for the device.

00:30:59.870 --> 00:31:02.780
Copy it to the
clipboard, and let's now

00:31:02.780 --> 00:31:04.940
go to Cloud Datastore.

00:31:04.940 --> 00:31:08.540
So Cloud Datastore is where we
keep the device configurations,

00:31:08.540 --> 00:31:13.550
and if the device is requesting
new configs we can simply

00:31:13.550 --> 00:31:16.410
Modify the value here.

00:31:16.410 --> 00:31:17.970
Let's write the new config here.

00:31:17.970 --> 00:31:21.710
I click Done, and I click
Save, and that's it.

00:31:21.710 --> 00:31:23.520
The next time the
device is saying,

00:31:23.520 --> 00:31:26.870
hey, Cloud, can you
give me my new configs,

00:31:26.870 --> 00:31:29.510
the Cloud Function
will pick up this value

00:31:29.510 --> 00:31:31.980
and send it back to the device.

00:31:31.980 --> 00:31:35.220
So that's quite simple.

00:31:35.220 --> 00:31:37.970
OK?

00:31:37.970 --> 00:31:40.980
Moving on.

00:31:40.980 --> 00:31:45.680
So far, what we have seen is we
have seen the Sigfox callback

00:31:45.680 --> 00:31:48.520
configuration, we
have seen the device,

00:31:48.520 --> 00:31:51.590
we have seen the Cloud Function
that receives the data.

00:31:51.590 --> 00:31:53.840
We looked at the logs,
we did some parsing

00:31:53.840 --> 00:31:56.810
of the binary payload,
and we saw that the data

00:31:56.810 --> 00:31:57.830
lands in BigQuery.

00:31:57.830 --> 00:31:59.030
So that's good.

00:31:59.030 --> 00:32:00.800
Then you can do your
analytics and data

00:32:00.800 --> 00:32:03.810
warehousing in BigQuery.

00:32:03.810 --> 00:32:06.540
And how did we actually
do the parsing?

00:32:06.540 --> 00:32:08.530
Let's take a quick
look at the code.

00:32:08.530 --> 00:32:13.823
I'm using Python's
BitStruct module here,

00:32:13.823 --> 00:32:15.240
because it's really
handy that you

00:32:15.240 --> 00:32:21.680
can declare a binary payload.

00:32:21.680 --> 00:32:24.830
So remember we have up
to 12 bytes of payload--

00:32:24.830 --> 00:32:29.560
so 96 bits-- and in order to
use those 96 bits in the most

00:32:29.560 --> 00:32:31.750
efficient manner,
you really want

00:32:31.750 --> 00:32:35.260
to minimize the number
of bits and bytes

00:32:35.260 --> 00:32:38.000
that you use to
convey some data.

00:32:38.000 --> 00:32:42.910
So for example, one byte
can be 255 values, right?

00:32:42.910 --> 00:32:45.370
It's 2 to the power of whatever.

00:32:45.370 --> 00:32:50.200
So 255, that could be, for
example, the speed of your car.

00:32:50.200 --> 00:32:54.130
So the speedometer reading
easily fits in one byte.

00:32:54.130 --> 00:32:56.770
OK, then you have 11 bytes left.

00:32:56.770 --> 00:32:57.820
OK, battery power.

00:32:57.820 --> 00:32:59.900
Maybe I can get
by with four bits.

00:32:59.900 --> 00:33:01.307
So half a byte.

00:33:01.307 --> 00:33:02.140
So you get the idea.

00:33:02.140 --> 00:33:05.650
You'll start constructing
the minimum number of bits

00:33:05.650 --> 00:33:08.920
that you need to convey
certain values with the desired

00:33:08.920 --> 00:33:09.520
accuracy.

00:33:09.520 --> 00:33:12.820
You can always drop the accuracy
and get by with less bits

00:33:12.820 --> 00:33:14.570
to transmit the data.

00:33:14.570 --> 00:33:19.090
So here we have an example from
this device, where first we--

00:33:19.090 --> 00:33:20.830
in the top lines there--

00:33:20.830 --> 00:33:23.020
we investigate the device mode.

00:33:23.020 --> 00:33:25.030
So as part of the
payload from the device,

00:33:25.030 --> 00:33:29.050
it sets a certain
value, mode, indicating

00:33:29.050 --> 00:33:32.020
what is the current mode, and
then the rest of the payload

00:33:32.020 --> 00:33:33.710
is dynamic based on that.

00:33:33.710 --> 00:33:36.770
So if the mode value
is 1, then the device

00:33:36.770 --> 00:33:39.140
is in temperature humidity mode.

00:33:39.140 --> 00:33:40.390
So that's here.

00:33:40.390 --> 00:33:43.660
And then as part of
the open source parser,

00:33:43.660 --> 00:33:48.220
we have a BitStruct that
specifies exactly how many bits

00:33:48.220 --> 00:33:51.020
are used for what values.

00:33:51.020 --> 00:33:53.260
And then on the
bottom, we can simply

00:33:53.260 --> 00:33:56.740
call this parser to give
us the human readable

00:33:56.740 --> 00:34:01.510
values, or standard Python
values like integer,

00:34:01.510 --> 00:34:06.110
and float, et cetera
from this binary mess.

00:34:06.110 --> 00:34:08.540
Now as the last thing,
what I'd like to show you,

00:34:08.540 --> 00:34:11.330
that was the generic
data up and down

00:34:11.330 --> 00:34:13.550
with Sigfox and Google Cloud.

00:34:13.550 --> 00:34:17.810
A handy thing with Sigfox is
that it can do estimated device

00:34:17.810 --> 00:34:21.920
location without any GPS or
GLONASS or other satellite

00:34:21.920 --> 00:34:23.420
systems.

00:34:23.420 --> 00:34:26.030
Because the Sigfox
network is so-called MIMO,

00:34:26.030 --> 00:34:28.820
multiple in, multiple out--
everybody's talking at the same

00:34:28.820 --> 00:34:29.600
time--

00:34:29.600 --> 00:34:31.520
they have multiple
base stations,

00:34:31.520 --> 00:34:33.590
and typically around
three base stations

00:34:33.590 --> 00:34:36.739
will receive the same
message from the devices.

00:34:36.739 --> 00:34:40.100
So then the Sigfox network
can reverse engineer

00:34:40.100 --> 00:34:43.219
and calculate an
estimated position

00:34:43.219 --> 00:34:44.639
and location of the device.

00:34:44.639 --> 00:34:47.850
It's not as accurate
as GPS of course,

00:34:47.850 --> 00:34:50.210
but it's still nice because
then your device doesn't

00:34:50.210 --> 00:34:51.920
have to have a GPS
receiver, which

00:34:51.920 --> 00:34:54.860
could be more expensive
than the rest of the device.

00:34:54.860 --> 00:34:58.880
The GPS receiver needs to see
the satellites to hear them,

00:34:58.880 --> 00:35:02.030
and it also consumes
a lot of power.

00:35:02.030 --> 00:35:04.730
Of course, you can have GPS, and
you can send the coordinates.

00:35:04.730 --> 00:35:06.890
But with Sigfox
Atlas Positioning,

00:35:06.890 --> 00:35:10.010
you can get a rough
estimate of the location

00:35:10.010 --> 00:35:12.630
no matter what kind
of device you have.

00:35:12.630 --> 00:35:14.870
So imagine that
you are monitoring

00:35:14.870 --> 00:35:16.640
the transport of some goods--

00:35:16.640 --> 00:35:20.450
maybe some frozen items
that need to stay frozen--

00:35:20.450 --> 00:35:23.630
from the manufacturing
all the way to the shop,

00:35:23.630 --> 00:35:27.480
so you need to verify
the cold chain quality.

00:35:27.480 --> 00:35:30.410
So if you'll just put a sensor
there in the container--

00:35:30.410 --> 00:35:32.540
physical container
in this case--

00:35:32.540 --> 00:35:35.240
and occasionally send
these sensor readings,

00:35:35.240 --> 00:35:38.360
you can get a real time update
when, for example, something

00:35:38.360 --> 00:35:41.810
starts to melt, or
temperature's going up.

00:35:41.810 --> 00:35:44.890
And then, with this positioning
system, you can even see where.

00:35:44.890 --> 00:35:48.590
Maybe it's on 101 going up to
San Francisco or something.

00:35:48.590 --> 00:35:51.960
You get a rough estimate
of the location.

00:35:51.960 --> 00:35:56.400
So let's see how we could
use the same system with that

00:35:56.400 --> 00:36:00.150
Sigfox Atlas Positioning,
BigQuery GIS--

00:36:00.150 --> 00:36:01.770
the new functionality
in BigQuery

00:36:01.770 --> 00:36:04.080
for geographical queries--

00:36:04.080 --> 00:36:06.548
and Google Maps.

00:36:06.548 --> 00:36:13.230
So let's switch back, and
let's take a look at BigQuery.

00:36:13.230 --> 00:36:15.310
There's something else I
didn't show you earlier.

00:36:15.310 --> 00:36:17.210
So when I showed you earlier
that, now in BigQuery,

00:36:17.210 --> 00:36:18.877
we have the data
coming from the device.

00:36:18.877 --> 00:36:19.410
Very nice.

00:36:19.410 --> 00:36:20.160
Yes.

00:36:20.160 --> 00:36:21.510
They are here.

00:36:21.510 --> 00:36:26.810
But if we scroll right,
there's more columns.

00:36:26.810 --> 00:36:32.430
Here, we can see that actually
as part of the metadata coming

00:36:32.430 --> 00:36:35.640
from Sigfox, when Sigfox
is forwarding the data

00:36:35.640 --> 00:36:38.760
to the backend system,
it's also including

00:36:38.760 --> 00:36:42.210
the computed location,
latitude and longitude,

00:36:42.210 --> 00:36:45.570
based on the Sigfox
Atlas estimated location

00:36:45.570 --> 00:36:48.510
of the device, based on
which base stations actually

00:36:48.510 --> 00:36:49.890
heard the message.

00:36:49.890 --> 00:36:54.130
So you start having coordinates
in your BigQuery database.

00:36:54.130 --> 00:36:55.910
And what can you do with those?

00:36:55.910 --> 00:36:58.760
Well, for example, this.

00:36:58.760 --> 00:37:01.580
So BigQuery now supports GIS--

00:37:01.580 --> 00:37:03.900
so geographical queries.

00:37:03.900 --> 00:37:06.140
So we have a nice
visualizer where

00:37:06.140 --> 00:37:07.470
you can start testing things.

00:37:07.470 --> 00:37:11.270
So specify your project,
your GCP project, and then,

00:37:11.270 --> 00:37:16.430
for example, you query BigQuery
with a standard SQL query,

00:37:16.430 --> 00:37:20.570
but you put there a
specific value, GEO point.

00:37:20.570 --> 00:37:23.750
So you're telling the system
that, hey, these two column

00:37:23.750 --> 00:37:26.600
values here in my data
warehouse actually

00:37:26.600 --> 00:37:29.990
contain geographical position
coordinates, latitude

00:37:29.990 --> 00:37:31.750
and longitude.

00:37:31.750 --> 00:37:34.670
So that's the first part in
the SELECT statement there.

00:37:34.670 --> 00:37:37.780
WKT will then contain
the coordinates.

00:37:37.780 --> 00:37:39.730
And then I'm also
asking, or querying

00:37:39.730 --> 00:37:43.220
from BigQuery, the device ID,
the temperature, humidity,

00:37:43.220 --> 00:37:47.620
and battery level
from the device data.

00:37:47.620 --> 00:37:50.740
And then let's see what
happens when I click Run.

00:37:50.740 --> 00:37:55.810
So now we are executing that
query live against BigQuery,

00:37:55.810 --> 00:37:58.790
and currently we are looking
at the last 20 messages.

00:37:58.790 --> 00:38:03.730
Let me increase
that to 30 messages.

00:38:03.730 --> 00:38:06.330
Let's look at the
last 30 messages.

00:38:06.330 --> 00:38:08.090
You can see that
I'm actually from--

00:38:08.090 --> 00:38:14.330
I live in Singapore, so when
we go back in time more,

00:38:14.330 --> 00:38:19.900
you can see that Singapore
starts coming up.

00:38:19.900 --> 00:38:22.420
So basically, this is
now asset tracking.

00:38:22.420 --> 00:38:25.790
We are tracking
my device earlier,

00:38:25.790 --> 00:38:30.670
and if I put the query back
to last 20 rows in BigQuery,

00:38:30.670 --> 00:38:32.680
everything should be near here.

00:38:32.680 --> 00:38:37.270
What I actually did was
I drove around this bay,

00:38:37.270 --> 00:38:40.370
and my device was transmitting
at regular intervals.

00:38:40.370 --> 00:38:44.050
So we got some
transmissions there.

00:38:44.050 --> 00:38:47.250
And if we zoom in
here to Google I/O,

00:38:47.250 --> 00:38:49.620
you can see that all these
messages were transmitted

00:38:49.620 --> 00:38:53.058
during I/O. So if I
click on one of these,

00:38:53.058 --> 00:38:54.600
you can see that we
have Google Maps,

00:38:54.600 --> 00:38:58.770
and we are overlaying, on
Google Maps, map pointers.

00:38:58.770 --> 00:39:01.410
And the data in the pointer
is the actual device

00:39:01.410 --> 00:39:05.620
data coming from BigQuery, so
we don't have any extra tools

00:39:05.620 --> 00:39:06.120
here.

00:39:06.120 --> 00:39:09.910
All of these are native
from GCP in Google tools,

00:39:09.910 --> 00:39:12.810
so we have a nice,
easy Maps integration

00:39:12.810 --> 00:39:16.330
with geographical
data in BigQuery here.

00:39:16.330 --> 00:39:19.170
So that's very handy.

00:39:19.170 --> 00:39:22.440
Quite often, it's good to know
where your IoT devices are,

00:39:22.440 --> 00:39:25.140
and you can do things like
geofencing, for example.

00:39:25.140 --> 00:39:28.230
Have an accent when your
device enters or exits

00:39:28.230 --> 00:39:29.520
a certain radius--

00:39:29.520 --> 00:39:32.300
a certain area.

00:39:32.300 --> 00:39:34.808
So with that, I really hope
that you found this useful,

00:39:34.808 --> 00:39:36.100
and I hope that you enjoyed it.

00:39:36.100 --> 00:39:38.200
A couple of useful links here.

00:39:38.200 --> 00:39:39.880
Please let me know
how you think.

00:39:39.880 --> 00:39:41.610
Thank you very much.

00:39:41.610 --> 00:39:44.360
[MUSIC PLAYING]

