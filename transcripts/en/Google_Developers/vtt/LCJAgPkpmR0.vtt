WEBVTT
Kind: captions
Language: en

00:00:01.190 --> 00:00:02.370
XAVIER DUCROHET: Good morning.

00:00:02.370 --> 00:00:03.940
My name is Xavier Ducrohet.

00:00:03.940 --> 00:00:07.175
I'm the lead for the Android
SDK developer tools.

00:00:07.175 --> 00:00:09.210
And I'm the main contributor
to the new build

00:00:09.210 --> 00:00:10.930
system for the SDK.

00:00:10.930 --> 00:00:12.420
So why a new build system?

00:00:12.420 --> 00:00:14.540
Well, if you look at the current
situation, on one

00:00:14.540 --> 00:00:17.420
hand, we have some end scripts
that are somewhat

00:00:17.420 --> 00:00:20.220
customizable, although we have
no public API for it, and it's

00:00:20.220 --> 00:00:22.440
likely to break whenever
we update the SDK.

00:00:22.440 --> 00:00:26.320
On the other hand, we have ADT
custom builders, very rigid,

00:00:26.320 --> 00:00:27.760
but at least it works
in the IDE.

00:00:27.760 --> 00:00:28.730
And then we have [INAUDIBLE]

00:00:28.730 --> 00:00:30.510
that has its own builder.

00:00:30.510 --> 00:00:32.540
It's a bit more flexible, but
it doesn't do many fast

00:00:32.540 --> 00:00:33.620
merging, some issues.

00:00:33.620 --> 00:00:34.670
So we want to fix that.

00:00:34.670 --> 00:00:37.320
We wanted to create a single
build system that was very

00:00:37.320 --> 00:00:39.040
flexible so that it adapts
to all of your

00:00:39.040 --> 00:00:41.780
needs, within reasons.

00:00:41.780 --> 00:00:45.290
And we wanted that build system
to work whether you're

00:00:45.290 --> 00:00:47.980
building from your continuous
integration server

00:00:47.980 --> 00:00:49.180
or within the IDE.

00:00:49.180 --> 00:00:51.430
If your customization doesn't
work in your IDE, then it just

00:00:51.430 --> 00:00:51.880
doesn't work.

00:00:51.880 --> 00:00:53.510
It breaks your workflow.

00:00:53.510 --> 00:00:55.570
We wanted to add some features,
like dependency

00:00:55.570 --> 00:00:59.810
management, the ability to
deploy and run tests, but also

00:00:59.810 --> 00:01:03.510
Android-specific features that
developers have asked us.

00:01:03.510 --> 00:01:05.060
We didn't want to start
from scratch.

00:01:05.060 --> 00:01:05.980
So we looked around.

00:01:05.980 --> 00:01:08.210
There's a lot of build
systems out there.

00:01:08.210 --> 00:01:11.740
They have plug-in ecosystem,
support in Jenkins, TeamCity,

00:01:11.740 --> 00:01:14.280
and we wanted to leverage
all of that.

00:01:14.280 --> 00:01:17.300
So we looked around, and
we settled on Gradle.

00:01:17.300 --> 00:01:18.010
So why Gradle?

00:01:18.010 --> 00:01:21.075
Well, as a user, it's
very powerful,

00:01:21.075 --> 00:01:23.100
great declarative syntax.

00:01:23.100 --> 00:01:25.830
But you can customize to your
need, and it has a great

00:01:25.830 --> 00:01:28.440
tooling API to do
IDE integration.

00:01:28.440 --> 00:01:32.260
From our point of view, when we
develop the plugin, we can

00:01:32.260 --> 00:01:36.090
create a new domain-specific
language to really make the

00:01:36.090 --> 00:01:37.310
configuration of the
build system

00:01:37.310 --> 00:01:40.030
very specific to Android.

00:01:40.030 --> 00:01:42.600
We can expose great
APIs for you to

00:01:42.600 --> 00:01:43.940
extend the build system.

00:01:43.940 --> 00:01:46.760
And the IDE integration can be
customized so that the IDE

00:01:46.760 --> 00:01:49.375
really knows not just about,
hey, just some sort of build

00:01:49.375 --> 00:01:52.180
system, but it's really an
Android Build System.

00:01:52.180 --> 00:01:55.400
It's also developed by a company
called Gradleware who

00:01:55.400 --> 00:01:57.140
designed open source.

00:01:57.140 --> 00:01:59.020
It's Apache, so that's
great for us.

00:01:59.020 --> 00:02:01.755
And we've worked together to
make sure that the build

00:02:01.755 --> 00:02:05.260
system Gradle itself is adding
features, specifically, that

00:02:05.260 --> 00:02:08.139
we need so that we can give the
best possible experience

00:02:08.139 --> 00:02:09.930
to you developers.

00:02:09.930 --> 00:02:12.730
So I figure that a lot of you
probably don't know Gradle, or

00:02:12.730 --> 00:02:13.940
maybe just tried it
a little bit.

00:02:13.940 --> 00:02:17.620
So I wanted to start with some
basics and go through some

00:02:17.620 --> 00:02:19.190
simple projects.

00:02:19.190 --> 00:02:23.010
So if you look at a very simple
Java project, first the

00:02:23.010 --> 00:02:25.510
configuration is in a file
called build.gradle that's

00:02:25.510 --> 00:02:28.900
located at the root of your
project, where you would find

00:02:28.900 --> 00:02:30.750
your build.xml, or pom.xml
if you build

00:02:30.750 --> 00:02:32.070
it with Ant or Maven.

00:02:32.070 --> 00:02:35.580
So with a simple line, what you
can do is build your main

00:02:35.580 --> 00:02:38.280
code and generate the JAR file,
build your test code,

00:02:38.280 --> 00:02:41.930
run your test, and get to output
some XML file that you

00:02:41.930 --> 00:02:45.490
can feed into your Jenkins
server to get some trends and

00:02:45.490 --> 00:02:49.050
dashboard, and a local HTML
report to get the same result

00:02:49.050 --> 00:02:52.180
when you're running your test
on your workstation.

00:02:52.180 --> 00:02:55.830
The same Android project is a
little bit more complicated,

00:02:55.830 --> 00:02:56.600
but it's not that bad, really.

00:02:56.600 --> 00:02:59.030
So the first section of the
build script is about telling

00:02:59.030 --> 00:03:01.320
Gradle where our plugin is.

00:03:01.320 --> 00:03:03.170
So we're saying here, hey
it's on mavenCentral.

00:03:03.170 --> 00:03:04.470
Here's the artifact.

00:03:04.470 --> 00:03:06.250
Just put it on the class path.

00:03:06.250 --> 00:03:08.910
It's something that the Gradle
developer wants to improve the

00:03:08.910 --> 00:03:11.740
future, so hopefully it will
be a bit less verbose.

00:03:11.740 --> 00:03:13.986
So we just apply the
plugin like we did

00:03:13.986 --> 00:03:15.910
for the Java plugin.

00:03:15.910 --> 00:03:18.710
And then the third block is
really the beginning of the

00:03:18.710 --> 00:03:21.700
configuration of the
Android plugin.

00:03:21.700 --> 00:03:23.460
And so we have two
properties here.

00:03:23.460 --> 00:03:25.690
The first one, compileSdkVersion
is what

00:03:25.690 --> 00:03:28.940
you'd use as target in
project.properties.

00:03:28.940 --> 00:03:31.910
We renamed it because target,
target SDK version, there was

00:03:31.910 --> 00:03:33.560
some confusion there.

00:03:33.560 --> 00:03:36.530
And then the second property
I will talk about later.

00:03:36.530 --> 00:03:37.100
So what can you do with that?

00:03:37.100 --> 00:03:39.130
Well, you can build an APK.

00:03:39.130 --> 00:03:40.330
We can build a test APK.

00:03:40.330 --> 00:03:43.500
It used to be that we had
a separate test project.

00:03:43.500 --> 00:03:44.760
It's just not flexible.

00:03:44.760 --> 00:03:45.620
We have to find it.

00:03:45.620 --> 00:03:46.940
It's so hard to find
the relation

00:03:46.940 --> 00:03:47.760
between the two projects.

00:03:47.760 --> 00:03:49.880
So it's back in the
main project.

00:03:49.880 --> 00:03:52.820
You can deploy those two APKs
and run the test on any number

00:03:52.820 --> 00:03:53.550
of connected devices.

00:03:53.550 --> 00:03:56.140
It will run them in parallel,
and you'll get the same two

00:03:56.140 --> 00:03:59.380
output-- the XML and the HTML.

00:03:59.380 --> 00:04:02.880
So already, we do more
than the Ant script.

00:04:02.880 --> 00:04:05.200
So as you noticed, I didn't
configure anything.

00:04:05.200 --> 00:04:08.210
It's convention over
configuration.

00:04:08.210 --> 00:04:11.130
And for source folder, this is
the convention for regular

00:04:11.130 --> 00:04:13.190
Java projects, because you
have your main code

00:04:13.190 --> 00:04:13.870
and your test code.

00:04:13.870 --> 00:04:16.230
It's in the source main
and source test.

00:04:16.230 --> 00:04:18.610
So for Android, we reuse
the same convention.

00:04:18.610 --> 00:04:20.160
We expand it a little
bit, because we

00:04:20.160 --> 00:04:21.350
have a lot more files.

00:04:21.350 --> 00:04:24.340
So source main, we add Android
manifest, XML.

00:04:24.340 --> 00:04:26.370
We add the resources,
the assets.

00:04:26.370 --> 00:04:29.000
We move the AID and run
the scripts files

00:04:29.000 --> 00:04:30.930
under their own folders.

00:04:30.930 --> 00:04:34.550
And then, on the test side, we
call that instrument test.

00:04:34.550 --> 00:04:37.460
We wanted to keep test for
actual true local [? JUnit ?]

00:04:37.460 --> 00:04:38.420
test.

00:04:38.420 --> 00:04:40.390
We don't have a manifest
in there.

00:04:40.390 --> 00:04:42.030
It will be automatically
generated.

00:04:42.030 --> 00:04:44.480
I'll talk about that later.

00:04:44.480 --> 00:04:45.960
All right, so that's
your structure.

00:04:45.960 --> 00:04:48.860
Now, how do you run the thing?

00:04:48.860 --> 00:04:50.260
Oh wait, hold on.

00:04:50.260 --> 00:04:53.060
So if you have an old project,
I'm guessing that you probably

00:04:53.060 --> 00:04:56.500
don't want to go back to all
of that and change your

00:04:56.500 --> 00:04:57.910
project just to try Gradle.

00:04:57.910 --> 00:05:02.370
So this is how you configure a
project that you currently

00:05:02.370 --> 00:05:04.860
have to tell Gradle this
is my structure.

00:05:04.860 --> 00:05:05.760
So here's it's very simple.

00:05:05.760 --> 00:05:08.830
Again, in the Android block,
we have a sourceSet.

00:05:08.830 --> 00:05:10.990
And that's a container
of sourceSet.

00:05:10.990 --> 00:05:12.755
And so, inside, we configure
the main and

00:05:12.755 --> 00:05:15.680
the instrument test.

00:05:15.680 --> 00:05:17.620
So for our instrument test, what
we do is that setRoot.

00:05:17.620 --> 00:05:18.860
We'll just move everything from

00:05:18.860 --> 00:05:21.470
source/instrumentTest to test.

00:05:21.470 --> 00:05:24.720
So test/Java, test/res
et cetera.

00:05:24.720 --> 00:05:28.080
Notice how, for the main
source sets, we have

00:05:28.080 --> 00:05:30.090
res.srcDirs.

00:05:30.090 --> 00:05:32.340
And it's actually a [INAUDIBLE]
with bracket.

00:05:32.340 --> 00:05:33.590
That's because we can
actually now support

00:05:33.590 --> 00:05:35.640
multiple res folders.

00:05:35.640 --> 00:05:37.810
So you can just organize your
source however you want them,

00:05:37.810 --> 00:05:40.530
and then we just merge them
together, detect duplicates,

00:05:40.530 --> 00:05:43.480
and do the right thing.

00:05:43.480 --> 00:05:44.550
All right, so to run Gradle.

00:05:44.550 --> 00:05:46.860
Well, once you have installed
Gradle, you go to your project

00:05:46.860 --> 00:05:50.530
root, and you just do Gradle
and some task name.

00:05:50.530 --> 00:05:52.910
To get the task, there's a task
called task that give you

00:05:52.910 --> 00:05:53.930
the list of tasks.

00:05:53.930 --> 00:05:56.030
And if you do dash dash all,
it will give you all the

00:05:56.030 --> 00:05:58.440
intermediate tasks that you
probably don't care about.

00:05:58.440 --> 00:06:01.270
And on the really complicated
project, it's going to be 50

00:06:01.270 --> 00:06:02.930
tasks, or something like that.

00:06:02.930 --> 00:06:03.980
You don't care about
all of those.

00:06:03.980 --> 00:06:06.000
You care about four of them.

00:06:06.000 --> 00:06:09.350
assemble will build your
project output.

00:06:09.350 --> 00:06:11.810
Check will run all your
checked and test.

00:06:11.810 --> 00:06:14.510
Build will do both assembling
and testing.

00:06:14.510 --> 00:06:15.780
This is what buildling
a product is.

00:06:15.780 --> 00:06:17.980
It's building it, but
also testing it.

00:06:17.980 --> 00:06:20.030
And then clean does the clean.

00:06:20.030 --> 00:06:22.200
So the thing that's interesting
here is that those

00:06:22.200 --> 00:06:23.300
tasks actually don't
do anything.

00:06:23.300 --> 00:06:25.350
I like to call them
anchor tasks.

00:06:25.350 --> 00:06:28.090
Plugins will go and kind of like
plug them under it, and

00:06:28.090 --> 00:06:31.900
say, hey, when the users says
assemble, here's the task that

00:06:31.900 --> 00:06:33.430
you should actually call.

00:06:33.430 --> 00:06:35.980
So the Java project,
for instance,

00:06:35.980 --> 00:06:37.620
has different tasks--

00:06:37.620 --> 00:06:40.770
JAR to build the JAR, and
test to run the test.

00:06:40.770 --> 00:06:43.780
So that means that when you
apply some other plugin like

00:06:43.780 --> 00:06:47.230
the [INAUDIBLE], there's a
FindBug plugin, you don't have

00:06:47.230 --> 00:06:48.510
to care what it's tasks are.

00:06:48.510 --> 00:06:51.590
You just call check, and it will
call test, FindBugs main

00:06:51.590 --> 00:06:52.810
and FindBugs test.

00:06:52.810 --> 00:06:56.180
So it's very powerful and very
extensible without you having

00:06:56.180 --> 00:06:57.770
to know what's going on

00:06:57.770 --> 00:06:59.300
So for Android, we do
the same thing.

00:06:59.300 --> 00:07:02.470
We have assemble, and then we
have check, and then we have

00:07:02.470 --> 00:07:03.910
connectedCheck and
deviceCheck.

00:07:03.910 --> 00:07:05.840
And this is because of
the test without

00:07:05.840 --> 00:07:07.060
device, test with device.

00:07:07.060 --> 00:07:08.990
I'll talk about that later.

00:07:08.990 --> 00:07:11.980
One of the differences, assemble
will actually build

00:07:11.980 --> 00:07:12.990
two different versions.

00:07:12.990 --> 00:07:14.650
We have the debug in [INAUDIBLE]
release, similar

00:07:14.650 --> 00:07:16.235
to Ant release and debug.

00:07:16.235 --> 00:07:18.140
Except that here, you can
actually build both of them in

00:07:18.140 --> 00:07:21.850
parallel and have them
built while Ant will

00:07:21.850 --> 00:07:24.280
override each other.

00:07:24.280 --> 00:07:26.920
All right, so let's talk about
customization a little bit.

00:07:26.920 --> 00:07:29.800
That's why we're building
this new build system.

00:07:29.800 --> 00:07:32.030
So the most basic customization
is, let's say

00:07:32.030 --> 00:07:33.520
you want to override
some properties.

00:07:33.520 --> 00:07:36.690
So for example, here we have a
defaultConfig object inside

00:07:36.690 --> 00:07:40.470
the Android object that says
hey, I'm going to do version

00:07:40.470 --> 00:07:42.920
code and minSdkVersion,
and something.

00:07:42.920 --> 00:07:46.780
And so when you build, those
values will get injected into

00:07:46.780 --> 00:07:48.260
your manifest and
that's great.

00:07:48.260 --> 00:07:50.090
You're probably wondering, well,
why do I want to do that

00:07:50.090 --> 00:07:52.810
when I can actually just put
those values in my manifest?

00:07:52.810 --> 00:07:55.690
Well, imagine that you want to
do a nightly build where you

00:07:55.690 --> 00:07:58.540
want to increase the version
code incrementally.

00:07:58.540 --> 00:08:01.173
So you could do some script that
goes in, and somehow hack

00:08:01.173 --> 00:08:03.745
your manifest around, and do
something, and that's probably

00:08:03.745 --> 00:08:05.280
not very good.

00:08:05.280 --> 00:08:08.790
So here, Gradle allow us to just
do something while you

00:08:08.790 --> 00:08:12.120
create a new function that will
get that version code

00:08:12.120 --> 00:08:16.490
from Jenkins, for example,
through system property or

00:08:16.490 --> 00:08:17.550
[INAUDIBLE].

00:08:17.550 --> 00:08:19.700
And then you just inject it
into the version code.

00:08:19.700 --> 00:08:22.310
And that will work
all the time.

00:08:22.310 --> 00:08:25.140
And then, if the function
actually returns minus one by

00:08:25.140 --> 00:08:28.960
default, which is when you're
running on your desktop, then

00:08:28.960 --> 00:08:31.100
the value will not
be injected.

00:08:31.100 --> 00:08:33.610
So you can do some custom logic,
but it's still very

00:08:33.610 --> 00:08:35.409
declarative.

00:08:35.409 --> 00:08:36.850
I mentioned just a minute
ago that we

00:08:36.850 --> 00:08:38.020
built debug and release.

00:08:38.020 --> 00:08:41.390
And a lot of developers have
asked us things like, hey, I

00:08:41.390 --> 00:08:42.630
want to run ProGaurd in debug.

00:08:42.630 --> 00:08:44.190
Can I do that please?

00:08:44.190 --> 00:08:46.060
And before it was like,
well we can't redo it.

00:08:46.060 --> 00:08:47.640
So we looked at it, and we
said we're going to do

00:08:47.640 --> 00:08:48.990
something really flexible.

00:08:48.990 --> 00:08:51.570
And so we introduced the
concept of build types.

00:08:51.570 --> 00:08:55.500
Build types are about how I
package my application and

00:08:55.500 --> 00:08:58.010
some options like, is it
debuggable, how is it signed,

00:08:58.010 --> 00:08:59.840
do I run ProGaurd?

00:08:59.840 --> 00:09:02.880
And you start with a built-in
debug and a built-in release

00:09:02.880 --> 00:09:06.090
one, but you can create
new ones.

00:09:06.090 --> 00:09:08.480
So here's the DSL to do it.

00:09:08.480 --> 00:09:10.000
So inside the Android
object, you have a

00:09:10.000 --> 00:09:10.900
very build types object.

00:09:10.900 --> 00:09:12.630
That's also a container.

00:09:12.630 --> 00:09:13.100
We saw that.

00:09:13.100 --> 00:09:13.760
We saw sets.

00:09:13.760 --> 00:09:14.770
We're going to use that again.

00:09:14.770 --> 00:09:17.510
It's a typical pattern
that we have.

00:09:17.510 --> 00:09:19.650
And so in it, we configure
the debug properties.

00:09:19.650 --> 00:09:21.790
And we set some property of
the debug build type.

00:09:21.790 --> 00:09:22.870
And we set some properties.

00:09:22.870 --> 00:09:25.180
And one of them is package
name suffix.

00:09:25.180 --> 00:09:28.680
So any time you build with
debug, whatever the package

00:09:28.680 --> 00:09:31.276
name of your application is,
will append the debug at the

00:09:31.276 --> 00:09:33.360
end of the package so that you
can study it side by side with

00:09:33.360 --> 00:09:35.190
your release application.

00:09:35.190 --> 00:09:39.390
And then suffix name will just
a suffix also to extend.

00:09:39.390 --> 00:09:41.200
It's something that a lot of
developers have asked us.

00:09:41.200 --> 00:09:43.780
And then we have this new thing
in Play Console where

00:09:43.780 --> 00:09:45.160
you can have a beta version.

00:09:45.160 --> 00:09:47.850
And maybe you want to actually
build a specific beta version

00:09:47.850 --> 00:09:49.650
for those testers.

00:09:49.650 --> 00:09:52.090
And so you can create
a new beta test.

00:09:52.090 --> 00:09:54.630
And so here we are adding
some properties.

00:09:54.630 --> 00:09:55.320
And that's great.

00:09:55.320 --> 00:09:56.320
But that's not really enough.

00:09:56.320 --> 00:09:58.870
You should really want to
customize that beta version.

00:09:58.870 --> 00:10:01.070
So for each build type,
you also get a

00:10:01.070 --> 00:10:02.670
custom source folders.

00:10:02.670 --> 00:10:05.580
So for example, in your beta
version, it's a beta test, so

00:10:05.580 --> 00:10:07.780
you want to gather some
statistics on how your users

00:10:07.780 --> 00:10:10.510
are using your application.

00:10:10.510 --> 00:10:11.310
So how do I do that?

00:10:11.310 --> 00:10:14.630
Well, under source/beta/java,
you just put some code.

00:10:14.630 --> 00:10:16.340
And that code will get packaged
with your beta

00:10:16.340 --> 00:10:19.350
application whenever you build
only the beta version, not the

00:10:19.350 --> 00:10:21.450
release, and not the
debug version.

00:10:21.450 --> 00:10:24.100
You probably want internet
permission to be able to send

00:10:24.100 --> 00:10:24.560
those data.

00:10:24.560 --> 00:10:26.340
And maybe your regular
application doesn't have the

00:10:26.340 --> 00:10:27.590
internet permission.

00:10:27.590 --> 00:10:30.960
So instead of bring it manually
in the manifest some

00:10:30.960 --> 00:10:33.570
time and forgetting to remove
it, which is not great, you

00:10:33.570 --> 00:10:35.530
just put it in source, beta,
Android manifest, and that

00:10:35.530 --> 00:10:38.320
gets merged into your main
manifest when you build only

00:10:38.320 --> 00:10:39.440
the beta version.

00:10:39.440 --> 00:10:42.250
And you can use that also for
things like if you have

00:10:42.250 --> 00:10:44.710
MapView API key and you want a
different API key on release

00:10:44.710 --> 00:10:46.920
and debug because it's tied to
you're signing configuration,

00:10:46.920 --> 00:10:49.540
well, you can just put that into
the res folder of those

00:10:49.540 --> 00:10:52.700
different build types.

00:10:52.700 --> 00:10:53.900
And of course, you need
to be able to

00:10:53.900 --> 00:10:55.050
build the beta version.

00:10:55.050 --> 00:10:56.940
So that's where the assemble
debug and assemble release are

00:10:56.940 --> 00:10:57.770
coming from.

00:10:57.770 --> 00:11:00.090
They are just automatically
generated whenever you add a

00:11:00.090 --> 00:11:01.270
new build type.

00:11:01.270 --> 00:11:02.940
So you can actually have all
three versions at the same

00:11:02.940 --> 00:11:05.410
time and build them.

00:11:05.410 --> 00:11:06.260
All right.

00:11:06.260 --> 00:11:10.030
So I just said that signing
was part of the build type

00:11:10.030 --> 00:11:11.490
configuration.

00:11:11.490 --> 00:11:14.990
So we wanted to make things
very flexible here.

00:11:14.990 --> 00:11:17.040
We have a container of signing
configuration.

00:11:17.040 --> 00:11:19.410
And a signing configuration is
in a location of the KeyStore,

00:11:19.410 --> 00:11:22.340
passwords, you know,
name of the key.

00:11:22.340 --> 00:11:24.610
And we have a default version
one called debug.

00:11:24.610 --> 00:11:27.580
And so here, what we're doing
in that simple example is we

00:11:27.580 --> 00:11:30.430
are telling Gradle, configuring
the debug signing

00:11:30.430 --> 00:11:33.320
configuration and using a
KeyStore that's at the root of

00:11:33.320 --> 00:11:36.040
my project so that way, everyone
on your team or your

00:11:36.040 --> 00:11:37.770
build server always
would build with

00:11:37.770 --> 00:11:39.030
the same debug KeyStore.

00:11:39.030 --> 00:11:41.390
And there won't be an issue
when your QA is trying to

00:11:41.390 --> 00:11:43.490
install something coming
from a different build.

00:11:43.490 --> 00:11:44.520
And that's all you have to do.

00:11:44.520 --> 00:11:47.920
The debug build type is
automatically configured to

00:11:47.920 --> 00:11:50.540
use that particular signing
configuration.

00:11:50.540 --> 00:11:53.140
Let's look at another a little
bit more complicated example.

00:11:53.140 --> 00:11:56.440
Let's say you have a release
version of your application

00:11:56.440 --> 00:11:59.040
that is different from your
debug because maybe you have

00:11:59.040 --> 00:12:01.650
some properties that tell it,
hey, I want to use my

00:12:01.650 --> 00:12:03.750
production server instead
of some test server.

00:12:03.750 --> 00:12:04.440
I'm using ProGuard.

00:12:04.440 --> 00:12:06.350
I'm obfuscating and doing
a lot of things.

00:12:06.350 --> 00:12:08.630
And I want to test
that version.

00:12:08.630 --> 00:12:09.330
I want to debug it.

00:12:09.330 --> 00:12:10.380
How do I do that?

00:12:10.380 --> 00:12:14.320
Well, what you would do, you
would create a new build type,

00:12:14.320 --> 00:12:16.510
call it debug release,
for instance.

00:12:16.510 --> 00:12:19.470
InitWith will initialize it with
the release build type.

00:12:19.470 --> 00:12:22.100
So every time you go and change
your release build

00:12:22.100 --> 00:12:25.420
type, it just gets copied
into your debug release.

00:12:25.420 --> 00:12:26.670
And then we customize
something.

00:12:26.670 --> 00:12:28.550
So we say, hey, it's
debuggable.

00:12:28.550 --> 00:12:31.140
We add a suffix to the package
name to make sure you can set

00:12:31.140 --> 00:12:33.260
it in parallel with the
your release version.

00:12:33.260 --> 00:12:36.880
And then we assign the debug
signing config so that anyone

00:12:36.880 --> 00:12:37.780
can build it.

00:12:37.780 --> 00:12:39.770
And then we change the sourceSet
to make sure that

00:12:39.770 --> 00:12:42.100
source/release, whatever you put
in there, is also used to

00:12:42.100 --> 00:12:44.120
build your debug release.

00:12:44.120 --> 00:12:46.170
And just with these few lines,
you suddenly have a new

00:12:46.170 --> 00:12:48.190
version of your application
that's exactly, and always

00:12:48.190 --> 00:12:51.650
exactly, the same as your
release, but you can debug it.

00:12:51.650 --> 00:12:53.940
And if you wanted to have some
custom ProGuard specifically,

00:12:53.940 --> 00:12:56.060
also, for that version, to
disable or enable some rules,

00:12:56.060 --> 00:12:56.740
you could do that.

00:12:56.740 --> 00:12:58.805
But by default, it will just
pick up all the rules that the

00:12:58.805 --> 00:13:00.440
version would use.

00:13:00.440 --> 00:13:02.570
What I really like about that
example, also, is that it's

00:13:02.570 --> 00:13:05.190
not showing you that
it's declarative.

00:13:05.190 --> 00:13:08.240
But initWith here doesn't
receive a primitive type.

00:13:08.240 --> 00:13:12.380
It receives, actually,
a buildtypes.release.

00:13:12.380 --> 00:13:15.450
That's actually an object
of type build type.

00:13:15.450 --> 00:13:18.400
So what happens is that every
time inside the build type

00:13:18.400 --> 00:13:22.940
container, you start using
release, or debug, or beta, if

00:13:22.940 --> 00:13:25.200
that particular object doesn't
exist, we create

00:13:25.200 --> 00:13:27.230
a build type instance.

00:13:27.230 --> 00:13:28.870
And we put it in
the container.

00:13:28.870 --> 00:13:31.770
So what you're really doing
here is not just setting a

00:13:31.770 --> 00:13:34.400
bunch of properties that will
be read later on, and by

00:13:34.400 --> 00:13:37.890
something that will parse that
file, and build something.

00:13:37.890 --> 00:13:41.220
Every line actually manipulates
a live model.

00:13:41.220 --> 00:13:43.260
And that's very important
and very powerful.

00:13:43.260 --> 00:13:47.180
That means that, let's say we
have the release, beta, debug,

00:13:47.180 --> 00:13:47.720
debug release.

00:13:47.720 --> 00:13:48.380
That's a lot of them.

00:13:48.380 --> 00:13:51.010
And maybe you don't want to put
the suffix for the package

00:13:51.010 --> 00:13:52.600
name on all of them manually.

00:13:52.600 --> 00:13:54.635
What if you could just
it programmatically?

00:13:54.635 --> 00:13:56.390
Well, just do something
like that.

00:13:56.390 --> 00:13:58.630
After the Android block, where
you configure all your build

00:13:58.630 --> 00:14:01.110
types, just loop on the build
types and just assign

00:14:01.110 --> 00:14:02.795
automatically the
package name.

00:14:02.795 --> 00:14:05.160
What's really interesting here
is that you're basically

00:14:05.160 --> 00:14:06.210
building that model.

00:14:06.210 --> 00:14:10.750
And that configured model is
what is sent to the IDE during

00:14:10.750 --> 00:14:12.990
the IDE integration when you
report your project.

00:14:12.990 --> 00:14:15.000
So whether you're setting those
package name suffixes

00:14:15.000 --> 00:14:17.980
manually or whether you're using
some logic, a loop, or

00:14:17.980 --> 00:14:19.880
maybe you say, hey, we only want
to add them on Mondays,

00:14:19.880 --> 00:14:21.830
whatever you're doing, it's
just going to work.

00:14:21.830 --> 00:14:24.250
The IDE will just be aware of
what's going on, because it

00:14:24.250 --> 00:14:26.880
gets the final configured
model.

00:14:26.880 --> 00:14:27.870
And that's very powerful.

00:14:27.870 --> 00:14:30.820
That allows us to really have
the IDE know everything about

00:14:30.820 --> 00:14:32.500
your project based
on that model.

00:14:32.500 --> 00:14:34.640
However, it is, whatever
logic you use to

00:14:34.640 --> 00:14:36.804
actually configure it.

00:14:36.804 --> 00:14:38.840
All right, let's look
at dependencies.

00:14:38.840 --> 00:14:41.320
It's something that a lot of
developers have asked for.

00:14:41.320 --> 00:14:45.020
So Gradle supports that
natively, so we

00:14:45.020 --> 00:14:46.110
benefit from that.

00:14:46.110 --> 00:14:49.740
So there's four scopes
of dependencies--

00:14:49.740 --> 00:14:52.240
compile, runtime, that's for
your main source code.

00:14:52.240 --> 00:14:54.945
And runtime always
extends compile.

00:14:54.945 --> 00:14:57.320
So if you had a dependency
to compile, runtime

00:14:57.320 --> 00:14:58.540
automatically gets it.

00:14:58.540 --> 00:15:00.230
And then there's the
same for test.

00:15:00.230 --> 00:15:03.100
So far Android, slightly
different, mostly because we

00:15:03.100 --> 00:15:06.150
renamed runtime to package,
because it's

00:15:06.150 --> 00:15:06.960
what really we do.

00:15:06.960 --> 00:15:09.700
We package all of your
dependencies into the APK.

00:15:09.700 --> 00:15:13.200
And then test, instrument test,
to make sure that it's

00:15:13.200 --> 00:15:15.240
always instrumentation test.

00:15:15.240 --> 00:15:18.920
So let's go back to your
beta version, right?

00:15:18.920 --> 00:15:21.620
We want to send the statistic
to the user.

00:15:21.620 --> 00:15:24.010
Let's say you want to use some
library to help you.

00:15:24.010 --> 00:15:26.120
Well, if you add them on
compile, that means that your

00:15:26.120 --> 00:15:27.440
release will also have
that library.

00:15:27.440 --> 00:15:28.660
And you don't want to do that.

00:15:28.660 --> 00:15:32.870
So we have scopes specifically
for your build types.

00:15:32.870 --> 00:15:35.440
So here, only on the build type
compile scope, you would

00:15:35.440 --> 00:15:37.620
say, hey, I use [INAUDIBLE]

00:15:37.620 --> 00:15:38.460
or something like that.

00:15:38.460 --> 00:15:41.620
And then it's only for
that build type.

00:15:41.620 --> 00:15:43.747
So this is how you do dependency
in Gradle.

00:15:43.747 --> 00:15:46.230
You have a dependencies
object.

00:15:46.230 --> 00:15:47.520
Compile is the scope.

00:15:47.520 --> 00:15:49.780
And then you give it whatever
dependency you have.

00:15:49.780 --> 00:15:52.960
Here we say, if I have an old
project and I have a bunch of

00:15:52.960 --> 00:15:56.330
JAR filing under my libs
project, that's what you do.

00:15:56.330 --> 00:15:57.410
[INAUDIBLE]

00:15:57.410 --> 00:16:00.110
every JAR file under libs.

00:16:00.110 --> 00:16:01.750
Very useful to migrate
your current project.

00:16:01.750 --> 00:16:04.880
So if you want to use
remote dependencies,

00:16:04.880 --> 00:16:05.740
this is what you do.

00:16:05.740 --> 00:16:09.400
First, you tell it what
repository to use.

00:16:09.400 --> 00:16:11.470
So here we say mavenCentral, but
you could say, if you have

00:16:11.470 --> 00:16:14.680
a custom internal artifact
repository, you

00:16:14.680 --> 00:16:16.070
can put the URL there.

00:16:16.070 --> 00:16:18.600
Whether it's Maven or Ivy,
it will support it--

00:16:18.600 --> 00:16:19.290
not a problem.

00:16:19.290 --> 00:16:22.520
And then in the dependency
block, the instrument test

00:16:22.520 --> 00:16:24.320
compile, you give the
artifact address.

00:16:24.320 --> 00:16:27.260
And here we use the fest-android
from square that

00:16:27.260 --> 00:16:31.230
allow you to have some nice
asserts and test output.

00:16:31.230 --> 00:16:34.150
And then notice how the beta
compile use the local JAR.

00:16:34.150 --> 00:16:36.920
So it's not I want to use either
dependency management

00:16:36.920 --> 00:16:39.200
with Maven or a local JAR
file, you can just mix

00:16:39.200 --> 00:16:40.340
depending on what you have.

00:16:40.340 --> 00:16:41.520
Gradle is very flexible.

00:16:41.520 --> 00:16:43.880
It will use whatever you want.

00:16:43.880 --> 00:16:47.130
So that's about using
someone else's code.

00:16:47.130 --> 00:16:50.320
If you want to use your own
code, it's slightly different.

00:16:50.320 --> 00:16:56.620
First, you need to have
a multi-project setup.

00:16:56.620 --> 00:16:57.920
It's something that we
didn't have before.

00:16:57.920 --> 00:16:59.990
Eclipse doesn't really support
that, and [INAUDIBLE]

00:16:59.990 --> 00:17:01.050
of course.

00:17:01.050 --> 00:17:03.290
So here, what we have
is, we have three

00:17:03.290 --> 00:17:04.930
different package modules.

00:17:04.930 --> 00:17:06.720
There's app, lib1, lib2.

00:17:06.720 --> 00:17:08.569
They're all their own project
with their own build.gradle.

00:17:08.569 --> 00:17:11.589
And there is settings.gradle
that say, here's all the

00:17:11.589 --> 00:17:12.880
different modules.

00:17:12.880 --> 00:17:16.420
And for the dependency, you
just say, hey, I want to

00:17:16.420 --> 00:17:19.359
include the project and the
path of the project.

00:17:19.359 --> 00:17:22.835
So that's very similar
and very easy.

00:17:22.835 --> 00:17:25.200
So library 1 could be
a library project.

00:17:25.200 --> 00:17:27.579
And then lib2 could be
just like a JAR file.

00:17:27.579 --> 00:17:29.980
And if lib1 depend on lib2,
of course, app will get

00:17:29.980 --> 00:17:32.540
transitively your
dependencies.

00:17:32.540 --> 00:17:35.670
And so if lib1 is a library
project, this is how you

00:17:35.670 --> 00:17:36.790
declare a library project.

00:17:36.790 --> 00:17:39.390
It's exactly the same as
a regular project.

00:17:39.390 --> 00:17:40.360
It's the same plugin.

00:17:40.360 --> 00:17:41.510
You only need one plugin.

00:17:41.510 --> 00:17:44.300
It has both only one
Maven artifact.

00:17:44.300 --> 00:17:45.750
It has both plugins inside.

00:17:45.750 --> 00:17:47.990
And the plugin name is
different, but it's exactly

00:17:47.990 --> 00:17:50.170
the same as a regular project.

00:17:50.170 --> 00:17:51.800
The DSL is slightly different,
because there's some

00:17:51.800 --> 00:17:52.420
restrictions.

00:17:52.420 --> 00:17:57.820
But I'm not going to go
into detail on that.

00:17:57.820 --> 00:18:00.150
So what does a library
project do?

00:18:00.150 --> 00:18:02.130
Very similar to what
they currently do.

00:18:02.130 --> 00:18:03.190
We have some new things.

00:18:03.190 --> 00:18:04.770
The first thing is that,
finally, we have binary

00:18:04.770 --> 00:18:05.790
packaging of them.

00:18:05.790 --> 00:18:07.990
So we package everything
into an AAR format.

00:18:07.990 --> 00:18:08.610
It's just a Zip file.

00:18:08.610 --> 00:18:09.790
It's a bundle.

00:18:09.790 --> 00:18:12.042
And you can upload that
into repositories.

00:18:12.042 --> 00:18:16.470
[APPLAUSE]

00:18:16.470 --> 00:18:20.660
XAVIER DUCROHET: Guess it's
been a long time coming.

00:18:20.660 --> 00:18:23.570
Other thing that we support, we
had support for assets, so

00:18:23.570 --> 00:18:25.040
just put assets in
your library.

00:18:25.040 --> 00:18:27.590
They'll get merged into
your application.

00:18:27.590 --> 00:18:28.410
We have ProGuard rules.

00:18:28.410 --> 00:18:30.990
So if, for example, your library
has some specific

00:18:30.990 --> 00:18:32.720
class that should not be
obfuscated, just create a

00:18:32.720 --> 00:18:35.620
ProGuard file to say keep
that particular file.

00:18:35.620 --> 00:18:37.875
And whenever that application
that use that library runs

00:18:37.875 --> 00:18:41.360
ProGuard, it will also enable
that ProGuard rule so that

00:18:41.360 --> 00:18:43.930
your class doesn't get
obfuscated, for instance.

00:18:43.930 --> 00:18:47.220
We don't have Lint integration
yet, but as soon as add it, we

00:18:47.220 --> 00:18:49.840
want to do things like not
custom Lint rules, so that if

00:18:49.840 --> 00:18:52.110
you have some custom-made APIs
that you want to make sure

00:18:52.110 --> 00:18:55.100
people use properly, you can
have some rules there.

00:18:55.100 --> 00:18:57.950
And we are looking at adding
other metadata so that whoever

00:18:57.950 --> 00:19:00.570
use your library, they have a
better experience in the tool

00:19:00.570 --> 00:19:04.535
chain, in the IDE, and it's
better for your user.

00:19:04.535 --> 00:19:08.760
All right, so library project
have been used for people who

00:19:08.760 --> 00:19:11.400
want to do free versus paid
and things like that.

00:19:11.400 --> 00:19:12.420
And it's great.

00:19:12.420 --> 00:19:16.850
Now multiple APK support in
Google Play also allow you to

00:19:16.850 --> 00:19:20.040
do, for example, different APK
for if you're targeting an

00:19:20.040 --> 00:19:23.120
older version of Android or a
newer version of Android, or

00:19:23.120 --> 00:19:26.960
if you're targeting ARM versus
MIPS versus x86.

00:19:26.960 --> 00:19:29.550
But if you want to use all three
or a combination, then

00:19:29.550 --> 00:19:32.950
it becomes impossible to deal
with library project.

00:19:32.950 --> 00:19:35.110
And so we have build variants.

00:19:35.110 --> 00:19:38.950
So this concept of product
flavor is about what is your

00:19:38.950 --> 00:19:39.880
application?

00:19:39.880 --> 00:19:41.760
So it's going to support
different applications,

00:19:41.760 --> 00:19:43.590
whether they have the same
package name or not, depending

00:19:43.590 --> 00:19:45.080
if free versus paid or not.

00:19:45.080 --> 00:19:48.580
And it will do customized
things.

00:19:48.580 --> 00:19:49.490
So it's really like a different

00:19:49.490 --> 00:19:50.660
dimension from build type.

00:19:50.660 --> 00:19:53.250
It's combined with
build types.

00:19:53.250 --> 00:19:54.420
So here's how you create them.

00:19:54.420 --> 00:19:56.440
We have a product flavor
containers.

00:19:56.440 --> 00:19:57.550
And you can just create
new ones.

00:19:57.550 --> 00:20:00.280
So here I'm creating two
flavors, flavor1, flavor2.

00:20:00.280 --> 00:20:01.470
I'm assigning some packages.

00:20:01.470 --> 00:20:03.940
One of them say, hey, I want
a different minSDK version.

00:20:03.940 --> 00:20:05.650
The other one will use the
minSDK version from the

00:20:05.650 --> 00:20:08.230
manifest automatically.

00:20:08.230 --> 00:20:10.520
And of course you want
to have different

00:20:10.520 --> 00:20:12.090
code in those, right?

00:20:12.090 --> 00:20:14.300
The free version will have
some code specifically to

00:20:14.300 --> 00:20:15.630
free, and the paid
version to paid.

00:20:15.630 --> 00:20:18.230
So for each of those, you get
a new source folder as well.

00:20:18.230 --> 00:20:19.980
And because you want to test
it separately, you get a

00:20:19.980 --> 00:20:21.660
separate test folder as well.

00:20:24.440 --> 00:20:27.690
And if you have a free version
that's supported by ads, you

00:20:27.690 --> 00:20:30.600
want to add some like dependency
on AdMob's SDK, for

00:20:30.600 --> 00:20:32.490
instance, but you don't want
to put that on the paid

00:20:32.490 --> 00:20:34.460
version as well, so you have
a different scope.

00:20:34.460 --> 00:20:36.050
So here, we'll have a lot
of scope for all your

00:20:36.050 --> 00:20:37.010
applications.

00:20:37.010 --> 00:20:38.950
And basically, based on what you
build, we'll pick all of

00:20:38.950 --> 00:20:41.870
them and put all your
dependencies together.

00:20:41.870 --> 00:20:44.910
So the part that's important is
that, if you don't have any

00:20:44.910 --> 00:20:48.240
flavor, and you have debug and
release build types, you get a

00:20:48.240 --> 00:20:50.200
debug and a release
application.

00:20:50.200 --> 00:20:52.880
If you have flavors, then it's
really a matrix, and we do a

00:20:52.880 --> 00:20:54.100
combination of everything.

00:20:54.100 --> 00:20:57.980
So if you have flavor1 and
flavor2, then you can't have

00:20:57.980 --> 00:20:58.845
just a debug build.

00:20:58.845 --> 00:21:00.110
It doesn't mean anything
anymore.

00:21:00.110 --> 00:21:03.730
It's either flavor1 debug
or flavor2 debug.

00:21:03.730 --> 00:21:05.550
So that's very useful if you
have flavors to [? spend. ?]

00:21:05.550 --> 00:21:07.650
Now, if you also want to combine
x86, versus MIPS and

00:21:07.650 --> 00:21:10.730
versus ARM, well, that doesn't
really work, right?

00:21:10.730 --> 00:21:14.180
So we have flavor dimensions.

00:21:14.180 --> 00:21:15.880
But we called then groups
in the DSL.

00:21:15.880 --> 00:21:16.850
We might have to rename that.

00:21:16.850 --> 00:21:19.350
So it's really a different
dimension compared to--

00:21:19.350 --> 00:21:22.380
so one dimension is ABI,
x86 versus ARM.

00:21:22.380 --> 00:21:24.480
And the other one is the
version, whether

00:21:24.480 --> 00:21:25.490
it's paid or free.

00:21:25.490 --> 00:21:28.080
And so here, we create two ARM,
and we assign them to a

00:21:28.080 --> 00:21:29.420
specific dimension.

00:21:29.420 --> 00:21:33.590
So note how the ARM1 doesn't
customize the package name.

00:21:33.590 --> 00:21:37.064
That's because it's just
the same version of you

00:21:37.064 --> 00:21:39.830
application, while the
paid version has

00:21:39.830 --> 00:21:41.470
its own package name.

00:21:41.470 --> 00:21:44.590
So there's going to be some
combination of all of that.

00:21:44.590 --> 00:21:47.120
First, at the end, you get
a lot of packages.

00:21:47.120 --> 00:21:48.530
And you just get them
automatically.

00:21:48.530 --> 00:21:51.040
And if you add a new dimension
or add something, it will just

00:21:51.040 --> 00:21:54.010
take care of generating
all of that for you.

00:21:54.010 --> 00:21:55.400
And so, because it's
complicated, you need to

00:21:55.400 --> 00:21:58.680
understand all the different
ways we combined all of those

00:21:58.680 --> 00:21:59.200
dimensions--

00:21:59.200 --> 00:22:03.320
build type and different
dimensions of product flavor.

00:22:03.320 --> 00:22:05.940
So you could get up to four
different source folders, for

00:22:05.940 --> 00:22:07.290
example, in that particular
example.

00:22:07.290 --> 00:22:09.180
And so they're all going to be
considered as if there was

00:22:09.180 --> 00:22:10.065
just one source folder.

00:22:10.065 --> 00:22:12.410
And we'll just combine
everything into a single SDK.

00:22:12.410 --> 00:22:15.260
If you have resources, we just
use override mechanisms.

00:22:15.260 --> 00:22:17.280
So we start with your
base resources.

00:22:17.280 --> 00:22:20.450
We override on top of
it the flavors.

00:22:20.450 --> 00:22:23.490
And then on top of that, we
override the build types.

00:22:23.490 --> 00:22:27.090
And that's for res and
for assets as well.

00:22:27.090 --> 00:22:29.820
And if you have libraries, they
will be under the main

00:22:29.820 --> 00:22:32.680
one, and they will be overridden
by all that.

00:22:32.680 --> 00:22:34.560
Signing configuration, here
we have some flexibility.

00:22:34.560 --> 00:22:35.900
It's a priority order.

00:22:35.900 --> 00:22:38.200
So highest priority order is
build type, and then flavor,

00:22:38.200 --> 00:22:39.970
and then your main
configuration.

00:22:39.970 --> 00:22:46.370
What's interesting here is that
the debug build type has

00:22:46.370 --> 00:22:48.380
the default debug
configuration.

00:22:48.380 --> 00:22:51.440
And so every debug build
type will get signed

00:22:51.440 --> 00:22:52.710
with the same key.

00:22:52.710 --> 00:22:55.200
For release, if you assign a
signing configuration on the

00:22:55.200 --> 00:22:57.670
release build type, all your
release will be signed with

00:22:57.670 --> 00:22:59.760
the same key.

00:22:59.760 --> 00:23:01.530
But if you don't want to do
that-- maybe your paid and

00:23:01.530 --> 00:23:03.880
your free needs different
signing key-- then don't

00:23:03.880 --> 00:23:06.520
assign a signing configuration
on the build type, and assign

00:23:06.520 --> 00:23:08.160
it on the flavor instead.

00:23:08.160 --> 00:23:10.150
And then it's the one that will
get picked up, and you

00:23:10.150 --> 00:23:11.460
can have different signing
for two different

00:23:11.460 --> 00:23:13.980
versions of your apps.

00:23:13.980 --> 00:23:16.880
And the package name, so you saw
that we have a lot of ways

00:23:16.880 --> 00:23:18.270
of customizing package name.

00:23:18.270 --> 00:23:19.440
So we start with the
base Android

00:23:19.440 --> 00:23:21.590
package name in the manifest.

00:23:21.590 --> 00:23:23.620
If you have a different
configuration that overrides

00:23:23.620 --> 00:23:25.140
it, we take this one instead.

00:23:25.140 --> 00:23:26.790
If you have a flavor,
we take this one.

00:23:26.790 --> 00:23:29.490
And then, when we figure out
which package you have, if you

00:23:29.490 --> 00:23:33.620
have one in the build type,
we append the suffix.

00:23:33.620 --> 00:23:36.520
But when we generate the R
class, we always use the

00:23:36.520 --> 00:23:39.030
package name in the
src/main/AndroidManifest.xml

00:23:39.030 --> 00:23:41.720
that so that all of your import,
wherever you are, are

00:23:41.720 --> 00:23:42.530
always the same one.

00:23:42.530 --> 00:23:43.760
There's no switching.

00:23:43.760 --> 00:23:45.270
You can generate many
applications with different

00:23:45.270 --> 00:23:45.530
package names.

00:23:45.530 --> 00:23:49.760
But all your imports are
always the same.

00:23:49.760 --> 00:23:52.640
OK let's talk about testing.

00:23:52.640 --> 00:23:54.450
I mentioned testing
here and there, so

00:23:54.450 --> 00:23:55.580
let's do a quick recap.

00:23:55.580 --> 00:23:59.100
You have source folders for
testing and one per flavor, if

00:23:59.100 --> 00:24:01.220
you use flavors.

00:24:01.220 --> 00:24:04.820
You have dependency scopes, one
specific for testing and

00:24:04.820 --> 00:24:07.080
one per flavors.

00:24:07.080 --> 00:24:08.370
We generate the manifests.

00:24:08.370 --> 00:24:09.940
And now you probably understand
why we generate

00:24:09.940 --> 00:24:12.270
those manifests, since if you
generate six different

00:24:12.270 --> 00:24:14.190
applications with six different
packages, you don't

00:24:14.190 --> 00:24:16.327
want to maintain six different
manifests for your test

00:24:16.327 --> 00:24:17.130
application.

00:24:17.130 --> 00:24:19.870
The manifest for the test
application actually reference

00:24:19.870 --> 00:24:21.190
the package being tested.

00:24:21.190 --> 00:24:23.550
So that would be a
lot to maintain.

00:24:23.550 --> 00:24:25.800
And for the package name of
the test application, we

00:24:25.800 --> 00:24:28.460
generate that automatically
based on the package name of

00:24:28.460 --> 00:24:30.670
the tested application.

00:24:30.670 --> 00:24:33.210
And we're going to have one
test app per tested

00:24:33.210 --> 00:24:34.460
application.

00:24:36.200 --> 00:24:38.520
So right now, we only test
to one build type.

00:24:38.520 --> 00:24:40.260
So debug, by default, you
can configure it.

00:24:40.260 --> 00:24:43.710
We'll probably change
that in the future.

00:24:43.710 --> 00:24:45.580
But right now, it's just one.

00:24:45.580 --> 00:24:47.840
And then finally, library
project, even though they

00:24:47.840 --> 00:24:51.390
output just an AAR not an
APK, we can test those.

00:24:51.390 --> 00:24:54.390
So inside the library
project, one of the

00:24:54.390 --> 00:24:55.960
outputs is the test APK.

00:24:55.960 --> 00:24:58.010
And it will embed your library
into it, so you can test your

00:24:58.010 --> 00:25:02.130
library separately and inside
your APK also, if you want.

00:25:02.130 --> 00:25:04.290
All right, so that's
about building.

00:25:04.290 --> 00:25:06.590
What about running tests?

00:25:06.590 --> 00:25:07.860
So that's a little
bit complicated.

00:25:07.860 --> 00:25:08.950
And we looked into it.

00:25:08.950 --> 00:25:10.550
And we found out that
there's really

00:25:10.550 --> 00:25:12.020
three different scenarios.

00:25:12.020 --> 00:25:15.240
The first scenario is I
don't have devices.

00:25:15.240 --> 00:25:18.270
I just want to test something.

00:25:18.270 --> 00:25:19.880
And we link that to the regular

00:25:19.880 --> 00:25:22.100
check task from Gradle.

00:25:22.100 --> 00:25:27.310
So you're going to be limited
to what you can run there.

00:25:27.310 --> 00:25:28.990
You're going to be able to run
static analysis like other

00:25:28.990 --> 00:25:31.360
FindBugs and all links.

00:25:31.360 --> 00:25:32.820
And if you use Robolectric,
well, you can

00:25:32.820 --> 00:25:34.910
run them there too.

00:25:34.910 --> 00:25:38.240
The second scenario is, I'm a
developer sitting at my desk.

00:25:38.240 --> 00:25:39.950
I have my phone connected
to my workstation,

00:25:39.950 --> 00:25:41.280
maybe also a tablet.

00:25:41.280 --> 00:25:42.250
I want to run something.

00:25:42.250 --> 00:25:43.610
So that's what connected
check is.

00:25:43.610 --> 00:25:46.260
It will just look for connected
devices, run

00:25:46.260 --> 00:25:49.650
everything on it in parallel,
just give you your results.

00:25:49.650 --> 00:25:53.070
OK, third scenario is
your build server.

00:25:53.070 --> 00:25:55.270
Well here, you shouldn't really
have devices connected

00:25:55.270 --> 00:25:57.160
directly to your build server.

00:25:57.160 --> 00:25:57.900
Several issues.

00:25:57.900 --> 00:26:01.610
First, well, you may have more
than one build server.

00:26:01.610 --> 00:26:02.130
So that's a problem.

00:26:02.130 --> 00:26:05.110
You're going to enable
a lot more devices.

00:26:05.110 --> 00:26:07.360
If you do build in parallel, you
can't run instrumentation

00:26:07.360 --> 00:26:10.090
tests that hit the UI in
parallel, because that's just

00:26:10.090 --> 00:26:11.700
not going to work.

00:26:11.700 --> 00:26:13.750
So we need to have some
sort of queue, right?

00:26:13.750 --> 00:26:16.710
So we looked around, and there's
really two different

00:26:16.710 --> 00:26:18.870
scenarios there,
sub-scenarios.

00:26:18.870 --> 00:26:22.000
So the first one is, you have
a device lab somewhere.

00:26:22.000 --> 00:26:23.030
And you have a queue system.

00:26:23.030 --> 00:26:25.980
And your build system just
builds something, and then it

00:26:25.980 --> 00:26:26.960
gets put in the queue.

00:26:26.960 --> 00:26:29.370
And you have devices,
and you test that.

00:26:29.370 --> 00:26:31.790
And, well, you're going to get
a remote dashboard, because

00:26:31.790 --> 00:26:33.370
it's not going to be your
Jenkins systems

00:26:33.370 --> 00:26:34.240
running your tests.

00:26:34.240 --> 00:26:37.460
So you'll get a different
dashboard.

00:26:37.460 --> 00:26:39.690
But that will work.

00:26:39.690 --> 00:26:42.960
So one thing that we think is
important here is that you

00:26:42.960 --> 00:26:46.290
don't want Jenkins to, after
your build, say hey, what's

00:26:46.290 --> 00:26:46.770
the output?

00:26:46.770 --> 00:26:49.660
I grab the output and I upload
it somewhere because Jenkins

00:26:49.660 --> 00:26:51.500
doesn't know about all the build
variants that I just

00:26:51.500 --> 00:26:52.430
talked about.

00:26:52.430 --> 00:26:56.120
So you want to have the build
system, who is aware of that,

00:26:56.120 --> 00:26:57.790
actually do the push.

00:26:57.790 --> 00:27:00.000
So that whenever you add a new
build variant, or remove one,

00:27:00.000 --> 00:27:01.490
you don't have to go
back and configure

00:27:01.490 --> 00:27:03.120
your Jenkins instance.

00:27:03.120 --> 00:27:04.355
So we created an API.

00:27:04.355 --> 00:27:06.480
And we call that test
server APIs.

00:27:06.480 --> 00:27:09.040
And it allows you to upload
an APK somewhere.

00:27:09.040 --> 00:27:11.100
It's very easy to implement.

00:27:11.100 --> 00:27:12.820
And so if you have your
own testing lab, you

00:27:12.820 --> 00:27:13.820
can implement it.

00:27:13.820 --> 00:27:15.480
If you don't have your own
testing lab, well, there are

00:27:15.480 --> 00:27:17.960
services out there
that do that.

00:27:17.960 --> 00:27:18.930
Testdroid is one.

00:27:18.930 --> 00:27:20.520
AppThwack is one.

00:27:20.520 --> 00:27:23.200
Both of them are
on the Sandbox.

00:27:23.200 --> 00:27:24.330
So you should go and
talk to them.

00:27:24.330 --> 00:27:26.800
And we're going to work with
those guys to make sure that

00:27:26.800 --> 00:27:30.820
they create a plugin, and
we integrate with them.

00:27:30.820 --> 00:27:33.300
The second scenario is, well,
what if you have [INAUDIBLE]

00:27:33.300 --> 00:27:36.030
devices or emulators, it's
generally going to be emulator

00:27:36.030 --> 00:27:38.850
that runs directly
and on demand.

00:27:38.850 --> 00:27:40.760
So here we have another API.

00:27:40.760 --> 00:27:42.280
It's very simple.

00:27:42.280 --> 00:27:43.450
We get the list of devices.

00:27:43.450 --> 00:27:45.990
And for each device, we connect
to them, which in case

00:27:45.990 --> 00:27:49.670
of emulator is really going
to be just starting them.

00:27:49.670 --> 00:27:52.620
Then we install, we get the
test, we drop them, and then

00:27:52.620 --> 00:27:54.940
we have, actually,
a local result.

00:27:54.940 --> 00:27:56.690
And there's different companies
doing that.

00:27:56.690 --> 00:27:57.770
One of them is Manimal.

00:27:57.770 --> 00:27:59.720
They're here, also,
on the Sandbox.

00:27:59.720 --> 00:28:03.010
So you can go and
talk to them.

00:28:03.010 --> 00:28:04.890
Or maybe I can show
you, actually.

00:28:04.890 --> 00:28:08.330
We worked with those guys,
and we created a plugin.

00:28:08.330 --> 00:28:11.930
So let's look at what
that looks like.

00:28:11.930 --> 00:28:14.720
So here I have a
sample project.

00:28:14.720 --> 00:28:15.870
It's very basic.

00:28:15.870 --> 00:28:19.330
I have a build.gradle here.

00:28:19.330 --> 00:28:22.050
So we applied the Android plugin
right here and then

00:28:22.050 --> 00:28:23.380
their plugin.

00:28:23.380 --> 00:28:26.200
So what that does is, basically,
their plugin, upon

00:28:26.200 --> 00:28:29.460
being installed, automatically
finds our plugin and says,

00:28:29.460 --> 00:28:31.400
hey, I'm implementing
that extension

00:28:31.400 --> 00:28:33.320
point, just go there.

00:28:33.320 --> 00:28:36.010
And then, because it's a greater
plugin, it can also

00:28:36.010 --> 00:28:39.050
have its own DSL.

00:28:39.050 --> 00:28:43.660
So here we have a custom DSL
that says, hey, I want to test

00:28:43.660 --> 00:28:44.790
on those two devices.

00:28:44.790 --> 00:28:46.400
But they have over 50
different emulator

00:28:46.400 --> 00:28:46.990
configurations.

00:28:46.990 --> 00:28:49.170
And so if you don't provide any
device, it's just going to

00:28:49.170 --> 00:28:50.720
say, I want to test
on all of them.

00:28:50.720 --> 00:28:52.830
So it's going to get the list
from their server, find the

00:28:52.830 --> 00:28:54.700
ones that are compatible with
your application, depending on

00:28:54.700 --> 00:28:56.690
your minSDK version and
things like that.

00:28:56.690 --> 00:28:59.120
Well, right now, only minSDK
version, but later, ABIs and

00:28:59.120 --> 00:29:00.270
things like that.

00:29:00.270 --> 00:29:02.680
And it will just run all
the tests in parallel.

00:29:02.680 --> 00:29:07.040
So here, for it to be easier,
we're just going to test on

00:29:07.040 --> 00:29:08.020
two different ones.

00:29:08.020 --> 00:29:10.880
So the first thing I want to
show you is, when you get the

00:29:10.880 --> 00:29:14.090
list of tasks, because
we know that there's

00:29:14.090 --> 00:29:15.520
this extension point--

00:29:18.120 --> 00:29:21.370
so we have here, automatically,
a many more

00:29:21.370 --> 00:29:23.740
instrument test method.

00:29:23.740 --> 00:29:26.440
And so, every time you have a
new service provider, we have

00:29:26.440 --> 00:29:27.610
a new task for it.

00:29:27.610 --> 00:29:28.700
But we're not going
to call it.

00:29:28.700 --> 00:29:31.720
On your build server, you
would directly do Gradle

00:29:31.720 --> 00:29:33.110
device check.

00:29:33.110 --> 00:29:35.160
I'm going to do info here.

00:29:35.160 --> 00:29:37.990
And so it's going to be build
the application, which

00:29:37.990 --> 00:29:39.470
actually doesn't need
to be built.

00:29:39.470 --> 00:29:42.320
So it's going to say,
up-to-date, up-to-date,

00:29:42.320 --> 00:29:43.060
up-to-date.

00:29:43.060 --> 00:29:44.130
And here we start building.

00:29:44.130 --> 00:29:45.920
Say, hey, connecting
to that emulator.

00:29:45.920 --> 00:29:48.880
And so my device is not starting
any emulator here.

00:29:48.880 --> 00:29:50.340
It's actually connecting
in the cloud.

00:29:50.340 --> 00:29:52.250
It's starting the
[INAUDIBLE] one.

00:29:52.250 --> 00:29:53.430
And then it's going to deploy.

00:29:53.430 --> 00:29:55.710
Hey, I have a test
that succeeded.

00:29:55.710 --> 00:29:58.090
And it's shutting it down now.

00:29:58.090 --> 00:29:59.870
And then I have another
test that succeeded.

00:29:59.870 --> 00:30:00.990
And it's done.

00:30:00.990 --> 00:30:01.360
And that's it.

00:30:01.360 --> 00:30:04.040
I just tested on two different
emulators on the cloud.

00:30:04.040 --> 00:30:07.120
It could've been 20,
50 in parallel.

00:30:07.120 --> 00:30:08.290
Super easy to do.

00:30:08.290 --> 00:30:10.627
And then you just go and you
do open build/reports/in

00:30:10.627 --> 00:30:12.780
strumentTests/device--

00:30:12.780 --> 00:30:15.030
and you have a report
per provider--

00:30:15.030 --> 00:30:16.980
index.html.

00:30:16.980 --> 00:30:20.460
And you have your test.

00:30:20.460 --> 00:30:21.800
It's tested on those
two devices.

00:30:21.800 --> 00:30:23.380
You can look per device.

00:30:23.380 --> 00:30:24.160
And it's there.

00:30:24.160 --> 00:30:26.260
Super easy to do.

00:30:26.260 --> 00:30:27.869
We really wanted to improve.

00:30:27.869 --> 00:30:35.700
[APPLAUSE]

00:30:35.700 --> 00:30:39.310
XAVIER DUCROHET: So we really
want to improve the experience

00:30:39.310 --> 00:30:40.510
of testing for Android.

00:30:40.510 --> 00:30:42.190
And there's a lot of things
that go in there.

00:30:42.190 --> 00:30:45.250
There's helping you
write tests.

00:30:45.250 --> 00:30:47.230
And we need to work on that.

00:30:47.230 --> 00:30:49.680
But running them is
a big part of it.

00:30:49.680 --> 00:30:52.390
And working with companies
like Manimal.

00:30:52.390 --> 00:30:54.240
So again, down on the show
floor, they actually have a

00:30:54.240 --> 00:30:57.010
special offer for
I/O attendees.

00:30:57.010 --> 00:30:59.950
So you should definitely
go and check them out.

00:30:59.950 --> 00:31:02.700
Integrating with third-party
services, or making it easy

00:31:02.700 --> 00:31:04.720
for you to integrate with
your own system

00:31:04.720 --> 00:31:06.330
internally is super important.

00:31:06.330 --> 00:31:12.070
And we want to make sure that
is super easy for you to use

00:31:12.070 --> 00:31:14.150
All right, the last thing I
want to talk about is the

00:31:14.150 --> 00:31:16.080
built environment.

00:31:16.080 --> 00:31:21.990
So we know that, in the past,
we've regularly updated the

00:31:21.990 --> 00:31:24.870
tools and somehow broke
your build.

00:31:24.870 --> 00:31:27.160
You get a new version of ADT,
and nothing compiles anymore.

00:31:27.160 --> 00:31:29.370
And it's a big problem.

00:31:29.370 --> 00:31:30.190
And we want to fix that.

00:31:30.190 --> 00:31:32.490
We want to make sure that this
doesn't happen again.

00:31:32.490 --> 00:31:34.500
And Gradle is really going
to help us do that.

00:31:34.500 --> 00:31:35.790
There's four key
points to that.

00:31:35.790 --> 00:31:38.900
First, well, you're in charge
of the Gradle version.

00:31:38.900 --> 00:31:41.800
And you were already in charge
of the Ant version somewhat,

00:31:41.800 --> 00:31:43.740
but Gradle actually--

00:31:43.740 --> 00:31:47.250
they increased, they added new
features so quickly compared

00:31:47.250 --> 00:31:50.030
to Ant that it's good that
you're in charge.

00:31:50.030 --> 00:31:51.830
And they have this feature
called the Wrapper that makes

00:31:51.830 --> 00:31:54.790
it super easy for you to really
control the fact that

00:31:54.790 --> 00:31:56.970
every developer, everybody build
server, has the same

00:31:56.970 --> 00:31:57.720
version of Gradle.

00:31:57.720 --> 00:31:59.690
It's a really sleek tool.

00:31:59.690 --> 00:32:01.620
Really check it out.

00:32:01.620 --> 00:32:04.550
Second point is, you're
in charge of the

00:32:04.550 --> 00:32:06.760
version of the plugin.

00:32:06.760 --> 00:32:09.680
So you saw in the DSL right at
the beginning how I say, hey,

00:32:09.680 --> 00:32:12.010
get the plugin from Maven
Central, and here's it is.

00:32:12.010 --> 00:32:14.850
Well, part of the artifact
address is the version number.

00:32:14.850 --> 00:32:16.790
When we update a new version,
we're not going to remove the

00:32:16.790 --> 00:32:16.880
old version.

00:32:16.880 --> 00:32:19.360
So you can always stay
on an older version.

00:32:19.360 --> 00:32:23.212
And it's up to you to switch
when you're ready to switch.

00:32:23.212 --> 00:32:26.070
The second point is that
probably, that I didn't talk

00:32:26.070 --> 00:32:27.760
about also at the beginning.

00:32:27.760 --> 00:32:31.180
So the plugin uses some tools,
like APT to compile the

00:32:31.180 --> 00:32:34.250
resources, DX to compile the
bytecode into Dalvik.

00:32:34.250 --> 00:32:37.370
And it used to be in the SDK
under a component called

00:32:37.370 --> 00:32:38.010
Platform Tools.

00:32:38.010 --> 00:32:39.980
And there was only one
version of it.

00:32:39.980 --> 00:32:42.030
And sometimes, when you update
the tools, it forces you to

00:32:42.030 --> 00:32:43.950
update the platform tool, and
so, suddenly, hey, it's

00:32:43.950 --> 00:32:45.620
updated under you, and you
don't have a choice.

00:32:45.620 --> 00:32:48.350
So here, we moved that out
of the SDK platform tool

00:32:48.350 --> 00:32:50.220
component, and we created
a new component

00:32:50.220 --> 00:32:51.070
called Build Tools.

00:32:51.070 --> 00:32:53.260
And the big point about Build
Tools is it that you can have

00:32:53.260 --> 00:32:55.080
many of them in the SDK.

00:32:55.080 --> 00:32:57.186
So imagine a case
where you have--

00:32:57.186 --> 00:32:59.170
[APPLAUSE]

00:32:59.170 --> 00:33:01.650
XAVIER DUCROHET: So imagine a
case where you have an SDK.

00:33:01.650 --> 00:33:03.450
You have an old project that
you don't want to migrate,

00:33:03.450 --> 00:33:04.550
because it's fine
the way it is.

00:33:04.550 --> 00:33:07.170
It's using an old plugin and
an version of Build Tools.

00:33:07.170 --> 00:33:08.010
It's not a problem.

00:33:08.010 --> 00:33:09.010
You want to start
a new project.

00:33:09.010 --> 00:33:09.790
You want to start fresh.

00:33:09.790 --> 00:33:11.450
You use the new version
of the plugin.

00:33:11.450 --> 00:33:13.040
You use a new version of Build
Tools, and you have two

00:33:13.040 --> 00:33:15.710
different projects using two
different tool chains from a

00:33:15.710 --> 00:33:17.410
single SDK.

00:33:17.410 --> 00:33:22.490
And then finally, the fourth
point is that, well, the IDE I

00:33:22.490 --> 00:33:24.850
mentioned that when we talked
about Studio on Wednesday.

00:33:24.850 --> 00:33:26.490
The IDE doesn't do
a build anymore.

00:33:26.490 --> 00:33:28.200
You import greater projects.

00:33:28.200 --> 00:33:31.350
You delegate to greater project
whenever you do build.

00:33:31.350 --> 00:33:34.410
So before, when you updated the
ADT, you would get both,

00:33:34.410 --> 00:33:37.000
inside the same plugin,
a builder and editors.

00:33:37.000 --> 00:33:38.930
Here, Studio is all
about editing, and

00:33:38.930 --> 00:33:40.250
debugging, and profiling.

00:33:40.250 --> 00:33:41.700
It's not about building
anymore.

00:33:41.700 --> 00:33:45.700
So feel free, every time we
release a new version of

00:33:45.700 --> 00:33:49.020
Studio or of ADT, when we
integrate Gradle into ADT,

00:33:49.020 --> 00:33:52.920
which is coming, feel free
to get the new version.

00:33:52.920 --> 00:33:56.440
Because Gradle, it's only when
you change those values in

00:33:56.440 --> 00:33:59.170
your build script that you will
force yourself to switch

00:33:59.170 --> 00:34:04.144
to a new version of the build.

00:34:04.144 --> 00:34:10.010
All right, so this is a very
short introduction to the

00:34:10.010 --> 00:34:11.440
build system.

00:34:11.440 --> 00:34:13.435
There's a lot of information
online at tools.android.com, a

00:34:13.435 --> 00:34:15.940
lot of documentation, and
more details about

00:34:15.940 --> 00:34:17.530
configuring the build.

00:34:17.530 --> 00:34:22.370
Like I mentioned, the DSL for
the library is very different.

00:34:22.370 --> 00:34:23.550
So you should check it out.

00:34:23.550 --> 00:34:24.670
We need your feedback, right?

00:34:24.670 --> 00:34:27.580
We want to make sure that it's
as flexible as it needs to be

00:34:27.580 --> 00:34:28.770
for all of you.

00:34:28.770 --> 00:34:30.900
I think we already have a
lot of customization.

00:34:30.900 --> 00:34:32.889
But I'm sure there are some
things that we're missing.

00:34:32.889 --> 00:34:35.010
And so give us feedback,
try it.

00:34:35.010 --> 00:34:37.000
Especially with Studio, anyway,
you have to try it.

00:34:37.000 --> 00:34:39.800
So that's why we're
very happy.

00:34:39.800 --> 00:34:42.730
And just give us feedback,
FindBug, and we'll do whatever

00:34:42.730 --> 00:34:44.440
we can to improve things.

00:34:44.440 --> 00:34:47.029
So actually, it looks like I
do have time for questions.

00:34:49.950 --> 00:34:52.770
[APPLAUSE]

00:34:52.770 --> 00:34:55.545
XAVIER DUCROHET: Thank you.

00:34:55.545 --> 00:34:59.870
So I will be after anyway in the
Sandbox upstairs to answer

00:34:59.870 --> 00:35:00.650
whatever questions.

00:35:00.650 --> 00:35:02.410
But we do have time,
so I guess we

00:35:02.410 --> 00:35:04.730
can take some questions.

00:35:04.730 --> 00:35:09.010
AUDIENCE: So you mentioned that
I believe you had compile

00:35:09.010 --> 00:35:12.650
and release dependencies or
runtime dependencies-- you

00:35:12.650 --> 00:35:15.760
guys have different
names for it.

00:35:15.760 --> 00:35:18.871
How is android.jar treated?

00:35:18.871 --> 00:35:20.190
XAVIER DUCROHET: I'm
sorry, android.jar?

00:35:20.190 --> 00:35:21.830
AUDIENCE: Yeah, because it's
like a build-only dependency.

00:35:21.830 --> 00:35:22.940
XAVIER DUCROHET: So it's
done automatically.

00:35:22.940 --> 00:35:24.330
You don't have to do it.

00:35:24.330 --> 00:35:26.380
In your DSL, at the beginning,
when you say compile SDK

00:35:26.380 --> 00:35:29.440
version 17, it just picks
the SDK version from 17.

00:35:29.440 --> 00:35:32.440
AUDIENCE: So can you add
a hook for that?

00:35:32.440 --> 00:35:35.570
Is it possible for you guys
to add a hook for that?

00:35:35.570 --> 00:35:36.220
XAVIER DUCROHET: I'm
sorry, do what?

00:35:36.220 --> 00:35:38.980
AUDIENCE: Well, some of us are
compiling custom versions of

00:35:38.980 --> 00:35:40.453
android.jar.

00:35:40.453 --> 00:35:42.868
XAVIER DUCROHET: Umm--

00:35:42.868 --> 00:35:45.780
well, you probably
shouldn't be.

00:35:45.780 --> 00:35:47.130
[LAUGHTER]

00:35:47.130 --> 00:35:48.940
AUDIENCE: Some of us are.

00:35:48.940 --> 00:35:50.460
XAVIER DUCROHET: Yeah.

00:35:50.460 --> 00:35:53.350
And we'll have to figure
something out, I guess.

00:35:53.350 --> 00:35:55.770
AUDIENCE: Thanks.

00:35:55.770 --> 00:35:56.790
AUDIENCE: First, thank you.

00:35:56.790 --> 00:35:59.040
It's a lot of stuff.

00:35:59.040 --> 00:36:00.200
I have two questions.

00:36:00.200 --> 00:36:02.920
One is about library
projects dot AAR.

00:36:02.920 --> 00:36:05.720
Do they each have their own
R.java or does the whole lab

00:36:05.720 --> 00:36:07.590
have its own R.java?

00:36:07.590 --> 00:36:09.605
XAVIER DUCROHET: So AAR has--

00:36:12.245 --> 00:36:13.620
I'm sorry.

00:36:13.620 --> 00:36:14.600
Can you repeat?

00:36:14.600 --> 00:36:16.940
AUDIENCE: So can library
projects

00:36:16.940 --> 00:36:18.336
have their own resources?

00:36:18.336 --> 00:36:20.510
XAVIER DUCROHET: Yeah,
resources, assets.

00:36:20.510 --> 00:36:21.926
So the AAR is a zip file.

00:36:21.926 --> 00:36:22.880
In it, you have classes.jar.

00:36:22.880 --> 00:36:24.070
That's your compile classes.

00:36:24.070 --> 00:36:26.560
It has your manifest, in case
you have activities,

00:36:26.560 --> 00:36:28.070
permissions, and things
like that.

00:36:28.070 --> 00:36:30.910
It has resource folder, assets
folder, it has a ProGuard

00:36:30.910 --> 00:36:33.400
file, in case you have one.

00:36:33.400 --> 00:36:37.170
Ultimately, it will have JNI
libraries if you have them,

00:36:37.170 --> 00:36:39.730
[INAUDIBLE], whatever.

00:36:39.730 --> 00:36:40.280
AUDIENCE: OK, thanks you.

00:36:40.280 --> 00:36:43.050
And the second question is
about NDK integration.

00:36:43.050 --> 00:36:43.420
XAVIER DUCROHET: Yeah.

00:36:43.420 --> 00:36:44.740
AUDIENCE: You had a couple
things there

00:36:44.740 --> 00:36:49.880
about x86 and JNI.

00:36:49.880 --> 00:36:52.920
XAVIER DUCROHET: So I do mention
the whole x86 and ARM,

00:36:52.920 --> 00:36:54.540
and that's the design of it.

00:36:54.540 --> 00:36:56.320
But we don't support
the NDK right now.

00:36:56.320 --> 00:36:58.710
So that's coming very
soon though.

00:36:58.710 --> 00:37:00.460
So you'll be able to
build directly.

00:37:00.460 --> 00:37:02.960
Gradle will call
out to the NDK.

00:37:02.960 --> 00:37:06.710
It will have a way of
configuring in a build type

00:37:06.710 --> 00:37:09.360
which ABI you want to use,
either all three if you want

00:37:09.360 --> 00:37:11.190
to do a fat package
or just one.

00:37:11.190 --> 00:37:12.970
And then it will call out to
the NDK saying, hey, please

00:37:12.970 --> 00:37:15.430
build the ARM version and put
the result here for that build

00:37:15.430 --> 00:37:18.272
type, build it for another
ABI, and put it there for

00:37:18.272 --> 00:37:19.110
another build type.

00:37:19.110 --> 00:37:21.120
And so that's how we're going
to do the filtering.

00:37:21.120 --> 00:37:23.370
AUDIENCE: And will that be
integrated into Android Studio

00:37:23.370 --> 00:37:24.720
also, the NDK building?

00:37:24.720 --> 00:37:26.980
XAVIER DUCROHET: Yes, so it
will be part of Gradle.

00:37:26.980 --> 00:37:29.350
So whenever you build with
Gradle, if you say, hey, I

00:37:29.350 --> 00:37:32.940
want to build native stuff,
it will build it.

00:37:32.940 --> 00:37:36.880
And Studio will technically
not care about it.

00:37:36.880 --> 00:37:39.900
At some point, we'll have to add
editing features for them.

00:37:39.900 --> 00:37:41.300
That's going to take longer.

00:37:41.300 --> 00:37:43.760
But at least you would be able
to edit your files and just to

00:37:43.760 --> 00:37:44.330
make it work.

00:37:44.330 --> 00:37:45.760
AUDIENCE: So where can
we see details of

00:37:45.760 --> 00:37:48.260
what's coming for NDK?

00:37:48.260 --> 00:37:49.575
XAVIER DUCROHET: We don't
really have any roadmap

00:37:49.575 --> 00:37:50.800
planned at this time.

00:37:50.800 --> 00:37:52.450
AUDIENCE: OK.

00:37:52.450 --> 00:37:54.020
XAVIER DUCROHET: I mean, we do
have some plans, but we don't

00:37:54.020 --> 00:37:57.550
have anything written down.

00:37:57.550 --> 00:37:59.570
AUDIENCE: Hi, my name is Mark.

00:37:59.570 --> 00:38:03.230
I would like to know that, OK,
so now we have many folders,

00:38:03.230 --> 00:38:07.550
like, SRC, JAVA, JNI, RRS,
asset, and so on.

00:38:07.550 --> 00:38:09.970
And the merging process
of these

00:38:09.970 --> 00:38:11.335
folders, are they different?

00:38:11.335 --> 00:38:15.070
Or what I really want to know,
can we have dependencies and

00:38:15.070 --> 00:38:17.935
assets, so if we have library
processes with the assets in

00:38:17.935 --> 00:38:21.300
it-- right now it's not built
into the final APK--

00:38:21.300 --> 00:38:24.630
is that true for the new one,
for the Gradle build?

00:38:24.630 --> 00:38:26.530
XAVIER DUCROHET: Yeah, so if
you have assets in your

00:38:26.530 --> 00:38:28.650
library that will get packed
into your package.

00:38:28.650 --> 00:38:31.470
You can have assets,
per flavor.

00:38:31.470 --> 00:38:35.470
Every flavor, every build type,
has its own JAVA code,

00:38:35.470 --> 00:38:38.970
its own manifest, it's own
resources, its own assets.

00:38:38.970 --> 00:38:41.040
And depending on which flavor
you're building, it just picks

00:38:41.040 --> 00:38:44.110
up and merge all of that
together automatically.

00:38:44.110 --> 00:38:46.520
And libraries are picked up
automatically and merged.

00:38:46.520 --> 00:38:47.210
And it's--

00:38:47.210 --> 00:38:50.444
AUDIENCE: Thanks, I waited
a long time for that.

00:38:50.444 --> 00:38:51.260
XAVIER DUCROHET: All right.

00:38:51.260 --> 00:38:54.320
AUDIENCE: So since you're not
supporting NDK, how about Ant?

00:38:54.320 --> 00:38:57.100
Is that still going to be
supported for the time being?

00:38:57.100 --> 00:39:02.440
XAVIER DUCROHET: Ant is going
to be, I guess, deprecated.

00:39:02.440 --> 00:39:05.100
I would recommend moving
to Gradle as soon

00:39:05.100 --> 00:39:05.930
as you're able to.

00:39:05.930 --> 00:39:06.870
If you're missing features--

00:39:06.870 --> 00:39:08.526
AUDIENCE: You're not
supporting NDK.

00:39:08.526 --> 00:39:11.000
XAVIER DUCROHET: Oh support
for the NDK?

00:39:11.000 --> 00:39:13.460
AUDIENCE: You just said that
you're not supporting NDK at

00:39:13.460 --> 00:39:14.290
this moment.

00:39:14.290 --> 00:39:17.210
So the only way to build it--
well, not the only way, but--

00:39:17.210 --> 00:39:19.530
XAVIER DUCROHET: Well, right
now, the NDK doesn't build

00:39:19.530 --> 00:39:20.620
with Ant either.

00:39:20.620 --> 00:39:23.090
It just makes files.

00:39:23.090 --> 00:39:26.380
AUDIENCE: Yes, but it's
easy to integrate.

00:39:26.380 --> 00:39:28.727
XAVIER DUCROHET: Yes, but
that's not the future.

00:39:28.727 --> 00:39:31.410
[LAUGHTER]

00:39:31.410 --> 00:39:33.380
XAVIER DUCROHET: It's like, I
mean, we're going to keep the

00:39:33.380 --> 00:39:35.950
make files inside
the NDK anyway.

00:39:35.950 --> 00:39:37.740
So you can call it manually
if you want.

00:39:37.740 --> 00:39:40.710
It's like, the problem with the
Ant stuff is that it's a

00:39:40.710 --> 00:39:43.050
mix of, I have some scripting
in the XML, we have some

00:39:43.050 --> 00:39:45.750
custom code, because whenever
we have some really complex

00:39:45.750 --> 00:39:48.990
logic, like combining all of
those sourceSet, assets, res,

00:39:48.990 --> 00:39:52.070
all of that, you can
do that in XML.

00:39:52.070 --> 00:39:53.370
So we have custom tasks.

00:39:53.370 --> 00:39:57.880
I reimplemented quick if/else
statements in the custom task

00:39:57.880 --> 00:39:59.340
to be able to use
it in my XML.

00:39:59.340 --> 00:40:00.360
But it's like, it's a mix.

00:40:00.360 --> 00:40:03.310
And we pass a lot of things to
the custom task, and then back

00:40:03.310 --> 00:40:05.580
to the XML, and back to another
custom task, it's just

00:40:05.580 --> 00:40:07.390
a fucking mess.

00:40:07.390 --> 00:40:09.190
It's just, we can't
maintain that.

00:40:09.190 --> 00:40:13.040
And I'm happy to let it be
whatever it is when it was

00:40:13.040 --> 00:40:15.570
switched to Gradle, but we're
not going to improve it.

00:40:15.570 --> 00:40:17.205
It's not going to work
from an IDE.

00:40:22.470 --> 00:40:23.810
It's deprecated.

00:40:23.810 --> 00:40:25.720
It will be deprecated.

00:40:25.720 --> 00:40:26.930
But I mean, it's open source.

00:40:26.930 --> 00:40:29.730
Take it, make sure that you have
a good version, if you

00:40:29.730 --> 00:40:31.160
really want to maintain it.

00:40:31.160 --> 00:40:33.560
But we're not going to
keep maintaining it.

00:40:33.560 --> 00:40:35.430
The goal of this build system
is to have a single one that

00:40:35.430 --> 00:40:36.160
works everywhere.

00:40:36.160 --> 00:40:39.175
So I'm not going to keep
maintaining also another one--

00:40:39.175 --> 00:40:40.530
although right now I am.

00:40:40.530 --> 00:40:43.791
But when we switch to 1.0,
we're not anymore.

00:40:43.791 --> 00:40:44.620
AUDIENCE: Hi [INAUDIBLE].

00:40:44.620 --> 00:40:45.840
My name's William.

00:40:45.840 --> 00:40:49.370
I've been using Maven to
build up until now.

00:40:49.370 --> 00:40:51.430
So it looks like I've got to
change the way I'm thinking

00:40:51.430 --> 00:40:52.350
about things.

00:40:52.350 --> 00:40:55.530
One of things that Maven does
really well is you can go and

00:40:55.530 --> 00:40:59.290
release your APK at the end.

00:40:59.290 --> 00:41:01.730
And it handles all of the
versioning and makes sure

00:41:01.730 --> 00:41:02.580
everything works all right.

00:41:02.580 --> 00:41:06.480
How's that going to
work with Gradle?

00:41:06.480 --> 00:41:08.735
XAVIER DUCROHET: Wait, sorry,
can you repeat that?

00:41:11.950 --> 00:41:14.760
AUDIENCE: Gradle doesn't seem to
have the release mechanism

00:41:14.760 --> 00:41:18.420
that Maven does where, when you
want to go and release a

00:41:18.420 --> 00:41:21.440
version of your APK, it handles
the versioning,

00:41:21.440 --> 00:41:25.640
interacts with your source
control mechanism, does all

00:41:25.640 --> 00:41:28.470
the build for you, updates
source control, publishes to

00:41:28.470 --> 00:41:31.730
your artifcat repositories,
et cetera.

00:41:31.730 --> 00:41:33.600
XAVIER DUCROHET: Yeah, that's
probably more like a question

00:41:33.600 --> 00:41:36.510
for Gradle itself
than our plugin.

00:41:36.510 --> 00:41:39.720
You know Gradle, where they
have a Sandbox, and when I

00:41:39.720 --> 00:41:42.960
take questions, there will be
people from Gradleware.

00:41:42.960 --> 00:41:44.540
Because it's more
like the whole

00:41:44.540 --> 00:41:46.570
workflow behind releasing.

00:41:46.570 --> 00:41:50.972
And Gradle I'm sure
supports that.

00:41:50.972 --> 00:41:52.840
We'll do that upstairs.

00:41:52.840 --> 00:41:54.040
We'll take that question
upstairs.

00:41:54.040 --> 00:41:56.910
AUDIENCE: All right, the other
one is, APK libs, which are

00:41:56.910 --> 00:41:58.190
pretty common imports now--

00:41:58.190 --> 00:42:00.160
XAVIER DUCROHET: Yes, so the
Maven plugin will switch to

00:42:00.160 --> 00:42:01.350
AAR format.

00:42:01.350 --> 00:42:02.860
I'm looking to supporting
APK lib.

00:42:02.860 --> 00:42:05.590
But I'm not sure if that's
going to happen or not.

00:42:05.590 --> 00:42:07.160
But they're switching to AAR.

00:42:07.160 --> 00:42:08.730
And I know some libraries
are going to

00:42:08.730 --> 00:42:09.630
publish to AAR already.

00:42:09.630 --> 00:42:12.230
So I talk to Jack
[? Wharton ?].

00:42:12.230 --> 00:42:12.970
[INAUDIBLE]

00:42:12.970 --> 00:42:15.130
at some point are going
to distribute AAR.

00:42:15.130 --> 00:42:16.390
So you'd be able to use that.

00:42:16.390 --> 00:42:21.710
AUDIENCE: So we'll be able to,
for our libraries we intend on

00:42:21.710 --> 00:42:24.670
publishing, we'll be able to
create an AAR as an output?

00:42:24.670 --> 00:42:24.950
XAVIER DUCROHET: Yeah.

00:42:24.950 --> 00:42:26.380
AUDIENCE: All right,
cool, thanks.

00:42:26.380 --> 00:42:27.870
XAVIER DUCROHET: All right,
thank you, so I'll be upstairs

00:42:27.870 --> 00:42:29.950
if you have more questions,
feel free to

00:42:29.950 --> 00:42:31.700
come and talk to me.

00:42:31.700 --> 00:42:34.890
[APPLAUSE]

