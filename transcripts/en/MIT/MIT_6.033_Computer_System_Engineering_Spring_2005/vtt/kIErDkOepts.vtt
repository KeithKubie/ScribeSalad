WEBVTT
Kind: captions
Language: en

00:00:16.370 --> 00:00:22.150
So just a brief
announcement, on this Friday

00:00:22.150 --> 00:00:24.200
you guys have a
writing tutorial.

00:00:24.200 --> 00:00:25.230
It's at 2 p.m.

00:00:25.230 --> 00:00:27.180
there's only one tutorial
this week at 2 p.m.,

00:00:27.180 --> 00:00:28.596
and it's going to
be in this room.

00:00:28.596 --> 00:00:30.080
So make sure you come.

00:00:30.080 --> 00:00:34.320
We're going to talk about
issues involved with preparing

00:00:34.320 --> 00:00:35.620
and presenting your DP2.

00:00:35.620 --> 00:00:40.220
And it's really important that
you come to pay attention.

00:00:40.220 --> 00:00:43.940
So today we're going to continue
our discussion of networking

00:00:43.940 --> 00:00:45.090
and network layering.

00:00:45.090 --> 00:00:48.710
If you remember
last time, we talked

00:00:48.710 --> 00:00:54.340
about the three layers that are
in any typical network stack.

00:00:54.340 --> 00:00:57.870
And these three layers we said
were the end-to-end layer,

00:00:57.870 --> 00:01:03.790
the network layer,
and the link layer.

00:01:06.860 --> 00:01:10.539
And we went to the example of
how these three layers interact

00:01:10.539 --> 00:01:12.080
with each other as,
say, a message is

00:01:12.080 --> 00:01:14.280
sent through a network.

00:01:14.280 --> 00:01:20.890
So, on a typical sender node,
we said there are these three

00:01:20.890 --> 00:01:22.148
layers --

00:01:28.934 --> 00:01:30.600
And there might also
be a receiver node.

00:01:34.730 --> 00:01:36.510
And then there could be several.

00:01:36.510 --> 00:01:40.780
Each time a message is
sent through the network,

00:01:40.780 --> 00:01:45.270
it might pass through any number
of intermediate gateway nodes,

00:01:45.270 --> 00:01:47.840
or intermediate switches.

00:01:47.840 --> 00:01:50.560
So when a packet
gets sent in, it

00:01:50.560 --> 00:01:52.760
gets sent through
the end-to-end layer

00:01:52.760 --> 00:01:55.850
in through the network layer,
down into the link layer.

00:01:55.850 --> 00:01:57.360
The link layer
chooses the next link

00:01:57.360 --> 00:01:59.960
to send the packet
out over, since it's

00:01:59.960 --> 00:02:01.280
one of these switches.

00:02:01.280 --> 00:02:05.880
The switch looks at the packet,
sends it up to its own network

00:02:05.880 --> 00:02:09.419
layer, which is in charge
of determining the next link

00:02:09.419 --> 00:02:12.060
that the message will take.

00:02:12.060 --> 00:02:15.280
On the next hop, the message
goes up to the link layer.

00:02:15.280 --> 00:02:18.580
The link layer determines
yet another link

00:02:18.580 --> 00:02:19.820
for the message to take.

00:02:19.820 --> 00:02:22.870
The network layer determines
yet another message, link,

00:02:22.870 --> 00:02:23.870
for the message to take.

00:02:23.870 --> 00:02:25.710
And then finally,
the message reaches

00:02:25.710 --> 00:02:29.510
the receiver or the message
propagates up through the link

00:02:29.510 --> 00:02:31.220
layer into the network
layer, and then

00:02:31.220 --> 00:02:34.120
finally to the end-to-end
layer, and out to the user.

00:02:34.120 --> 00:02:36.900
So we talked a
little bit last time

00:02:36.900 --> 00:02:39.580
about various things that
happen in this architecture.

00:02:39.580 --> 00:02:46.060
We said that there's this
process of encapsulation

00:02:46.060 --> 00:02:49.090
that happens at each
step along the way.

00:02:49.090 --> 00:02:52.340
So the end-to-end layer
may attach headers

00:02:52.340 --> 00:02:55.370
on to the packet, a header
or trailer onto the packet;

00:02:55.370 --> 00:02:57.470
the network layer may
attach a header and trailer,

00:02:57.470 --> 00:02:59.610
and the link layer may
attach a header and trailer.

00:02:59.610 --> 00:03:01.568
But at no point does any
layer look at the data

00:03:01.568 --> 00:03:03.520
that a higher layer sent.

00:03:03.520 --> 00:03:08.330
And you also notice that in
this architecture, what we've

00:03:08.330 --> 00:03:10.580
shown here is that only the
link layer and the network

00:03:10.580 --> 00:03:13.340
layer of the switches that
are forwarding packets

00:03:13.340 --> 00:03:16.310
are actually
processing the packets.

00:03:16.310 --> 00:03:18.431
So the end-to-end
layer, by definition,

00:03:18.431 --> 00:03:20.430
is not involved in the
forwarding of the packet.

00:03:20.430 --> 00:03:22.290
The end-to-end layer
is only involved

00:03:22.290 --> 00:03:25.794
when one of the endpoints of
the communication is involved.

00:03:25.794 --> 00:03:27.460
So what we're going
to talk about today,

00:03:27.460 --> 00:03:29.501
we're going to finish very
briefly our discussion

00:03:29.501 --> 00:03:30.400
of the link layer.

00:03:30.400 --> 00:03:32.600
And then we're going to
turn and focused mostly

00:03:32.600 --> 00:03:33.810
on the networking layer.

00:03:36.540 --> 00:03:40.620
So do you remember last time?

00:03:40.620 --> 00:03:42.750
We got as far as saying
that the link layer is

00:03:42.750 --> 00:03:45.940
in charge of a number of
sort of important issues

00:03:45.940 --> 00:03:49.400
with the transmission of data
across one link of the network.

00:03:49.400 --> 00:03:51.640
And we talked for awhile
at the end of class

00:03:51.640 --> 00:03:56.030
last time about this
analog, to digital,

00:03:56.030 --> 00:04:00.630
sorry, got that backwards
digital to analog

00:04:00.630 --> 00:04:01.780
to digital conversion.

00:04:01.780 --> 00:04:03.729
We are going to talk
about the other issue,

00:04:03.729 --> 00:04:05.270
though, that I said
we needed to talk

00:04:05.270 --> 00:04:07.190
about in the context
of the network layer

00:04:07.190 --> 00:04:11.400
or the link layer is
the issue of framing.

00:04:11.400 --> 00:04:14.060
So the idea with framing is when
you're sending a message out

00:04:14.060 --> 00:04:17.070
over a network link, the
receiver on the other end

00:04:17.070 --> 00:04:18.850
needs to have some
way of knowing

00:04:18.850 --> 00:04:21.850
that a packet is starting or
a packet is ending, right?

00:04:21.850 --> 00:04:23.830
So as we call these
packets when they

00:04:23.830 --> 00:04:25.620
are at the link layer, frames.

00:04:25.620 --> 00:04:28.970
So, the issue with framing is to
identify the sort of beginning

00:04:28.970 --> 00:04:31.440
and end of every
one of these frames

00:04:31.440 --> 00:04:33.010
as it transmits
over the network.

00:04:33.010 --> 00:04:35.660
And there is a sort
of fairly obvious way

00:04:35.660 --> 00:04:38.374
to do this is, well,
attach some special symbol,

00:04:38.374 --> 00:04:40.040
but some special
symbol at the beginning

00:04:40.040 --> 00:04:41.040
and end of every packet.

00:04:43.880 --> 00:04:45.880
So, for example, if we
were looking at Ethernet,

00:04:45.880 --> 00:04:48.270
the payload of an
Ethernet packet

00:04:48.270 --> 00:04:51.280
might contain the
destination address,

00:04:51.280 --> 00:04:53.380
the source address, the type.

00:04:53.380 --> 00:04:55.570
So we'll talk more about
what the type field means

00:04:55.570 --> 00:04:59.830
in a minute, the data, and
some checksum information that

00:04:59.830 --> 00:05:03.040
can be used to detect errors.

00:05:03.040 --> 00:05:06.206
And the preamble
is a special code

00:05:06.206 --> 00:05:07.580
that is attached
to the beginning

00:05:07.580 --> 00:05:09.070
of every one of these messages.

00:05:09.070 --> 00:05:11.880
And this is used to make the
Manchester encoding, which

00:05:11.880 --> 00:05:15.410
you remember we talked
about last class.

00:05:15.410 --> 00:05:18.130
This is used, sorry,
to allow the phase lock

00:05:18.130 --> 00:05:20.790
loop to lock into the
message, which we talked about

00:05:20.790 --> 00:05:22.080
at last class.

00:05:22.080 --> 00:05:24.100
And it might be, in
the case of Ethernet,

00:05:24.100 --> 00:05:27.050
it's a well-defined sequence:
one, zero, one, zero, one,

00:05:27.050 --> 00:05:28.076
zero, one, zero.

00:05:28.076 --> 00:05:29.450
But remember that
with Manchester

00:05:29.450 --> 00:05:32.740
encoding that the data
that's actually transmitted

00:05:32.740 --> 00:05:34.790
looks a little bit different.

00:05:34.790 --> 00:05:36.430
And then following
the preamble, there

00:05:36.430 --> 00:05:38.270
is this start of frame symbol.

00:05:38.270 --> 00:05:39.820
And then at the
end of the message,

00:05:39.820 --> 00:05:42.290
there's this end symbol.

00:05:42.290 --> 00:05:44.260
So, one thing we might
be concerned about

00:05:44.260 --> 00:05:47.050
is, say, for example
what if the network

00:05:47.050 --> 00:05:48.820
layer tries to
send a message that

00:05:48.820 --> 00:05:51.110
contains the end symbol in it?

00:05:51.110 --> 00:05:57.020
that would be a problem,
right, because then the end

00:05:57.020 --> 00:05:59.840
layer would have inadvertently
terminated the message,

00:05:59.840 --> 00:06:02.090
even though this wasn't
really the end of the message,

00:06:02.090 --> 00:06:03.590
this is just something
that happened

00:06:03.590 --> 00:06:06.930
to be the same code as whatever
the link layer had chosen

00:06:06.930 --> 00:06:09.580
for its end of code symbol.

00:06:09.580 --> 00:06:12.186
And the reason that this
is a concern is, remember,

00:06:12.186 --> 00:06:13.810
we don't want the
network layer to have

00:06:13.810 --> 00:06:16.750
to understand lots of details
about how the link layer

00:06:16.750 --> 00:06:18.140
operates underneath it, right?

00:06:18.140 --> 00:06:20.690
The network layer shouldn't
have to make any assumptions

00:06:20.690 --> 00:06:23.300
about what our valid
symbols for it to transmit,

00:06:23.300 --> 00:06:26.090
and what are invalid
symbols for it to transmit.

00:06:26.090 --> 00:06:27.820
So the way that we're
going to solve this

00:06:27.820 --> 00:06:29.300
is through one of
two techniques.

00:06:29.300 --> 00:06:33.550
One: so the first technique
that will talk about

00:06:33.550 --> 00:06:36.290
for a moment is this
idea of bit stuffing.

00:06:39.942 --> 00:06:41.150
I'll get to that in a minute.

00:06:41.150 --> 00:06:42.860
Another simple thing
that we could do

00:06:42.860 --> 00:06:46.800
would be to simply use a
code that can't possibly

00:06:46.800 --> 00:06:49.450
be generated by, say for
example, the Manchester

00:06:49.450 --> 00:06:50.430
encoding scheme.

00:06:50.430 --> 00:06:53.940
So if the network layer sends
a message like one, one, one,

00:06:53.940 --> 00:06:57.080
one, the link layer is
going to convert that

00:06:57.080 --> 00:06:59.070
into some sequence
of ones and zeros

00:06:59.070 --> 00:07:00.700
once it applies
Manchester coding.

00:07:00.700 --> 00:07:03.530
So if the link layer
on the receiver

00:07:03.530 --> 00:07:05.960
sees a message like
one, one, one, one, one,

00:07:05.960 --> 00:07:08.820
that can't possibly
be a valid code.

00:07:08.820 --> 00:07:12.930
That can't possibly
be a valid message

00:07:12.930 --> 00:07:15.100
that could have been generated
by the network layer.

00:07:15.100 --> 00:07:17.766
Only the link layer can actually
send that sequence of bits out.

00:07:17.766 --> 00:07:20.840
So we could tell that would
be a terminating symbol.

00:07:20.840 --> 00:07:23.840
Another simple way, though,
to send one of these end codes

00:07:23.840 --> 00:07:26.030
is using this technique
called bit stuffing.

00:07:26.030 --> 00:07:27.655
And the idea is pretty
simple, and it's

00:07:27.655 --> 00:07:32.580
kind of a neat technique that
can be used in general when

00:07:32.580 --> 00:07:35.830
you have to do this kind
of encoding a lower layer.

00:07:35.830 --> 00:07:37.470
So the idea is,
suppose we set our end

00:07:37.470 --> 00:07:43.270
code was equal to some bit
string like one, one, one, one.

00:07:43.270 --> 00:07:46.900
And, the solution in bit
stuffing is very simple.

00:07:46.900 --> 00:07:50.580
What it says is that when you
receive a sequence of bytes

00:07:50.580 --> 00:07:54.100
or sequence of bits from the
network layer at the link

00:07:54.100 --> 00:07:57.510
layer, it says that you should
convert any sequence of bytes

00:07:57.510 --> 00:08:00.300
that look like one, one,
one, three ones in a row,

00:08:00.300 --> 00:08:03.420
into three ones in a
row followed by a zero.

00:08:03.420 --> 00:08:07.020
So this happens at the center.

00:08:07.020 --> 00:08:10.560
And then the receiver
just reverses this,

00:08:10.560 --> 00:08:14.310
says any sequence of one,
one, one, zero, gets converted

00:08:14.310 --> 00:08:15.680
to one, one, one, one.

00:08:15.680 --> 00:08:17.790
OK, so you could
see that this means,

00:08:17.790 --> 00:08:19.980
and this transform
is only applied

00:08:19.980 --> 00:08:22.250
to the payload of
data packets that it's

00:08:22.250 --> 00:08:24.930
coming from the network layer
down into the link layer.

00:08:24.930 --> 00:08:27.740
OK, so you can see that there
is no way for the link layer,

00:08:27.740 --> 00:08:31.000
now, to send a sequence,
or for the network layer

00:08:31.000 --> 00:08:35.929
to actually cause
four one's in a row

00:08:35.929 --> 00:08:38.809
to be sent out over the wire
because of this transformation.

00:08:38.809 --> 00:08:43.100
So if the network layer
tries to send a message that

00:08:43.100 --> 00:08:46.520
contains a sequence with four
ones, what the link layer is

00:08:46.520 --> 00:08:51.940
going to send is
three ones followed

00:08:51.940 --> 00:08:53.759
by a zero followed by a one.

00:08:53.759 --> 00:08:55.300
Notice, however,
that this also means

00:08:55.300 --> 00:08:58.270
that if the network layer tries
to send a sequence of three

00:08:58.270 --> 00:09:03.100
ones followed by a zero, the
link layer will transmit three

00:09:03.100 --> 00:09:05.920
ones followed by two zeros, OK?

00:09:05.920 --> 00:09:08.000
And then at the
receiving end, we

00:09:08.000 --> 00:09:10.840
can just trivially apply
this reverse transformation.

00:09:10.840 --> 00:09:12.450
So this idea of
bit stuffing allows

00:09:12.450 --> 00:09:19.340
us to guarantee that
any time that the link

00:09:19.340 --> 00:09:20.840
layer on the receiving
side actually

00:09:20.840 --> 00:09:23.732
sees four ones in a row, this
is really the end symbol as

00:09:23.732 --> 00:09:25.690
opposed to the network
layer trying to transmit

00:09:25.690 --> 00:09:28.260
four ones in a row, OK?

00:09:28.260 --> 00:09:32.170
So that's all I want to
say about the network layer

00:09:32.170 --> 00:09:34.230
or about the link layer.

00:09:34.230 --> 00:09:35.730
And what I want to
do now is to move

00:09:35.730 --> 00:09:37.430
on to a discussion
of the network layer.

00:09:52.390 --> 00:09:54.188
So the network layer --

00:09:56.940 --> 00:10:02.720
-- has two primary functions
that we're going to talk about

00:10:02.720 --> 00:10:03.740
today.

00:10:03.740 --> 00:10:05.165
The first was forwarding.

00:10:09.817 --> 00:10:10.900
And the second is routing.

00:10:15.180 --> 00:10:16.980
So the idea was
forwarding is as follows.

00:10:20.300 --> 00:10:22.550
So the idea was
forwarding is basically

00:10:22.550 --> 00:10:28.110
to allow nodes to decide,
given a particular packet

00:10:28.110 --> 00:10:31.120
to allow them to decide what
the next hop for that packet

00:10:31.120 --> 00:10:33.850
should be by looking at
the destination address

00:10:33.850 --> 00:10:36.346
deaths in the message that
they are trying to transmit.

00:10:36.346 --> 00:10:38.470
So they're going to look
at the destination address

00:10:38.470 --> 00:10:41.045
and make some decision about
where to send this packet next.

00:10:41.045 --> 00:10:42.670
And they're going to
do that by keeping

00:10:42.670 --> 00:10:44.860
a table that basically
maps every address

00:10:44.860 --> 00:10:48.742
into the next link to send to.

00:10:48.742 --> 00:10:50.450
So let's look at a
really simple example.

00:10:58.510 --> 00:11:03.880
Suppose we have five
machines, A, B, C, D, and E --

00:11:03.880 --> 00:11:08.230
-- connected as follows.

00:11:14.030 --> 00:11:16.480
And let's number these links.

00:11:16.480 --> 00:11:20.010
Let's number this
link from E to B.

00:11:20.010 --> 00:11:21.150
We're going to call it L1.

00:11:21.150 --> 00:11:25.710
We're going to letter
this link E to D L2.

00:11:25.710 --> 00:11:27.870
And then, I'm going to
number all the links sort

00:11:27.870 --> 00:11:28.820
of in the same way.

00:11:28.820 --> 00:11:29.950
So, B's link to A.

00:11:29.950 --> 00:11:31.120
I'll number L1.

00:11:31.120 --> 00:11:34.500
B's link to D I'll number
L2, and B's link to E I'll

00:11:34.500 --> 00:11:35.390
number L3.

00:11:35.390 --> 00:11:39.199
So, notice that this link, I've
given two names to this link

00:11:39.199 --> 00:11:40.990
depending on whether
we're talking about it

00:11:40.990 --> 00:11:42.560
from a perspective of B or E.

00:11:42.560 --> 00:11:46.385
OK, so now we can do
the same numbering

00:11:46.385 --> 00:11:47.510
for all of the other links.

00:11:47.510 --> 00:11:49.160
So, call this L1.

00:11:49.160 --> 00:11:50.120
Call this L2.

00:11:50.120 --> 00:11:51.570
Call this L3.

00:11:51.570 --> 00:11:55.990
And, this one is L1, L2
from C's perspective.

00:11:55.990 --> 00:11:59.180
And this is L1 and L2
from A's perspective.

00:11:59.180 --> 00:12:01.380
So now we have this
labeled graph here.

00:12:01.380 --> 00:12:04.570
And now let's look and see what
the forwarding table for one

00:12:04.570 --> 00:12:05.880
of these nodes might look like.

00:12:05.880 --> 00:12:07.820
So, for example, if we
look at the forwarding

00:12:07.820 --> 00:12:11.450
table for node A,
what we'll see is

00:12:11.450 --> 00:12:17.610
one entry for each of the other
nodes that are in the network.

00:12:17.610 --> 00:12:21.180
And this entry will tell
us, given a message destined

00:12:21.180 --> 00:12:25.170
for this, whatever address is
in, this is the destination

00:12:25.170 --> 00:12:26.540
address.

00:12:26.540 --> 00:12:28.760
So given a particular
destination address,

00:12:28.760 --> 00:12:33.850
it will tell us what the
next link we should use is.

00:12:33.850 --> 00:12:39.060
OK so, and this is
the forwarding table

00:12:39.060 --> 00:12:40.320
for a particular node.

00:12:40.320 --> 00:12:42.320
So in this case, we're
looking at the forwarding

00:12:42.320 --> 00:12:43.080
table for node A.

00:12:43.080 --> 00:12:46.720
So, if A sees a node destined
to node A, what should

00:12:46.720 --> 00:12:47.330
it do with it?

00:12:52.050 --> 00:12:53.784
Well, it's destined
to its local mode.

00:12:53.784 --> 00:12:56.200
So it's going to do the obvious
thing, which is send it up

00:12:56.200 --> 00:12:57.199
to the end to end layer.

00:12:57.199 --> 00:12:59.710
So I'll just write E to E.

00:12:59.710 --> 00:13:07.620
So if it receives a node
destined for B, it's going to,

00:13:07.620 --> 00:13:10.200
presumably it wants to send
it along whatever the shortest

00:13:10.200 --> 00:13:10.750
path is.

00:13:10.750 --> 00:13:13.369
And we'll talk about how the
next step, routing is actually

00:13:13.369 --> 00:13:14.910
deciding which thing
should be there.

00:13:14.910 --> 00:13:18.640
But, for example, it might
have L2 as the next link.

00:13:18.640 --> 00:13:20.430
OK, and if it
wants to send to C,

00:13:20.430 --> 00:13:22.100
it might have L1
as the next link.

00:13:22.100 --> 00:13:26.440
So, A to B is using, it's using
L2, and A to C it's using L1.

00:13:26.440 --> 00:13:30.760
OK, now, node D is, say
if it wants to route to D,

00:13:30.760 --> 00:13:34.290
it's going to have to route
through either B or C.

00:13:34.290 --> 00:13:37.010
And so, for now, let's
just say it routes to L1.

00:13:37.010 --> 00:13:39.330
And so, it routes
to C, and then it's

00:13:39.330 --> 00:13:42.120
going to allow C to go ahead
and forward the packet onto D.

00:13:42.120 --> 00:13:44.720
If it wants to route
to E, well, again, it

00:13:44.720 --> 00:13:46.432
can either route
through B or through C.

00:13:46.432 --> 00:13:48.390
But let's say maybe it
wants to route through B

00:13:48.390 --> 00:13:50.300
because it has a shorter path.

00:13:50.300 --> 00:13:54.580
So, we'll write L2 here.

00:13:54.580 --> 00:14:00.320
OK, so this is just a
very simple example.

00:14:00.320 --> 00:14:03.200
Now you can see that any time
that A wants to send a packet,

00:14:03.200 --> 00:14:05.900
it has a next hop that it
should use for every destination

00:14:05.900 --> 00:14:07.300
address within the network.

00:14:07.300 --> 00:14:08.700
So, this is very simple.

00:14:08.700 --> 00:14:14.070
And this is sort of a high level
the way that forwarding works.

00:14:14.070 --> 00:14:15.720
Of course, there are
some other details

00:14:15.720 --> 00:14:19.550
associated with getting
forwarding to work properly.

00:14:19.550 --> 00:14:22.880
In order to sort of talk about
how forwarding actually works,

00:14:22.880 --> 00:14:27.970
the interaction between these
layers, what I want to do

00:14:27.970 --> 00:14:31.090
is just give you some examples
of what the packet headers look

00:14:31.090 --> 00:14:33.840
like for different
kinds of protocols that

00:14:33.840 --> 00:14:35.100
are used in the real world.

00:14:35.100 --> 00:14:38.280
So we're talking about here,
this is the IPV4 header.

00:14:38.280 --> 00:14:43.054
So, remember, IP is a protocol
that runs at the network layer.

00:14:43.054 --> 00:14:45.220
And this header has the
following information in it.

00:14:45.220 --> 00:14:48.310
So, what I've shown
here down the left side

00:14:48.310 --> 00:14:50.350
is a sequence of words.

00:14:50.350 --> 00:14:54.150
So these are 32-bit words.

00:14:54.150 --> 00:14:57.100
And I'd just broken up the
bits by number along the top.

00:14:57.100 --> 00:15:03.179
So, the first sort of
word has information

00:15:03.179 --> 00:15:05.470
about the version of the
protocol that's running in it.

00:15:05.470 --> 00:15:07.550
So in this case the
version would be four

00:15:07.550 --> 00:15:09.040
because this is IPV4.

00:15:09.040 --> 00:15:11.460
There's a new IP
protocol that is

00:15:11.460 --> 00:15:13.450
in the process of
being deployed called

00:15:13.450 --> 00:15:16.450
IPV6, which you'll
sometimes see referenced.

00:15:16.450 --> 00:15:18.369
There's a header length field.

00:15:18.369 --> 00:15:20.160
It just specifies the
length of the header.

00:15:20.160 --> 00:15:21.800
There's a TOS field.

00:15:21.800 --> 00:15:22.920
This is type of service.

00:15:22.920 --> 00:15:25.544
It's typically not
used in most packets.

00:15:25.544 --> 00:15:26.960
And then there's
the packet length

00:15:26.960 --> 00:15:28.660
which is the entire length
of the whole packet,

00:15:28.660 --> 00:15:30.076
not just the length
of the header.

00:15:30.076 --> 00:15:32.320
So this should be
fairly straightforward

00:15:32.320 --> 00:15:33.820
except for the type
of service field

00:15:33.820 --> 00:15:42.580
which you guys don't need
to pay any attention to.

00:15:42.580 --> 00:15:44.930
So the next field, so
there's this identification.

00:15:44.930 --> 00:15:49.980
The next [word?] has
identification, flags,

00:15:49.980 --> 00:15:51.350
and fragment offset.

00:15:51.350 --> 00:15:53.060
Let's just look at the next one.

00:15:53.060 --> 00:15:55.000
And the next one has
time delay of end

00:15:55.000 --> 00:15:56.520
to end protocol and checksum.

00:15:56.520 --> 00:16:02.510
So the important
fields, I'm blanking

00:16:02.510 --> 00:16:05.200
on what the identification
field contains,

00:16:05.200 --> 00:16:08.140
which is why I'm stalling.

00:16:08.140 --> 00:16:12.340
So the identification
field, so let's

00:16:12.340 --> 00:16:14.090
just talk about the
other fields and we'll

00:16:14.090 --> 00:16:18.460
come back to identification
if I remember it.

00:16:18.460 --> 00:16:21.530
So the flag's field simply
contains some information

00:16:21.530 --> 00:16:24.980
about whether this packet
has been fragmented

00:16:24.980 --> 00:16:25.980
or should be fragmented.

00:16:25.980 --> 00:16:29.900
So fragmentation is something
that this packet can be split

00:16:29.900 --> 00:16:31.510
into multiple sub packets.

00:16:31.510 --> 00:16:34.470
You don't need to worry
about it too much.

00:16:34.470 --> 00:16:36.500
And the fragment offset
as if this packet has

00:16:36.500 --> 00:16:38.930
been split into these sub
packets, these fragments.

00:16:38.930 --> 00:16:41.060
Then this is the number
of the fragment that's

00:16:41.060 --> 00:16:43.780
being transmitted so,
the interesting ones

00:16:43.780 --> 00:16:44.930
now come in this next row.

00:16:44.930 --> 00:16:46.520
So, we have the
time to live flag,

00:16:46.520 --> 00:16:48.980
the end to end protocol,
and then the checksum.

00:16:48.980 --> 00:16:54.640
So, the time to live field
is sometimes abbreviated TTL.

00:16:54.640 --> 00:16:58.107
And time to live is a little
bit of a strange name for it.

00:16:58.107 --> 00:17:00.440
Basically what this says is
that as this packet is being

00:17:00.440 --> 00:17:02.000
forwarded through
the network, we're

00:17:02.000 --> 00:17:04.584
going to decrement the time
to live by one on every step

00:17:04.584 --> 00:17:06.250
that it's forwarded
through the network.

00:17:06.250 --> 00:17:07.960
And if the time to
live reaches zero,

00:17:07.960 --> 00:17:09.589
we're going to stop
forwarding this.

00:17:09.589 --> 00:17:11.470
So the reason that we
care about time to live

00:17:11.470 --> 00:17:16.250
is that there can sometimes be
loops and are fording routes.

00:17:16.250 --> 00:17:18.030
So suppose that
we had set this up

00:17:18.030 --> 00:17:23.300
so that A sends messages
destined for, say, A sent

00:17:23.300 --> 00:17:26.920
messages destined
for E through C.

00:17:26.920 --> 00:17:30.752
But C sent messages destined
through E through A, right?

00:17:30.752 --> 00:17:32.960
So that would be a loop,
and that would be a problem.

00:17:32.960 --> 00:17:36.210
So, we're going to try and
avoid forming these loops

00:17:36.210 --> 00:17:38.142
when we do our routing protocol.

00:17:38.142 --> 00:17:40.100
But they're going to be
certain situations when

00:17:40.100 --> 00:17:42.730
those fail, for example, that
loops can occasionally occur.

00:17:42.730 --> 00:17:44.605
And we're going to use
the time to live field

00:17:44.605 --> 00:17:46.350
to eliminate those.

00:17:46.350 --> 00:17:48.100
The next thing is the
end to end protocol.

00:17:48.100 --> 00:17:54.410
So the end to end protocol
is the specification

00:17:54.410 --> 00:17:57.040
of which end to end
protocol we should

00:17:57.040 --> 00:17:59.200
forward this message onto.

00:17:59.200 --> 00:18:01.009
So I'll talk about
that more in a second.

00:18:01.009 --> 00:18:02.550
And then there's
this checksum field,

00:18:02.550 --> 00:18:06.730
which can be used to determine
whether the message was fully

00:18:06.730 --> 00:18:11.060
formed, although it turns
out that in most cases in IP,

00:18:11.060 --> 00:18:13.104
this field probably isn't used.

00:18:13.104 --> 00:18:14.770
So, and then there
is the source address

00:18:14.770 --> 00:18:15.853
and a destination address.

00:18:15.853 --> 00:18:18.020
So these are IP
addresses that identify

00:18:18.020 --> 00:18:21.180
the endpoints of the packet
and then, finally, there

00:18:21.180 --> 00:18:23.920
is some additional,
optional information

00:18:23.920 --> 00:18:27.900
which can specify a huge
range of different things.

00:18:27.900 --> 00:18:29.190
It can be up to 44 bytes.

00:18:29.190 --> 00:18:31.530
In this case, you don't
need to worry about it.

00:18:31.530 --> 00:18:33.080
And then finally
there's the payload,

00:18:33.080 --> 00:18:35.340
which is the actual message
that was sent from the end

00:18:35.340 --> 00:18:38.209
to end layer into the IP layer.

00:18:38.209 --> 00:18:39.750
So what you see
happening here, if we

00:18:39.750 --> 00:18:51.600
look at a diagram of what
the interface between the end

00:18:51.600 --> 00:18:55.160
to end layer, what the interface
between the network layer

00:18:55.160 --> 00:18:56.400
and link layer is.

00:18:56.400 --> 00:19:01.240
So let's just look at
our three layers again.

00:19:01.240 --> 00:19:02.910
We have our end to end layer.

00:19:02.910 --> 00:19:05.640
We have our network layer.

00:19:05.640 --> 00:19:08.840
And we have our link layer.

00:19:08.840 --> 00:19:11.630
And one of the things
that we can pick out here

00:19:11.630 --> 00:19:13.310
is that notice that
we have this end

00:19:13.310 --> 00:19:15.680
to end protocol that's
actually in our IP packet

00:19:15.680 --> 00:19:19.250
so what this means is that if I
have a network protocol like IP

00:19:19.250 --> 00:19:23.270
that's running here, when it
receives a packet destined

00:19:23.270 --> 00:19:26.270
for its local address, say,
destined to itself where it's

00:19:26.270 --> 00:19:28.490
supposed to forward it up
to the end to end layer,

00:19:28.490 --> 00:19:31.120
it can actually dispatch
this packet to a number

00:19:31.120 --> 00:19:33.020
of different end to end layers.

00:19:33.020 --> 00:19:36.800
So, for example, we talked last
time about the TCP protocol.

00:19:36.800 --> 00:19:38.660
But there are a
number of other end

00:19:38.660 --> 00:19:41.234
to end layers that can
be used in the Internet.

00:19:41.234 --> 00:19:42.900
So we'll talk in this
class a little bit

00:19:42.900 --> 00:19:44.756
about a different
protocol called UDP.

00:19:44.756 --> 00:19:45.880
We'll talk about this more.

00:19:45.880 --> 00:19:48.230
We'll talk about the end to
end layer more next time.

00:19:48.230 --> 00:19:51.390
But the point is that this
up call to the layer above us

00:19:51.390 --> 00:19:55.560
is controlled by the contents
of this header that we have.

00:19:55.560 --> 00:20:01.440
So similarly, if we look
an Ethernet header, what

00:20:01.440 --> 00:20:06.190
the Ethernet header has on it is
the destination address, which

00:20:06.190 --> 00:20:09.760
is 48 bits, and the source
address which are 48 bits,

00:20:09.760 --> 00:20:12.920
followed by a link protocol.

00:20:12.920 --> 00:20:15.710
So the link protocol says,
and so the Ethernet, remember,

00:20:15.710 --> 00:20:18.140
is a link layer protocol.

00:20:18.140 --> 00:20:23.840
And what happens is, so
if we have Ethernet here,

00:20:23.840 --> 00:20:28.060
it has a protocol ID that
specifies the protocol

00:20:28.060 --> 00:20:30.970
that it's supposed to
send messages back up to.

00:20:30.970 --> 00:20:35.380
OK, so these fields, one
question you might ask

00:20:35.380 --> 00:20:38.490
is, well, how does the Ethernet
layer know which link protocol

00:20:38.490 --> 00:20:40.530
it should send messages to?

00:20:40.530 --> 00:20:43.380
Or how does the network protocol
know which end to end protocol

00:20:43.380 --> 00:20:45.520
to send its messages to?

00:20:45.520 --> 00:20:50.480
So it's kind of
interesting and it's worth

00:20:50.480 --> 00:20:53.382
looking at the pseudocode
for one of these protocols

00:20:53.382 --> 00:20:54.840
just quickly in
order to understand

00:20:54.840 --> 00:20:56.280
this a little bit better.

00:20:56.280 --> 00:21:00.010
So let's look at the
pseudocode for the function

00:21:00.010 --> 00:21:04.350
which we're going to call Net
Handle that accepts messages

00:21:04.350 --> 00:21:07.310
either from the end to
end layer to be sent out

00:21:07.310 --> 00:21:10.240
across the network,
or from the link layer

00:21:10.240 --> 00:21:12.147
when a message is
sort of received

00:21:12.147 --> 00:21:13.230
as it's forwarded through.

00:21:13.230 --> 00:21:15.660
So we can use this procedure
both for down calls

00:21:15.660 --> 00:21:18.370
and up calls, and
it accepts a packet

00:21:18.370 --> 00:21:21.632
which, say for example, has this
format that I've shown here,

00:21:21.632 --> 00:21:23.340
which is the same as
the format that I've

00:21:23.340 --> 00:21:25.097
shown on the other page.

00:21:25.097 --> 00:21:26.680
So the first thing
this is going to do

00:21:26.680 --> 00:21:28.721
is it's going to check
and see if the destination

00:21:28.721 --> 00:21:31.054
of the packet, for example,
is the local address.

00:21:31.054 --> 00:21:33.470
And if the destination of the
packet is the local address,

00:21:33.470 --> 00:21:35.910
then we know what we
should do with it, right?

00:21:35.910 --> 00:21:38.920
We're going to pass it
up to the end and layer.

00:21:38.920 --> 00:21:42.320
And we're going to send,
so what we're going to do

00:21:42.320 --> 00:21:44.800
is we're going to de-encapsulate
this packet, right?

00:21:44.800 --> 00:21:46.200
We are going to strip
the header off of it.

00:21:46.200 --> 00:21:48.783
So we're just going to send the
payload up to the layer above,

00:21:48.783 --> 00:21:50.489
but we're going to
need to dispatch

00:21:50.489 --> 00:21:52.030
to the appropriate
layer, which we're

00:21:52.030 --> 00:21:54.097
going to do by sort
of saying and naming

00:21:54.097 --> 00:21:56.680
what the end to end protocol is
that we would like to dispatch

00:21:56.680 --> 00:21:58.230
to.

00:21:58.230 --> 00:22:00.220
And there may be
some other options

00:22:00.220 --> 00:22:02.130
that we pass along
with this as well.

00:22:02.130 --> 00:22:04.780
So that's what the
three dots there mean.

00:22:04.780 --> 00:22:07.510
So now, if this isn't
for the local packet,

00:22:07.510 --> 00:22:10.330
for the local node, then we need
to send this packet out again,

00:22:10.330 --> 00:22:10.830
right?

00:22:10.830 --> 00:22:12.246
So what we're going
to do is we're

00:22:12.246 --> 00:22:16.100
going to check the time
to live on this packet.

00:22:16.100 --> 00:22:18.030
And if the time to live
is greater than zero,

00:22:18.030 --> 00:22:22.310
then we are going to
decrement the time to live.

00:22:22.310 --> 00:22:24.780
If the time to live is
less than or equal to zero,

00:22:24.780 --> 00:22:28.080
then we know that we're not
going to forward this packet

00:22:28.080 --> 00:22:28.580
anymore.

00:22:28.580 --> 00:22:29.746
We're just going to drop it.

00:22:29.746 --> 00:22:31.410
So the time to live
gets set initially

00:22:31.410 --> 00:22:33.160
by the first guy who
sends the packet out.

00:22:33.160 --> 00:22:35.680
He initializes it
to some value, which

00:22:35.680 --> 00:22:38.150
is the maximum number of hops
that he wants this message

00:22:38.150 --> 00:22:40.150
to be propagated for.

00:22:40.150 --> 00:22:43.260
And so, after we decrement
the time to live,

00:22:43.260 --> 00:22:46.290
we're going to look up
in our forwarding table

00:22:46.290 --> 00:22:48.450
the next link that
we want to use.

00:22:48.450 --> 00:22:52.299
OK, and what I've shown
here is that we're

00:22:52.299 --> 00:22:53.840
going to look up
the sort of protocol

00:22:53.840 --> 00:22:57.600
to use and the name
of the next link.

00:22:57.600 --> 00:23:02.450
So, for example,
this IP layer might

00:23:02.450 --> 00:23:05.000
have Ethernet underneath it,
which might be one protocol.

00:23:05.000 --> 00:23:08.560
But there might
also be a WiFi layer

00:23:08.560 --> 00:23:11.320
that's here that we could
also send messages out.

00:23:11.320 --> 00:23:17.080
So we could send out through
either one of these protocols.

00:23:17.080 --> 00:23:18.830
So we look up the one
we want to send out,

00:23:18.830 --> 00:23:20.700
and then we call this
link send routine,

00:23:20.700 --> 00:23:22.910
which actually does
the transmission out

00:23:22.910 --> 00:23:26.470
over the appropriate named link.

00:23:26.470 --> 00:23:30.740
Notice now what I've specified,
I have this [NETPROT?] in all

00:23:30.740 --> 00:23:31.360
caps here.

00:23:31.360 --> 00:23:34.710
So in this case, this
should be, for example, IP.

00:23:34.710 --> 00:23:36.400
It's the name of the
network protocol.

00:23:36.400 --> 00:23:38.890
So when the network protocol
sends the message to the link

00:23:38.890 --> 00:23:41.480
layer below it, it specifies
what the network protocol

00:23:41.480 --> 00:23:44.730
is that wants to have
returned, that it

00:23:44.730 --> 00:23:46.150
wants to be called on return.

00:23:46.150 --> 00:23:48.674
So it says, please
link layer; when

00:23:48.674 --> 00:23:50.840
you have received a message
that needs to be sent up

00:23:50.840 --> 00:23:53.640
to the network layer, dispatch
it to the network layer named

00:23:53.640 --> 00:23:54.900
NETPROT.

00:23:54.900 --> 00:24:00.020
OK, and then for
example the TTL we

00:24:00.020 --> 00:24:02.760
can't transmit the message out.

00:24:02.760 --> 00:24:04.196
TTL has expired.

00:24:04.196 --> 00:24:05.820
If we've sent it too
many hops already,

00:24:05.820 --> 00:24:08.278
then we're going to need to do
some kind of error handling.

00:24:08.278 --> 00:24:11.600
In this case, error handling
might be, send a message back

00:24:11.600 --> 00:24:14.300
to the source address
of this message,

00:24:14.300 --> 00:24:16.440
and tell them that the TTL
ran out on this message.

00:24:16.440 --> 00:24:17.940
That will be one
thing you could do.

00:24:17.940 --> 00:24:20.106
Another thing you might do
is simply drop the packet

00:24:20.106 --> 00:24:21.810
or ignore the error.

00:24:21.810 --> 00:24:23.870
OK, so this is just
a simple example

00:24:23.870 --> 00:24:28.432
of how forwarding might work.

00:24:28.432 --> 00:24:30.140
And what I wanted to
use it to illustrate

00:24:30.140 --> 00:24:33.300
is the fact that there can
be multiple different link

00:24:33.300 --> 00:24:35.680
layers at the bottom that
can be dispatched to.

00:24:35.680 --> 00:24:37.740
And these link
layers can, in fact,

00:24:37.740 --> 00:24:41.230
dispatch up to multiple
different network layers

00:24:41.230 --> 00:24:41.770
as well.

00:24:41.770 --> 00:24:44.970
So in today's Internet,
it's uncommon to see,

00:24:44.970 --> 00:24:47.220
you'll rarely
interact with anything

00:24:47.220 --> 00:24:50.900
that's not using IP at some
layer or some network layer.

00:24:50.900 --> 00:24:52.570
But there have,
in the past, been

00:24:52.570 --> 00:24:55.230
a variety of different network
layers that have been proposed.

00:24:55.230 --> 00:24:57.400
You guys may have
seen an old protocol

00:24:57.400 --> 00:24:59.650
from Novell called
IPX, or you may

00:24:59.650 --> 00:25:04.040
have used AppleTalk, which
is an Apple protocol that

00:25:04.040 --> 00:25:07.585
in some varieties also
runs at the IP layer.

00:25:07.585 --> 00:25:08.960
Finally, I just
want to point out

00:25:08.960 --> 00:25:12.260
that the last little layering
detail that I want to get to

00:25:12.260 --> 00:25:16.740
is that if you think
about the link layer

00:25:16.740 --> 00:25:18.690
from the perspective
of the network layer,

00:25:18.690 --> 00:25:21.680
the link layer is
simply, the link

00:25:21.680 --> 00:25:24.280
just looks like one hop
to one more connection.

00:25:24.280 --> 00:25:27.540
But in fact, these links
can, themselves, be networks.

00:25:27.540 --> 00:25:29.549
So it's just kind of
a weird statement.

00:25:29.549 --> 00:25:31.340
But here's a simple
example of what I mean.

00:25:31.340 --> 00:25:35.380
Suppose that this link
layer, that one of the link

00:25:35.380 --> 00:25:37.530
layers that the IP layers
can send a message to

00:25:37.530 --> 00:25:40.457
is a modem connection, OK?

00:25:40.457 --> 00:25:42.540
But if you think about
what a modem connection is,

00:25:42.540 --> 00:25:45.060
right, it's a connection
out over a phone line.

00:25:45.060 --> 00:25:46.596
And a phone line
is, itself, right,

00:25:46.596 --> 00:25:48.470
as we talked about at
the beginning of class,

00:25:48.470 --> 00:25:50.732
a phone line is, itself,
a kind of the network.

00:25:50.732 --> 00:25:52.690
Right, it's this kind of
circuit-switched thing

00:25:52.690 --> 00:25:55.310
that goes through multiple
ones of these circuit

00:25:55.310 --> 00:25:57.150
switches as opposed to
going through these.

00:25:57.150 --> 00:26:00.710
So underneath the
modem, the modem layer,

00:26:00.710 --> 00:26:05.340
which looks like a link
to the network layer,

00:26:05.340 --> 00:26:08.850
there's actually, these link
layers can actually themselves

00:26:08.850 --> 00:26:10.370
be composed of a
number of links,

00:26:10.370 --> 00:26:12.780
and they can, themselves,
be a type of a network.

00:26:12.780 --> 00:26:14.767
So it's sort of worth
realizing that there

00:26:14.767 --> 00:26:16.600
is a kind of hierarchical
relationship, one,

00:26:16.600 --> 00:26:21.010
but the link layer
may actually itself

00:26:21.010 --> 00:26:24.065
be a network consisting
of multiple links,

00:26:24.065 --> 00:26:26.440
but from the point of view of
the higher-level link layer

00:26:26.440 --> 00:26:28.830
here, it's just a single
link, a modem connection

00:26:28.830 --> 00:26:32.590
to some endpoint that we
can send a message over.

00:26:32.590 --> 00:26:39.740
OK, so what I want to do
now is take you through,

00:26:39.740 --> 00:26:41.550
we're going to switch
gears a little bit

00:26:41.550 --> 00:26:44.746
and talk about the
sort of next piece

00:26:44.746 --> 00:26:46.120
that I said we
needed to address,

00:26:46.120 --> 00:26:48.732
which is this issue of routing.

00:26:48.732 --> 00:26:50.690
So I said we're going to
talk about forwarding,

00:26:50.690 --> 00:26:52.340
and then we're going to talk
about something else called

00:26:52.340 --> 00:26:53.040
routing.

00:26:53.040 --> 00:27:01.810
So routing is the process
by which we build up

00:27:01.810 --> 00:27:03.090
our forwarding tables.

00:27:03.090 --> 00:27:05.210
OK, so what I showed
you here was I

00:27:05.210 --> 00:27:06.800
just sort of told
you what the values

00:27:06.800 --> 00:27:08.570
that should go in these
forwarding tables should be.

00:27:08.570 --> 00:27:10.361
But I didn't tell you
how they were derived

00:27:10.361 --> 00:27:11.517
or where they came from.

00:27:11.517 --> 00:27:13.100
So in this case of
the simple network,

00:27:13.100 --> 00:27:15.670
it was relatively easy
for us to, by hand,

00:27:15.670 --> 00:27:19.900
sort of come up with a set
of possible forwarding paths

00:27:19.900 --> 00:27:21.470
that seem reasonable.

00:27:21.470 --> 00:27:24.010
But you can imagine that if
this network had scaled up

00:27:24.010 --> 00:27:25.790
to a million nodes,
that's not something

00:27:25.790 --> 00:27:27.864
that we want any
individual to have to do.

00:27:27.864 --> 00:27:29.280
No person should
have to configure

00:27:29.280 --> 00:27:32.854
all these routing tables or
all these forwarding tables.

00:27:32.854 --> 00:27:34.270
So instead, what
we're going to do

00:27:34.270 --> 00:27:36.321
is we're going to use
this process called

00:27:36.321 --> 00:27:38.070
routing in order to
build these forwarding

00:27:38.070 --> 00:27:40.320
tables automatically.

00:27:40.320 --> 00:27:44.820
And we really want our routing
protocol to be three things.

00:27:44.820 --> 00:27:47.540
First, we wanted to be scalable.

00:27:47.540 --> 00:27:49.860
And the obvious way in which
we want it to be scalable

00:27:49.860 --> 00:27:51.026
is the way that I just said.

00:27:51.026 --> 00:27:53.570
We don't want to
have to have people,

00:27:53.570 --> 00:27:55.414
we want this thing
to scale up to, say,

00:27:55.414 --> 00:27:57.080
a million nodes or
several million nodes

00:27:57.080 --> 00:27:58.413
and be able to continue to work.

00:27:58.413 --> 00:28:00.600
We shouldn't have to have
people sort of involved

00:28:00.600 --> 00:28:03.520
with configuring, building
up these forwarding tables

00:28:03.520 --> 00:28:05.210
at every step of the way.

00:28:05.210 --> 00:28:06.590
We also want it to be robust.

00:28:06.590 --> 00:28:11.140
So by that, I mean it should
be tolerant of faults.

00:28:11.140 --> 00:28:14.150
If a node fails in the
network, the network

00:28:14.150 --> 00:28:16.410
should eventually discover
that that node has failed

00:28:16.410 --> 00:28:18.720
and be able to forward
packets around the failure

00:28:18.720 --> 00:28:22.470
or be able to compensate for
the failure if at all possible.

00:28:22.470 --> 00:28:24.159
Finally, we want
this routing protocol

00:28:24.159 --> 00:28:25.325
hopefully to be distributed.

00:28:30.250 --> 00:28:32.970
So we don't want to have
to have one machine that's

00:28:32.970 --> 00:28:35.800
responsible for setting up
the forwarding table on all

00:28:35.800 --> 00:28:36.910
the other machines.

00:28:36.910 --> 00:28:38.730
We don't want to
have one machine that

00:28:38.730 --> 00:28:41.174
needs to contact all
of the other nodes

00:28:41.174 --> 00:28:43.590
and collect information about
what all of their links are,

00:28:43.590 --> 00:28:45.631
and assemble all of those
links together into one

00:28:45.631 --> 00:28:47.100
global forwarding scheme.

00:28:47.100 --> 00:28:51.460
And this really gets at
the scalability again.

00:28:51.460 --> 00:28:54.050
So what I want to
do is to take you

00:28:54.050 --> 00:28:55.460
through the process of routing.

00:28:55.460 --> 00:28:58.530
Before I do that, I just want
to take a quick digression.

00:28:58.530 --> 00:29:01.260
We're going to start off with
very tiny networks on this,

00:29:01.260 --> 00:29:03.782
and just talking about a
very simple baby network.

00:29:03.782 --> 00:29:05.240
It just so that
you guys don't feel

00:29:05.240 --> 00:29:07.080
like this is
completely unrealistic,

00:29:07.080 --> 00:29:10.120
I want to show you that in
fact the Internet at some level

00:29:10.120 --> 00:29:11.620
started out like this, too.

00:29:11.620 --> 00:29:13.020
What we're going to do it
in the course of this class

00:29:13.020 --> 00:29:16.000
is sort of build up from these
very simple networks that maybe

00:29:16.000 --> 00:29:19.260
look the way the Internet did
at first, the schemes that

00:29:19.260 --> 00:29:21.740
are more like what is actually
used in today's production

00:29:21.740 --> 00:29:22.650
Internet.

00:29:22.650 --> 00:29:28.010
So, sorry I went
back on you guys.

00:29:30.730 --> 00:29:34.070
OK, so this is a picture of what
the Internet look like in 1969.

00:29:34.070 --> 00:29:37.570
So you may not be able to read
the labels on these things,

00:29:37.570 --> 00:29:41.330
but we're looking
at three nodes here.

00:29:41.330 --> 00:29:47.650
This is UC Santa Barbara
on the coast of California.

00:29:47.650 --> 00:29:49.290
It's southern
central California.

00:29:49.290 --> 00:29:52.450
This is Stanford
Research Institute, SRI,

00:29:52.450 --> 00:29:54.130
which is the Bay Area.

00:29:54.130 --> 00:29:56.990
This is Utah, and this is UCLA.

00:29:56.990 --> 00:30:00.180
So, this was the ARPANET,
which was a precursor

00:30:00.180 --> 00:30:02.890
to the Internet, and was
sort of one of the very first

00:30:02.890 --> 00:30:07.341
of these large
wide-area networks

00:30:07.341 --> 00:30:08.340
that was ever developed.

00:30:08.340 --> 00:30:10.530
And each of these
little square nodes

00:30:10.530 --> 00:30:13.630
here is a machine
that's on this.

00:30:13.630 --> 00:30:16.810
So there were four machines
on the ARPANET in 1969.

00:30:16.810 --> 00:30:22.290
And there were these four
routers that were being used.

00:30:22.290 --> 00:30:24.640
So, this is 1971.

00:30:24.640 --> 00:30:27.410
So by 1971, there
still is a cluster

00:30:27.410 --> 00:30:29.100
of these machines in California.

00:30:29.100 --> 00:30:33.122
But you notice that Illinois,
Carnegie Mellon, and Boston

00:30:33.122 --> 00:30:34.580
have suddenly
appeared on this map.

00:30:34.580 --> 00:30:37.650
So, MIT is here,
Lincoln Labs is here,

00:30:37.650 --> 00:30:41.940
Harvard is here, BBN, which
is another large company that

00:30:41.940 --> 00:30:44.670
does a lot of networking
research in this area is here.

00:30:44.670 --> 00:30:46.300
So, the network has
started to evolve.

00:30:46.300 --> 00:30:48.300
And in particular, you
notice that there are now

00:30:48.300 --> 00:30:50.649
these sort of two clusters,
these two regions, one

00:30:50.649 --> 00:30:52.440
on the West Coast and
one on the East Coast

00:30:52.440 --> 00:30:54.360
that have a number of nodes.

00:30:54.360 --> 00:30:56.180
So, it just keeps
growing and growing.

00:30:56.180 --> 00:30:58.380
So, by 1980, you
see the network has

00:30:58.380 --> 00:30:59.840
gotten substantially larger.

00:30:59.840 --> 00:31:01.673
And one of the interesting
things about this

00:31:01.673 --> 00:31:03.740
is you are starting to
see a diversity of links.

00:31:03.740 --> 00:31:08.470
So notice that Hawaii is now
connected into California

00:31:08.470 --> 00:31:13.220
by way of a satellite
connection, as is London.

00:31:13.220 --> 00:31:16.410
So, we now have not only just
these wires that are running,

00:31:16.410 --> 00:31:18.130
but in fact we have
wireless links.

00:31:18.130 --> 00:31:20.331
But at the same time
this was happening,

00:31:20.331 --> 00:31:22.080
all the protocols we've
been talking about

00:31:22.080 --> 00:31:23.130
were being developed.

00:31:23.130 --> 00:31:24.300
And one of the
whole goals of this

00:31:24.300 --> 00:31:26.633
was to be able to support
these multiple different kinds

00:31:26.633 --> 00:31:29.450
of links on top of the
standard networking protocol.

00:31:29.450 --> 00:31:32.650
OK, so by 1987, this
thing has really

00:31:32.650 --> 00:31:36.640
become, turned into a number
of decentralized networks.

00:31:36.640 --> 00:31:38.630
There's this large network
called the ARPANET.

00:31:38.630 --> 00:31:41.210
There is something smaller
called the NSF backbone,

00:31:41.210 --> 00:31:43.230
and a number of other
networks that are

00:31:43.230 --> 00:31:44.970
military networks, and so on.

00:31:44.970 --> 00:31:46.910
These are all
connected together,

00:31:46.910 --> 00:31:49.130
and they're all
being, by 1987 they

00:31:49.130 --> 00:31:51.800
were all running this
TCP/IP protocol that

00:31:51.800 --> 00:31:54.390
was being used to exchange
information between all

00:31:54.390 --> 00:31:56.030
of these things.

00:31:56.030 --> 00:31:59.140
So roundabout a few
years after this, right,

00:31:59.140 --> 00:32:01.460
the sort of World Wide
Web suddenly happened,

00:32:01.460 --> 00:32:03.510
and there became this
huge commercial interest

00:32:03.510 --> 00:32:05.290
in the Internet.

00:32:05.290 --> 00:32:10.490
And that has really just
sparked this explosion of nodes,

00:32:10.490 --> 00:32:12.950
and made the network just
huge and incredibly vast.

00:32:12.950 --> 00:32:15.710
So it's hard to see this,
but in the middle of this

00:32:15.710 --> 00:32:18.410
you notice that there is
a little orange node here.

00:32:18.410 --> 00:32:21.420
This bar on the left side
is showing the out degree

00:32:21.420 --> 00:32:22.690
of the nodes in the network.

00:32:22.690 --> 00:32:25.005
So this number is 2,977.

00:32:25.005 --> 00:32:27.630
So that means there's a node at
the center of the Internet that

00:32:27.630 --> 00:32:31.770
has 2,977 links to
other nodes in it.

00:32:31.770 --> 00:32:35.160
OK, so this is a really
incredibly large network.

00:32:35.160 --> 00:32:38.400
And you notice that
all of these 20 or 30

00:32:38.400 --> 00:32:41.320
bright pink red nodes
here have hundreds

00:32:41.320 --> 00:32:43.210
to thousands of
outgoing connections

00:32:43.210 --> 00:32:44.099
on each one of them.

00:32:44.099 --> 00:32:45.640
So there is this
core of the Internet

00:32:45.640 --> 00:32:48.580
that is very highly
connected to a very

00:32:48.580 --> 00:32:49.850
large part of the network.

00:32:49.850 --> 00:32:51.840
And now, down or
out around the edges

00:32:51.840 --> 00:32:53.570
are these much
smaller networks that

00:32:53.570 --> 00:32:56.020
have much lower collectivity.

00:32:56.020 --> 00:32:57.950
And these are things
like service providers,

00:32:57.950 --> 00:33:01.569
for example, that consumers
might pay some money

00:33:01.569 --> 00:33:02.610
to get a connection from.

00:33:02.610 --> 00:33:04.443
So this is the sort of
core of the Internet.

00:33:04.443 --> 00:33:06.781
These are the people who are
not so much the end-users

00:33:06.781 --> 00:33:08.530
on the Internet, but
the service providers

00:33:08.530 --> 00:33:10.682
that are providing
connectivity for the end-users.

00:33:10.682 --> 00:33:12.390
Each one of these
little nodes represents

00:33:12.390 --> 00:33:13.970
one of those service providers.

00:33:13.970 --> 00:33:15.480
This was as of 2003.

00:33:15.480 --> 00:33:21.477
OK, so what I want to do
now is to start as I said.

00:33:21.477 --> 00:33:23.310
We're going to sort of
start off with a baby

00:33:23.310 --> 00:33:24.185
version of a network.

00:33:24.185 --> 00:33:26.590
In particular, we're going
to look how forwarding,

00:33:26.590 --> 00:33:29.650
or how routing might work
in this very simple network

00:33:29.650 --> 00:33:30.620
that I've shown here.

00:33:30.620 --> 00:33:32.774
So let's see what happens.

00:33:32.774 --> 00:33:34.440
So we're going to use
a protocol that we

00:33:34.440 --> 00:33:36.366
call path vector routing.

00:33:36.366 --> 00:33:37.990
And the idea behind
path vector routing

00:33:37.990 --> 00:33:41.870
is that we're going to build
up the paths from, that is,

00:33:41.870 --> 00:33:46.880
the sequence of nodes that we
should forward messages through

00:33:46.880 --> 00:33:50.386
in order to reach a
particular destination.

00:33:50.386 --> 00:33:51.760
And the way this
is going to work

00:33:51.760 --> 00:33:54.140
is we're going to
have two steps.

00:33:54.140 --> 00:33:58.890
So, let's put it over here.

00:33:58.890 --> 00:34:10.699
So routing is going to consist
of two steps: an advertisement

00:34:10.699 --> 00:34:17.914
phase or an advertisement
step, and an integration step.

00:34:21.995 --> 00:34:24.120
And the idea is that during
the advertisement step,

00:34:24.120 --> 00:34:26.310
each node is going to
advertise what other

00:34:26.310 --> 00:34:28.549
nodes it knows how to reach.

00:34:28.549 --> 00:34:30.090
And then during the
integration step,

00:34:30.090 --> 00:34:33.530
each node is going to take
all of the advertisements that

00:34:33.530 --> 00:34:36.600
heard during the previous
advertisement step,

00:34:36.600 --> 00:34:38.560
and integrate them into
a new set of routes

00:34:38.560 --> 00:34:41.699
that identifies the new set of
nodes that this node can reach.

00:34:41.699 --> 00:34:45.020
OK, so this'll be very clear
when I show you the example.

00:34:45.020 --> 00:34:47.330
So let's just look at the
case of all the nodes,

00:34:47.330 --> 00:34:49.704
figuring out how they
can reach node E.

00:34:49.704 --> 00:34:51.620
So what's going to happen
is that first node E

00:34:51.620 --> 00:34:53.370
is going to send out
an advertisement that

00:34:53.370 --> 00:34:55.940
says that node E knows how
to reach node E, right,

00:34:55.940 --> 00:34:57.234
which it obviously does.

00:34:57.234 --> 00:34:58.650
And the way that
it reaches node E

00:34:58.650 --> 00:35:00.190
is simply by
forwarding a message up

00:35:00.190 --> 00:35:01.720
to its end to end layer.

00:35:01.720 --> 00:35:03.530
So it says, to reach
node E, come this way.

00:35:03.530 --> 00:35:05.640
And it sends it out
over the two links

00:35:05.640 --> 00:35:07.640
that it has to node C and D.

00:35:07.640 --> 00:35:09.550
So when node C and D
hear this advertisement,

00:35:09.550 --> 00:35:11.800
during this integration step
what they are going to do

00:35:11.800 --> 00:35:16.612
is to add this information
about this connection to node E,

00:35:16.612 --> 00:35:18.820
and they're going to store
which link it is that they

00:35:18.820 --> 00:35:21.500
send that message out over.

00:35:21.500 --> 00:35:24.460
They should send messages out
over in order to reach node E.

00:35:24.460 --> 00:35:27.690
So node C is going
to store link one,

00:35:27.690 --> 00:35:29.389
and node D is going
to store link two.

00:35:29.389 --> 00:35:30.930
But in addition to
that link, they're

00:35:30.930 --> 00:35:33.300
going to store the
path that they use.

00:35:33.300 --> 00:35:36.300
But now what's going to happen
is that each of C and D,

00:35:36.300 --> 00:35:38.320
during the next
advertisement step,

00:35:38.320 --> 00:35:40.520
C and D are going to also
advertise the information

00:35:40.520 --> 00:35:43.780
that they have about
the nodes that they

00:35:43.780 --> 00:35:45.260
can reach in the network.

00:35:45.260 --> 00:35:48.100
So, I'm only showing the
advertisements for node E here.

00:35:48.100 --> 00:35:49.935
But of course, at the
same time, C and D

00:35:49.935 --> 00:35:51.560
are also advertising
the fact that they

00:35:51.560 --> 00:35:53.710
can reach themselves,
and maybe their ability

00:35:53.710 --> 00:35:55.800
to reach other nodes in the
network that we haven't shown.

00:35:55.800 --> 00:35:57.320
So we're just looking
at E, but bear in mind

00:35:57.320 --> 00:35:59.403
that all the advertisements
are being done for all

00:35:59.403 --> 00:36:00.960
the nodes at the same time.

00:36:00.960 --> 00:36:05.310
So, C sends out an advertisement
that says I can reach node E,

00:36:05.310 --> 00:36:08.240
and the way to do it
is to send, and I can

00:36:08.240 --> 00:36:12.100
reach node E via C and then E.

00:36:12.100 --> 00:36:13.720
And similarly, D
sends out a message

00:36:13.720 --> 00:36:17.000
that says I can reach
node E by a D and then E.

00:36:17.000 --> 00:36:19.289
So, OK, up to this
point we haven't really

00:36:19.289 --> 00:36:20.580
seen anything very interesting.

00:36:20.580 --> 00:36:22.430
But now during the
next integration step,

00:36:22.430 --> 00:36:26.510
we see that these
two nodes, B and A,

00:36:26.510 --> 00:36:29.890
now have heard an advertisement
that gives them a path that

00:36:29.890 --> 00:36:33.030
allows them to reach node E.

00:36:33.030 --> 00:36:35.180
So now, every node
has a path that

00:36:35.180 --> 00:36:36.730
allows them to reach node E.

00:36:36.730 --> 00:36:40.227
But this advertisement
and integrations process

00:36:40.227 --> 00:36:41.310
is going to keep going on.

00:36:41.310 --> 00:36:44.190
So, for example,
nodes A and B are

00:36:44.190 --> 00:36:46.140
going to advertise that
they can, also, reach

00:36:46.140 --> 00:36:48.100
node E to their neighbors.

00:36:48.100 --> 00:36:52.560
And in this case, it's probably
unlikely that any of the nodes

00:36:52.560 --> 00:36:54.930
would like to switch
to a new route.

00:36:54.930 --> 00:37:00.140
So, for example, it's not clear,
there's no reason, for example,

00:37:00.140 --> 00:37:02.634
that A would want to
forward its message.

00:37:02.634 --> 00:37:04.050
It's probably
unlikely that A will

00:37:04.050 --> 00:37:07.960
want to forward its messages
through B to reach E,

00:37:07.960 --> 00:37:12.550
right, because that's going
to be a longer path than for A

00:37:12.550 --> 00:37:14.930
to send its messages simply
through C and then to E.

00:37:14.930 --> 00:37:17.660
But B doesn't actually
know whether or not

00:37:17.660 --> 00:37:19.260
A knows about E yet or not.

00:37:19.260 --> 00:37:23.110
So it needs to continue to
broadcast this information out.

00:37:23.110 --> 00:37:25.530
So this is pretty simple.

00:37:25.530 --> 00:37:27.050
It's pretty clear
how this works.

00:37:27.050 --> 00:37:29.210
And once this process has
been running for a while,

00:37:29.210 --> 00:37:32.220
you can see that the network is
going to converge into a state

00:37:32.220 --> 00:37:36.910
where every node has, as long
as the network is connected,

00:37:36.910 --> 00:37:39.760
it will converge into a state
where every node has a path

00:37:39.760 --> 00:37:41.766
to node E, right?

00:37:41.766 --> 00:37:44.140
And the amount of time that
it'll take for that to happen

00:37:44.140 --> 00:37:47.670
is equal to the
maximum number of hops

00:37:47.670 --> 00:37:50.160
that any node is
away from node E.

00:37:50.160 --> 00:37:52.180
So, once this node
has converged,

00:37:52.180 --> 00:37:55.200
now we can trivially build up
our forwarding table simply

00:37:55.200 --> 00:37:59.480
by pulling out the link number
from each one of these nodes.

00:37:59.480 --> 00:38:03.920
So, for example, we can see
that E's forwarding table simply

00:38:03.920 --> 00:38:06.970
says: to reach node E, you
send it to my end to end layer.

00:38:06.970 --> 00:38:09.510
D's forwarding table would
say, to reach node E,

00:38:09.510 --> 00:38:11.680
you send it over my link, L2.

00:38:11.680 --> 00:38:14.130
C's forwarding table would
say, to reach node E,

00:38:14.130 --> 00:38:15.870
you send it over L1.

00:38:15.870 --> 00:38:18.500
B's forwarding table would
say, to reach node E,

00:38:18.500 --> 00:38:21.420
you send it out over
my L1, and so on, OK?

00:38:21.420 --> 00:38:24.560
So, once we've done this
path vector routing,

00:38:24.560 --> 00:38:27.254
at the end of this process
we will know which links,

00:38:27.254 --> 00:38:28.920
we'll have built up
the forwarding table

00:38:28.920 --> 00:38:32.150
that we can use for
sending our links.

00:38:32.150 --> 00:38:33.972
OK, so this is a
very simple process.

00:38:33.972 --> 00:38:35.430
But now, let's look
at what happens

00:38:35.430 --> 00:38:38.260
when something, so
what we said here

00:38:38.260 --> 00:38:42.770
is that each advertisement step,
and after each advertisement,

00:38:42.770 --> 00:38:44.620
we're going to go ahead
and do integration.

00:38:44.620 --> 00:38:46.060
Integration, basically
what we're going to do

00:38:46.060 --> 00:38:48.610
is we're going to try and pick
the best path in some way.

00:38:48.610 --> 00:38:49.900
What we've shown here
is just simply picking

00:38:49.900 --> 00:38:50.760
the shortest path.

00:38:50.760 --> 00:38:53.310
So we've picked the
shortest possible path

00:38:53.310 --> 00:38:55.880
for every node to reach node E.

00:38:55.880 --> 00:38:58.360
And in case it wasn't
clear, I didn't explicitly

00:38:58.360 --> 00:39:01.400
state this, it's important to
realize that nodes are going

00:39:01.400 --> 00:39:03.470
to ignore advertisements
with their own address

00:39:03.470 --> 00:39:04.530
in the vector.

00:39:04.530 --> 00:39:11.490
OK so if, for example, when
node E hears node D advertising

00:39:11.490 --> 00:39:14.030
that it can reach node E,
node E is going to say,

00:39:14.030 --> 00:39:17.030
oh, well, I am node E.

00:39:17.030 --> 00:39:18.840
I don't actually need
to pick up this path.

00:39:18.840 --> 00:39:21.530
I don't need to send my packets
to myself through node D.

00:39:21.530 --> 00:39:22.960
That would be a
silly thing to do.

00:39:22.960 --> 00:39:24.100
That would create
a routing loop,

00:39:24.100 --> 00:39:26.210
which is something that we
presumably don't want to do.

00:39:26.210 --> 00:39:28.020
So, this is a simple
way using these path

00:39:28.020 --> 00:39:32.600
vectors we can use to avoid
creating routing loops.

00:39:32.600 --> 00:39:34.770
OK, so now let's look at
what happens, something

00:39:34.770 --> 00:39:35.750
a little bit more interesting.

00:39:35.750 --> 00:39:37.880
Let's look and see what happens
when, for example, there's

00:39:37.880 --> 00:39:38.430
a failure.

00:39:38.430 --> 00:39:41.560
So this is just exactly the
same network that I showed you.

00:39:41.560 --> 00:39:45.560
But, suppose for example that
the link between D and E fails.

00:39:45.560 --> 00:39:52.327
OK, so now node D no longer
has a route to node E.

00:39:52.327 --> 00:39:53.910
But remember, the
way that I described

00:39:53.910 --> 00:39:56.700
this is that this
advertisement process is just

00:39:56.700 --> 00:39:58.890
going to continue going on
in the background, right?

00:39:58.890 --> 00:40:01.230
So what's going to happen
is that at some point node

00:40:01.230 --> 00:40:04.810
D is going to realize that
its link to node E went down.

00:40:04.810 --> 00:40:09.150
And, node D is going to cross
this table out of its entry.

00:40:09.150 --> 00:40:12.980
So, node D is going to basically
stop hearing advertisements

00:40:12.980 --> 00:40:13.980
from node E.

00:40:13.980 --> 00:40:16.560
When it stops hearing
advertisements from node E,

00:40:16.560 --> 00:40:18.340
eventually it's going
to do something.

00:40:18.340 --> 00:40:22.050
It's basically going to expire
that entry from its link table.

00:40:22.050 --> 00:40:23.850
So after it hasn't
heard advertisements

00:40:23.850 --> 00:40:26.350
from node E for a while,
it'll expire that entry.

00:40:26.350 --> 00:40:29.330
And then, sometime later it
will hear an advertisement

00:40:29.330 --> 00:40:33.617
from node C saying I know
how to get to node E.

00:40:33.617 --> 00:40:35.950
And now, node D can go ahead
and integrate this new path

00:40:35.950 --> 00:40:37.860
into its routing table.

00:40:37.860 --> 00:40:39.460
Now, notice that
this process is just

00:40:39.460 --> 00:40:41.085
going to propagate
through the network.

00:40:41.085 --> 00:40:43.350
So, once node D stops
hearing advertisements

00:40:43.350 --> 00:40:45.310
for how to reach
node E, it's going

00:40:45.310 --> 00:40:48.050
to stop sending advertisements
for how to reach node E.

00:40:48.050 --> 00:40:53.140
And so, similarly, because B
is also routing its information

00:40:53.140 --> 00:40:57.270
through, had previously
been routing its packets

00:40:57.270 --> 00:40:59.680
to reach node E
by way of D, it's

00:40:59.680 --> 00:41:02.850
going to say, oh, well, I stop
hearing about this route, DE,

00:41:02.850 --> 00:41:03.560
from node D.

00:41:03.560 --> 00:41:05.470
So I'm going to stop using this.

00:41:05.470 --> 00:41:08.080
And instead, then
sometime later, it's

00:41:08.080 --> 00:41:10.050
going to hear about
this new route, DCE,

00:41:10.050 --> 00:41:12.050
and it's going to integrate
that into its table.

00:41:12.050 --> 00:41:13.730
So, it's this
process where there

00:41:13.730 --> 00:41:19.670
is this sort of process whereby
nodes continually advertise

00:41:19.670 --> 00:41:22.270
and integrate routes.

00:41:22.270 --> 00:41:24.270
And there's this sort of
interesting thing which

00:41:24.270 --> 00:41:26.686
happens, which is that nodes
forget about routes that they

00:41:26.686 --> 00:41:28.180
haven't heard about
for awhile when

00:41:28.180 --> 00:41:29.650
they miss an advertisement.

00:41:29.650 --> 00:41:33.980
So this, forgetting about
routes is an important sort

00:41:33.980 --> 00:41:36.180
of principle that's often
employed in networking

00:41:36.180 --> 00:41:37.200
called soft state.

00:41:40.580 --> 00:41:44.640
And the idea with soft state
is that you should only

00:41:44.640 --> 00:41:48.200
keep information when that
information gets refreshed.

00:41:48.200 --> 00:41:51.599
So all the information that you
have has some time limit on it.

00:41:51.599 --> 00:41:53.390
And when you haven't
heard that information

00:41:53.390 --> 00:41:55.510
refreshed after some time
limit, you throw it out.

00:41:55.510 --> 00:41:57.510
So that's what we're doing
with the routes here.

00:41:57.510 --> 00:42:00.790
And so we only keep
routes that we have heard

00:42:00.790 --> 00:42:03.460
advertised recently, basically.

00:42:03.460 --> 00:42:05.420
And that has this
nice property that it

00:42:05.420 --> 00:42:07.980
allows us to adapt to faults
within the network, right?

00:42:07.980 --> 00:42:09.390
So we saw a failure happen.

00:42:09.390 --> 00:42:11.720
We saw that sometime
after that failure,

00:42:11.720 --> 00:42:13.840
this soft state
property would cause

00:42:13.840 --> 00:42:15.900
the information about
the link between D and E

00:42:15.900 --> 00:42:18.360
to disappear from the
network, and then nodes

00:42:18.360 --> 00:42:20.850
would rediscover their
new links that allow

00:42:20.850 --> 00:42:23.560
them to connect to node E.

00:42:23.560 --> 00:42:29.140
OK, so what I want
to do now, so this

00:42:29.140 --> 00:42:30.372
is sort of the basic process.

00:42:30.372 --> 00:42:32.580
And, path vector routing is
fairly similar to the way

00:42:32.580 --> 00:42:36.052
that routing in the
Internet actually works.

00:42:36.052 --> 00:42:37.510
For next time in
recitation, you're

00:42:37.510 --> 00:42:39.843
going to talk about a protocol
called the border gateway

00:42:39.843 --> 00:42:40.460
protocol.

00:42:40.460 --> 00:42:42.330
And you're going to actually
study in much more detail

00:42:42.330 --> 00:42:43.680
how Internet routing works.

00:42:43.680 --> 00:42:46.180
But this is a nice simple
model of how routing

00:42:46.180 --> 00:42:49.660
in a small network might act.

00:42:49.660 --> 00:42:53.890
So the problem with what
we've discussed so far,

00:42:53.890 --> 00:43:01.680
while we are here, is that if
this is a very large network,

00:43:01.680 --> 00:43:03.199
these number of
routes that you're

00:43:03.199 --> 00:43:04.990
going to have to hear
about is really huge.

00:43:04.990 --> 00:43:07.406
So suppose that this, instead
of being a five node network

00:43:07.406 --> 00:43:08.640
was a million node network.

00:43:08.640 --> 00:43:13.120
Well, now every node is
going to have a table that's

00:43:13.120 --> 00:43:14.620
a million entries long, right?

00:43:14.620 --> 00:43:15.580
That's going to be
really big, and it's

00:43:15.580 --> 00:43:17.640
going to have to hear a
million advertisements.

00:43:17.640 --> 00:43:19.315
And every time there's
a failure, well,

00:43:19.315 --> 00:43:20.940
that's going to be
a pain because we're

00:43:20.940 --> 00:43:22.920
going to have to wait for that
information about that failure

00:43:22.920 --> 00:43:24.544
to propagate through
the whole network.

00:43:24.544 --> 00:43:28.590
So in some sense, this simple
path vector routing protocol

00:43:28.590 --> 00:43:31.089
we have doesn't really
meet the scalability goal

00:43:31.089 --> 00:43:32.630
that we want to
scale this network up

00:43:32.630 --> 00:43:34.270
to a very large size.

00:43:34.270 --> 00:43:38.320
So we have an issue
with path vector routing

00:43:38.320 --> 00:43:39.540
and its scalability.

00:43:39.540 --> 00:43:45.970
OK, so the solution is
a solution that is often

00:43:45.970 --> 00:43:49.070
used when we have a scalability
problem in a computer system:

00:43:49.070 --> 00:43:51.306
its hierarchy, OK?

00:43:51.306 --> 00:43:52.680
So let's see what
I mean by that.

00:43:56.710 --> 00:43:58.810
So, you remember when I
was showing those pictures

00:43:58.810 --> 00:44:03.670
of the Internet, there are these
different kind of subnetworks

00:44:03.670 --> 00:44:06.360
that were forming over
time on the West Coast,

00:44:06.360 --> 00:44:09.750
on the East Coast, or there was
the ARPANET, and the NSFNET,

00:44:09.750 --> 00:44:12.120
and the MILNET [SP?] that
were these sort of different

00:44:12.120 --> 00:44:14.500
networks that were all a part
of the Internet as a whole.

00:44:14.500 --> 00:44:16.660
But they were these sort
of different regions

00:44:16.660 --> 00:44:18.300
that were separately
administered,

00:44:18.300 --> 00:44:21.470
and that often corresponded
to a specific organization

00:44:21.470 --> 00:44:24.740
like the NSF or
like the military.

00:44:24.740 --> 00:44:29.270
So, oftentimes these
regions, so it's

00:44:29.270 --> 00:44:31.550
very common when you
look at any network

00:44:31.550 --> 00:44:33.610
to have these kinds
of regions in them.

00:44:33.610 --> 00:44:36.170
So, for example, clearly
there's a network

00:44:36.170 --> 00:44:37.950
that is MIT's network, right?

00:44:37.950 --> 00:44:40.310
And Harvard, for example,
has a network that's

00:44:40.310 --> 00:44:41.540
Harvard's network, right?

00:44:41.540 --> 00:44:45.100
And those two things are
sort of logical regions

00:44:45.100 --> 00:44:49.180
that define different
parts or different groups

00:44:49.180 --> 00:44:50.490
within a network.

00:44:50.490 --> 00:44:52.340
So if you were to
look at any network,

00:44:52.340 --> 00:44:54.700
you would see that sort of
almost any large network

00:44:54.700 --> 00:44:57.302
is organized in this
way into these regions.

00:44:57.302 --> 00:44:58.760
In the paper next
time, we're going

00:44:58.760 --> 00:45:09.520
to call these regions
autonomous systems or AS's, OK,

00:45:09.520 --> 00:45:12.610
so autonomous as in sort
of operating on its own,

00:45:12.610 --> 00:45:15.546
operating without
being dependent

00:45:15.546 --> 00:45:16.920
on the other parts
of the system.

00:45:16.920 --> 00:45:19.830
So for example, if MIT's
Internet connection went down,

00:45:19.830 --> 00:45:21.610
connection to the
outside world went down,

00:45:21.610 --> 00:45:24.100
that wouldn't stop you
from being able to connect

00:45:24.100 --> 00:45:26.250
to machines within MIT, right?

00:45:26.250 --> 00:45:27.770
So MIT is autonomous
in the sense

00:45:27.770 --> 00:45:30.311
that it continues to operate in
the absence of its connection

00:45:30.311 --> 00:45:32.200
to the rest of the Internet.

00:45:32.200 --> 00:45:36.880
So let's look at a simple
example of a network that

00:45:36.880 --> 00:45:38.442
has this hierarchy
property, and see

00:45:38.442 --> 00:45:40.650
how we would modify the
routing algorithm that I just

00:45:40.650 --> 00:45:41.810
talked about.

00:45:41.810 --> 00:45:45.150
So suppose I have
two small networks,

00:45:45.150 --> 00:45:47.220
each with three nodes in them.

00:45:47.220 --> 00:45:51.550
Let's call them A, B,
C, and D, E, and F, OK?

00:45:55.642 --> 00:45:57.350
So, these are each
going to be autonomous

00:45:57.350 --> 00:46:01.320
systems, which I'll draw by
drawing a circle around them.

00:46:01.320 --> 00:46:03.450
OK, so one way we
could be routing

00:46:03.450 --> 00:46:05.740
would be to do what
I had shown before,

00:46:05.740 --> 00:46:08.640
which is that each node
within, say, this autonomous

00:46:08.640 --> 00:46:11.010
region which I'll label
one, or autonomous system

00:46:11.010 --> 00:46:13.745
one, and this one two,
would have information

00:46:13.745 --> 00:46:16.120
about all the other nodes
everywhere else in the network.

00:46:16.120 --> 00:46:19.300
But that has the scalability
problem that we mentioned.

00:46:19.300 --> 00:46:21.010
So instead, what
we want to do is

00:46:21.010 --> 00:46:25.710
we want to make it so that only
a few of the nodes in here,

00:46:25.710 --> 00:46:27.640
so that we don't have
to have information

00:46:27.640 --> 00:46:31.210
about all of the nodes that are
anywhere within the network.

00:46:31.210 --> 00:46:33.880
We only have to know
about a few nodes

00:46:33.880 --> 00:46:36.527
we say are on the edge of
each one of these networks.

00:46:36.527 --> 00:46:37.610
So the idea is as follows.

00:46:37.610 --> 00:46:39.692
Suppose these are
connected in this way.

00:46:39.692 --> 00:46:41.150
And what we're
going to do is we're

00:46:41.150 --> 00:46:43.900
going to appoint one node within
each one of these regions.

00:46:43.900 --> 00:46:45.630
For example, it could
be several modes.

00:46:45.630 --> 00:46:48.160
One of these regions to
be a so-called border

00:46:48.160 --> 00:46:50.875
node that sort of sits on the
edge of these two regions.

00:46:50.875 --> 00:46:53.250
And we're going to connect
just those two nodes together.

00:46:53.250 --> 00:46:57.360
So we're only going to have a
small number of links between

00:46:57.360 --> 00:46:58.910
our two AS's.

00:46:58.910 --> 00:47:01.990
And now, if we look at the
forwarding table for one

00:47:01.990 --> 00:47:06.050
of these nodes within, say, AS1,
it's going to look as follows.

00:47:06.050 --> 00:47:07.550
So what I'm going
to do is I'm going

00:47:07.550 --> 00:47:09.750
to write the addresses
for these different AS's

00:47:09.750 --> 00:47:11.210
as hierarchical addresses.

00:47:11.210 --> 00:47:15.500
So, we're going to call
node A's address 1.A.

00:47:15.500 --> 00:47:21.070
And, we'll call node
E's address 2.E, OK?

00:47:21.070 --> 00:47:23.910
So, what our forwarding
table looks like

00:47:23.910 --> 00:47:32.200
is a list of addresses,
and then a link to use.

00:47:32.200 --> 00:47:35.140
OK, so this is going to be
the forwarding table, again,

00:47:35.140 --> 00:47:36.280
for node A.

00:47:36.280 --> 00:47:38.190
So, A is going to
have an address.

00:47:38.190 --> 00:47:40.771
It's going to have
an address 1.A in it.

00:47:40.771 --> 00:47:43.020
And, the link to use, in
that case, we've already said

00:47:43.020 --> 00:47:44.180
is end-to-end.

00:47:44.180 --> 00:47:50.140
OK, it's going to have an
address 1.B. So, to get to B,

00:47:50.140 --> 00:47:53.110
A is going to route
by this link here,

00:47:53.110 --> 00:47:56.780
which let's call this
link number one, OK?

00:47:56.780 --> 00:47:59.060
So, it's going to
route to link one.

00:47:59.060 --> 00:48:01.529
And it's going to have a
connection to 1.C, which

00:48:01.529 --> 00:48:03.070
is going to route
via this link here,

00:48:03.070 --> 00:48:07.820
which let's label that two, OK?

00:48:07.820 --> 00:48:09.580
So now, we don't
have any information

00:48:09.580 --> 00:48:11.610
about how to reach network two.

00:48:11.610 --> 00:48:14.200
So what we're going to do is
rather than storing information

00:48:14.200 --> 00:48:16.330
about every machine
and network two,

00:48:16.330 --> 00:48:18.820
we're going to store just
information about how

00:48:18.820 --> 00:48:20.460
to reach the edge
of network two,

00:48:20.460 --> 00:48:23.020
and then trust that network two
is going to be able to route

00:48:23.020 --> 00:48:25.200
to anybody whose
address begins with two.

00:48:25.200 --> 00:48:27.800
So what we're going to do is
we're going to say two dot

00:48:27.800 --> 00:48:30.470
star, right, two dot everybody.

00:48:30.470 --> 00:48:34.450
So, [we'll star?] the character
that says anybody whose address

00:48:34.450 --> 00:48:36.150
has this prefix two dot.

00:48:36.150 --> 00:48:37.910
So, anybody whose
address has prefix two

00:48:37.910 --> 00:48:40.790
dot, we are just going
to send to node C.

00:48:40.790 --> 00:48:44.960
So, we're just going to
send that over link two, OK?

00:48:44.960 --> 00:48:46.780
And so, similarly
on the other side,

00:48:46.780 --> 00:48:48.110
we're going to have a table.

00:48:48.110 --> 00:48:51.010
Each of these nodes is going
to have an entry, one dot star,

00:48:51.010 --> 00:48:53.870
that specifies that it should
route messages for network one

00:48:53.870 --> 00:48:55.470
through node D.

00:48:55.470 --> 00:48:57.132
OK, so you see in
this way now what

00:48:57.132 --> 00:48:58.590
we've been able to
do is to make it

00:48:58.590 --> 00:49:02.410
so that each one of these
autonomous systems, sort

00:49:02.410 --> 00:49:04.790
of each node only knows
how to route to other nodes

00:49:04.790 --> 00:49:09.810
within its sort of group, and
that in order to cross groups,

00:49:09.810 --> 00:49:15.200
you route through one of these
special sort of border routers

00:49:15.200 --> 00:49:18.107
or border nodes, OK?

00:49:18.107 --> 00:49:19.690
And, we're going to
talk about the way

00:49:19.690 --> 00:49:21.640
that this border routing
protocol actually

00:49:21.640 --> 00:49:24.310
works in the Internet
in recitation.

00:49:24.310 --> 00:49:25.810
But you can see
that what we've done

00:49:25.810 --> 00:49:30.290
is we've accomplished
this sort of hierarchy

00:49:30.290 --> 00:49:32.370
so we can make this
system, you can

00:49:32.370 --> 00:49:35.070
make these tables much smaller
by including these star

00:49:35.070 --> 00:49:36.720
entries in them.

00:49:36.720 --> 00:49:39.200
It's worth just mentioning
as a final caveat

00:49:39.200 --> 00:49:42.580
that we have given up
something for doing this.

00:49:42.580 --> 00:49:45.940
OK, what we've done is we've
forced every node that's

00:49:45.940 --> 00:49:48.000
within one of these regions.

00:49:48.000 --> 00:49:53.350
Now, this node's address,
in order for this node 1.A

00:49:53.350 --> 00:49:55.630
to be able to
continue to operate,

00:49:55.630 --> 00:49:58.880
it can only be
connected to somebody

00:49:58.880 --> 00:50:02.160
like C who can advertise
information about all the nodes

00:50:02.160 --> 00:50:03.795
whose names begin with one.

00:50:06.780 --> 00:50:11.030
So, we've basically forced this
sort of network to have this.

00:50:11.030 --> 00:50:12.640
By imposing this
kind of a hierarchy

00:50:12.640 --> 00:50:15.440
on the network we've limited,
to some extent, the ability

00:50:15.440 --> 00:50:19.150
of these nodes to move between
networks because node A can

00:50:19.150 --> 00:50:22.740
only be advertised
by way of node C.

00:50:22.740 --> 00:50:25.700
So in the Internet
today, there's

00:50:25.700 --> 00:50:27.337
actually multiple
layers of hierarchy.

00:50:27.337 --> 00:50:29.420
So you may have noticed
that Internet IP addresses

00:50:29.420 --> 00:50:33.280
have the form A.B.C.D.
So, it's a four layer

00:50:33.280 --> 00:50:34.960
hierarchy that we
have in the Internet.

00:50:34.960 --> 00:50:38.680
You guys will learn more about
this on Thursday in recitation.

00:50:38.680 --> 00:50:40.880
And what we'll do
next time is talk

00:50:40.880 --> 00:50:44.730
about the end-to-end
layer, and eliminating

00:50:44.730 --> 00:50:48.600
some of the limitations of
the best effort network.

